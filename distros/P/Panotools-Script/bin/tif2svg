#!/usr/bin/perl

use strict;
use warnings;
use Image::Size;

use File::Temp qw/tempdir/;
use File::Spec;

my $tempdir = tempdir (CLEANUP => 1);

my @files = grep (/\.tif$/i, @ARGV);
my @args = grep (!/\.tif$/i, @ARGV);

exit unless @files;

my $stub0 = $files[0];
$stub0 =~ s/\.tif$//i;
my $stub1 = $files[-1];
$stub1 =~ s/\.tif$//i;
$stub1 =~ s/.*(\/|\\)//;

my ($width, $height) = imgsize ($files[0]);

open (SVG, ">$stub0-$stub1.svg");

print SVG qq|<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
width="$width" height="$height" version="1.0">
<defs>|;

for my $index (0 .. (scalar (@files) - 1))
{
    next unless grep (/--trace/, @args);
    # extract an alpha channel and convert to SVG
    my $tiff = File::Spec->rel2abs ($files[$index]);
    my $stub = File::Spec->catfile ($tempdir, $index);
    system ('convert', $tiff, '-depth', '8', '-channel', 'matte', '-negate', '-separate', "$stub.pgm");
    system ('autotrace', '-background-color', '000000', '-corner-threshold', '150',
            '-corner-surround', '16', '-output-format', 'svg',
            '-output-file', "$stub.svg", "$stub.pgm");

    open (FILE, "$stub.svg") or die "Can't open $stub.svg: $!";
    my @lines = <FILE>;
    my $xml = join ('', @lines);
    close FILE;
    my @d = $xml =~ /( d="[^"]+")/gc;

    print SVG qq|
    <clipPath
       clipPathUnits="userSpaceOnUse" id="clipPath$index">
      <path
         style="fill:#00ff00;fill-opacity:0.25;fill-rule:evenodd;stroke:#00ff00;stroke-width:1px;stroke-opacity:1"
         $d[0] id="path$index" />
    </clipPath>|;
}
print SVG qq|
</defs>|;

my $index = 0;
for my $file (@files)
{
    if (grep (/--jpeg-proxies/, @args))
    {
        my $tif = $file;
        $file =~ s/\.tif/\.jpg/;
        system ('convert', '-geometry', '25%', $tif, $file);
    }
    $file =~ s/.*(\/|\\)//;
    print SVG qq|
    <g inkscape:groupmode="layer"
    id="layer$index"
    style="opacity:0.75"
    inkscape:label="$index">
        <image y="0" x="0" id="image$index" style="display:inline"
        clip-path="url(#clipPath$index)"
        width="$width" height="$height" xlink:href="$file" />
    </g>|;
    $index++;
}

print SVG qq|
</svg>|

__END__

=head1 NAME

tif2svg - generates an SVG file from hugin 'multiple TIFF' output

=head1 Synopsis

  tif2svg [options] INPUT INPUT ...

=head1 DESCRIPTION

Takes a list of TIFF files and assembles an SVG file with each TIFF referenced
on a separate layer. 

If the --trace option is given, alpha channels are traced with 'autotrace' and
this vector path is inserted as clip paths.

Typically, multiple TIFF output is generated by hugin/nona, instead of adjusting
alpha channels for enblend, this tool allows the masks to adjusted in Inkscape
instead.  The saved SVG file can be blended with 'enblend-svg'.

Requires Image::Size and autotrace.

L<http://enblend.sourceforge.net/>

Note that the 'multiple TIFF' files can be large and unwieldy, use the
--jpeg-proxies option to generate JPEG versions for use in Inkscape.
'enblend-svg' will swap these back when blending.

=head1 License

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

=head1 See Also

L<perl>, L<Panotools::Script>

=head1 Author

September 2007, Bruno Postle <bruno AT postle.net>

