<?xml version="1.0"?>
<!DOCTYPE recdescent-xml SYSTEM "recdescent.dtd">
<recdescent-xml>
  <doc>
    <title>XSH</title>
    <shortdesc>XML Editing Shell</shortdesc>
    <description>
      <para>
	XSH acts as a command interpreter.  Individual commands must
	be separated with a semicolon. Each command may be followed by
	a pipeline redirection to capture the command's output. In the
	interactive shell, backslash may be used at the end of line to
	indicate that the command follows on the next line.
      </para>
      <para>
	A pipeline redirections may be used either to feed the
	command's output to a unix command or to store it in a XSH
	string variable.</para> <para>In the first case, the syntax is
	<literal>xsh-command | shell-command ;</literal> where
	<literal>xsh-command</literal> is any XSH
	command and <literal>shell-command</literal> is any command (or code) recognized
	by the default shell interpreter of the operating system
	(i.e. on UNIX systems by <literal>sh</literal> or
	<literal>csh</literal>, on Windows systems by
	<literal>cmd</literal>).  Brackets may be used to join more shell commands (may
	depend on which shell is used).
      </para>
      <example>
	<title>Count attributes of words containing string foo in its name or value.</title>
	<code>xsh&gt; <userinput>ls //words/@* | grep foo | wc</userinput></code>
      </example>
      <para>
	In order to store a command's output in a string variable, the
	pipeline redirection must take the form <literal>xsh-command
	|&gt; $variable</literal> where <literal>xsh-command</literal> is
	any XSH command and <literal>$variable</literal> is any valid
	name for a string <link linkend="Variables">variable</link>.
      </para>
      <example>
	<title>Store the number of all words in a variable named count.</title>
	<code>xsh&gt; <userinput>count //words |&gt; $count</userinput></code>
      </example>
      <para>
	<literal><xref linkend="help_command"/> command</literal>
	gives a list of all XSH commands.
      </para>
      <para>
	<literal><xref linkend="help_command"/> type</literal> gives a
	list of all argument types.
      </para>
      <para>
	<literal><xref linkend="help_command"/></literal> followed by
	a command or type name gives more information on the
	particular command or argument type.
      </para>
    </description>
    <section id="Documents">
      <title>Files/Documents</title>
      <para>
	XSH is intended to query and manipulate XML and HTML
	documents. Use one of the
	<literal>open/open-*/create</literal> commands to load an XML
	or HTML document from a local file, external URL (such as
	http:// or ftp://), string or pipe.  While loading, XSH parses
	and optionally validates (see <xref linkend="validation"/> and
	<xref linkend="load_ext_dtd"/>) the document. Parsed documents
	are stored in memory as <ulink url="http://www.w3.org/DOM/">DOM</ulink> trees, that can be
	<link linkend="Navigation">navigated</link> and <link linkend="Manipulation">manipulated</link> quite similarly to a
	local filesystem.
      </para>
      <para>
	Every opened document is associated with an identifier (<xref linkend="ID"/>), that is a symbolic name for the document in
	  XSH and can be used for example as a prefix of <xref linkend="xpath"/>.
      </para>
      <para>
	In the current version, XSH is only able to save documents
	locally.  To store a document on any other location, use <xref linkend="list_command"/> command and pipe redirection to feed
	the XML representation of the document to any external program
	that is able to store it on a remote location.
      </para>
      <example>
	<title>Store XSH document DOC on a remote machine using Secure Shell</title>
	<code>xsh&gt; <userinput>ls DOC:/ | ssh my.remote.org 'cat &gt; test.xml'</userinput></code>
      </example>
    </section>
    <section id="Navigation">
      <title>Tree navigation</title>
      <para>
	With XSH, it is possible to browse <link
	linkend="Documents">document trees</link> as if they were a
	local filesystem, except that <link
	linkend="xpath">XPath</link> expressions are used instead of
	ordinary UNIX paths.</para> <para>Current position in the
	document tree is called the <emphasis>current node</emphasis>.
	Current node's XPath may be queried with <xref
	linkend="pwd_command"/> command.  In the interactive shell,
	current node is also displayed in the command line
	prompt. Remember, that beside <xref
	linkend="chxpath_command"/> command, current node (and
	document) is silently changed by all variant of <xref
	linkend="open_command"/> command, <xref
	linkend="create_command"/> command and temporarily also by the
	node-list variant of the <xref linkend="foreach"/>
	statement.
      </para>
      <para>Documents are specified
	in a similar way as harddrives on DOS/Windows(TM) systems
	(except that their names are not limitted to one letter in
	XSH), i.e. by a prefix of the form doc: where doc is the
	<xref linkend="ID"/> associated with the document.
      </para>
      <para>
	To mimic the filesystem navigation as closely as
	possible, XSH contains several commands named by analogy of
	UNIX filesystem commands, such as <xref linkend="chxpath_command"/>, <xref linkend="list_command"/> and
	<xref linkend="pwd_command"/>.	
      </para>
      <example>
	<code>xsh scratch:/&gt; <userinput>open docA=&quot;testA.xml&quot;</userinput>
	  xsh docB:/&gt; <userinput>open docB=&quot;testB.xml&quot;</userinput>
	  xsh&gt; <userinput>pwd</userinput>
	  docB:/
	  xsh docB:/&gt; <userinput>cd docA:/article/chapter[title='Conclusion']</userinput>
	  xsh docA:/article/chapter[5]&gt; <userinput>pwd</userinput>
	  docA:/article/chapter[5]
	  xsh docA:/article/chapter[5]&gt; <userinput>cd previous-sibling::chapter</userinput>
	  xsh docA:/article/chapter[4]&gt; <userinput>cd ..</userinput>
	  xsh docA:/article&gt; <userinput>select docB</userinput>
	  xsh docB:/&gt;
	</code>
      </example>
    </section>
    <section id="Manipulation">
      <title>Tree modification</title>
      <para>
	XSH provides mechanisms not only to browse and inspect the DOM
	tree but also to modify its content by providing commands for
	copying, moving, and deleting its nodes as well as adding
	completely new nodes or XML fragments to it. It is quite easy
	to learn these commands since their names or aliases mimic
	their well-known filesystem analogies.  On the other hand,
	many of these commands have two versions one of which is
	prefixed with a letter &quot;x&quot;. This &quot;x&quot;
	stands for &quot;cross&quot;, thus e.g. <xref
	linkend="xcopy_command"/> should be read as &quot;cross
	copy&quot;. Let's explain the difference on the
	example of <xref linkend="xcopy_command"/>.</para>
      <para>
	When you copy, you have to specify what are you copying and
	where are you copying to, so you have to specify the
	<emphasis>source</emphasis> and the
	<emphasis>target</emphasis>.  XSH is very much XPath-based so,
	XPath is used here to specify both of them. However, there
	might be more than one node that satisfies an XPath expression. So,
	the rule of thumb is that the &quot;cross&quot; variant of a
	command places <emphasis>one and every</emphasis> of the source nodes
	to the location of <emphasis>one and every</emphasis> destination
	node, while the plain variant works one-by-one, placing the
	first source node to the first destination, the second source
	node to the second destination, and so on (as long as there
	are both source nodes and destinations left).
      </para>
      <example>
	<code>xsh&gt; <userinput>create a &quot;&lt;X&gt;&lt;A/&gt;&lt;Y/&gt;&lt;A/&gt;&lt;/X&gt;&quot;;</userinput>
	  xsh&gt; <userinput>create b &quot;&lt;X&gt;&lt;B/&gt;&lt;C/&gt;&lt;B/&gt;&lt;C/&gt;&lt;B/&gt;&lt;/X&gt;&quot;;</userinput>
	  xsh&gt; <userinput>xcopy a://A replace b://B;</userinput>
	  xsh&gt; <userinput>copy b://C before a://A;</userinput>
	  xsh&gt; <userinput>ls a:/;</userinput>
	  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
	  &lt;X&gt;&lt;C/&gt;&lt;A/&gt;&lt;Y/&gt;&lt;C/&gt;&lt;A/&gt;&lt;/X&gt;

	  xsh&gt; <userinput>ls b:/;</userinput>
	  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
	  &lt;X&gt;&lt;A/&gt;&lt;A/&gt;&lt;C/&gt;&lt;A/&gt;&lt;A/&gt;&lt;C/&gt;&lt;A/&gt;&lt;A/&gt;&lt;/X&gt;
	</code>
      </example>
      <para>
	As already indicated by the example, another issue of tree
	modification is the way in which the destination node
	determines the target location. Should the source node be
	placed before, after, or into the resulting node? Should it
	replace it completely? This information has to be given in the
	<xref linkend="loc"/> argument that usually precedes the
	destination XPath.
      </para>
      <para>
	Now, what happens if source and destination nodes are of
	incompatible types? XSH tries to avoid this by implicitly
	converting between node types when necessary.  For example, if
	a text, comment, and attribute node is copied into, before or
	after an attribute node, the original value of the
	attribute is replaced, prepended or appended respectively with
	the textual content of the source node. Note however, that
	<emphasis>element nodes are never converted</emphasis> into
	text, attribute or any other textual node.  There
	are many combinations here, so try yourself and see the
	results.
      </para>
      <para>You may even use some more sofisticated way to convert
	between node types, as shown in the following example, where
	an element is first commented out and than again uncommented.
	Note, that the particular approach used for resurrecting the
	commented XML material works only for well-balanced chunks of
	XML.
      </para>
      <example>
	<title>Using string variables to convert between different
	  types of nodes</title>
	<code>
	  <userinput>create doc &lt;&lt;EOF;
	  &lt;?xml version='1.0'?&gt;
	    &lt;book&gt;
	    <tab/>&lt;chapter&gt;
	  <tab count="2"/>&lt;title&gt;Intro&lt;/title&gt;
	  <tab/>&lt;/chapter&gt;
	  <tab/>&lt;chapter&gt;
	    <tab count="2"/>&lt;title&gt;Rest&lt;/title&gt;
	  <tab/>&lt;/chapter&gt;
	    &lt;/book&gt;
	  EOF
	  </userinput>

	  # comment out the first chapter
	  <userinput>ls //chapter[1] |&gt; $chapter_xml;</userinput>
	  <userinput>add comment $chapter_xml replace //chapter[1];</userinput>
	  <userinput>ls / 0;</userinput>
	  # OUTPUT:
	  &lt;?xml version=&quot;1.0&quot;?&gt;
	  &lt;book&gt;
	  &lt;!--<tab/>&lt;chapter&gt;
	  <tab count="2"/>&lt;title&gt;Intro&lt;/title&gt;
	  <tab/>&lt;/chapter&gt;
	  --&gt;
	  <tab/>&lt;chapter&gt;
	  <tab count="2"/>&lt;title&gt;Rest&lt;/title&gt;
	  <tab/>&lt;/chapter&gt;
	  &lt;/book&gt;


	  # un-comment the chapter
	  <userinput>$comment = string(//comment()[1]);</userinput>
	  <userinput>add chunk $comment replace //comment()[1];</userinput>
	  <userinput>ls / 0;</userinput>
	  # OUTPUT:
	  &lt;?xml version=&quot;1.0&quot;?&gt;
	  &lt;book&gt;
	  <tab/>&lt;chapter&gt;
	  <tab count="2"/>&lt;title&gt;Intro&lt;/title&gt;
	  <tab/>&lt;/chapter&gt;

	  <tab/>&lt;chapter&gt;
	  <tab count="2"/>&lt;title&gt;Rest&lt;/title&gt;
	  <tab/>&lt;/chapter&gt;
	  &lt;/book&gt;
	</code>
      </example>
    </section>
    <section id="Flow">
      <title>Flow control</title>
      <para>
	What a scripting language XSH would be had it not some kind of
	conditional statements, loops and other stuff that
	influences the way in which XSH commands are processed.
      </para>
      <para>
	Most notable XSH's feature in this area is that some of the
	basic flow control statements, namely <xref linkend="if"/>,
	<xref linkend="unless"/>, <xref linkend="while"/> and <xref linkend="foreach"/> have two variants, an XPath-based
	one and a Perl-based one.  The XPath-based variant uses <xref linkend="xpath"/> expressions to specify the condition or
	node-lists to iterate, while the other one utilizes <xref linkend="perl_code"/> for this purpose. See 
	descriptions of the individual statements for more detail.
      </para>
    </section>
    <section id="Information">
      <title>Retrieving more information</title>
      <para> Beside the possibility to browse the DOM tree and
	list some parts of it (as described in <xref linkend="Navigation"/>), XSH provides commands to obtain other
	information related to open documents as well as the XSH
	interpreter itself. These commands are listed bellow.
      </para>
    </section>
    <section id="Argtypes">
      <title>Argument Types</title>
      <para>
	XSH commands accept different types of arguments, such as
	usual strings (<xref linkend="expression"/>) or
	<link linkend="xpath">XPath expressions</link>. 
	Notably, these two types and types based on them
	support string variable interpolation. See documentation
	of the individual types for more information.
      </para>
    </section>
    <section id="Variables">
      <title>Variables</title>
      <para>
	In the current version, XSH supports two types of variables:
	string (scalar) variables and node-list variables.  Perl
	programmers that might miss some other kinds of variables
	(arrays or hashes) may use the support for <link linkend="Perl_shell">interacting
	with Perl</link> to access these types (see some examples below).
      </para>
      <para>
	These two kinds of variables differ syntactically in the
	prefix: string variables are prefixed with a dollar sign
	(<literal>$</literal>) while node-list variables are prefixed
	with a percent sign (<literal>%</literal>).
      </para>
      <section id="string_variables">
	<title>String Variables</title>
	<para>
	  Every string variable name consists of a dollar sign
	  (<literal>$</literal>) prefix and an <xref linkend="ID"/>,
	  that has to be unique among other scalar variables, e.g.
	  <literal>$variable</literal>.  Values are
	  assigned to variables either by simple <link
	  linkend="assign_command">assignments</link> of the form
	  <literal>$variable = <xref linkend="xpath"/></literal> or by
	  capturing the output of some command with a variable
	  redirection of the form <literal>command |&gt;
	  $variable</literal>.
	</para>
	<para>
	  String variables may be used in <link
	  linkend="expression">string expressions</link>, <link
	  linkend="xpath">XPath expressions</link>, or even in
	  perl-code as $<xref linkend="ID"/> or ${<xref
	  linkend="ID"/>}. In the first two cases, variables act as
	  macros in the sense that all variables occurences are
	  replaced by the corresponding values before the expression
	  itself is evaluated.
	</para>
	<para>
	  To display current value of a variable, use the 
	  <xref linkend="print_command"/> command,
	  <xref linkend="var_command"/> command or
	  simply the variable name:
	</para>
	<example>
	  <code>xsh> <userinput>$b="chapter";</userinput>
	    xsh> <userinput>$file="${b}s.xml";</userinput>
	    xsh> <userinput>open f=$file;</userinput>
	    xsh> <userinput>ls //$b[count(descendant::para)>10]</userinput>
	    xsh> <userinput>print $b</userinput>
	    chapter
	    xsh> <userinput>$b</userinput>
	    $b='chapter';
	    xsh> <userinput>variables</userinput>
	    $a='chapters.xml';
	    $b='chapter';
	  </code>
	</example>
      </section>
      <section id="nodelist_variables">
	<title>Node-list Variables</title>
	<para>
	  Every string variable name consists of a percent sign
	  (<literal>%</literal>) prefix and an <xref linkend="ID"/>,
	  that has to be unique among other node-list variables, e.g.
	  <literal>%variable</literal>.
	</para>
	<para>
	  Node-list variables can be used to store lists of nodes that
	  result from evaluating an XPath. This is especially useful
	  when several changes are performed on some set of nodes and
	  evaluating the XPath expression repeatedly would take too
	  long. Other important use is to remember a node that would
	  otherwise be extremely hard or even impossible to locate by
	  XPath expressions after some changes to the tree structure
	  are made, since such an XPath cannot be predicted in
	  advance.
	</para>
	<para>
	  Although node-list variables act just like XPath expressions
	  that would result in the same node-list, for implementation
	  reasons it is not possible to use node-list variables as
	  parts of complex XPath expressions except for one case. They
	  <emphasis>may be only used at the very beginning of an XPath
	  expression</emphasis>. So while constructions such as

	  <literal>%creatures[4]</literal>,
	  <literal>%creatures[@race='elf']</literal>, or
	  <literal>%creatures/parents/father</literal> <emphasis>do
	  work</emphasis> as expected,
	  <literal>string(%creatures[2]/@name)</literal>
	  <literal>//creature[%creatures[2]/@name=@name]</literal>, or
	  <literal>%creatures[@race='elf'][2]</literal> <emphasis>do
	  not</emphasis>.  In the first two cases it is because
	  node-list variables cannot be evaluated in the middle of an
	  XPath expression. The third case fails because this
	  construction actually translates into a sequence of
	  evaluations of <literal>self::*[@race='elf'][2]</literal>
	  for each node in the <literal>%creatures</literal>
	  node-list, which is not equivallent to the intended
	  expression as the <literal>[2]</literal> filter does not
	  apply to the whole result of
	  <literal>%creatures[@race='elf']</literal> at once but
	  rather to the partial results.</para> <para>Fortunatelly, it
	  is usually possible to work around these unsupported
	  constructions quite easily.  This is typically done by
	  introducing some more variables as well as using the <xref
	  linkend="foreach"/> statement.  The following
	  example should provide some idea on how to do this:
	</para>
	<example>
	  <code># work around for $name=string(%creatures[2]/@name)
	    xsh> <userinput>foreach %creatures[2] $name=string(@name)</userinput>
	    # work around for ls //creature[%creatures[2]/@name=@name]
	    xsh> <userinput>ls //creature[$name=@name]</userinput>
	    # work around for ls %creatures[@race='elf'][2]
	    xsh> <userinput>%elves = %creatures[@race='elf']</userinput>
	    xsh> <userinput>ls %elves[2]</userinput>
	  </code>
	</example>
	<para>
	  Remember, that when a node is deleted from a tree it is at
	  the same time removed from all node-lists it occurs in.
	  Note also, that unlike string variables, node-list variables
	  can not be (and are not intended to be) directly accessed
	  from Perl code.
	</para>
      </section>
      <section id="other_types">
	<title>Accessing Perl Variables</title>
	<para>
	  All XSH string variables are usual Perl scalar variables
	  from the <literal>XML::XSH::Map</literal> namespace, which
	  is the default namespace for any Perl code evaluated from
	  XSH. Thus it is possible to arbitrarily intermix XSH and
	  Perl assignments:
	</para>
	<example>
	  <code>
	    xsh> <userinput>ls //chapter[1]/title</userinput>
	    &lt;title>Introduction&lt;/title>
	    xsh> <userinput>$a=string(//chapter[1]/title)</userinput>
	    xsh> <userinput>eval { $b="CHAPTER 1: ".uc($a); }</userinput>
	    xsh> <userinput>print $b</userinput>
	    CHAPTER 1: INTRODUCTION
	  </code>
	</example>
	<para>
	  If needed, it is, however, possible to use any other type of Perl
	  variables by means of evaluating a corresponding
	  perl code. The following example demonstrates using Perl
	  hashes to collect and print some simple racial statistics
	  about the population of Middle-Earth:
	</para>
	<example>
	  <code>
	    foreach a:/middle-earth/creature { 
  	    <tab/>$race=string(@race);
	    <tab/>eval { $races{$race}++ };
	    }
	    print "Middle-Earth Population (race/number of creatures)"
	    eval { 
	    <tab/>echo map "$_/$races{$_}\n",
	    <tab count="2"/>sort ($a cmp $b), keys(%races); 
	    };
	  </code>
	</example>
      </section>
    </section>
    <section id="Configuration">
      <title>Options</title> <para>The following commands are used to
	modify the default behaviour of the XML parser or XSH itself.
	Some of the commands are switch between two different modes
	according to a given expression (which is expected to result
	either in zero or non-zero value). Other commands also working
	as a flip-flop have their own explicit counterpart (e.g.
	<xref linkend="verbose"/> and <xref linkend="quiet"/> or <xref linkend="debug"/> and <xref linkend="nodebug"/>).  This
	misconsistency is due to historical reasons.
      </para>
      <para>
	The <xref linkend="encoding"/> and <xref linkend="query_encoding"/> options allow to specify character
	encoding that should be expected from user as well as the
	encoding to be used by XSH on output. This is particularly
	useful when you work with UTF-8 encoded documents on a console
	which supports only 8-bit characters.
      </para>
      <para>
	The <xref linkend="options_command"/> command
	displays current settings by means of XSH commands.
	Thus it can not only be used to review current values, but
	also to store them future use, e.g. in ~/.xshrc file.
      </para>
      <example>
	<code>xsh&gt; <userinput>options | cat &gt; ~/.xshrc</userinput></code>
      </example>
    </section>
    <section id="Perl_shell">
      <title>Interacting with Perl and Shell</title>
      <para>
	To allow more complex tasks to be achieved, XSH provides ways
	for interaction with the Perl programming language and the
	system shell.
      </para>
      <section id="binding_perl">
	<title>Calling Perl</title>
	<para>
	  Perl is a language optimized for scanning arbitrary text
	  files, extracting information from those text files, and
	  printing reports based on that information.  It's also a
	  good language for many system management tasks.  The
	  language is intended to be practical (easy to use,
	  efficient, and complete). XSH itself is written in Perl,
	  so it is extremely easy to support this language as an
	  extension to XSH.
	</para>
	<para>
	  Perl <link linkend="perl_code">expressions or blocks of
	  code</link> can either be simply evaluated with the <xref
	  linkend="eval_command"/> command, used to do quick changes
	  to nodes of the DOM tree (see <xref linkend="map_command"/>
	  command), used to provide list of strings to iterate over in
	  a <xref linkend="foreach"/> loop, or to specify more
	  complex conditions for <xref linkend="if"/>, <xref
	  linkend="unless"/>, and <xref linkend="while"/> statements.
	</para>
	<para>
	  To prevent conflict between XSH internals and the evaluated
	  perl code, XSH runs such code in the context of a special
	  namespace <literal>XML::XSH::Map</literal>. As described in
	  the section <xref linkend="Variables"/>, XSH string
	  variables may be accessed and possibly assigned from Perl
	  code in the most obvious way, since they actually
	  <emphasis>are</emphasis> Perl variables defined in the
	  <literal>XML::XSH::Map</literal> namespace.</para>
	<para>
	  The interaction between XSH and Perl actually works also the
	  other way round, so that you may call back XSH from the
	  evaluated Perl code.  For this, Perl function
	  <literal>xsh</literal> is defined in the
	  <literal>XML::XSH::Map</literal> namespace.  All parameters
	  passed to this function are interpreted as XSH commands. To
	  simplify evaluation of XPath expressions, another three
	  functions:  The first one, named <literal>count</literal>,
	  returns the same value as would be printed by <xref
	  linkend="count_command"/> command in XSH on the same XPath
	  expression. The second function, named <literal>literal</literal>,
	  returns the result of XPath evaluation as if the whole
	  expression was wrapped with the XPath
	  <literal>string()</literal> function. In other words,
	  <literal>literal('doc:expression')</literal> returns the same
	  value as <literal>count('doc:string(expression)')</literal>.
	  The third function, named <literal>xml_list</literal>, returns
	  the result of the XPath search as a XML string which is
	  equivallent to the output of a <xref
	  linkend="list_command"/> on the same XPath expression
	  (without indentation and without folding or any other
	  limitation on the depth of the listing).
	</para>
	<para>
	  In the following examples we use Perl to populate the
	  Middle-Earth with Hobbits whose names are read from a text
	  file called <literal>hobbits.txt</literal>, unless there are
	  some Hobbits in Middle-Earth already.
	</para>
	<example>
	  <title>Use Perl to read text files</title>
	  <code>
	    unless (//creature[@race='hobbit']) {
	    <tab/>perl 'open $file, "hobbits.txt"';
	    <tab/>perl '@hobbits=&lt;$file>';
	    <tab/>perl 'close $file';
	    <tab/>foreach { @hobbits } {
	    <tab count="2"/>insert element "&lt;creature name='$__' race='hobbit'>"
	    <tab count="3"/>into m:/middle-earth/creatures;
	    <tab/>}
	    }
	  </code>
	</example>
	<example>
	  <title>The same code as a single Perl block</title>
	  <code>perl {
	    <tab/>unless (count(//creature[@race='hobbit'])) {
	    <tab count="2"/>open my $file, "hobbits.txt";
	    <tab count="2"/>foreach (&lt;$file>) {
	    <tab count="3"/>xsh(qq{insert element "&lt;creature name='$_' race='hobbit'>"
	    <tab count="4"/>into m:/middle-earth/creatures});
	    <tab count="2"/>}
	    <tab count="2"/>close $file;
	    <tab/>}
	    };</code>
	</example>
      </section>
      <section id="binding_perl_xpathextensions">
        <title>Writing your own XPath extension functions in Perl</title>
        <para>
	  XSH allows the user to extend the set of XPath functions by
	  providing an extension function written in Perl.  This can
	  be achieved using the <xref linkend="registerfunc_command"/>
	  command.  The perl code implementing an extension function
	  works as a usual perl routine accepting its arguments in
	  <literal>@_</literal> and returning the result. The
	  following conventions are used:
	</para>
	<para>
	  The arguments passed to the perl implementation by the XPath
	  engine are either simple scalars or
	  <literal>XML::LibXML::NodeList</literal> objects, depending
	  on the types of the XPath arguments.  The implementation is
	  responsible for checking the argument number and types.  The
	  implementation may use arbitrary
	  <literal>XML::LibXML</literal> methods to process the
	  arguments and return the result.
	  (<literal>XML::LibXML</literal> perl module documentation
	  can be found for example at <ulink
	  url="http://search.cpan.org/author/PHISH/XML-LibXML-1.54/LibXML.pm">http://search.cpan.org/author/PHISH/XML-LibXML-1.54/LibXML.pm</ulink>).
	</para>
	<para>
	  The implementation SHOULD NOT, however, MODIFY the document.
	  Doing so could not only confuse the XPath engine but result
	  in an critical error (such as segmentation fault).
	</para>
	<para>
	  Calling XSH commands from extension function implementations
	  is not currently allowed.
	</para>
	<para>
	  The perl code must return a single value, which can be of
	  one of the following types: a simple scalar (a number or
	  string), <literal>XML::LibXML::Boolean</literal> object
	  reference (result is a boolean value),
	  <literal>XML::LibXML::Literal</literal> object reference
	  (result is a string), <literal>XML::LibXML::Number</literal>
	  object reference (resulat is a float),
	  <literal>XML::LibXML::Node</literal> (or derived) object
	  reference (result is a nodeset consisting of a single node),
	  or <literal>XML::LibXML::NodeList</literal> (result is a
	  nodeset). For convenience, simple (non-blessed) array
	  references consisting of
	  <literal>XML::LibXML::Node</literal> objects can also be
	  used for a nodeset result instead of a
	  <literal>XML::LibXML::NodeList</literal>.
        </para>
      </section>
      <section id="binding_shell">
	<title>Calling the System Shell</title>
	<para>
	  In the interactive mode, XSH interprets all lines starting
	  with a exclamation mark (<literal>!</literal>) as shell
	  commands and invokes the system shell to interpret them
	  (this is to mimic FTP command-line interpreters).
	</para>
	<example>
	  <code>xsh> <userinput>!ls -l</userinput>
-rw-rw-r--    1 pajas    pajas        6355 Mar 14 17:08 Artistic
drwxrwxr-x    2 pajas    users         128 Sep  1 10:09 CVS
-rw-r--r--    1 pajas    pajas       14859 Aug 26 15:19 ChangeLog
-rw-r--r--    1 pajas    pajas        2220 Mar 14 17:03 INSTALL
-rw-r--r--    1 pajas    pajas       18009 Jul 15 17:35 LICENSE
-rw-rw-r--    1 pajas    pajas         417 May  9 15:16 MANIFEST
-rw-rw-r--    1 pajas    pajas         126 May  9 15:16 MANIFEST.SKIP
-rw-r--r--    1 pajas    pajas       20424 Sep  1 11:04 Makefile
-rw-r--r--    1 pajas    pajas         914 Aug 26 14:32 Makefile.PL
-rw-r--r--    1 pajas    pajas        1910 Mar 14 17:17 README
-rw-r--r--    1 pajas    pajas         438 Aug 27 13:51 TODO
drwxrwxr-x    5 pajas    users         120 Jun 15 10:35 blib
drwxrwxr-x    3 pajas    users        1160 Sep  1 10:09 examples
drwxrwxr-x    4 pajas    users          96 Jun 15 10:35 lib
-rw-rw-r--    1 pajas    pajas           0 Sep  1 16:23 pm_to_blib
drwxrwxr-x    4 pajas    users         584 Sep  1 21:18 src
drwxrwxr-x    3 pajas    users         136 Sep  1 10:09 t
-rw-rw-r--    1 pajas    pajas          50 Jun 16 00:06 test
drwxrwxr-x    3 pajas    users         496 Sep  1 20:18 tools
-rwxr-xr-x    1 pajas    pajas        5104 Aug 30 17:08 xsh</code>
	</example>
	<para>
	  To invoke a system shell command or program
	  from the non-interactive mode or from a complex
	  XSH construction, use the <xref linkend="exec_command"/>
	  command.
	</para>
	<para>
	  Since UNIX shell commands are very powerful tool for
	  processing textual data, XSH supports direct redirection of
	  XSH commands output to system shell command.  This is very
	  similarly to the redirection known from UNIX shells, except
	  that here, of course, the first command in the pipe-line
	  colone is an XSH command. Since semicolon (<literal>;</literal>)
	  is used in XSH to separate commands, it has to be prefixed
	  with a backslash if it should be used for other purposes.
	</para>
	<example>
	  <title>Use grep and less to display context of `funny'</title>
	  <code>xsh> ls //chapter[5]/para | grep funny | less</code>
	</example>
	<example>
	  <title>The same on Windows 2000/XP systems</title>
	  <code>xsh> ls //chapter[5]/para | find "funny" | more</code>
	</example>
      </section>
    </section>
  </doc>
  <preamb>
<![CDATA[
package XML::XSH::Grammar;

use strict;
use Parse::RecDescent;
use vars qw/$grammar/;

$Parse::RecDescent::skip = '(\s|\n|#[^\n]*)*';
$grammar=<<'_EO_GRAMMAR_';
]]>
  </preamb>
  <postamb>
<![CDATA[

_EO_GRAMMAR_

sub compile {
  Parse::RecDescent->Precompile($grammar,"XML::XSH::Parser");
}

sub new {
  return new Parse::RecDescent ($grammar);
}

1;
]]>
  </postamb>
  <rules>
    <!-- ================== commands and options ====================== -->
    <rule id="command" type="list">
      <production>
	<lookahead/>
	<regexp>\s*[}{;]</regexp>
	<directive type="commit"/>
	<directive type="reject"/>
      </production>
      <ruleref ref="cdonopen"/>
      <ruleref ref="backups"/>
      <ruleref ref="nobackups"/>
      <ruleref ref="quiet"/>
      <ruleref ref="verbose"/>
      <ruleref ref="test_mode"/>
      <ruleref ref="run_mode"/>
      <ruleref ref="debug"/>
      <ruleref ref="nodebug"/>
      <ruleref ref="version"/>
      <ruleref ref="validation"/>
      <ruleref ref="recovering"/>
      <ruleref ref="parser_expands_entities"/>
      <ruleref ref="keep_blanks"/>
      <ruleref ref="pedantic_parser"/>
      <ruleref ref="complete_attributes"/>
      <ruleref ref="indent"/>
      <ruleref ref="empty_tags"/>
      <ruleref ref="skip_dtd"/>
      <ruleref ref="parser_expands_xinclude"/>
      <ruleref ref="load_ext_dtd"/>
      <ruleref ref="encoding"/>
      <ruleref ref="query_encoding"/>
      <ruleref ref="options_command"/>
      <ruleref ref="copy_command"/>
      <ruleref ref="xcopy_command"/>
      <ruleref ref="move_command"/>
      <ruleref ref="xmove_command"/>
      <ruleref ref="list_command"/>
      <ruleref ref="exit_command"/>
      <ruleref ref="prune_command"/>
      <ruleref ref="map_command"/>
      <ruleref ref="rename_command"/>
      <ruleref ref="sort_command"/>
      <ruleref ref="close_command"/>
      <ruleref ref="validate_command"/>
      <ruleref ref="valid_command"/>
      <ruleref ref="list_dtd_command"/>
      <ruleref ref="print_enc_command"/>
      <ruleref ref="set_enc_command"/>
      <ruleref ref="set_standalone_command"/>
      <ruleref ref="cd_command"/>
      <ruleref ref="clone_command"/>
      <ruleref ref="count_command"/>
      <ruleref ref="eval_command"/>
      <ruleref ref="save_command"/>
      <ruleref ref="files_command"/>
      <ruleref ref="xslt_command"/>
      <ruleref ref="insert_command"/>
      <ruleref ref="xinsert_command"/>
      <ruleref ref="help_command"/>
      <ruleref ref="exec_command"/>
      <ruleref ref="include_command"/>
      <ruleref ref="ifinclude_command"/>
      <ruleref ref="assign_command"/>
      <ruleref ref="local_command"/>
      <ruleref ref="print_var_command"/>
      <ruleref ref="var_command"/>
      <ruleref ref="print_command"/>
      <ruleref ref="create_command"/>
      <ruleref ref="list_defs_command"/>
      <ruleref ref="select_command"/>
      <ruleref ref="if_command"/>
      <ruleref ref="unless_command"/>
      <ruleref ref="while_command"/>
      <ruleref ref="foreach_command"/>
      <ruleref ref="process_xinclude_command"/>    	
      <ruleref ref="chxpath_command"/>
      <ruleref ref="pwd_command"/>
      <ruleref ref="locate_command"/>
      <ruleref ref="xupdate_command"/>
      <ruleref ref="open_command"/>
      <ruleref ref="fold_command"/>
      <ruleref ref="unfold_command"/>
      <ruleref ref="normalize_command"/>
      <ruleref ref="strip_ws_command"/>
      <ruleref ref="last_command"/>
      <ruleref ref="next_command"/>
      <ruleref ref="prev_command"/>
      <ruleref ref="redo_command"/>
      <ruleref ref="return_command"/>
      <ruleref ref="throw_command"/>
      <ruleref ref="catalog_command"/>
      <ruleref ref="registerns_command"/>
      <ruleref ref="unregisterns_command"/>
      <ruleref ref="registerns_xhtml_command"/>
      <ruleref ref="registerns_xsh_command"/>
      <ruleref ref="unregisterfunc_command"/>
      <ruleref ref="registerfunc_command"/>
      <ruleref ref="stream_process_command"/>
      <ruleref ref="namespaces_command"/>
      <ruleref ref="xpath_completion_command"/>
      <ruleref ref="xpath_axis_completion_command"/>
      <ruleref ref="doc_info_command"/>
      <ruleref ref="ignore_use_command"/>
      <!-- ADD NEW COMMANDS HERE -->
      <production>
	<ruleref ref="call_command"/>
      </production>
      <documentation>
	<title>List of XSH commands</title>
	<description>
	  <para><typeref types="command"/></para>
	</description>
      </documentation>
    </rule>
    <rule id="statement">
      <production>
	<lookahead/>
	<regexp>\s*[}{;]</regexp>
	<directive type="commit"/>
	<directive type="reject"/>
      </production>
      <ruleref ref="if"/>
      <ruleref ref="unless"/>
      <ruleref ref="while"/>
      <ruleref ref="foreach"/>
      <ruleref ref="try_catch"/>
      <ruleref ref="iterate"/>
    </rule>

    <rule id="complex_command">
      <production>
	<string>;</string>
      </production>
      <production>
	<ruleref ref="statement"/>
	<directive type="commit"/>
	<ruleref ref="trail" rep="?"/>
	<action>
	  if (scalar(@{$item[3]})) {
	    if ($item[3][0][0] eq 'pipe') {
  	      $return=[\&amp;XML::XSH::Functions::pipe_command,[$item[1]],$item[3][0][1]]
	    } else {
   	      $return=[\&amp;XML::XSH::Functions::string_pipe_command,[$item[1]],$item[3][0][1]]
	    }
          } else {
            $return=$item[1]
          }
	</action>
      </production>
      <production>
	<ruleref ref="command"/>
	<directive type="commit"/>
	<ruleref ref="trail" rep="?"/>
	<group>
	  <production>
	    <string>;</string>
	  </production>
	  <production>
	    <lookahead/>
	    <regexp>^\s*(}|\Z)</regexp>
	  </production>
	</group>
	<action>
	  if (scalar(@{$item[3]})) {
	    if ($item[3][0][0] eq 'pipe') {
  	      $return=[\&amp;XML::XSH::Functions::pipe_command,[$item[1]],$item[3][0][1]]
	    } else {
   	      $return=[\&amp;XML::XSH::Functions::string_pipe_command,[$item[1]],$item[3][0][1]]
	    }
          } else {
            $return=$item[1]
          }
	</action>
      </production>
      <production>
	<directive type="error">Parse error near: "}.substr($text,0,40).qq{ ..."</directive>
      </production>
    </rule>

    <rule id="statement_or_command">
      <production><ruleref ref="def"/></production>
      <production><ruleref ref="undef"/></production>
      <production><ruleref ref="complex_command"/></production>
    </rule>

    <rule id="block" type="argtype" name="command-block">
      <production>
	<string>{</string>
	<directive type="commit"/>
	<ruleref ref="complex_command" rep="s"/>
	<string>}</string>
	<action>[grep ref,@{$item[3]}]</action>
      </production>
      <documentation sections="Argtypes Flow">
	<title>command-block argument type</title>
	<shortdesc>single XSH command or a block of XSH commands</shortdesc>
	<description>
	  <para>
	    XSH command or a block of semicolon-separated
	    commands enclosed within curly brackets.
	  </para>
	  <example>
	    <title>Count paragraphs in each chapter</title>
	    <code>
	      $i=0;
	      foreach //chapter {
	      <tab/>$c=count(./para);
	      <tab/>$i=$i+1;
	      <tab/>print &quot;$c paragraphs in chapter no.$i&quot;;
	      }
	    </code>
	  </example>
	</description>	
      </documentation>
    </rule>



    <!-- ================== help on types ====================== -->
    <rule id="type" type="list">
      <production/>
      <documentation>
	<title>List of command argument types</title>
	<description>
	  <para><typeref types="argtype"/></para>
	</description>
      </documentation>
    </rule>
    <!-- ================== terminals ====================== -->
    <rule id="TOKEN">
      <production>
	<regexp>\S+</regexp>
      </production>
    </rule>
    <rule id="STRING">
      <production>
	<regexp>([^'&quot;\$\\ \t\n\r\|;\{\}]|\$[^{]|\$\{[^{}]*\}|]|\\.)+</regexp>
      </production>
    </rule>
    <rule id="single_quoted_string">
      <production>
	<regexp>\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\'</regexp>
	<action>
	  local $_=$item[1];
	  s/^\'|\'$//g;
	  s{(\\)(.|\n)|(\$)}{ ($3 eq '$') ? "\\\$" : (($2 eq "\\")
	  ? "\\\\" : (($2 eq "'") ? "'" : ( ($2 eq '$') ? "\\\\\\$2" :
	  "\\\\$2"))) }eg;
	  $_;
	</action>
      </production>
    </rule>
    <rule id="double_quoted_string">
      <production>
	<regexp>\&quot;([^\&quot;\\]|\\.)*\&quot;</regexp>
	<action>
	  local $_=$item[1];
	  s/^\&quot;|\&quot;$//g;
	  $_;
	</action>
      </production>
    </rule>
    <!-- ================== expressions ====================== -->
    <rule id="exp_part">
      <production>
	<ruleref ref="STRING"/>
      </production>
      <production>
	<ruleref ref="exp_inline_count"/>
      </production>
      <production>
	<ruleref ref="single_quoted_string"/>
      </production>
      <production>
	<ruleref ref="double_quoted_string"/>
      </production>
    </rule>
    <rule id="exp_inline_count">
      <production>
	<regexp>\$\{\((.+?)\)\}</regexp>
      </production>
      <production>
	<regexp>\$\{\{\{(.+?)\}\}\}</regexp>
      </production>
      <production>
	<regexp>\$\{\{([^{].*?)\}\}</regexp>
      </production>
    </rule>
    <rule id="expression" type="argtype">
<production>
	<regexp>&lt;&lt;</regexp>
	<regexp>(\'|\")?</regexp>
	<ruleref ref="ID"/>
	<regexp>$item[2]</regexp>
	<directive type="skip">&quot;&quot;</directive> 
	<regexp>.*\n</regexp>
	<regexp>(.|\n)*?\n$item[3]\s*(\n|$)</regexp>
	<action>
	    $text=$item[6].$text;
	    local $_=$item[7]; s/\n$item[3]\s*$//;
	    if ($item[2] eq "'") {
	      s{(\\)(.|\n)|(\$)}{ ($3 eq '$') ? "\\\$" : (($2 eq "\\")
	      ? "\\\\" : (($2 eq "'") ? "'" : ( ($2 eq '$') ? "\\\\\\$2" :
	      "\\\\$2"))) }eg;
          }
	    $_;
	  </action>
      </production>
      <production>
	<ruleref ref="exp_part"/>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="expression" rep="?"/>
	<action>$item[1].join(&quot;&quot;,@{$item[3]})</action>
      </production>
      <documentation sections="Argtypes Variables Manipulation Perl_shell">
	<title>expression argument type</title>
	<shortdesc>string-like expression</shortdesc>
	<description>
	  <para>
	    Expression is a string consisting of unquoted characters
	    other than whitespace or semicolon, single quote or double
	    quote characters or quoted characters of any kind (but see
	    also special case of expression - so called here-documents -
	    described below). Quoting means either preceding a single
	    character with a backslash or enclosing a part of the
	    string into single quotes '...'  or double quotes
	    &quot;...&quot;. Quoting characters are removed from the
	    string so they must be quoted themselves if they are a
	    part of the expression: \\, \' or " ' ", \" or ' " '.
	    Unquoted (sub)expressons and (sub)expressions quoted with
	    double-quotes are subject to variable, Perl, and XPath
	    expansions.
	  </para>
	  <para>
	    Variable expansion replaces substrings of the form $id or
	    ${id} with the value of the variable named $id, unless
	    the '$' sign is quoted.
	  </para>
	  <para>
	    Perl expansion evaluates every substring enclosed in between
	    <literal>${{{</literal> and <literal>}}}</literal>
	    as a Perl expresson (in very much the same way as the <xref
	    linkend="eval_command"/> command) and replaces the whole thing
	    with the resulting value.
	  </para>
	  <para>
	    XPath interpolation evaluates every substring enclosed in
	    between     
	    <literal>${{</literal> and <literal>}}</literal>
	    as an XPath expression (in very much the same way as the
	    <xref linkend="count_command"/> command) and substitutes
	    the whole thing with the resul.
	  </para>
	  <para>
	    For convenience, another kind XPath interpolation is
	    performed on expressions. It replaces any substring
	    occuring between <literal>${(</literal> and
	    <literal>)}</literal> with a <emphasis>literal</emphasis>
	    result of XPath evaluation of the string. This means, that
	    if the evaluation results in a node-list, the textual
	    content of its first node is substituted rather than the
	    number of nodes in the node-list (as with <literal>${{
	    ... }}</literal>).
	  </para>
	  <example>
	    <code>echo foo "bar"                        # prints: foo bar</code>
	    <code>echo foo"bar"                         # prints: foobar</code>
	    <code>echo foo'"bar"'                       # prints: foo"bar"</code>
	    <code>echo foo"'b\\a\"r'"                   # prints: foo'b\a"r'</code>
	    <code>$a="bar"</code>
	    <code>echo foo$a                            # prints: foobar</code>
	    <code>echo foo\$a                           # prints: foo$a</code>
	    <code>echo '$a'                             # prints: '$a'</code>
	    <code>echo "'$a'"                           # prints: 'bar'</code>
	    <code>echo "${{//middle-earth/creatures}}"  # prints: 10</code>
	    <code>echo '${{//middle-earth/creatures}}'  # prints: ${{//middle-earth/creatures}}</code>
	    <code>echo ${{//creature[1]/@name}}         # !!! prints: 1</code>
	    <code>echo ${(//creature[1]/@name)}         # prints: Bilbo</code>
	    <code>echo ${{{ join(",",split(//,$a)) }}}  # prints: b,a,r</code>
	  </example>
	  <para>
	    There is one more special type of expressions, so called
	    ``here-documents'' following syntax of similar constructs
	    in Bash and Perl.  Following a <literal>&lt;&lt;</literal>
	    you specify a string to terminate the quoted material, and
	    all lines following the current line down to the
	    terminating string are the value of the expression.  The
	    terminating string is either quoted or unquoted identifier
	    (a word).  If quoted, the type of quotes you use
	    determines the treatment of the text, just as in regular
	    quoting, i.e. in case of double quotes, the material
	    contained in the here-document is subject to variable,
	    Perl, and XPath expansions.  An unquoted identifier works
	    just like double quotes. There must be no space between
	    the <literal>&lt;&lt;</literal> and the identifier. The
	    terminating string must appear by itself (unquoted and
	    with no surrounding whitespace) on the terminating line.
	  </para>
	  <example>
	    <code>$a="bar"</code>
	    <code>echo foo &lt;&lt;END baz;
xx $a yy
END
	# prints foo xx bar yy baz</code>
	    <code>echo foo &lt;&lt;"END" baz;
xx $a yy
END
	# same as above</code>
	    <code>echo foo &lt;&lt;'END' baz;
xx $a yy
END
	# prints foo xx $a yy baz</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <!-- ================= optional arguments =================== -->
    <rule id="ws">
      <production>
	<regexp>(\s|\n|#[^\n]*)+</regexp>
      </production>
    </rule>
    <rule id="optional_expression">
      <production>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="ws"/>
	<ruleref ref="expression"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <rule id="optional_expressions">
      <production>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="ws"/>
	<ruleref ref="expression" rep="s"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <rule id="optional_xpath">
      <production>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="ws"/>
	<ruleref ref="xpath"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <!-- ================== encoding string ====================== -->
    <rule id="enc_string" type="argtype" name="enc-string">
      <production>
	<ruleref ref="expression"/>
      </production>
      <documentation sections="Argtypes Configuration">
	<title>enc_string argument type</title>
	<shortdesc>character encoding (codepage) identifier</shortdesc>
	<description>
	  <para>
	    An <xref linkend="expression"/> which interpolates to a valid encoding
	    string, e.g. to utf-8, utf-16, iso-8859-1, iso-8859-2,
	    windows-1250 etc.
	  </para>
	</description>
      </documentation>
    </rule>
    <!-- ================== identifyer ====================== -->
    <rule id="ID" type="argtype" name="id">
      <production>
	<regexp>[a-zA-Z_][a-zA-Z0-9_]*</regexp>
      </production>
      <documentation sections="Argtypes Variables Documents">
	<title>id argument type</title>
	<shortdesc>identifier</shortdesc>
	<description>
	  <para>
	    An identifier, that is, a string beginning with a letter or
	    underscore, and containing letters, underscores, and
	    digits.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="id_or_var">
      <production><ruleref ref="ID"/></production>
      <production><ruleref ref="variable"/></production>
    </rule>
    <!-- ================== scheme (DTD,RNG,XSD) ====================== -->
    <rule id="public_dtd">
      <production>
	<string>PUBLIC</string>
	<ruleref ref="expression"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="system_dtd">
      <production>
	<regexp>SYSTEM|FILE</regexp>
	<ruleref ref="filename"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="validation_scheme">
      <production>
	<string>DTD</string>
	<ruleref ref="public_dtd"/>
	<ruleref ref="system_dtd"/>
	<action>['DTD','FILE',$item[2],$item[3]]</action>
      </production>
      <production>
	<string>DTD</string>
	<ruleref ref="public_dtd"/>
	<action>['DTD','FILE',$item[2],undef]</action>
      </production>
      <production>
	<string>DTD</string>
	<ruleref ref="system_dtd"/>
	<action>['DTD','FILE',undef,$item[2]]</action>
      </production>
      <production>
	<string>DTD</string>
	<string>STRING</string>
	<ruleref ref="expression"/>
	<action>['DTD','STRING',$item[3]]</action>
      </production>
      <production>
	<regexp>RNG|RelaxNG|RELAXNG</regexp>
	<regexp>FILE|STRING|DOC</regexp>
	<ruleref ref="filename"/>
	<action>['RNG',@item[2,3]]</action>
      </production>
      <production>
	<regexp>Schema|SCHEMA|XSD</regexp>
	<regexp>FILE|STRING|DOC</regexp>
	<ruleref ref="filename"/>
	<action>['XSD',@item[2,3]]</action>
      </production>
    </rule>
    <!-- ================== filename ====================== -->
    <rule id="filename" type="argtype">
      <production>
	<ruleref ref="expression"/>
      </production>
      <documentation sections="Argtypes Documents">
	<title>Filename argument type</title>
	<shortdesc>file name</shortdesc>
	<description>
	  <para>An <xref linkend="expression"/> which interpolates to
	  a valid file name or URL.</para>
	</description>
      </documentation>
    </rule>
    <!-- ================== XPATH ====================== -->
    <rule id="xpath" type="argtype">
      <production>
	<ruleref ref="id_or_var"/>
	<directive type="skip">&quot;&quot;</directive>
	<regexp>:(?!:)</regexp>
	<ruleref ref="xp"/>
	<action>[$item[1],$item[4]]</action>
      </production>
      <production>
	<ruleref ref="xp"/>
	<action>[undef,$item[1]]</action>
      </production>
      <production>
	<directive type="error">expected ID:XPath or XPath, but got "}.substr($text,0,40).qq{ ..."</directive>
      </production>
      <documentation sections="Argtypes Navigation Manipulation Variables">
	<title>XPath argument type</title>
	<shortdesc>XPath expression</shortdesc>
	<description>
	  <para>
	    XSH supports arbitrary XPath expression as defined in W3C
	    recommendation at <ulink
	    url="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</ulink>.
	    (Nice interactive XPath tutorials and references
	    can be found at <ulink url="http://www.zvon.org">http://www.zvon.org</ulink>.)
	    In XSH, XPath expressoin may be optionally preceded with a
	    document identifier followed by colon (<xref linkend="ID"/>:xpath). If no document
	    identifier is given, the current document is used.
	  </para>
	  <para>
	    As an extension, the following XPath extension functions are defined in
	    the XSH namespace:
	  </para>
	  <para>
	    <literal>xsh:doc(id-string)</literal> -
	    returns a nodelist consisting of the document node
	    associated in XSH with an identifier given in
	    <literal>id-string</literal>.	    
	  </para>
	  <para>
	    <literal>xsh:matches(match-string,regexp-string)</literal> -
	    returns <literal>true</literal> if <literal>match-string</literal>
	    matches the regular expression given in
	    <literal>regexp-string</literal>.
	    Otherwise returns <literal>false</literal>.
	  </para>
	  <para>
	    <literal>xsh:grep(node-set, regexp-string)</literal> -
	    returns a node set consisting of nodes of the
	    given <literal>node-set</literal> whose content 
	    (as returned by the built-in XPath 
	    function <literal>string()</literal>)
	    matches the regular expression given in <literal>regexp-string</literal>.
	  </para>
	  <para>
	    <literal>xsh:same(node-set1, node-set2)</literal> -
	    returns <literal>true</literal> if the given node sets
	    both contain the same node
	    (in XPath, this can also be expressed as
	    <literal>count(node-set1|node-set2)+count(node-set1)+count(node-set2)=1</literal>).
	  </para>
	  <example>
	    <title>Open a document and count all sections containing a
	      subsection
	    </title>
	    <code>
	      xsh scratch:/&gt; <userinput>open v = mydocument1.xml;</userinput>
	      xsh v:/&gt; <userinput>open k = mydocument2.xml;</userinput>
	      xsh k:/&gt; <userinput>count //section[subsection];</userinput> # searches k
	      xsh k:/&gt; <userinput>count v://section[subsection];</userinput> # searches v
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xpcont">
      <production>
	<group>
	  <production>
	    <ruleref ref="xpfilters"/>
	  </production>
	  <production>
	    <ruleref ref="xpbrackets"/>
	  </production>
	</group>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="xp" rep="?"/>
	<action>$item[1].join(&quot;&quot;,@{$item[3]})</action>
      </production>
      <production>
	<ruleref ref="xp"/>
	<action>$item[1]</action>
      </production>
    </rule>
    <rule id="xp">
      <production>
	<ruleref ref="xpsimple"/>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="xpcont" rep="?"/>
	<action>$item[1].join(&quot;&quot;,@{$item[3]})</action>
      </production>
      <production>
	<ruleref ref="xpstring"/>
      </production>
    </rule>
    <rule id="xpfilters">
      <production>
	<ruleref ref="xpfilter" rep="s"/>
	<action>join(&quot;&quot;,@{$item[1]})</action>
      </production>
    </rule>
    <rule id="xpfilter">
      <production>
	<string>[</string>
	<ruleref ref="xpinter"/>
	<string>]</string>
	<action>&quot;[$item[2]]&quot;</action>
      </production>
    </rule>
    <rule id="xpbracket">
      <production>
	<string>(</string>
	<ruleref ref="xpinter"/>
	<string>)</string>
	<action>&quot;($item[2])&quot;</action>
      </production>
    </rule>
    <rule id="xpbrackets">
      <production>
	<ruleref ref="xpbracket"/>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="xpfilters" rep="?"/>
	<action>join &quot;&quot;,$item[1],@{$item[3]}</action>
      </production>
    </rule>
    <rule id="xpintercont">
      <production>
	<group>
	  <production>
	    <ruleref ref="xpfilters"/>
	  </production>
	  <production>
	    <ruleref ref="xpbrackets"/>
	  </production>
	</group>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="xpinter" rep="?"/>
	<action>join(&quot;&quot;,$item[1],@{$item[3]})</action>
      </production>
    </rule>
    <rule id="xpinter">
      <production>
	<ruleref ref="xps"/>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="xpintercont" rep="?"/>
	<action>join(&quot;&quot;,$item[1],@{$item[3]})</action>
      </production>
    </rule>
    <rule id="xps">
      <production>
	<regexp>([^][()'&quot;]|'[^']*'|&quot;[^&quot;]*&quot;)*</regexp>
      </production>
    </rule>
    <rule id="xpstring">
      <production>
	<regexp>'[^']*'|&quot;[^&quot;]*&quot;</regexp>
      </production>
    </rule>
    <rule id="xpsimple">
      <production>
	<regexp>[^]}|&quot;' [();]+</regexp>
      </production>
      <production>
	<ruleref ref="xpbrackets"/>
      </production>
    </rule>
    <!-- ================== perl expression=expression ====================== -->
    <rule id="perl_expression">
      <production>
	<ruleref ref="expression"/>
      </production>
    </rule>
    <!-- ================== variables ====================== -->
    <rule id="variable">
      <production>
	<string>$</string>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="ID"/>
	<action>&quot;$item[1]$item[3]&quot;</action>
      </production>
    </rule>
    <rule id="nodelistvariable">
      <production>
	<string>%</string>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="ID"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <rule id="loosenodelistvariable">
      <production>
	<string>%</string>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="id_or_var"/>
	<action>$item[3]</action>
      </production>
    </rule>
    <!-- ================== EOF ====================== -->
    <rule id="eof">
      <production>
	<regexp>^\Z</regexp>
	<action>1;</action>
      </production>
    </rule>
    <!-- ================== STARTRULE and such ====================== -->
    <rule id="startrule">
      <production>
	<ruleref ref="shell"/>
	<directive type="commit"/>
	<ruleref ref="eof"/>
	<action>XML::XSH::Functions::run_commands($item[1],1)</action>
      </production>
      <production>
	<ruleref ref="statement_or_command" rep="s"/>
	<directive type="commit"></directive>
	<ruleref ref="eof"/>
	<action>XML::XSH::Functions::run_commands($item[1],1)</action>
      </production>
    </rule>
    <rule id="trail">
      <production>
	<string>|&gt;</string>
	<directive type="commit"/>
	<ruleref ref="variable"/>
	<action>['var',$item[3]]</action>
      </production>
      <production>
	<string>|</string>
	<directive type="commit"/>
	<ruleref ref="shline"/>
	<action>['pipe',$item[3]]</action>
      </production>
    </rule>
    <rule id="shline_nosc">
      <production>
	<regexp>([^;()\\&quot;'\|]|\|[^&gt;]|\\.|\&quot;([^\&quot;\\]|\\.)*\&quot;|\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\')*</regexp>
      </production>
    </rule>
    <rule id="shline_inter">
      <production>
	<regexp>([^()\\&quot;']|\\.|\&quot;([^\&quot;\\]|\\.)*\&quot;|\'([^\'\\]|\\\'|\\\\|\\[^\'\\])*\')*</regexp>
      </production>
    </rule>
    <rule id="shline_bracket">
      <production>
	<string>(</string>
	<ruleref ref="shline_inter"/>
	<ruleref ref="shline_bracket" rep="?"/>
	<ruleref ref="shline_inter"/>
	<string>)</string>
	<action>join(&quot;&quot;,'(',$item[2],@{$item[3]},$item[4],')')</action>
      </production>      
    </rule>
    <rule id="shline">
      <production>
	<ruleref ref="shline_nosc"/>
	<ruleref ref="shline_bracket" rep="?"/>
	<ruleref ref="shline_nosc"/>
	<action>join(&quot;&quot;,$item[1],@{$item[2]},$item[3])</action>
      </production>
    </rule>
    <rule id="shell">
      <production>
	<regexp>!\s*</regexp>
	<directive type="commit"></directive>
	<regexp>.*</regexp>
	<action>[[\&amp;XML::XSH::Functions::sh,$item[3]]]</action>
      </production>
      <production>
	<directive type="error-if-committed">Parse error near: "! }.substr($text,0,40).qq{ ..."</directive>
	<directive type="reject"/>
      </production>
    </rule>
    <!-- ================== STATEMENTS ====================== -->
    <rule id="condition">
      <production><directive type="perl_codeblock"/></production>
      <production><ruleref ref="xpath"/></production>
    </rule>
    <rule id="elsif_block" name="elsif">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<ruleref ref="elsif_block"/>
	<action>[[$item[3],$item[4]],@{$item[5]}]</action>
      </production>
      <production>
	<lookahead negative="yes"/>
	<selfref/>
	<action>[]</action>
      </production>
      <production>
	<directive type="uncommit"/>
	<directive type="error">Parse error near keyword elsif: "}.substr($text,0,40).qq{ ..."</directive>
      </production>
    </rule>
    <rule id="else_block" name="else">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="block"/>
	<action>[[undef,$item[3]]]</action>
      </production>
      <production>
	<lookahead negative="yes"/>
	<selfref/>
	<action>[]</action>
      </production>
      <production>
	<directive type="uncommit"/>
	<directive type="error">Parse error near keyword else: "}.substr($text,0,40).qq{ ..."</directive>
      </production>
    </rule>
    <!-- try/catch -->
    <rule id="local_var">
      <production>
	<group rep="?">
	  <production>
	    <regexp>local\s</regexp>
	  </production>
	</group>
	<ruleref ref="variable"/>
	<action>[$item[2],@{$item[1]}]</action>
      </production>
    </rule>
    <rule id="try_catch" type="command" name="try" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="block"/>
	<string>catch</string>
	<ruleref ref="local_var" rep="?"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::try_catch,$item[3],$item[6],@{$item[5]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>try <xref linkend="block"/> catch [[local] $<xref linkend="ID"/>] <xref linkend="block"/></usage>
	<shortdesc>try/catch statement</shortdesc>
	<description>
	  <para>
	    Execute <xref linkend="block"/> following the
	    <literal>try</literal> keyword.  If an error or exception
	    occures during the evaluation, execute the
	    <literal>catch</literal> <xref linkend="block"/>.  If a
	    variable follows <literal>catch</literal> and the
	    <literal>try</literal> block fails, an error message of
	    the exception occured is stored to the variable before the
	    <literal>catch</literal> block is executed.  Optionally,
	    the variable name may be preceded with the keyword
	    <literal>local</literal> in order to make the assignment
	    local to the <literal>catch</literal> block (see <xref
	    linkend="local_command"/>).
	  </para>
	  <para>
	    The <xref linkend="throw_command"/> command and the equivalent
	    perl construction <literal>perl { die "error message"
	    }</literal> allow user to throw custom exceptions.
	  </para>
	  <example>
	    <title>Handle parse errors</title>
	    <code>try {
	      <tab/>open XML doc=$input;
	      } catch {
	      <tab/>try {
	      <tab count="2"/>echo "XML parser failed, trying HTML";
	      <tab count="2"/>open HTML doc=$input;
	      <tab/>} catch local $error {
	      <tab count="2"/>echo "Stopping due to errors: $error";
	      <tab count="2"/>exit 1;
	      <tab/>}
	      }
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="throw_command"/>
	</see-also>
      </documentation>
    </rule>
    <!-- if -->
    <rule id="if" type="command" name="if" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<ruleref ref="elsif_block"/>
	<ruleref ref="else_block"/>
	<action>[\&amp;XML::XSH::Functions::if_statement,[$item[3],$item[4]],@{$item[5]},@{$item[6]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>if <xref linkend="xpath"/>|<xref linkend="perl_code"/> <xref linkend="command"/>
	</usage>
	<usage>
          if <xref linkend="xpath"/>|<xref linkend="perl_code"/>
	  <xref linkend="block"/> [ elsif <xref linkend="block"/> ]* [ else <xref linkend="block"/> ]
	</usage>
	<shortdesc>if statement</shortdesc>
	<description>
	  <para>
	    Execute <xref linkend="block"/> if a given <xref
	    linkend="xpath"/> or <xref linkend="perl_code"/>
	    expression evaluates to a non-emtpty node-list, true
	    boolean-value, non-zero number or non-empty literal. If
	    the first test fails, check all possibly following
	    <literal>elsif</literal> conditions and execute the
	    corresponding <xref linkend="block"/> for the first one of
	    them which is true. If none of them succeeds, execute the
	    <literal>else</literal> <xref linkend="block"/> (if any).
	  </para>
	  <example>
	    <title>Display node type</title>
	    <code>def node_type %n {
	      <tab/>foreach (%n) {
	      <tab count="2"/>if ( . = self::* ) { # XPath trick to check if . is an element
	      <tab count="3"/>echo 'element';
	      <tab count="2"/>} elsif ( . = ../@* ) { # XPath trick to check if . is an attribute
	      <tab count="3"/>echo 'attribute';
	      <tab count="2"/>} elsif ( . = ../processing-instruction() ) {
	      <tab count="3"/>echo 'pi';
              <tab count="2"/>} elsif ( . = ../text() ) {
	      <tab count="3"/>echo 'text';
              <tab count="2"/>} elsif ( . = ../comment() ) {
              <tab count="3"/>echo 'comment'
	      <tab count="2"/>} else { # well, this should not happen, but anyway, ...
              <tab count="3"/>echo 'unknown-type';
              <tab count="2"/>}
              <tab/>}
	      }
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="if_command" name="if" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::if_statement,[$item[3],[$item[4]]]]</action>
      </production>
    </rule>
    <!-- unless -->
    <rule id="unless" type="command" name="unless" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<ruleref ref="else_block" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::unless_statement,$item[3],$item[4],@{$item[5]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>unless <xref linkend="xpath"/>|<xref linkend="perl_code"/>
	  <xref linkend="command"/>
	</usage>
	<usage>
          unless <xref linkend="xpath"/>|<xref linkend="perl_code"/>
	  <xref linkend="block"/> [ else <xref linkend="block"/> ]
	</usage>
	<shortdesc>negated if statement</shortdesc>
	<description>
	  <para>Like if but negating the result of the expression.</para>
	</description>
	<see-also>
	  <ruleref ref="if"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="unless_command" name="unless" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::unless_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <!-- while -->
    <rule id="while_command" name="while" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::while_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <rule id="while" type="command" name="while" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::while_statement,$item[3],$item[4]]</action>
      </production>
      <documentation sections="Flow">
	<usage>while <xref linkend="xpath"/>|<xref linkend="perl_code"/> <xref linkend="block"/></usage>
	<shortdesc>simple while loop</shortdesc>
	<description>
	  <para> Execute <xref linkend="block"/> as long as
	    the given <xref linkend="xpath"/> or <xref linkend="perl_code"/> expression evaluates to a non-emtpty
	    node-list, true boolean-value, non-zero number or
	    non-empty literal.
	  </para>
	  <example>
	    <title>The commands have the same results</title>
	    <code>
	      xsh&gt; <userinput>while /table/row remove /table/row[1];</userinput>
	      xsh&gt; <userinput>remove /table/row;</userinput>
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <!-- foreach -->
    <rule id="foreach_command" name="foreach" inline="yes">
      <aliases>
	<alias name="for"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="command"/>
	<action>[\&amp;XML::XSH::Functions::foreach_statement,$item[3],[$item[4]]]</action>
      </production>
    </rule>
    <rule id="foreach" type="command" name="foreach" inline="yes">
      <aliases>
	<alias name="for"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::foreach_statement,$item[3],$item[4]]</action>
      </production>
      <documentation sections="Flow">
	<usage>foreach <xref linkend="xpath"/>|<xref linkend="perl_code"/> 
	  <xref linkend="command"/>|<xref linkend="block"/></usage>
	<shortdesc>loop iterating over a node-list or perl array</shortdesc>
	<description>
	  <para>
	    If the first argument is an <xref linkend="xpath"/>
	    expression, execute the command-block for each node
	    matching the expression making it temporarily the current
	    node, so that all relative XPath
	    expressions are evaluated in its context.
	  </para>
	  <para>
	    If the first argument is a <xref linkend="perl_code"/>, it
	    is evaluated and the resulting perl-list is iterated
	    setting the variable $__ (note that there are
	    <emphasis>two</emphasis> underscores!)  to be each element
	    of the list in turn. It works much like perl's foreach,
	    except that the variable used consists of two underscores.
	  </para>
	  <example>
	    <title>Move all employee elements in a company element
	      into a staff subelement of the same company</title>
	    <code>xsh&gt; <userinput>foreach //company xmove ./employee into ./staff;</userinput></code>
	  </example>
	  <example>
	    <title>List content of all XML files in current directory</title>
	    <code>
	      xsh&gt; <userinput>foreach { glob('*.xml') } { open f=$__; list f:/; }</userinput>
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <!-- def -->
    <rule id="typedvariable">
      <production>
	<regexp>[\$\%]</regexp>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="ID"/>
	<action>"$item[1]$item[3]"</action>
      </production>
    </rule>
    <rule id="undef" type="command" name="undef">
      <aliases>
	<alias name="undefine"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>
	  &amp;XML::XSH::Functions::undef_sub($item[3]);
	</action>
      </production>
      <documentation sections="Flow">
	<usage>undef <xref linkend="expression"/></usage>
	<shortdesc>undefine sub-routine (macro)</shortdesc>
	<description>
	  <para>
	    This command can be used to undefine previously defined
	    XSH subroutines. The <xref linkend="expression"/> is
	    evaluated as a Perl regular expression. All subroutines
	    whose names match are undefined. Note, that like
	    <literal>def</literal>, all <literal>undef</literal>
	    commands are processed during the compilation of the
	    source code, not at run-time, so it doesn't matter how
	    deep in the code is a <literal>undef</literal> command
	    nested.
	  </para>
	  <example>
	    <code>xsh> include my_defs.xsh
xsh> call my_sub1 //foo;
xsh> call my_sub2 //bar;
xsh> undefine 'my_sub.*'
xsh> # change/edit the definitions in my_defs.xsh and reload
xsh> include my_defs.xsh</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="def" type="command" name="def">
      <aliases>
	<alias name="define"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="ID"/>
	<ruleref ref="typedvariable" rep="s?"/>
	<ruleref ref="block" rep="?"/>
	<action>
	  &amp;XML::XSH::Functions::def($item[3],$item[5],$item[4]);
	</action>
      </production>
      <production>
	<directive type="error-if-committed">Parse error near: "}.substr($text,0,40).qq{ ..."</directive>
	<directive type="reject"/>
      </production>
      <documentation sections="Flow">
	<usage>def <xref linkend="ID"/> [$<xref linkend="ID"/> | %<xref linkend="ID"/>]* <xref linkend="block"/>
         or
	def <xref linkend="ID"/> [$<xref linkend="ID"/> | %<xref linkend="ID"/>]*;
	</usage>
	<shortdesc>sub-routine (macro) declaration</shortdesc>
	<description>
	  <para>
	    Define a new XSH subroutine named <xref linkend="ID"/>.
	    The subroutine may require zero or more parameters of
	    nodelist or string type. These are declared as a
	    whitespace-separated list of (so called) <emphasis>parametric
	    variables</emphasis> (of nodelist or string type). The body of the
	    subroutine is specified as a <xref linkend="block"/>.
	    Note, that all subroutine declarations are processed
	    during the parsing and not at run-time, so it does not
	    matter where the subroutine is defined.
	  </para>
	  <para>The routine can be later invoked using the <xref
	    linkend="call_command"/> command followed by the routine
	    name and parameters. Nodelist parameters must be given
	    as an XPath expressions, and are evaluated just before the
	    subroutine's body is executed. String parameters must be
	    given as (string) <xref linkend="expression"/>s.
	    Resulting node-lists/strings are stored into the
	    parametric variables before the body is executed. These
	    variables are local to the subroutine's call tree (see also the <xref
	    linkend="local_command"/> command). If there is a global
	    variable using the same name as some parametric variable,
	    the original value of the global variable is replaced with
	    the value of the parametric variable for the time of the
	    subroutine's run-time.
	  </para>
	  <para>
	    Note that subroutine has to be declared before it is
	    called with <xref linkend="call_command"/>. If you cannot
	    do so, e.g. if you want to call a subroutine recursively,
	    you have to pre-declare the subroutine using a
	    <literal>def</literal> with no <xref linkend="block"/>.
	    There may be only one full declaration (and possibly one
	    pre-declaration) of a subroutine for one <xref
	    linkend="ID"/> and the declaration and pre-declaration has
	    to define the same number of arguments and their types
	    must match.
	  </para>
	  <example>
	    <code>def l3 %v {
<tab/>ls %v 3; # list given nodes upto depth 3
}
call l3 //chapter;
	    </code>
	  </example>
	  <example>
	    <title>Commenting and un-commenting pieces of document</title>
	    <code>
def comment
<tab/><tab/>%n      # nodes to move to comments
<tab/><tab/>$mark   # maybe some handy mark to recognize such comments
{
<tab/>foreach %n {
<tab/><tab/>if ( . = ../@* ) {
<tab/><tab/><tab/>echo "Warning: attribute nodes are not supported!";
<tab/><tab/>} else {
<tab/><tab/><tab/>echo "Commenting out:";
<tab/><tab/><tab/>ls .;
<tab/><tab/><tab/>local $node = "";
<tab/><tab/><tab/>ls . |> $node;
<tab/><tab/><tab/>add comment "$mark$node" replace .;
<tab/><tab/>}
<tab/>}
}

def uncomment %n $mark {
<tab/>foreach %n {
<tab/><tab/>if (. = ../comment()) { # is this node a comment node
<tab/><tab/><tab/>local $string = substring-after(.,"$mark");
<tab/><tab/><tab/>add chunk $string replace .;
<tab/><tab/>} else {
<tab/><tab/><tab/>echo "Warning: Ignoring non-comment node:";
<tab/><tab/><tab/>ls . 0;
<tab/><tab/>}
<tab/>}
}


# comment out all chapters with no paragraphs
call comment //chapter[not(para)] "COMMENT-NOPARA";

# uncomment all comments (may not always be valid!)
$mark="COMMENT-NOPARA";
call uncomment //comment()[starts-with(.,"$mark")] $mark;
</code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="call_command"/>
	  <ruleref ref="return_command"/>
	  <ruleref ref="local_command"/>
	</see-also>
      </documentation>
    </rule>
    <!-- ================== COMMANDS ====================== -->
    <rule id="assign_command" type="command" name="assign" inline="yes">
      <production>
	<group rep="?">
	  <production><selfref/></production>
	</group>
	<ruleref ref="variable"/>
	<string>=</string>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::xpath_assign,$item[2],$item[4]]</action>
      </production>
      <production>
	<group rep="?">
	  <production><selfref/></production>
	</group>
	<ruleref ref="nodelistvariable"/>
	<string>=</string>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::nodelist_assign,$item[2],$item[4]]</action>
      </production>
      <documentation sections="Variables">
	<usage>assign $<xref linkend="ID"/>=<xref linkend="xpath"/>
	</usage>
	<usage>
	  $<xref linkend="ID"/>=<xref linkend="xpath"/></usage>
	<usage>
	  assign %<xref linkend="ID"/>=<xref linkend="xpath"/></usage>
	<usage>
	  %<xref linkend="ID"/>=<xref linkend="xpath"/></usage>
	<shortdesc>variable assignment</shortdesc>
	<description>
	  <para> 
	    In the first two cases (where dollar sign appears)
	    store the result of evaluation of the <xref linkend="xpath"/> in a variable named $<xref linkend="ID"/>.
	    In this case, <xref linkend="xpath"/> is evaluated in a
	    simmilar way as in the case of the <xref linkend="count_command"/>: if it results in a literal
	    value this value is used. If it results in a node-list,
	    number of nodes occuring in that node-list is used.
	    Use the <literal>string()</literal> XPath function
	    to obtain a literal values in these cases.
	  </para>
	  <example>
	    <title>String expressions</title>
	    <code>xsh&gt; <userinput>$a=string(chapter/title)</userinput>
	      xsh&gt; <userinput>$b=&quot;hallo world&quot;</userinput>
	    </code>
	  </example>
	  <example>
	    <title>Arithmetic expressions</title>
	    <code>xsh&gt; <userinput>$a=5*100</userinput>
	      xsh&gt; <userinput>$a</userinput>
	      $a=500
	      xsh&gt; <userinput>$a=(($a+5) div 10)</userinput>
	      xsh&gt; <userinput>$a</userinput>
	      $a=50.5
	    </code>
	  </example>
	  <example>
	    <title>Counting nodes</title>
	    <code>xsh&gt; <userinput>$a=//chapter</userinput>
	      xsh&gt; <userinput>$a</userinput>
	      $a=10
	      xsh&gt; <userinput>%chapters=//chapter</userinput>
	      xsh&gt; <userinput>$a=%chapters</userinput>
	      xsh&gt; <userinput>$a</userinput>
	      $a=10
	    </code>
	  </example>
	  <example>
	    <title>Some caveats of counting node-lists</title>
	    <code>xsh&gt; <userinput>ls ./creature</userinput>
	          &lt;creature race='hobbit' name=&quot;Bilbo&quot;/&gt;

	      ## WRONG (@name results in a singleton node-list) !!!
	      xsh&gt; <userinput>$name=@name</userinput>
	      xsh&gt; <userinput>$name</userinput>
	      $name=1

	      ## CORRECT (use string() function)
	      xsh&gt; <userinput>$name=string(@name)</userinput>
	      xsh&gt; <userinput>$name</userinput>
	      $name=Bilbo
	    </code>
	  </example>
	  <para> 
	    In the other two cases (where percent sign appears)
	    find all nodes matching a given <xref linkend="xpath"/>
	    and store the resulting node-list in the variable
	    named %<xref linkend="ID"/>. The variable may be later used
	    instead of an XPath expression.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="var_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="anyvariable">
      <production>
	<ruleref ref="variable"/>
	<action>['$',$item[1]]</action>
      </production>
      <production>
	<ruleref ref="nodelistvariable"/>
	<action>['%',$item[1]]</action>
      </production>
    </rule>
    <rule id="local_command" type="command" name="local" inline="yes">
      <production>
	<selfref/>
	<ruleref ref="variable"/>
	<string>=</string>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::xpath_assign_local,$item[2],$item[4]]</action>
      </production>
      <production>
	<selfref/>
	<ruleref ref="nodelistvariable"/>
	<string>=</string>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::nodelist_assign_local,$item[2],$item[4]]</action>
      </production>
      <production>
	<selfref/>
	<ruleref ref="anyvariable" rep="s"/>
	<action>[\&amp;XML::XSH::Functions::make_local,@{$item[2]}]</action>
      </production>
      <documentation sections="Variables">
	<usage>local $<xref linkend="ID"/> = <xref linkend="xpath"/></usage>
	<usage>local %<xref linkend="ID"/> = <xref linkend="xpath"/></usage>
	<usage>local $<xref linkend="ID"/>|%<xref linkend="ID"/> [ $<xref linkend="ID"/>|%<xref linkend="ID"/> ... ] </usage>
	<shortdesc>temporarily assign new value to a variable</shortdesc>
	<description>
	  <para> 
	    This command acts in a very similar way as
	    <xref linkend="assign_command"/> does, except
	    that the variable assignment is done temporarily
	    and lasts only for the rest of the nearest enclosing
	    <xref linkend="block"/>. At the end of the
	    enclosing block or subroutine the original value
	    is restored. This command may also be used without the
	    assignment part and assignments may be done later using
	    the usual <xref linkend="assign_command"/> command.
	  </para>
	  <para>Note, that the variable itself is not lexically is
	    still global in the sense that it is still visible to any
	    subroutine called subsequently from within the same block.
	    A local just gives temporary values to global (meaning
	    package) variables. Unlike Perl's <literal>my</literal>
	    declarations it does not <emphasis>create</emphasis> a
	    local variable.  This is known as dynamic scoping.
	    Lexical scoping is not implemented in XSH.
	  </para>
	  <para>
	    To sum up for Perl programmers: <literal>local</literal>
	    in XSH works exactly the same as <literal>local</literal>
	    in Perl.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="assign_command"/>
	  <ruleref ref="def"/>
	</see-also>
      </documentation>
    </rule>

    <rule id="print_var_command" inline="yes">
      <production>
	<ruleref ref="variable"/>
	<action>[\&amp;XML::XSH::Functions::print_var,$item[1]]</action>
      </production>
    </rule>
    <rule id="options_command" type="command" name="options" inline="yes">
      <aliases>
	<alias name="flags"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<action>[\&amp;XML::XSH::Functions::list_flags]</action>
      </production>
      <documentation sections="Information Configuration">
	<usage>options</usage>
	<shortdesc>list current settings using XSH syntax</shortdesc>
	<description>
	  <para>List current values of all XSH flags and options (such as
	  validation flag or query-encoding).</para>
	  <example>
	    <title>Store current settings in your .xshrc</title>
	    <code>xsh&gt; <userinput>options | cat &gt; ~/.xshrc</userinput></code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="list_defs_command" type="command" name="defs" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<action>[\&amp;XML::XSH::Functions::list_defs]</action>
      </production>
      <documentation sections="Information">
	<usage>defs</usage>
	<shortdesc>list all user-defined routines (macros)</shortdesc>
	<description>
	  <para>List names and parametric variables for all defined XSH routines.</para>
	</description>
	<see-also>
	  <ruleref ref="def"/>
	  <ruleref ref="var_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="ifinclude_command" type="command" name="ifinclude" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::include,$item[3],1]</action>
      </production>
      <documentation sections="Flow">
	<usage>ifinclude <xref linkend="filename"/></usage>
	<shortdesc>conditionally include another XSH source in current position</shortdesc>
	<description>
	  <para>
	    Include a file named <xref linkend="filename"/> and execute all XSH
	    commands therein unless the file was already included
	    using either <xref linkend="include_command"/> of <xref
	    linkend="ifinclude_command"/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="include_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="include_command" type="command" name="include" inline="yes">
      <aliases>
	<alias name="." regexp="\."/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::include,$item[3]]</action>
      </production>
      <documentation sections="Flow">
	<usage>include <xref linkend="filename"/></usage>
	<shortdesc>include another XSH source in current position</shortdesc>
	<description>
	  <para>
	    Include a file named <xref linkend="filename"/> and execute all XSH
	    commands therein.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="ifinclude_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="match_typedargs">
      <production>
	<action>
	  $return = ((@arg and $arg[0]&lt;=$#arg and $arg[$arg[0]]=~m/^%/) 
	            ? $arg[$arg[0]] : undef)
	</action>
	<ruleref ref="xpath"/>
	<ruleref ref="match_typedargs" arguments="$arg[0]+1,@arg[1..$#arg]"/>
	<action>
	  $return=(defined($item[3]) ? [$item[2],@{$item[3]}] : undef);
	</action>
      </production>
      <production>
	<action>
	  $return = ((@arg and $arg[0]&lt;=$#arg and $arg[$arg[0]]=~m/^\$/)
  	            ? $arg[$arg[0]] : undef)
	</action>
	<ruleref ref="expression"/>
	<ruleref ref="match_typedargs" arguments="$arg[0]+1,@arg[1..$#arg]"/>
	<action>
	  $return=(defined($item[3]) ? [$item[2],@{$item[3]}] : undef);
	</action>
      </production>
      <production>
	<action>
	  $return= (($arg[0]==$#arg+1) ? [] : undef);
	</action>
      </production>
    </rule>
    <rule id="subroutine_arguments">
      <production>
	<action>
	  if (exists($XML::XSH::Functions::_defs{$arg[0]})) {
	    $return=[ @{$XML::XSH::Functions::_defs{$arg[0]}} ];
	    shift @$return;
          } else { 
	    $return=undef;
	  }
	</action>
      </production>
      <production>
	<directive type="error">Call to undefined subroutine $arg[0]!</directive>
      </production>
    </rule>
    <rule id="call_command" type="command" name="call" inline="no">
      <production>
	<directive type="rulevar"> @args</directive>
      </production>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="ID"/>
	<ruleref ref="subroutine_arguments" arguments="$item[3]"/>
	<ruleref ref="match_typedargs" arguments="1,@{$item[4]}"/>
	<action>
	  $return=[\&amp;XML::XSH::Functions::call,$item[3],$item[5]]
	</action>
      </production>
      <documentation sections="Flow">
	<usage>call <xref linkend="ID"/> [<xref linkend="xpath"/> | <xref linkend="expression"/>]*</usage>
	<shortdesc>call user-defined routine (macro)</shortdesc>
	<description>
	  <para>
	    Call an XSH subroutine named <xref linkend="ID"/> previously
	    created using def. If the subroutine requires some
	    paramters, these have to be specified after the <xref
	    linkend="ID"/>. Node-list parameters are given by means of
	    <xref linkend="xpath"/> expressions. String parameters
	    have to be string <xref linkend="expression"/>s.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="def"/>
	  <ruleref ref="return_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="help_command" type="command" name="help" inline="yes">
      <aliases>
	<alias name="?" regexp="\?"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::help,@{$item[3]}]</action>
      </production>
      <documentation sections="Information">
	<usage>help <xref linkend="command"/>|argument-type</usage>
	<shortdesc>on-line documentation</shortdesc>
	<description>
	  <para>Print help on a given command or argument type.</para>
	</description>
      </documentation>
    </rule>
    <rule id="exec_command" type="command" name="exec" inline="yes">
      <aliases>
	<alias name="system"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression" rep="s"/>
	<action>[\&amp;XML::XSH::Functions::sh,join(&quot; &quot;,@{$item[3]})]</action>
      </production>
      <documentation sections="Perl_shell">
	<usage>exec <xref linkend="expression"/> [<xref linkend="expression"/> ...]</usage>
	<shortdesc>execute a shell command</shortdesc>
	<description>
	  <para>execute the system command(s) in <xref linkend="expression"/>s.
	  </para>
	  <example>
	    <title>Count words in &quot;hallo wold&quot; string, then print name
	      of your machine's operating system.</title>
	    <code>
	      exec echo hallo world;                 # prints hallo world
	      exec &quot;echo hallo word&quot; | wc; # counts words in hallo world
	      exec uname;                            # prints operating system name
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xslt_params">
      <production>
	<regexp>(params|parameters)\s</regexp>
	<ruleref ref="param" rep="s"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="xslt_command" type="command" name="xslt" inline="yes">
      <aliases>
	<alias name="transform"/>
	<alias name="xsl"/>
	<alias name="xsltproc"/>
	<alias name="process"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<ruleref ref="filename"/>
	<ruleref ref="expression"/>
	<ruleref ref="xslt_params" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::xslt,@item[3,4,5],@{$item[6]}]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>xslt <xref linkend="ID"/> <xref linkend="filename"/> <xref linkend="ID"/> [(params|parameters) name=<xref linkend="expression"/> [name=<xref linkend="expression"/> ...]]</usage>
	<shortdesc>transform document with XSLT</shortdesc>
	<description>
	  <para>
	    Load an XSLT stylesheet from a file and use it to transform
	    the document of the first <xref linkend="ID"/> into a new
	    document named <xref linkend="ID"/>. Parameters
	    may be passed to a stylesheet after params keyword in the
	    form of a list of name=value pairs where name is the
	    parameter name and value is an <xref linkend="expression"/> interpolating to
	    its value. The resulting value is interpretted by XSLT
	    processor as an XPath expression so e.g. quotes surrounding
	    a XPath string have to be quoted themselves to preveserve
	    them during the XSH expression interpolation.           
	  </para>
	  <example>
	    <code>xslt src stylesheet.xsl rslt params font=&quot;'14pt'&quot; color=&quot;'red'&quot;</code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="param">
      <production>
	<regexp>[^=\s]+</regexp>
	<string>=</string>
	<ruleref ref="expression"/>
	<action>[$item[1],$item[3]]</action>
      </production>
    </rule>
    <rule id="files_command" type="command" name="documents"
	inline="yes">
      <aliases>
	<alias name="files"/>
	<alias name="docs"/>
      </aliases>
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::files]</action>
      </production>
      <documentation sections="Information Documents">
	<usage>files</usage>
	<shortdesc>display a list of open files</shortdesc>
	<description>
	  <para>List open files and their identifiers.</para>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="var_command" type="command" name="variables" inline="yes">
      <aliases>
	<alias name="vars"/>
	<alias name="var"/>
      </aliases>
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::variables]</action>
      </production>
      <documentation sections="Information">
	<usage>variables</usage>
	<shortdesc>display a list of defined variables</shortdesc>
	<description>
	  <para>List all defined variables and their values.</para>
	</description>
	<see-also>
	  <ruleref ref="files_command"/>
	  <ruleref ref="list_defs_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="copy_command" type="command" name="copy" inline="yes">
      <aliases>
	<alias name="cp"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::copy,@item[3,5,4]]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>copy <xref linkend="xpath"/> <xref linkend="loc"/> <xref linkend="xpath"/></usage>
	<shortdesc>copy nodes (in the one-to-one mode)</shortdesc>
	<description>
	  <para>
	    Copies nodes matching the first <xref linkend="xpath"/> to
	    the destinations determined by the <xref linkend="loc"/> directive relative to the second <xref linkend="xpath"/>. If more than one node matches the first
	    <xref linkend="xpath"/> than it is copied to the position
	    relative to the corresponding node matched by the second
	    <xref linkend="xpath"/> according to the order in which are
	    nodes matched. Thus, the n'th node matching the first <xref linkend="xpath"/> is copied to the location relative to the
	    n'th node matching the second <xref linkend="xpath"/>.
          </para>
          <para>The
	    possible values for <xref linkend="loc"/> are: after,
	    before, into, replace and cause copying the source nodes
	    after, before, into (as the last child-node).  the
	    destination nodes. If replace <xref linkend="loc"/> is
	    used, the source node is copied before the destination node
	    and the destination node is removed.
	  </para>
	  <para>
	    Some kind of type conversion is used when the types of the
	    source and destination nodes are not equal.  Thus, text,
	    cdata, comment or processing instruction node data prepend,
	    append or replace value of a destination attribute when
	    copied before,after/into or instead (replace) an attribute,
	    and vice versa.
	  </para>
	  <para>
	    Attributes may be copied after, before or into some other
	    attribute to append, prepend or replace the destination
	    attribute value. They may also replace the destination
	    attribute completely (both its name and value).
	    To copy an attribute from one element to another,
	    simply copy the attribute node into the destination element.
	  </para>
	  <para>
	    Elements may be copied into other elements (which results in
	    appending the child-list of the destination element), or
	    before, after or instead (replace) other nodes of any type
	    except attributes.
	  </para>
	  <example>
	    <title>Replace living-thing elements in the document b with
	      the coresponding creature elements of the document a.</title>
	    <code>xsh&gt; <userinput>copy a://creature replace b://living-thing</userinput></code>             
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="xcopy_command" type="command" name="xcopy" inline="yes">
      <aliases>
	<alias name="xcp"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::copy,@item[3,5,4],1]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>xcopy <xref linkend="xpath"/> <xref linkend="loc"/> <xref linkend="xpath"/></usage>
	<shortdesc>copy nodes (in the all-to-every mode)</shortdesc>
	<description>
	  <para>
	    xcopy is similar to <xref linkend="copy_command"/>, but copies *all* nodes matching
	    the first <xref linkend="xpath"/> to *all* destinations determined by the
	    <xref linkend="loc"/> directive relative to the
	    second <xref linkend="xpath"/>. See <xref
	    linkend="copy_command"/>
	    for detailed description of <literal>xcopy</literal> arguments.
	  </para>
	  <example>
	    <title>Copy all middle-earth creatures within the document a
	      into every world of the document b.</title>
	    <code>xsh&gt; <userinput>xcopy a:/middle-earth/creature into b://world</userinput></code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="cd_command" type="command" name="lcd" inline="yes">
      <aliases>
	<alias name="chdir"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::cd,@{$item[3]}]</action>
      </production>
      <documentation sections="Perl_shell">
	<usage>lcd <xref linkend="expression"/></usage>
	<shortdesc>change system working directory</shortdesc>
	<description>
	  <para>
	    Changes the filesystem working directory to <xref linkend="expression"/>, if possible.  If <xref linkend="expression"/> is omitted, changes to the directory
	    specified in HOME environment variable, if set; if not,
	    changes to the directory specified by LOGDIR environment
	    variable.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="insert_command" type="command" name="insert" inline="yes">
      <aliases>
	<alias name="add"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="nodetype"/>
	<ruleref ref="expression"/>
	<ruleref ref="namespace" rep="?"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::insert,@item[3,4,7,6],$item[5][0],0]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>insert <xref linkend="nodetype"/> <xref
	linkend="expression"/> [namespace <xref
	linkend="expression"/>] <xref linkend="loc"/> <xref linkend="xpath"/>
	</usage>
	<shortdesc>create a node in on a given target location</shortdesc>
	<description>
	  <para>
	    Works just like xadd, except that the new node is attached
	    only the first node matched.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="xinsert_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="xmove_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="xinsert_command" type="command" name="xinsert" inline="yes">
      <aliases>
	<alias name="xadd"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="nodetype"/>
	<ruleref ref="expression"/>
	<ruleref ref="namespace" rep="?"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::insert,@item[3,4,7,6],$item[5][0],1]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>xinsert <xref linkend="nodetype"/> <xref
	linkend="expression"/> [namespace <xref
	linkend="expression"/>] <xref linkend="loc"/> <xref linkend="xpath"/>
	</usage>
	<shortdesc>create nodes on all target locations</shortdesc>
	<description>
	  <para>
	    Use the <xref linkend="expression"/> to create a new node of a given
	    <xref linkend="nodetype"/> in the <xref linkend="loc"/> relative to the given
	    <xref linkend="xpath"/>.
	  </para>
	  <para>
	    For element nodes, the format of the <xref linkend="expression"/> should look like
	      &quot;&lt;element-name att-name='attvalue' ...&gt;&quot;.  The
	      <literal>&lt;</literal> and <literal>&gt;</literal>
	      characters are optional. If no attributes are used, the
	      expression may simply consist the element name. Note,
	      that in the first case, the quotes are required since
	      the expression contains spaces.
	  </para>
	  <para>
	    Attribute nodes use the following syntax:
	    &quot;att-name='attvalue' [...]&quot;.
	  </para>
	  <para>
	    For the other types of nodes (text, cdata, comments) the
	    expression should contain the node's literal content. Again,
	    it is necessary to quote all whitespace and special
	    characters as in any expression argument.
	  </para>
	  <para>
	    The <xref linkend="loc"/> argument should be one of:
	    <literal>after</literal>, <literal>before</literal>,
	    <literal>into</literal>,
	    <literal>replace</literal>, <literal>append</literal>
	    or <literal>prepend</literal>. See documentation
	    of the <xref linkend="loc"/> argument type for more detail.
	  </para>
	  <para>
	    The namespace <xref linkend="expression"/> is only valid for
	    elements and attributes and must evaluate to the namespace
	    URI. In that case, the element or attribute name must have a
	    prefix. The created node is associated with a given
	    namespace.
	  </para>
	  <example>
	    <title>Append a new Hobbit element to the list of
	      middle-earth creatures and name him Bilbo.</title>
	    <code>
	      xsh&gt; <userinput>xadd element &quot;&lt;creature race='hobbit' manner='good'&gt;&quot; \
		<tab/>into /middle-earth/creatures</userinput>
	      xsh&gt; <userinput>xadd attribute &quot;name='Bilbo'&quot; \
		<tab/>into /middle-earth/creatures/creature[@race='hobbit'][last()]</userinput>
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="xmove_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nodetype" name="node-type" type="argtype">
      <production>
	<regexp>element|attribute|attributes|text|cdata|pi|comment|chunk|entity_reference</regexp>
      </production>
      <documentation sections="Argtypes Manipulation">
	<title>Node-type argument type</title>
	<shortdesc>node type specification (such as element, attribute, etc.)</shortdesc>
	<description>
	  <para>
	    One of: element, attribute, text, cdata, comment, chunk
	    and (EXPERIMENTALLY!) entity_reference.  A
	    chunk is a character string which forms a well-balanced
	    peace of XML.
	  </para>
	  <example>
	    <code>
	      add element hobbit into //middle-earth/creatures;
	      add attribute 'name=&quot;Bilbo&quot;' into //middle-earth/creatures/hobbit[last()];
	      add chunk '&lt;hobbit name=&quot;Frodo&quot;&gt;A small guy from &lt;place&gt;Shire&lt;/place&gt;.&lt;/hobbit&gt;' 
	      <tab/>into //middle-earth/creatures;
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="namespace">
      <production>
	<regexp>namespace\s</regexp>
	<ruleref ref="expression"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="loc" type="argtype" name="location">
      <production><regexp>after\s</regexp>
	<action>&quot;after&quot;</action>
</production>
      <production><regexp>before\s</regexp>
	<action>&quot;before&quot;</action>
</production>
      <production><regexp>(in)?to\s</regexp>
	<action>&quot;into&quot;</action>
      </production>
      <production><regexp>(append(ing)?|as\s+(a\s+)child(\s+of)?)\s</regexp>
	<action>&quot;append&quot;</action>
      </production>
      <production><regexp>(prepend(ing)?|(as\s+)(the\s+)first(\s+child(\s+of)?)?)\s</regexp>
	<action>&quot;prepend&quot;</action>
      </production>
      <production><regexp>(replace|instead( of)?)\s</regexp>
	<action>&quot;replace&quot;</action>
      </production>
      <documentation sections="Argtypes Manipulation">
	<title>Location argument type</title>
	<shortdesc>relative destination specification (such as after, before, etc.)</shortdesc>
	<description>
	  <para>One of: 
	    <literal>after</literal>, 
	    <literal>before</literal>, 
	    <literal>into</literal>,
	    <literal>append</literal>,
	    <literal>prepend</literal>,
	    <literal>replace</literal>.
	  </para>
	  <para>
	    NOTE: XSH 1.6 introduces two new values for location
	    argument:
	    <literal>append</literal> and <literal>prepend</literal>
	    and slighlty changes behavior of
	    <literal>after</literal> and <literal>before</literal>!
	  </para>
	  <para>
	    This argument is required by all commands that insert
	    nodes to a document in some way to a destination described
	    by an XPath expression. The meaning of the values listed
	    above is supposed be obvious in most cases, however the
	    exact semantics for location argument values depends on
	    types of both the source node and the target node.
	  </para>
	  <para>
	    <literal>after/before</literal> place the node right
	    after/before the destination node, except for when the
	    destination node is a document node or one of the source
	    nodes is an attribute: If the destination node is a
	    document node, the source node is attached to the
	    end/beginning of the document (remember: there is no
	    "after/before a document").  If both the source and
	    destination nodes are attributes, then the source node is
	    simply attached to the element containing the destination
	    node (remember: there is no order on attribute nodes). If
	    the destination node is an attribute but the source node
	    is of a different type, then the textual content of the
	    source node is appended to the value of the destination
	    attribute (i.e. in this case after/before act just as
	    append/prepend).
	  </para>
	  <para>
	    <literal>append/prepend</literal> appends/prepends the
	    source node to the destination node. If the destination
	    node can contain other nodes (i.e. it is an element or a
	    document node) then the entire source node is attached to
	    it. In case of other destination node types, the textual
	    content of the source node is appended/prepended to the
	    content of the destination node.
	  </para>
	  <para>
	    <literal>into</literal> can also be used to place
	    the source node to the end of an element (in the same way
	    as <literal>append</literal>), to attach an attribute
	    to an element, or, if the destination node is a text node,
	    cdata section, processing-instruction, attribute or comment,
	    to replace its textual content with the textual content of 
	    the source node.
	  </para>
	  <para>
	    <literal>replace</literal> replaces the entire destination
	    node with the source node except for the case when the
	    destination node is an attribute and the source node is
	    not. In such a case only the value of the destination
	    attribute is replaced with the textual content of the
	    source node. Note also that document node can never be
	    replaced.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="move_command" type="command" name="move" inline="yes">
      <aliases>
	<alias name="mv"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::move,@item[3,5,4]]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>move <xref linkend="xpath"/> <xref linkend="loc"/> <xref linkend="xpath"/></usage>
	<shortdesc>move nodes (in the one-to-one mode)</shortdesc>
	<description>
	  <para><literal>move</literal> command acts exactly like
	      <xref linkend="copy_command"/>, except that it
	      <emphasis>removes</emphasis> the source nodes after a
	      succesfull copy. Remember that the moved nodes are
	      actually <emphasis>different nodes</emphasis> from the
	      original ones (which may not be obvious when moving
	      nodes within a single document into locations that do
	      not require type conversion). So, after the move, the
	      original nodes do not exist neither in the document
	      itself nor any nodelist variable.
	  </para>
	  <para>
	    See <xref linkend="copy_command"/> for more details on how
	    the copies of the moved nodes are created.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="copy_command"/>
	  <ruleref ref="xmove_command"/>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="xinsert_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="xmove_command" type="command" name="xmove" inline="yes">
      <aliases>
	<alias name="xmv"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpath"/>
	<ruleref ref="loc"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::move,@item[3,5,4],1]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>xmove <xref linkend="xpath"/> <xref linkend="loc"/> <xref linkend="xpath"/></usage>
	<shortdesc>move nodes (in the all-to-every mode)</shortdesc>
	<description>
	  <para>Like <xref linkend="xcopy_command"/>, except that
	    <literal>xmove</literal> <emphasis>removes</emphasis> the
	    source nodes after a succesfull copy.  Remember that the
	    moved nodes are actually <emphasis>different
	    nodes</emphasis> from the original ones (which may not be
	    obvious when moving nodes within a single document into
	    locations that do not require type conversion). So, after
	    the move, the original nodes do not exist neither in the
	    document itself nor any nodelist variable.
	  </para>
	  <para>
	    See <xref linkend="xcopy_command"/> for more details on
	    how the copies of the moved nodes are created.
	  </para>
	  <para>
	    The following example demonstrates how <literal>xcopy</literal>
	    can be used to get rid of HTML <literal>&lt;font&gt;</literal>
	    elements while preserving their content. As an exercise,
	    try to find out why simple
	    <literal>foreach //font { xmove node() replace . }</literal>
	    would not work here.
	  </para>
	  <example>
	    <title>Get rid of all &lt;font&gt; tags</title>
	    <code>
	      while //font[1] {
	      <tab/>foreach //font[1] {
	      <tab/><tab/>xmove ./node() replace .;
	      <tab/>}
	      }
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="xcopy_command"/>
	  <ruleref ref="move_command"/>
	  <ruleref ref="insert_command"/>
	  <ruleref ref="xinsert_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="clone_command" type="command" name="clone" inline="yes">
      <aliases>
	<alias name="dup"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::clone,@item[3,5]]</action>
      </production>
      <documentation sections="Manipulation Documents">
	<usage>clone <xref linkend="ID"/>=<xref linkend="ID"/></usage>
	<shortdesc>clone a given document</shortdesc>
	<description>
	  <para>
	    Make a copy of the document identified by the <xref linkend="ID"/> following the equal sign assigning it the
	    identifier of the first <xref linkend="ID"/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="normalize_command" type="command" name="normalize" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::normalize_nodes,$item[3]]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>normalize <xref linkend="xpath"/></usage>
	<shortdesc>normalizes adjacent textnodes</shortdesc>
	<description>
	  <para><literal>normalize</literal> 
	    puts all text nodes in the full depth of the sub-tree
	      underneath each node selected by a given <xref
	      linkend="xpath"/>,
	    into a "normal" form where only structure (e.g., elements,
	    comments, processing instructions, CDATA sections, and
	    entity references) separates text nodes, i.e., there are
	    neither adjacent Text nodes nor empty Text nodes.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="strip_ws_command" type="command" name="strip-whitespace"
	    inline="yes">
      <aliases>
	<alias name="strip_whitespace"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::strip_ws,$item[3]]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>strip <xref linkend="xpath"/></usage>
	<shortdesc>strip leading and trailing whitespace</shortdesc>
	<description>
	  <para><literal>strip-whitespace</literal> removes all leading and
	    trailing whitespace from given nodes. If applied to an
	    element node, it removes all leading and trailing child
	    text nodes and CDATA sections that consist entirely of
	    whitespace.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="list_command" type="command" name="ls" inline="yes">
      <aliases>
	<alias name="list"/>
      </aliases>
      <production>
	<selfref/>
	<ruleref ref="xpath"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::list,$item[2],$item[3]]</action>
      </production>
      <production>
	<selfref/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::list,$item[2],-1]</action>
      </production>
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::list,[undef,'.'],1]</action>
      </production>
      <documentation sections="Navigation Information">
	<usage>ls <xref linkend="xpath"/> [<xref linkend="expression"/>]</usage>
	<shortdesc>list a given part of a document as XML</shortdesc>
	<description>
	  <para>
	    List the XML representation of all nodes matching <xref
	      linkend="xpath"/>. The optional <xref
	      linkend="expression"/> argument may be provided to
	      specify the depth of XML tree listing. If negative, the
	      tree will be listed to unlimited depth.  If the <xref
	      linkend="expression"/> results in the word
	      <literal>fold</literal>, elements marked with the <xref
	      linkend="fold_command"/> command are folded, i.e. listed
	      only to a certain depth (this feature is still
	      EXPERIMENTAL!).
	  </para>
	  <para>
	    Unless in quiet mode, this command prints also number of
	    nodes matched on stderr.
	  </para>
	  <para>
	    If the <xref linkend="xpath"/> parameter is omitted,
	    current context node is listed to the depth of 1.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="count_command"/>
	  <ruleref ref="fold_command"/>
	  <ruleref ref="unfold_command"/>
	</see-also>
      </documentation>    
    </rule>
    <rule id="count_command" type="command" name="count" inline="yes">
      <aliases>
	<alias name="print_value"/>
	<alias name="get"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::print_count,$item[3]]</action>
      </production>
      <documentation sections="Information">
	<usage>count <xref linkend="xpath"/></usage>
	<shortdesc>calculate a given XPath expression and enumerate node-lists</shortdesc>
	<description>
	  <para>
	    Calculate a given <xref linkend="xpath"/> expression. If
	    the result is a node-list, return number of nodes in the
	    node-list.  If the <xref linkend="xpath"/> results in a
	    boolean, numeric or literal value, return the value.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="perl_code" type="argtype" name="perl-code">
      <production>
	<directive type="perl_codeblock"/>
      </production>
      <production>
	<ruleref ref="perl_expression"/>
      </production>
      <documentation sections="Argtypes Perl_shell">
	<title>Perl-code argument type</title>
	<shortdesc>in-line code in Perl programming language</shortdesc>
	<description>
	  <para>
	    A block of perl code enclosed in curly brackets or an
	    expression which interpolates to a perl
	    expression. Variables defined in XSH are visible in perl
	    code as well. Since, in the interactive mode, XSH
	    redirects output to the terminal, you cannot simply use
	    perl print function for output if you want to filter the
	    result with a shell command. Instead use the predefined perl
	    routine <literal>echo(...)</literal> which is equivalent to
	    Perl's
	    <literal>print $::OUT ...</literal>. The <literal>$::OUT</literal>
	    perl-variable stores the reference to the terminal file
	    handle.
	  </para>
	  <para>
	    For more information about embedded Perl code in XSH, predefined
	    functions etc. see <xref linkend="Perl_shell"/>.
	  </para>
	  <example>
	    <code>
	      xsh&gt; <userinput>$i=&quot;foo&quot;;</userinput>
	      xsh&gt; <userinput>eval { echo &quot;$i-bar\n&quot;; }</userinput> # prints foo-bar
	      xsh&gt; <userinput>eval 'echo &quot;\$i-bar\n&quot;;'</userinput>  # exactly the same as above
	      xsh&gt; <userinput>eval 'echo &quot;$i-bar\n&quot;;'</userinput>   # prints foo-bar too, but $i is
	      <tab count="2"/># interpolated by XSH. Perl actually evaluates echo &quot;foo-bar\n&quot;;
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="eval_command" type="command" name="perl" inline="yes">
      <aliases>
	<alias name="eval"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="perl_code"/>
	<action>[\&amp;XML::XSH::Functions::print_eval,$item[3]]</action>
      </production>
      <documentation sections="Perl_shell">
	<usage>eval <xref linkend="perl_code"/></usage>
	<shortdesc>evaluate in-line Perl code</shortdesc>
	<description>
	  <para>Evaluate a given perl expression.</para>
	</description>
	<see-also>
	  <ruleref ref="count_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="prune_command" type="command" name="remove" inline="yes">
      <aliases>
	<alias name="rm"/>
	<alias name="prune"/>
	<alias name="delete"/>
	<alias name="del"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::prune,$item[3]]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>remove <xref linkend="xpath"/></usage>
	<shortdesc>remove given nodes</shortdesc>
	<description>
	  <para>Remove all nodes matching <xref linkend="xpath"/>.</para>
	  <example>
	    <title>Get rid of all evil creatures.</title>
	    <code>xsh&gt; <userinput>del //creature[@manner='evil']</userinput></code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="print_command" type="command" name="print" inline="yes">
      <aliases>
	<alias name="echo"/>
      </aliases>
      <production>
	<selfref/>
	<ruleref ref="expression" rep="s"/>
	<action>[\&amp;XML::XSH::Functions::echo,@{$item[2]}]</action>
      </production>
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::echo]</action>
      </production>
      <documentation sections="Information">
	<usage>print <xref linkend="expression"/> [<xref linkend="expression"/> ...]</usage>
	<shortdesc>print given stuff on standard console output</shortdesc>
	<description>
	  <para>Interpolate and print a given expression(s).</para>
	</description>
      </documentation>
    </rule>
    <rule id="sort_command" type="command" name="sort" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="condition"/>
	<ruleref ref="perl_code"/>
	<ruleref ref="nodelistvariable"/>
	<action>[\&amp;XML::XSH::Functions::perlsort,@item[3..5]]</action>
      </production>
      <documentation>
	<usage>sort <xref linkend="xpath"/>|<xref linkend="perl_code"/> <xref linkend="perl_code"/> %<xref linkend="ID"/></usage>
	<shortdesc>sort a given node-list by given criteria</shortdesc>
	<description>
	  <para>
	    EXPERIMENTAL! This command is not yet guaranteed to remain in the 
	    future releases.
	  </para>
	  <para>
	    DOCUMENTATION OBSOLETE! Syntax changed!
	  </para>
	  <para>This command may be used to sort the node-list stored
	    in the node-list variable <xref linkend="ID"/>. First, for
	    each node in the node-list %<xref linkend="ID"/>, the
	    first argument (either a <xref linkend="xpath"/> or <xref
	    linkend="perl_code"/> expression), which serves as a
	    sorting criterion, is evaluated in the context of the node
	    and the obtained value is stored together with the
	    node. (In case of <xref linkend="xpath"/> the result of
	    whatever type is cast to a string). Then perl's sorting
	    algorithm is used to sort the nodelist, consulting the
	    second, <xref linkend="perl_code"/>, argument to compare
	    nodes. Before the <xref linkend="perl_code"/> is
	    evaluated, the values obtained from the previous
	    evaluation of the sorting crierion argument on the two
	    nodes being compared are stored into <literal>$a</literal>
	    and <literal>$b</literal> variables in the respective
	    order.  The <xref linkend="perl_code"/> being consulted is
	    supposed to return either -1 (the first node should come
	    first), 0 (no order precedence), or 1 (the second node
	    should come first). Note that Perl provides very
	    convenient operators <literal>cmp</literal> and
	    <literal>&lt;=&gt;</literal> for string and numeric
	    comparison of this kind as shown in the examples below.
	  </para>
	  <para>
	    Remember that <literal>sort</literal> (unlike <xref
	      linkend="assign_command"/>, <xref linkend="if"/>, or
	      <xref linkend="while"/>) evaluates the first <xref
	      linkend="xpath"/> argument (the sorting criterion) in a
	      way to obtain a string. Thus you need not to bother with
	      wrapping node-queries with a <literal>string()</literal>
	      function but you must remember to explicitly wrap the
	      expression in <literal>count()</literal> if the number
	      of the nodes is to be the sorting criterion.
	  </para>
	  <example>
	    <title>Sort creatures by name (XPath-based sort)
	      in ascending order using current locale settings
	    </title>
	    <code>
	      xsh&gt; <userinput>local %c=/middle-earth[1]/creatures</userinput>
	      xsh&gt; <userinput>sort @name { use locale; lc($a) cmp lc($b) } %c</userinput>
	      xsh&gt; <userinput>xmove %c into /middle-earth[1]</userinput># replaces the creatures</code>
	  </example>
	  <example>
	    <title>Sort (descending order) a node-list by score (Perl-based sort)</title>
	    <code>
	      xsh&gt; <userinput>sort { $scores{ literal('@name') } } { $b &lt;=&gt; $a } %players</userinput>
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="map_command" type="command" name="map" inline="yes">
      <aliases>
	<alias name="sed"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="perl_code"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::perlmap,@item[4,3]]</action>
      </production>
      <documentation sections="Perl_shell Manipulation">
	<usage>map <xref linkend="perl_code"/> <xref linkend="xpath"/></usage>
	<shortdesc>quickly modify node value/data using Perl code</shortdesc>
	<description>
	  <para>
	    This command provides an easy way to modify node's data
	    (content) using arbitrary Perl code.
	  </para>
	  <para>
	    Each of the nodes matching <xref linkend="xpath"/> is
	    passes its data to the <xref linkend="perl_code"/> via
	    the <literal>$_</literal> variable and receives the (possibly)
	    modified data using the same variable.
	  </para>
	  <para>Since element nodes do not really have any proper
	    content (they are only a storage for other nodes), node's
	    name (tag) is used in case of elements. Note, however,
	    that recent versions of XSH provide a special command
	    <xref linkend="rename_command"/> with a very similar
	    syntax to <literal>map</literal>, that should be used for
	    renaming element, attribute, and processing instruction
	    nodes.
	  </para>
	  <example>
	    <title>Capitalises all hobbit names</title>
	    <code>xsh&gt; <userinput>map { $_=ucfirst($_) } //hobbit/@name</userinput></code>	  
	  </example>
	  <example>
	    <title>Changes goblins to orcs in all hobbit tales.</title>
	    <code>xsh&gt; <userinput>map { s/goblin/orc/gi } //hobbit/tale/text()</userinput></code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="rename_command" type="command" name="rename" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="perl_code"/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::perlrename,@item[4,3]]</action>
      </production>
      <documentation sections="Perl_shell Manipulation">
	<usage>rename <xref linkend="perl_code"/> <xref linkend="xpath"/></usage>
	<shortdesc>quickly rename nodes with in-line Perl code</shortdesc>
	<description>
	  <para>
	    This command is very similar to the <xref linkend="map_command"/>
	    command, except that it operates on nodes' names rather
	    than their data/values. For every element, attribute or
	    processing-instruction matched by the <xref
	    linkend="xpath"/> expression the following procedure is
	    used: 1) the name of the node is stored into Perl's
	    <literal>$_</literal> variable, 2) the <xref
	    linkend="perl_code"/> is evaluated, and 3) the (posibly
	    changed) content of the <literal>$_</literal> variable is
	    used as a new name for the node.
	  </para>
	  <example>
	    <title>Renames all hobbits to halflings</title>
	    <code>xsh&gt; <userinput>map $_='halfling' //hobbit</userinput></code>
	  </example>
	  <example>
	    <title>Make all elements and attributes uppercase</title>
	    <code>xsh&gt; <userinput>map { $_=uc($_) } (//*|//@*)</userinput></code>	  
	  </example>
	</description>
	<see-also>
	  <ruleref ref="map_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="close_command" type="command" name="close" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::close_doc,@{$item[3]}]</action>
      </production>
      <documentation sections="Documents">
	<usage>close [<xref linkend="ID"/>]</usage>
	<shortdesc>close document (do not save it, though)</shortdesc>
	<description>
	  <para>
	    Close the document identified by <xref linkend="ID"/>,
	    removing its parse-tree from memory (note also that all
	    nodes belonging to the document are removed from all
	    nodelists they appear in). If <xref linkend="ID"/> is
	    omitted, the command closes the current document.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="select_command" type="command" name="select" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_local_xpath,[$item[3],&quot;/&quot;]]</action>
      </production>
      <documentation sections="Documents Navigation">
	<usage>select <xref linkend="ID"/></usage>
	<shortdesc>make a given document the current one</shortdesc>
	<description>
	  <para>
	    Make <xref linkend="ID"/> the document identifier to be used in the next
	    xpath evaluation without identifier prefix.
	  </para>
	  <example>
	    <code>
	      xsh&gt; <userinput>a=mydoc1.xml</userinput>       # opens and selects a
	      xsh&gt; <userinput>ls /</userinput>               # lists a
	      xsh&gt; <userinput>b=mydoc2.xml</userinput>       # opens and selects b
	      xsh&gt; <userinput>ls /</userinput>               # lists b
	      xsh&gt; <userinput>ls a:/</userinput>             # lists and selects a
	      xsh&gt; <userinput>select b</userinput>           # does nothing except selecting b
	      xsh&gt; <userinput>ls /</userinput>               # lists b
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="open_command" type="command" name="open" inline="yes">
      <production>
	<regexp>open((\s*|_|-)(HTML|XML|DOCBOOK|html|xml|docbook)(?!\s*=))?((\s*|_|-)(FILE|file|PIPE|pipe|STRING|string)(?!\s*=))?</regexp>
	<directive type="commit"/>
	<ruleref ref="id_or_var"/>
	<regexp>\s*=\s*</regexp>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[3,5,1]]</action>
      </production>
      <production>
	<ruleref ref="ID"/>
	<regexp>\s*=\s*</regexp>
	<directive type="commit"/>
	<ruleref ref="filename"/>
	<action>[\&amp;XML::XSH::Functions::open_doc,@item[1,4]]</action>
      </production>
      <documentation sections="Documents">
	<usage>[open [HTML|XML|DOCBOOK] [FILE|PIPE|STRING]] <xref linkend="ID"/>=<xref linkend="expression"/></usage>
	<shortdesc>load an XML, HTML, or Docbook SGML document from a
	file, pipe or URI</shortdesc>
	<description>
	  <para>
	    Load a new XML, HTML or SGML DOCBOOK document from the file
	    (actually arbitrary URL), command output or string provided by
	    the <xref linkend="expression" />.  In XSH the document is given a
	    symbolic name <xref
	    linkend="ID"/>.  To identify the documentin commands like close,
	    save, validate, dtd or enc simply use <xref
	    linkend="ID"/>. In commands which work on document nodes, give
	    <xref linkend="ID"/>: prefix to XPath expressions to point the
	    XPath to the document.
	  </para>
	  <example>
	    <code>
	      xsh&gt; <userinput>open x=mydoc.xml # open a document</userinput>

              # open a HTML document from the Internet
	      xsh&gt; <userinput>open HTML h="http://www.google.com/?q=xsh"</userinput>
	      # quote file name if it contains whitespace
	      xsh&gt; <userinput>open y=&quot;document with a long name with spaces.xml&quot;</userinput>

	      # you may omit the word open when loading an XML file/URI.
	      xsh&gt; <userinput>z=mybook.xml</userinput>

	      # use HTML or DOCBOOK keywords to load these types
	      xsh&gt; open HTML <userinput>z=index.htm</userinput>

	      # use PIPE keyword to read output of a command
	      xsh&gt; open HTML PIPE <userinput>z='wget -O - xsh.sourceforge.net/index.html'</userinput>

	      # use z: prefix to identify the document opened with the
	      # previous comand in an XPath expression.
	      xsh&gt; <userinput>ls z://chapter/title	    </userinput>
	    </code>
	  </example>
	</description>
      </documentation>
    </rule>
    <rule id="create_command" type="command" name="create" inline="yes">
      <aliases>
	<alias name="new"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::create_doc,@item[3,4]]</action>
      </production>
      <documentation sections="Documents">
	<usage>create <xref linkend="ID"/> <xref linkend="expression"/></usage>
	<shortdesc>make a new document from a given XML fragment</shortdesc>
	<description>
	  <para>
	    Create a new document using <xref linkend="expression"/> to
	    form the root element and associate it with a given
	    identifier.
	  </para>
	  <example>
	    <code>
	      xsh&gt; <userinput>create t1 root</userinput>
	      xsh&gt; <userinput>ls /</userinput>
	      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
	      &lt;root/&gt;

	      xsh&gt; <userinput>create t2 &quot;&lt;root id='r0'&gt;Just a &lt;b&gt;test&lt;/b&gt;&lt;/root&gt;&quot;</userinput>
	      xsh&gt; <userinput>ls /</userinput>
	      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
	      &lt;root id='r0'&gt;Just a &lt;b&gt;test&lt;/b&gt;&lt;/root&gt;
	      xsh&gt; <userinput>files</userinput>
	      scratch = new_document.xml
	      t1 = new_document1.xml
	      t2 = new_document2.xml
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="clone_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="encoding_param">
      <production>
	<regexp>encoding\s</regexp>
	<ruleref ref="expression"/>
	<action>$item[2]</action>
      </production>
    </rule>
    <rule id="save_command" type="command" name="save" inline="yes">
      <production>
	<regexp>save(as|_as|-as)?((\s*|_|-)(HTML|html|XML|xml|XINCLUDE|Xinclude|xinclude))?((\s*|_|-)(FILE|file|PIPE|pipe|STRING|string))?</regexp>
	<ruleref ref="expression"/>
	<ruleref ref="filename"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_doc,@item[1,2,3,4]]</action>
      </production>
      <production>
	<regexp>save(as|_as|-as)?((\s*|_|-)(HTML|html|XML|xml|XINCLUDE|Xinclude|xinclude))?((\s*|_|-)(FILE|file|STRING|string))?</regexp>
	<ruleref ref="expression"/>
	<ruleref ref="encoding_param" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::save_doc,@item[1,2],undef,$item[3]]</action>
      </production>
      <production>
	<regexp>save(as|_as|-as)?([-_](HTML|html|XML|xml|XINCLUDE|Xinclude|xinclude))?</regexp>
	<directive type="commit"/>
	<action>[\&amp;XML::XSH::Functions::save_doc,$item[1]]</action>
      </production>
      <documentation sections="Documents">
	<usage>save [HTML|XML|XInclude] [FILE|PIPE|STRING] <xref linkend="ID"/> <xref
	    linkend="expression"/> [encoding <xref
	    linkend="enc_string"/>]
or
	  save <xref linkend="ID"/>
or
	  save
</usage>
	<shortdesc>save a document as XML or HTML</shortdesc>
	<description>
	  <para>
	    Save the document identified by <xref linkend="ID"/>.
	    Using one of the <literal>FILE</literal>,
	    <literal>PIPE</literal>, <literal>STRING</literal>
	    keywords the user may choose to save the document to a
	    file send it to a given command's input via a pipe or
	    simply return its content as a string. If none of the
	    keywords is used, it defaults to FILE. If saving to a
	    PIPE, the <xref linkend="expression"/> argument must
	    provide the coresponding command and all its parameters.
	    If saving to a FILE, the <xref linkend="expression"/>
	    argument may provide a filename; if omitted, it defaults
	    to the original filename of the document. If saving to a
	    STRING, the <xref linkend="expression"/> argument
	    is ignored and may freely be omitted.
	  </para>
	  <para>
	    The output format is controlled using one of the XML,
	    HTML, XInclude keywords (see below). If the format keyword
	    is ommited, save it defaults to XML.
	  </para>
	  <para>
	    Note, that a document should be saved as HTML only if it
	    actually is a HTML document.  Note also, that the optional
	    encoding parameter forces character conversion only; it is
	    up to the user to declare the document encoding in the
	    appropriate HTML &lt;META&gt; tag.
	  </para>
	  <para>
	    The XInclude keyword automatically implies XML format and
	    can be used to force XSH to save all already expanded
	    XInclude sections back to their original files while
	    replacing them with &lt;xi:include&gt; tags in the main
	    XML file. Moreover, all material included within
	    &lt;include&gt; elements from the
	    <ulink url="http://www.w3.org/2001/XInclude">http://www.w3.org/2001/XInclude</ulink>
	    namespace is saved to separate files too according to the
	    <literal>href</literal> attribute, leaving only empty
	    &lt;include&gt; element in the root file. This feature may
	    be used to split the document to new XInclude fragments.
	  </para>
	  <para>
	    The encoding keyword followed by a <xref
	    linkend="enc_string"/> can be used to convert the document
	    from its original encoding to a different encoding.  In
	    case of XML output, the &lt;?xml?&gt; declaration is
	    changed accordingly.  The new encoding is also set as the
	    document encoding for the particular document.
	  </para>
	  <example>
	    <title>Use save to preview a HTML document in Lynx</title>
	    <code>save HTML PIPE mydoc 'lynx -stdin'</code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="open_command"/>
	  <ruleref ref="close_command"/>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="files_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="list_dtd_command" type="command" name="dtd" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::list_dtd,@{$item[3]}]</action>
      </production>
      <documentation sections="Information">
	<usage>dtd [<xref linkend="ID"/>]</usage>
	<shortdesc>show document's DTD</shortdesc>
	<description>
	  <para>
	    Print external or internal DTD for a given document.  If
	    no document identifier is given, the current document is used.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="valid_command"/>
	  <ruleref ref="validate_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="set_enc_command" type="command" name="set-enc" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::set_doc_enc,$item[3],@{$item[4]}]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>set-enc <xref linkend="enc_string"/> [<xref linkend="ID"/>]</usage>
	<shortdesc>set document's charset (encoding)</shortdesc>
	<description>
	  <para>
	    Changes character encoding of a given document. If no document
	    <xref linkend="ID"/> is given, the command applies to the
	    current document. This has two effects:
	    changing the XMLDecl encoding declaration 
	    in the document prolog to display the new
	    encoding and making all future <xref linkend="save_command"/> operations
	    on the document default to the given charset.
	  </para>
	  <example>
	    <code>xsh&gt; <userinput>ls</userinput>
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;foo&gt;...&lt;/foo&gt;
xsh&gt; <userinput>set-enc "utf-8"</userinput>
xsh&gt; <userinput>ls</userinput>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;foo&gt;...&lt;/foo&gt;
xsh&gt; <userinput>save</userinput> # saves the file in UTF-8 encoding
</code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="print_enc_command"/>
	  <ruleref ref="doc_info_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="set_standalone_command" type="command" name="set-standalone" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::set_doc_standalone,$item[3],@{$item[4]}]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>set-standalone <xref linkend="expression"/> [<xref linkend="ID"/>]</usage>
	<shortdesc>set document's standalone flag</shortdesc>
	<description>
	  <para>
	    Changes the value of <literal>standalone</literal> declaration
            in the XMLDecl prolog of a document. The <xref
            linkend="expression"/> should evaluate to either 1 or 0 
	    or <literal>'yes'</literal> or <literal>'no'</literal>.
	    The result of applying the command on other values is not specified.
	    If no document <xref linkend="ID"/> is given, 
	    the command applies to the current document. 
	  </para>
	</description>
	<see-also>
	  <ruleref ref="doc_info_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="print_enc_command" type="command" name="enc" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::print_enc,@{$item[3]}]</action>
      </production>
      <documentation sections="Information">
	<usage>enc [<xref linkend="ID"/>]</usage>
	<shortdesc>show document's original character encoding</shortdesc>
	<description>
	  <para>
	    Print the original document encoding string.
	    If no document identifier is given, the current document is
	    used.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="set_enc_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="validate_command" type="command" name="validate" inline="yes">
      <production>
	<selfref sep="no"/>
	<ruleref ref="validation_scheme"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::validate_doc,1,$item[2],@{$item[3]}]</action>
      </production>
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::validate_doc,1,[],@{$item[3]}]</action>
      </production>
      <documentation sections="Information">
	<usage>validate [<xref linkend="ID"/>]
or
validate DTD PUBLIC <xref linkend="expression"/> [SYSTEM <xref
	    linkend="filename"/>] <xref linkend="ID"/>
or
validate (DTD|RelaxNG|XSD) FILE <xref linkend="filename"/> [<xref
	    linkend="ID"/>]
or
validate (DTD|RelaxNG|XSD) STRING <xref linkend="filename"/> [<xref
	    linkend="ID"/>]
or
validate (RelaxNG|XSD) DOC <xref linkend="ID"/> [<xref linkend="ID"/>]</usage>
	<shortdesc>validate a document against a DTD, RelaxNG, or XSD schemas</shortdesc>
	<description>
	  <para>
	    This command validates the document identified with <xref
	      linkend="ID"/> against a DTD, RelaxNG or XSD schema and
	      report all validity errors. If no document identifier
	      is given, the current document is used. A DTD can be
	      specified either by its PUBLIC or SYSTEM identifier (or
	      both), or as a STRING.  RelaxNG and XSD schemas can be
	      specified either as a filename or url (FILE <xref
	      linkend="filename"/>), as a string (STRING <xref
	      linkend="expression"/>), or as a XSH document (DOC <xref
	      linkend="ID"/>).  If no schema is specified, validation
	      is performed against the internal or external DTD subset
	      of the document being validated.
	  </para>
	  <example>
	    <code>open mydoc="test.xml"</code>
	    <code># in all examples below, mydoc can be ommited</code>
	    <code>validate mydoc; # validate against the documet's DOCTYPE</code>
	    <code>validate DTD PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" mydoc</code>
	    <code>validate DTD SYSTEM "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" mydoc</code>
	    <code>validate DTD FILE "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" mydoc</code>
	  </example>
	  <example>
	    <code>validate RelaxNG FILE "test.rng" mydoc</code>
	    <code>validate RelaxNG STRING $relaxschema mydoc</code>
	    <code>open rng="test.rng"</code>
	    <code>validate RelaxNG DOC rng mydoc</code>
	  </example>
	  <example>
	    <code>validate XSD FILE "test.xsd" mydoc</code>
	    <code>validate XSD STRING $xsdschema mydoc</code>
	    <code>open xsd="test.xsd"</code>
	    <code>validate XSD DOC xsd mydoc</code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="valid_command"/>
	  <ruleref ref="list_dtd_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="valid_command" type="command" name="valid" inline="yes">
      <production>
	<selfref sep="no"/>
	<ruleref ref="validation_scheme"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::validate_doc,0,$item[2],@{$item[3]}]</action>
      </production>
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::validate_doc,0,[],@{$item[3]}]</action>
      </production>
      <documentation sections="Information">
	<usage>valid [validation-scheme] [<xref linkend="ID"/>]</usage>
	<shortdesc>check if the document is valid (according to a
	DTD, RelaxNG, or XSD schemas)</shortdesc>
	<description>
	  <para>
	    Check and report the validity of the document <xref
	    linkend="ID"/> with respect to a DTD, RelaxNG, or XSD
	    schemas specified in <literal>validation-scheme</literal>
	    (see <xref linkend="validate_command"/> for information,
	    on how <literal>validation-scheme</literal> may be
	    specified).  Prints &quot;yes&quot; if the document is
	    valid and &quot;no&quot; otherwise.  If no document
	    identifier is given, the current document is used. If no
	    <literal>validation-scheme</literal> is specified, the
	    validity against the DTD subset is checked.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="validate_command"/>
	  <ruleref ref="list_dtd_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="exit_command" type="command" name="exit" inline="yes">
      <aliases>
	<alias name="quit"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::quit,@{$item[3]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>exit [<xref linkend="expression"/>]</usage>
	<shortdesc>exit XSH shell</shortdesc>
	<description>
	  <para>
	    Exit xsh immediately, optionally with the exit-code
	    resulting from a given expression.
	  </para>
	  <para>
	    WARNING: No files are saved on exit.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="process_xinclude_command" type="command" name="process-xinclude" inline="yes">
      <aliases>
	<alias name="process_xinclude"/>
	<alias name="process-xincludes"/>
	<alias name="process_xincludes"/>
	<alias name="xinclude"/>
	<alias name="xincludes"/>
	<alias name="load_xincludes"/>
	<alias name="load-xincludes"/>
	<alias name="load_xinclude"/>
	<alias name="load-xinclude"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>	
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::process_xinclude,@{$item[3]}]</action>
      </production>
      <documentation sections="Manipulation Documents">
	<usage>process_xinclude [<xref linkend="ID"/>]</usage>
	<shortdesc>load and insert XInclude sections</shortdesc>
	<description>
	  <para>
	    Process any xinclude tags in the document <xref linkend="ID"/>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="parser_expands_xinclude"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="chxpath_command" type="command" name="cd" inline="yes">
      <aliases>
	<alias name="chxpath"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_xpath" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::set_local_xpath,@{$item[3]}]</action>
      </production>
      <documentation sections="Navigation">
	<usage>cd [<xref linkend="xpath"/>]</usage>
	<shortdesc>change current context node</shortdesc>
	<description>
	  <para>Change current context node (and current document) to
	    the first node matching a given <xref linkend="xpath"/>
	    argument.
          </para>
	</description>
      </documentation>
    </rule>
    <rule id="pwd_command" type="command" name="pwd" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::print_pwd]</action>
      </production>
      <documentation sections="Navigation Information">
	<usage>pwd</usage>
	<shortdesc>show current context node location (as a cannonical XPath)</shortdesc>
	<description>
	  <para>Print XPath leading to the current context node.  This
	    is equivalent to <literal>locate .</literal>.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="locate_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="locate_command" type="command" name="locate" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_xpath" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::locate,@{$item[3]}]</action>
      </production>
      <documentation sections="Navigation Information">
	<usage>locate <xref linkend="xpath"/></usage>
	<shortdesc>show a given node location (as a cannonical XPath)</shortdesc>
	<description>
	  <para>Print canonical XPaths leading to nodes matched by
	    a given <xref linkend="xpath"/>.</para>
	</description>
	<see-also>
	  <ruleref ref="pwd_command"/>
	</see-also>
      </documentation>
    </rule>    
    <rule id="xupdate_command" type="command" name="xupdate" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<ruleref ref="expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::xupdate,$item[3],@{$item[4]}]</action>
      </production>
      <documentation sections="Manipulation">
	<usage>xupdate <xref linkend="ID"/> [<xref linkend="ID"/>]</usage>
	<shortdesc>apply XUpdate commands on a document</shortdesc>
	<description>
	  <para>Modify the current document or the document specified
	    by the second <xref linkend="ID"/> argument according to
	    XUpdate commands of the first <xref linkend="ID"/>
	    document. XUpdate is a XML Update Language which aims to
	    be a language for updating XML documents.
	  </para>
	  <para>
	    XUpdate langauge is described in XUpdate Working Draft at
            <ulink url="http://www.xmldb.org/xupdate/xupdate-wd.html">http://www.xmldb.org/xupdate/xupdate-wd.html</ulink>.	    	    
	  </para>
	  <para>XUpdate output can be generated for example by
            Python xmldiff utility from
	    <ulink url="http://www.logilab.org/xmldiff/">http://www.logilab.org/xmldiff/</ulink>. Unfortunatelly,
	    there are few bugs (or, as I tend to say In case of
            Python, white-space problems) in their code, so its 
            XUpdate output is not always correct.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="verbose" type="command" name="verbose" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_quiet,0]</action>
      </production>
      <documentation sections="Configuration">
	<usage>verbose</usage>
	<shortdesc>make XSH print many messages</shortdesc>
	<description>
	  <para>Turn on verbose messages (default).</para>
	  <para>This is equivalent to setting
	    <literal>$QUIET</literal> variable to 0.</para>
	</description>
	<see-also>
	  <ruleref ref="quiet"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="test_mode" type="command" name="test-mode" inline="yes">
      <aliases>
	<alias name="test_mode"/>
      </aliases>
      <production>
	<selfref/>
	<action>[&quot;test-mode&quot;]</action>
      </production>
      <documentation sections="Flow Configuration">
	<usage>test-mode</usage>
	<shortdesc>do not execute any command, only check the syntax</shortdesc>
	<description>
	  <para>
	    Switch into test mode in which no commands are actually
	    executed and only command syntax is checked.
	  </para>
	  <para>This is equivalent to setting
	    <literal>$TEST_MODE</literal> variable to 1.</para>
	</description>
	<see-also>
	  <ruleref ref="run_mode"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="run_mode" type="command" name="run-mode" inline="yes">
      <aliases>
	<alias name="run_mode"/>
      </aliases>
      <production>
	<selfref/>
	<action>[&quot;run-mode&quot;]</action>
      </production>
      <documentation sections="Flow Configuration">
	<usage>run-mode</usage>
	<shortdesc>switch into normal execution mode (quit <xref linkend="test_mode"/>)</shortdesc>
	<description>
	  <para>
	    Switch into normal XSH mode in which all commands are
	    executed.
	  </para>
	  <para>This is equivalent to setting
	    <literal>$TEST_MODE</literal> variable to 0.</para>
	</description>
	<see-also>
	  <ruleref ref="test_mode"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="debug" type="command" name="debug" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_debug,1]</action>
      </production>
      <documentation sections="Configuration">
	<usage>debug</usage>
	<shortdesc>display many annoying debugging messages</shortdesc>
	<description>
	  <para>Turn on debugging messages.</para>
	  <para>This is equivalent to setting
	    <literal>$DEBUG</literal> variable to 1.</para>
	</description>
	<see-also>
	  <ruleref ref="nodebug"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nodebug" type="command" name="nodebug" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_debug,0]</action>
      </production>
      <documentation sections="Configuration">
	<usage>nodebug</usage>
	<shortdesc>turn off debugging messages</shortdesc>
	<description>
	  <para>Turn off debugging messages.</para>
	  <para>This is equivalent to setting
	    <literal>$DEBUG</literal> variable to 0.</para>
	</description>
	<see-also>
	  <ruleref ref="debug"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="version" type="command" name="version" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::print_version,0]</action>
      </production>
      <documentation sections="Information">
	<usage>version</usage>
	<shortdesc>show version information</shortdesc>
	<description>
	  <para>
	    Prints program version plus version numbers of the most
	    important libraries used.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="validation" type="command" name="validation" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_validation,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>validation <xref linkend="expression"/></usage>
	<shortdesc>turn on/off validation in XML parser</shortdesc>
	<description>
	  <para>
	    Turn on validation during the parse process if the
	    <xref linkend="expression"/> is non-zero or off otherwise.
	    In XSH version 1.6 and later, defaults to off.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$VALIDATION</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="recovering" type="command" name="recovering" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_recovering,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>recovering <xref linkend="expression"/></usage>
	<shortdesc>turn on/off parser's ability to fix broken XML</shortdesc>
	<description>
	  <para>
	    Turn on recovering parser mode if the
	    <xref linkend="expression"/> is non-zero or off otherwise.
	    Defaults to off. Note, that the in the recovering mode,
            validation is not performed by the parser even if
	    the validation flag is on and that recovering mode flag
            only influences parsing of XML documents (not HTML).
	  </para>
	  <para>The recover mode helps to efficiently recover
	  documents that are almost well-formed. This for example
	  includes documents without a close tag for the document
	  element (or any other element inside the document).</para>
	  <para>This command is equivalent to setting the
	    <literal>$RECOVERING</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="parser_expands_entities" type="command" name="parser-expands-entities" inline="yes">
      <aliases>
	<alias name="parser_expands_entities"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_expand_entities,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>parser_expands_entities <xref linkend="expression"/></usage>
	<shortdesc>turn on/off parser's tendency to expand entities</shortdesc>
	<description>
	  <para>
	    Enable the entity expansion during the parse process if the
	    <xref linkend="expression"/> is non-zero, disable it otherwise.
	    If entity
	    expansion is off, any external parsed entities in the
	    document are left as entities. Defaults to on.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$PARSER_EXPANDS_ENTITIES</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="keep_blanks" type="command" name="keep-blanks" inline="yes">
      <aliases>
	<alias name="keep_blanks"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_keep_blanks,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>keep_blanks <xref linkend="expression"/></usage>
	<shortdesc>turn on/off ignorable whitespace preservation</shortdesc>
	<description>
	  <para>
	    Allows you to turn off XML::LibXML's default behaviour of
	    maintaining whitespace in the document. Non-zero expression
	    forces the XML parser to preserve all whitespace.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$KEEP_BLANKS</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="pedantic_parser" type="command" name="pedantic-parser" inline="yes">
      <aliases>
	<alias name="pedantic_parser"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_pedantic_parser,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>pedantic_parser <xref linkend="expression"/></usage>
	<shortdesc>make the parser more pedantic</shortdesc>
	<description>
	  <para>
	    If you wish, you can make XML::LibXML more pedantic by passing
	    a non-zero <xref linkend="expression"/> to this command.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$PEDANTIC_PARSER</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="complete_attributes" type="command" name="parser-completes-attributes" inline="yes">
      <aliases>
	<alias name="complete_attributes"/>
	<alias name="complete-attributes"/>
	<alias name="parser_completes_attributes"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_complete_attributes,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>parser-completes-attributes <xref linkend="expression"/></usage>
	<shortdesc>turn on/off parser's ability to fill default attribute values</shortdesc>
	<description>
	  <para>
	    If the expression is non-zero, this command allows XML parser
	    to complete the elements attributes lists with the ones
	    defaulted from the DTDs.  By default, this option is enabled.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$PARSER_COMPLETES_ATTRIBUTES</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="indent" type="command" name="indent" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_indent,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>indent <xref linkend="expression"/></usage>
	<shortdesc>turn on/off pretty-printing</shortdesc>
	<description>
	  <para>If the value of <xref linkend="expression"/> is 1,
	    format the XML output while saving a document by adding
	    some nice ignorable whitespace. If the value is 2 (or
	    higher), XSH will act as in case of 1, plus it will add a
	    leading and a trailing linebreak to each text node.
	  </para>
	  <para>Note, that since the underlying C library
	    (libxml2) uses a hardcoded indentation of 2 space
	    characters per indentation level, the amount of
	    whitespace used for indentation can not be
	    altered on runtime.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$INDENT</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="empty_tags" type="command" name="empty-tags"
	    inline="yes">
      <aliases>
	<alias name="empty_tags"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_empty_tags,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>empty-tags <xref linkend="expression"/></usage>
	<shortdesc>turn on/off serialization of empty tags</shortdesc>
	<description>
	  <para>If the value of <xref linkend="expression"/> is 1
	    (non-zero), empty tags are serialized as a
	    start-tag/end-tag pair
	    (<literal>&lt;foo&gt;&lt;/foo&gt;</literal>).  This option
	    affects both <xref linkend="list_command"/> and <xref
	    linkend="save_command"/> and possibly other
	    commands. Otherwise, they are compacted into a short-tag
	    form (<literal>&lt;foo/&gt;</literal>). Default value is
	    <literal>0</literal>.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$EMPTY_TAGS</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="skip_dtd" type="command" name="skip-dtd"
	    inline="yes">
      <aliases>
	<alias name="skip_dtd"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_skip_dtd,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>skip-dtd <xref linkend="expression"/></usage>
	<shortdesc>turn on/off serialization of DTD DOCTYPE declaration</shortdesc>
	<description>
	  <para>If the value of <xref linkend="expression"/> is 1 (non-zero),
	    DTD DOCTYPE declaration is omitted from any serialization
	    of XML documents (including <xref linkend="list_command"/>
	    and <xref linkend="save_command"/>). Default value is
	    <literal>0</literal>.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$SKIP_DTD</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="parser_expands_xinclude" type="command" name="parser-expands-xinclude" inline="yes">
      <aliases>
	<alias name="parser_expands_xinclude"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_expand_xinclude,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>parser_expands_xinclude <xref linkend="expression"/></usage>
	<shortdesc>turn on/off transparent XInclude insertion by parser</shortdesc>
	<description>
	  <para>
	    If the <xref linkend="expression"/> is non-zero, the parser is
	    allowed to expand XIinclude tags imidiatly while parsing the
	    document.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$PARSER_EXPANDS_XINCLUDE</literal> variable.</para>
	</description>
	<see-also>
	  <ruleref ref="process_xinclude_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="load_ext_dtd" type="command" name="load-ext-dtd" inline="yes">
      <aliases>
	<alias name="load_ext_dtd"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_load_ext_dtd,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>load_ext_dtd <xref linkend="expression"/></usage>
	<shortdesc>turn on/off external DTD fetching</shortdesc>
	<description>
	  <para>
	    If the expression is non-zero, XML parser loads external DTD
	    subsets while parsing. By default, this option is enabled.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$LOAD_EXT_DTD</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="encoding" type="command" name="encoding" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_encoding,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>encoding <xref linkend="enc_string"/></usage>
	<shortdesc>choose output charset</shortdesc>
	<description>
	  <para>Set the default output character encoding.</para>
	  <para>This command is equivalent to setting the
	    <literal>$ENCODING</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="query_encoding" type="command" name="query-encoding" inline="yes">
      <aliases>
	<alias name="query_encoding"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_qencoding,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>query-encoding <xref linkend="enc_string"/></usage>
	<shortdesc>declare the charset of XSH source files and terminal input</shortdesc>
	<description>
	  <para>Set the default query character encoding.</para>
	  <para>This command is equivalent to setting the
	    <literal>$QUERY_ENCODING</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="quiet" type="command" name="quiet" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_quiet,1]</action>
      </production>
      <documentation sections="Configuration">
	<usage>quiet</usage>
	<shortdesc>turn off many XSH messages</shortdesc>
	<description>
	  <para>Turn off verbose messages.</para>
	  <para>This command is equivalent to setting the
	    <literal>$QUIET</literal> variable.</para>
	</description>
	<see-also>
	  <ruleref ref="verbose"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="cdonopen" type="command" name="switch-to-new-documents"
      inline="yes">
      <aliases>
	<alias name="switch_to_new_documents"/>
      </aliases>
      <production>
	<selfref/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_cdonopen,$item[2]]</action>
      </production>
      <documentation sections="Configuration Documents">
	<usage>switch-to-new-documents <xref linkend="expression"/></usage>
	<shortdesc>set on/off changing current document to newly
	  open/created files</shortdesc>
	<description>
	  <para>If non-zero, XSH changes
	    current node to the document node of a newly open/created
	    files every time a new document is opened or created with
	    <xref linkend="open_command"/> or <xref
	    linkend="create_command"/>.
	    Default value for this option is 1. 
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$SWITCH_TO_NEW_DOCUMENTS</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="backups" type="command" name="backups" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_backups,1]</action>
      </production>
      <documentation sections="Configuration Documents">
	<usage>backups</usage>
	<shortdesc>turn on backup file creation</shortdesc>
	<description>
	  <para>Enable creating backup files on save (default).</para>
	  <para>This command is equivalent to setting the
	    <literal>$BACKUPS</literal> variable to 1.</para>
	</description>
	<see-also>
	  <ruleref ref="nobackups"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="nobackups" type="command" name="nobackups" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::set_backups,0]</action>
      </production>
      <documentation sections="Configuration Documents">
	<usage>nobackups</usage>
	<shortdesc>turn off backup file creation</shortdesc>
	<description>
	  <para>Disable creating backup files on save.</para>
	  <para>This command is equivalent to setting the
	    <literal>$BACKUPS</literal> variable to 0.</para>
	</description>
	<see-also>
	  <ruleref ref="nobackups"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="fold_command" type="command" name="fold" inline="yes">
      <production>
	<selfref/>
	<ruleref ref="xpath"/>
	<ruleref ref="expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::mark_fold,$item[2],@{$item[3]}]</action>
      </production>
      <documentation sections="Navigation">
	<usage>fold <xref linkend="xpath"/> [<xref
	linkend="expression"/>]</usage>
	<shortdesc>mark elements to be folded by list
	command</shortdesc>
	<description>
	  <para>
	    This feature is still EXPERIMENTAL! Fold command may be
	    used to mark elements matching the <xref linkend="xpath"/>
	    with a <literal>xsh:fold</literal> attribute from the
	    <literal>http://xsh.sourceforge.net/xsh/</literal>
	    namespace. When listing the DOM tree using <literal><xref
	    linkend="list_command"/> <xref linkend="xpath"/>
	    fold</literal>, elements marked in this way are folded to
	    the depth given by the <xref linkend="expression"/>
	    (default depth is 0 = fold immediately).
	  </para>
	  <example>
	    <code>xsh> <userinput>fold //chapter 1</userinput>
	      xsh> <userinput>ls //chapter[1] fold</userinput>
	      &lt;chapter id="intro" xsh:fold="1">
	      <tab/>&lt;title>...&lt;/title>
	      <tab/>&lt;para>...&lt;/para>
	      <tab/>&lt;para>...&lt;/para>
	      &lt;/chapter>
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="unfold_command"/>
	  <ruleref ref="list_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="unfold_command" type="command" name="unfold" inline="yes">
      <production>
	<selfref/>
	<ruleref ref="xpath"/>
	<action>[\&amp;XML::XSH::Functions::mark_unfold,$item[2]]</action>
      </production>
      <documentation sections="Navigation">
	<usage>unfold <xref linkend="xpath"/></usage>
	<shortdesc>unfold elements folded with fold command</shortdesc>
	<description>
	  <para>
	    This feature is still EXPERIMENTAL! Unfold command removes
	    <literal>xsh:fold</literal> attributes from all elements
	    matching a given <xref linkend="xpath"/> created by previous
	    usage of <xref linkend="fold_command"/>.  Be aware, that
	    <literal>xmlns:xsh</literal> namespace declaration may
	    still be present in the document even when all elements
	    are unfolded.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="fold_command"/>
	  <ruleref ref="list_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="redo_command" type="command" name="redo" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::loop_redo,@{$item[3]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>redo [<xref linkend="expression"/>]</usage>
	<shortdesc>restart the innermost enclosing loop block</shortdesc>
	<description>
	  <para>
	    The redo command restarts a loop block without evaluating
	    the conditional again. The optional <xref
	    linkend="expression"/> argument may evaluate
	    to a positive integer number that indicates which
	    level of the nested loops should be restarted.
	    If omitted, it defaults to 1, i.e. the innermost loop.
	  </para>
	  <para>
	    Using this command outside a loop causes an immediate
	    run-time error.
	  </para>
	  <example>
	    <title>Restart a higher level loop from an inner one</title>
	    <code>while ($i&lt;100) { 
	      <tab/># ...
	      <tab/>foreach //para {
	      <tab/><tab/># some code
	      <tab/><tab/>if $param { 
	      <tab/><tab/><tab/>redo; # redo foreach loop
	      <tab/><tab/>} else {
	      <tab/><tab/><tab/>redo 2; # redo while loop
	      <tab/><tab/>}
	      <tab/>}
	      }
	    </code>
	  </example>
	</description>
	<see-also>
	  <ruleref ref="foreach"/>
	  <ruleref ref="while"/>
	  <ruleref ref="iterate"/>
	  <ruleref ref="next_command"/>
	  <ruleref ref="last_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="next_command" type="command" name="next" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::loop_next,@{$item[3]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>next [<xref linkend="expression"/>]</usage>
	<shortdesc>start the next iteration of an enclosing
	loop</shortdesc>
	<description>
	  <para>
	    The next command is like the continue statement in C; it starts the
	    next iteration of an enclosing loop. The optional <xref
	    linkend="expression"/> argument may evaluate
	    to a positive integer number that indicates which
	    level of the nested loops should be restarted.
	    If omitted, it defaults to 1, i.e. the innermost loop.
	  </para>
	  <para>
	    Using this command outside a loop causes an
	    immediate run-time error.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="foreach"/>
	  <ruleref ref="while"/>
	  <ruleref ref="iterate"/>
	  <ruleref ref="redo_command"/>
	  <ruleref ref="last_command"/>
	  <ruleref ref="prev_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="prev_command" type="command" name="prev" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::loop_prev,@{$item[3]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>prev [<xref linkend="expression"/>]</usage>
	<shortdesc>restart an iteration on a previous node</shortdesc>
	<description>
	  <para>
	    This command is only allowed inside an
	    <literal>iterate</literal> loop. It returns the iteration
	    one step back, to the previous node on the iterated axis.
	    The optional <xref linkend="expression"/> argument may be
	    used to indicate to which level of nested loops the
	    command applies to.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="iterate"/>
	  <ruleref ref="redo_command"/>
	  <ruleref ref="last_command"/>
	  <ruleref ref="next_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="last_command" type="command" name="last" inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::loop_last,@{$item[3]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>last [<xref linkend="expression"/>]</usage>
	<shortdesc>immediately exit an enclosing loop</shortdesc>
	<description>
	  <para>
	    The last command is like the break statement in C (as used
	    in loops); it immediately exits an enclosing loop.  The
	    optional <xref linkend="expression"/> argument may
	    evaluate to a positive integer number that indicates which
	    level of the nested loops to quit.  If this argument is
	    omitted, it defaults to 1, i.e. the innermost loop.
	  </para>
	  <para>
	    Using this command outside a subroutine causes an
	    immediate run-time error.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="foreach"/>
	  <ruleref ref="while"/>
	  <ruleref ref="iterate"/>
	  <ruleref ref="next_command"/>
	  <ruleref ref="last_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="return_command" type="command" name="return" inline="yes">
      <production>
	<selfref/>
	<action>[\&amp;XML::XSH::Functions::call_return]</action>
      </production>
      <documentation sections="Flow">
	<usage>return</usage>
	<shortdesc>return from a subroutine</shortdesc>
	<description>
	  <para>
	    This command immediatelly stops the execution of a
	    procedure it occurs in and returns the execution to the
	    place of the script from which the subroutine was called.
	  </para>
	  <para>
	    Using this command outside a subroutine causes an
	    immediate run-time error.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="def"/>
	  <ruleref ref="call_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="throw_command" type="command" name="throw" inline="yes">
      <production>
	<selfref/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::throw_exception,$item[2]]</action>
      </production>
      <documentation sections="Flow">
	<usage>throw <xref linkend="expression"/></usage>
	<shortdesc>throw an exception</shortdesc>
	<description>
	  <para>
	    This command throws and exception containing error message
	    given by the obligatory <xref linkend="expression"/>
	    argument. If the exception is not handled 
	    by some surrounding <xref linkend="try_catch"/> block,
	    the execution is stopped immediatelly and the error
	    message is printed.
	  </para>
	  <para>
	    Note: There is a special class of internal exceptions with
	    error message starting with a word 'UNCATCHABLE'. Such
	    exceptions are not trapped by <xref
	    linkend="try_catch"/> constructions and should be avoided
	    in ordinary XSH scripts.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="try_catch"/>
	</see-also>
      </documentation>
    </rule>

    <rule id="catalog_command" type="command" name="catalog" inline="yes">
      <production>
	<selfref/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::load_catalog,$item[2]]</action>
      </production>
      <documentation sections="Documents">
	<usage>catalog <xref linkend="expression"/></usage>
	<shortdesc>use a catalog file during all parsing processes</shortdesc>
	<description>
	  <para>
	    Will use a given catalog file as a catalog during all parsing
	    processes. Using a catalog will significantly speed up
	    parsing processes if many external ressources are loaded
	    into the parsed documents (such as DTDs or XIncludes)
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="xpaxis">
      <production>
	<regexp>[-a-z]+::</regexp>
      </production>
    </rule>
    <rule id="xpnodetest">
      <production>
	<regexp>node\(\)|text\(\)|comment\(\)|processing-instruction\(\)|[^\(\[\/\"\'\&amp;\;\s]+</regexp>
      </production>
    </rule>
    <rule id="xplocationstep">
      <production>
	<ruleref ref="xpaxis" rep="?"/>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="xpnodetest"/>
	<action>[ (@{$item[1]} ? $item[1][0] : 'child::'),$item[3] ]</action>
      </production>
    </rule>
    <rule id="xpstep">
      <production>
	<ruleref ref="xplocationstep"/>
	<directive type="skip">&quot;&quot;</directive>
	<ruleref ref="xpfilter" rep="?"/>
	<action>[ @{$item[1]}, @{$item[3]}]</action>
      </production>
    </rule>
    <rule id="iterate" type="command" name="iterate" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="xpstep"/>
	<ruleref ref="block"/>
	<action>[\&amp;XML::XSH::Functions::iterate,$item[4],@{$item[3]}]</action>
      </production>
      <documentation sections="Flow">
	<usage>iterate <xref linkend="xpath"/> <xref linkend="block"/></usage>
	<shortdesc>iterate a block over current subtree</shortdesc>
	<description>
	  <para>
	    Iterate works very much like the XPath variant of <xref
	      linkend="foreach"/>, except that <literal>iterate</literal>
	    evaluates the <xref linkend="block"/> as soon as 
	    a new node matching a given <xref linkend="xpath"/> 
	    is found. As a limitation, the <xref linkend="xpath"/>
	    expresion used with <literal>iterate</literal>
	    may only consist of one XPath step, i.e. it cannot
	    contain an XPath step separator <literal>/</literal>.
	  </para>
	  <para>
	    What are the benefits of <literal>iterate</literal> over a
	    <xref linkend="foreach"/> loop, then? Well, under some
	    circumstances it is efficiency, under other there are
	    none. To clarify this, we have to dive a bit deeper into
	    the details of XPath implementation.  By definition, the
	    node-list resulting from evaluation of an XPath has to be
	    ordered in the canonical document order. That means that
	    an XPath implementation must contain some kind of a
	    sorting algorithm. This would not itself be much trouble
	    if a relative document order of two nodes of a DOM tree
	    could be determined in a constant time. Unfortunately, the
	    libxml2 library, used behind XSH, does not implement
	    mechanisms that would allow this complexity restriction
	    (which is, however, quite natural and reasonable approach
	    if all the consequences are considered). Thus, when
	    comparing two nodes, libxml2 traverses the tree to find
	    their nearest common ancestor and at that point determines
	    the relative order of the two subtrees by trying to seek
	    one of them in a list of right siblings of the other. This
	    of course cannot be handled in a constant time. As a
	    result, the sorting algorithm, reasonably efficient for a
	    constant time comparison (polynomial of a degree &lt; 1.5) or
	    small node-lists, becomes rather unusable for huge
	    node-lists with linear time comparison (still polynomial
	    but of a degree &gt; 2).
	  </para>
	  <para>
	    The <literal>iterate</literal> command provides a way to
	    avoid sorting the resulting nodelist by limiting allowed
	    XPath expression to one step (and thus one axis) at a
	    time. On the other hand, since <literal>iterate</literal>
	    is implemented in Perl, a proxy object glueing the C and
	    Perl layers has to be created for every node the iterator
	    passes by. This (plus some extra subroutine calls) makes
	    it about two to three times slower compared to a similar
	    tree-traversing algorithm used by libxml2 itself during
	    XPath evaluation.
	  </para>
	  <para>
	    Our experience shows that <literal>iterate</literal> beats
	    <xref linkend="foreach"/> in performance on large
	    node-lists (>=1500 nodes, but your milage may vary) while
	    <xref linkend="foreach"/> wins on smaller node-lists.
	  </para>
	  <para>
	    The following two examples give equivallent results.
	    However, the one using iterate may be faster esp. if
	    the number of nodes being counted is very large.
	  </para>
	  <example>
	    <title>Count inhabitants of the kingdom of Rohan in productive age</title>
	    <code>cd rohan/inhabitants;</code>
	    <code>iterate child::*[@age&gt;=18 and @age&lt;60] { perl $productive++ };</code>
	    <code>echo "$productive inhabitants in productive age";</code>
	  </example>
	  <example>
	    <title>Using XPath</title>
	    <code>$productive=count(rohan/inhabitants/*[@age&gt;=18 and @age&lt;60]);</code>
	    <code>echo "$productive inhabitants in productive age";</code>
	  </example>
	  <para>
	    Use e.g. <literal>| time cut</literal> pipe-line
	    redirection to benchmark a XSH command on a UNIX system.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="foreach"/>
	  <ruleref ref="next_command"/>
	  <ruleref ref="prev_command"/>
	  <ruleref ref="last_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="registerns_command" type="command" name="register-namespace"
      inline="yes">
      <aliases>
	<alias name="regns"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::register_ns,
                 $item[3],$item[4]]</action>
      </production>
      <documentation sections="Navigation Configuration">
	<usage>register-namespace <xref linkend="expression"/> <xref linkend="expression"/></usage>
	<shortdesc>register namespace prefix to use XPath expressions</shortdesc>
	<description>
	  <para>
             Registers the first argument
             as a prefix for the namespace given in the second argument.
             The prefix can later be used in XPath expressions.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="unregisterns_command" type="command" name="unregister-namespace"
      inline="yes">
      <aliases>
	<alias name="unregns"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::unregister_ns,
                 $item[3]]</action>
      </production>
      <documentation sections="Navigation Configuration">
	<usage>unregister-namespace <xref linkend="expression"/></usage>
	<shortdesc>unregister namespace prefix</shortdesc>
	<description>
	  <para>
	    Unregisters given namespace prefix previously registered
	    using <xref linkend="registerns_command"/>.  The prefix
	    can no longer be used in XPath expressions unless declared
	    within the current scope of the queried document.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="registerns_xhtml_command" type="command" 
      name="register-xhtml-namespace"
      inline="yes">
      <aliases>
	<alias name="regns-xhtml"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::register_ns,
                 $item[3],'http://www.w3.org/1999/xhtml']</action>
      </production>
      <documentation sections="Navigation Configuration">
	<usage>register-xhtml-namespace <xref linkend="expression"/></usage>
	<shortdesc>register XHTML namespace prefix to use XPath expressions</shortdesc>
	<description>
	  <para>
             Registers a prefix for the XHTML namespace.
             The prefix can later be used in XPath expressions.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="registerns_xsh_command" type="command" 
      name="register-xsh-namespace"
      inline="yes">
      <aliases>
	<alias name="regns-xsh"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::register_ns,
                 $item[3],$XML::XSH::xshNS]</action>
      </production>
      <documentation sections="Navigation Configuration">
	<usage>register-xsh-namespace <xref linkend="expression"/></usage>
	<shortdesc>register XSH namespace prefix to use XPath expressions</shortdesc>
	<description>
	  <para>
	    Registers a new prefix for the XSH namespace.  The prefix
	    can later be used in XPath expressions.  Note, that XSH
	    namespace is by default registered with
	    <literal>xsh</literal> prefix. This command is thus, in
	    general, useful only when some document uses
	    <literal>xsh</literal> prefix for a different namespace.
	  </para>
	</description>
      </documentation>
    </rule>

    <rule id="registerfunc_command" type="command" 
      name="register-function"
      inline="yes">
      <aliases>
	<alias name="regfunc"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<ruleref ref="perl_code"/>
	<action>[\&amp;XML::XSH::Functions::register_func,
                 $item[3],$item[4]]</action>
      </production>
      <documentation sections="Navigation Configuration">
	<usage>register-function <xref linkend="expression"/> <xref linkend="perl_code"/></usage>
	<shortdesc>define XPath extension function (EXPERIMENTAL)</shortdesc>
	<description>
	  <para>
	    EXPERIMENTAL!  Register given perl code as a new XPath
	    extension function under a name provided in the first
	    argument (<xref linkend="expression"/>). XML::LibXML DOM
	    API may be used in the perl code for object processing. If
	    the name contains a colon, then the first part before the
	    colon must be a registered namespace prefix (see <xref
	    linkend="registerns_command"/>) and the function is
	    registered within the corresponding namespace.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="unregisterfunc_command" type="command" 
      name="unregister-function"
      inline="yes">
      <aliases>
	<alias name="unregfunc"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::unregister_func, $item[3]]</action>
      </production>
      <documentation sections="Navigation Configuration">
	<usage>unregister-function <xref linkend="expression"/></usage>
	<shortdesc>undefine extension function (EXPERIMENTAL)</shortdesc>
	<description>
	  <para>
	    EXPERIMENTAL!  Unregiseter XPath extension function of a
	    given name previously registered using <xref
	    linkend="registerfunc_command"/>.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="stream_select">
      <production>
	<regexp>select\s</regexp>
	<ruleref ref="xp"/>
	<ruleref ref="block"/>
        <action>[$item[2],$item[3]]</action>
      </production>
    </rule>
    <rule id="stream_process_command" type="command" name="stream" inline="yes">
      <production>
        <selfref/>
	<directive type="commit"/>
	<regexp>input((\s*|_|-)(FILE|file|PIPE|pipe|STRING|string))?\s</regexp>
	<ruleref ref="filename"/>
	<regexp>output((\s*|_|-)(FILE|file|PIPE|pipe|STRING|string))?\s</regexp>
	<ruleref ref="filename"/>
        <ruleref ref="stream_select" rep="s"/>
	<action>[\&amp;XML::XSH::Functions::stream_process,$item[3],$item[4],$item[5],$item[6],$item[7]]</action>
      </production>
      <documentation sections="Flow Documents">
	<usage>stream input [FILE|PIPE|STRING] <xref linkend="expression"/>
                      output [FILE|PIPE|STRING] <xref linkend="expression"/>
                      select <xref linkend="xpath"/> <xref linkend="block"/>
                    [ select <xref linkend="xpath"/> <xref linkend="block"/> ... ]
                   </usage>
	<shortdesc>process selected elements from an XML stream (EXPERIMENTAL)</shortdesc>
	<description>
	  <para>
	    EXPERIMENTAL!  This command provides a memory efficient
	    (though slower) way to process selected parts of an XML
	    document with XSH. A streaming XML parser (SAX parser) is
	    used to parse the input. The parser has two states which
	    will be refered to as A and B below. The initial state of
	    the parser is A.</para> <para>In the state A, only a
	    limited vertical portion of the DOM tree is built. All XML
	    data comming from the input stream other than start-tags
	    are immediatelly copied to the output stream.  If a new
	    start-tag of an element arrives, a new node is created in
	    the tree. All siblings of the newly created node are
	    removed. Thus, in the state A, there is exactly one node
	    on every level of the tree. After a node is added to the
	    tree, all the <xref linkend="xpath"/> expressions
	    following the <literal>select</literal> keyword
	    are
	    checked. If none matches, the parser remains in state A
	    and copies the start-tag to the output stream. Otherwise,
	    the first expression that matches is remembered and the
	    parser changes its state to B.
	  </para>
	  <para>
	    In state B the parser builds a complete DOM subtree of the
	    element that was last added to the tree before the parser
	    changed its state from A to B. No data are sent to the
	    output at this stage. When the subtree is complete
	    (i.e. the corresponding end-tag for its topmost element is
	    encountered), the <xref linkend="block"/> of instructions
	    following the <xref linkend="xpath"/> expression that
	    matched is invoked with the root element of the subtree as
	    the current context node. The commands in <xref
	    linkend="block"/> are allowed to transform the whole
	    element subtree or even to replace it with a different DOM
	    subtree or subtrees. They must, however, preserve the
	    element's parent as well as all its ancestor nodes
	    intact. Failing to do so can result in an error or
	    unpredictable results.
	  </para>
	  <para>
	    After the subtree processing <xref linkend="block"/>
	    returns, all subtrees that now appear in the DOM tree in
	    the place of the original subtree are serialized to the
	    output stream. After that, they are deleted and the parser
	    returns to state A.
	  </para>
	  <para>
	    Note that this type of processing highly limits the amount
	    of information the XPath expressions can use. First
	    notable fact is that elements can not be selected by their
	    content. The only information present in the tree at the
	    time of the XPath evaluation is the element's name and
	    attributes plus the same information for all its
	    ancestors. There is nothing known yet about possible
	    child nodes of the element as well as of the node's position
	    within its siblings.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="namespaces_command" type="command" name="namespaces"
	    inline="yes">
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="xpath" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::list_namespaces,@{$item[3]}]</action>
      </production>
      <documentation sections="Information">
	<usage>namespaces [<xref linkend="xpath"/>]</usage>
	<shortdesc>List namespaces in current scope (or in scope of
	  given nodes)</shortdesc>
	<description>
	  <para>
	    For each node matching given <xref linkend="xpath"/> lists
	    all namespaces that are valid in its scope in the form of
	    <literal>xmlns:prefix="uri"</literal> declarations.
	    If no <xref linkend="xpath"/> is given, lists namespaces
	    in the scope of the current node.
	  </para>
	</description>
      </documentation>
    </rule>
    <rule id="xpath_completion_command" type="command"
	    name="xpath-completion" inline="yes">
      <aliases>
	<alias name="xpath_completion"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_xpath_completion,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>xpath_completion <xref linkend="expression"/></usage>
	<shortdesc>turn on/off TAB completion for xpath expressions in
	the interactive mode</shortdesc>
	<description>
	  <para>
	    If the
	    <xref linkend="expression"/> is non-zero,
	    enable the TAB completion for <xref linkend="xpath"/>
	    expansions in the interactive shell mode, disable it
	    otherwise. Defaults to on.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$XPATH_COMPLETION</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="xpath_axis_completion_command" type="command"
	    name="xpath-axis-completion" inline="yes">
      <aliases>
	<alias name="xpath_axis_completion"/>
      </aliases>
      <production>
	<selfref/>
	<directive type="commit"/>
	<ruleref ref="expression"/>
	<action>[\&amp;XML::XSH::Functions::set_xpath_axis_completion,$item[3]]</action>
      </production>
      <documentation sections="Configuration">
	<usage>xpath-axis-completion <xref linkend="expression"/></usage>
	<shortdesc>sets TAB completion for axes in xpath expressions in
	the interactive mode</shortdesc>
	<description>
	  <para>
	    The following values are allowed:
	    <literal>always</literal>, <literal>never</literal>,
	    <literal>when-empty</literal>. Note, that all other values
	    (including 1) work as <literal>never</literal>!
	  </para>
	  <para>
	    If the <xref linkend="expression"/> evaluates 
	    to <literal>always</literal>, TAB completion for
	    XPath expressions always includes axis names.
	  </para>
	  <para>
	    If the <xref linkend="expression"/> evaluates to
	    <literal>when-empty</literal>, the TAB completion list for
	    XPath expressions includes axis names only if no element name
	    matches the completion.
	  </para>
	  <para>
	    If the <xref linkend="expression"/> evaluates to
	    <literal>never</literal>, the TAB completion list for
	    XPath expressions never includes axis names.
	  </para>
	  <para>
	    The default value for this optio is
	    <literal>always</literal>.
	  </para>
	  <para>This command is equivalent to setting the
	    <literal>$XPATH_AXIS_COMPLETION</literal> variable.</para>
	</description>
      </documentation>
    </rule>
    <rule id="doc_info_command" type="command"
	    name="doc-info" inline="yes">
      <aliases>
	<alias name="doc_info"/>
      </aliases>
      <production>
	<selfref sep="no"/>
	<directive type="commit"/>
	<ruleref ref="optional_expression" rep="?"/>
	<action>[\&amp;XML::XSH::Functions::doc_info,@{$item[3]}]</action>
      </production>
      <documentation sections="Information">
	<usage>doc-info [<xref linkend="expression"/>]</usage>
	<shortdesc>displays various information about a document</shortdesc>
	<description>
	  <para>
	    In the present implementation, this command displays
	    information provided in the <literal>&lt;?xml
	    ...?&gt;</literal> declaration of a document:
	    <literal>version</literal>, <literal>encoding</literal>,
	    <literal>standalone</literal>, plus information about
	    level of <literal>gzip</literal> compression of the
	    original XML file.
	  </para>
	</description>
	<see-also>
	  <ruleref ref="set_enc_command"/>
	  <ruleref ref="set_standalone_command"/>
	</see-also>
      </documentation>
    </rule>
    <rule id="ignore_use_command" name="use" inline="yes">
      <production>
	<selfref/>
	<directive type="commit"/>
	<regexp>Inline::XSH</regexp>
	<action>1</action>
      </production>
    </rule>
  </rules>  
</recdescent-xml>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml-tools/dtd/catalog /home/pajas/lib/sgml/iso-entities-8879.1986/iso-entities.cat /home/pajas/share/sgml/dtd/docbook/3.1/docbook.cat /home/pajas/share/sgml/stylesheets/docbook/catalog /home/pajas/share/sgml/entities/iso-entities-8879.1986/iso-entities.cat /home/pajas/share/sgml/dtd/jade/dsssl.cat /home/pajas/share/sgml/stylesheets/sgmltools/sgmltools.cat /home/pajas/share/sgml/dtd/sgmltools/catalog")
sgml-local-ecat-files:nil
End:
-->
