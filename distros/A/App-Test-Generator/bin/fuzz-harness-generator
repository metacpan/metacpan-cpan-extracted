#!/usr/bin/env perl

use strict;
use warnings;

use App::Test::Generator;
use autodie qw(:all);
use File::Temp;
use Getopt::Long qw(GetOptions);
use Pod::Usage;

my $infile;
my $outfile;
my $help;
my $run;
GetOptions(
	'help|h' => \$help,
	'input|i=s' => \$infile,
	'output|o=s' => \$outfile,
	'run|r' => \$run,
) or pod2usage(2);

pod2usage(1) if $help;

$infile ||= shift @ARGV or pod2usage('No config file given');

if($run && !$outfile) {
	my $fh;
	($fh, $outfile) = File::Temp::tempfile();

	App::Test::Generator::generate($infile, $outfile);

	system("prove -l $outfile");

	exit $?;
}

App::Test::Generator::generate($infile, $outfile);

chmod 0755, $outfile;
if($run) {
	system("prove -l $outfile");
}

exit 0;

__END__

=head1 NAME

fuzz-harness-generator - Generate fuzzing + corpus-based test harnesses

=head1 SYNOPSIS

  fuzz-harness-generator [-r] [-o outputile] input_file

=head1 DESCRIPTION

This tool generates a C<t/fuzz.t> test file that fuzzes and validates a target module's function or method,
using both randomized fuzz cases and static corpus
cases (Perl or YAML).

=head1 OPTIONS

=over 4

=item B<--help>

Show this help.

=item B<--input>

The input configuration file

=item B<--output>

The (optional) output file.

=item B<--run>

Call C<prove> on the output file.

C<fuzz-harness-generator -r t/conf/data_text_append.conf> will, therefore, dynamically create and run tests on the C<append> method of L<Data::Text>

=back

=cut
