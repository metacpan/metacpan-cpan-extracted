# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Server::Daemon extends Mojo::Server {
  version_from Mojolicious;
  
  use Mojo::URL;
  use Mojo::Util;
  use IO::Socket;
  use IO::Socket::IP;
  use Mojo::Connection::Server;
  use Mojo::Connection::Stream;
  use Go::Channel;
  use Go::OS::Signal;
  use Sys::Signal::Constant as SIGNAL;
  use Go::Sync::WaitGroup;
  use Sys::Socket::Constant as SOCKET;
  
  # Fields
  has acceptors : rw Mojo::Connection::Server[];
  
  has backlog : rw int;
  
  has max_clients : rw int;
  
  has inactivity_timeout : rw int;
  
  has keep_alive_timeout : rw int;
  
  has max_requests : rw int;
  
  has listen : rw string[];
  
  has reverse_proxy : rw byte;
  
  has trusted_proxies : rw string[];
  
  has silent : rw byte;
  
  has accept_wg : Go::Sync::WaitGroup;
  
  has signal_handler_wg : Go::Sync::WaitGroup;
  
  has signal_handler_stop_ch : Go::Channel;
  
  has accept_semaphore_ch : Go::Channel;
  
  # Class Methods
  static method new : Mojo::Server::Daemon () {
    
    my $self = new Mojo::Server::Daemon;
    
    $self->init;
    
    return $self;
  }
  
  static method DEBUG : int () {
    return length(my $_ = Sys->env("SPVM_MOJO_SERVER_DEBUG")) ? (int)$_ : 0;
  }
  
  # Instance Methods
  protected method init : void () {
    
    $self->{acceptors} = new Mojo::Connection::Server[0];
    
    $self->{inactivity_timeout} = length(my $_ = Sys->env("SPVM_MOJO_INACTIVITY_TIMEOUT")) ? (int)$_ : 30;
    
    $self->{keep_alive_timeout} = length(my $_ = Sys->env("SPVM_MOJO_KEEP_ALIVE_TIMEOUT")) ? (int)$_ : 5;
    
    $self->{max_requests} = 100;
    
    $self->{listen} = length(my $_ = Sys->env("SPVM_MOJO_KEEP_ALIVE_TIMEOUT")) ? Fn->split(",", $_) : ["http://*:3000"];
    
    $self->{max_clients} = 1000;
    
    $self->{accept_wg} = Go::Sync::WaitGroup->new;
    
    $self->{signal_handler_wg} = Go::Sync::WaitGroup->new;
    
    $self->{signal_handler_stop_ch} = Go->make;
    
    $self->{accept_semaphore_ch} = Go->make($self->max_clients);
    
  }
  
  method ports : int[] () {
    
    my $acceptors = $self->acceptors;
    
    my $ports_list = IntList->new;
    for (my $i = 0; $i < @$acceptors; $i++) {
      my $handle = $acceptors->[$i];
      $ports_list->push($handle->port);
    }
    
    return $ports_list->to_array;
  }
  
  method run : void () {
    
    Go->go([$self : Mojo::Server::Daemon] method : void () {
      $self->start;
    });
    
    Go->gosched;
    
    $self->{accept_wg}->wait;
    
    $self->{signal_handler_stop_ch}->close;
    
    $self->{signal_handler_wg}->wait;
  }
  
  private method add_signal_handler : void () {
    
    $self->{signal_handler_wg}->add(1);
    Go->go([$self : Mojo::Server::Daemon] method : void () {
        
      Fn->defer([$self : Mojo::Server::Daemon] method : void () {
        $self->{signal_handler_wg}->done;
      });
      
      my $signal_ch = Go->make(1);
      Go::OS::Signal->notify($signal_ch, SIGNAL->SIGTERM);
      Go::OS::Signal->notify($signal_ch, SIGNAL->SIGINT);
      
      my $select = Go->new_select;
      $select->add_read($signal_ch);
      $select->add_read($self->{signal_handler_stop_ch});
      
      while (1) {
        
        my $result = $select->select;
        
        if ($result) {
          if ($result->channel == $signal_ch) {
            for my $acceptor (@{$self->acceptors}) {
              unless ($acceptor->handle->opened) {
                $acceptor->handle->close;
              }
            }
          }
          elsif ($result->channel == $self->{signal_handler_stop_ch}) {
            return;
          }
        }
      }
    });
  }
  
  method start : void () {
    
    # Start listening
    if (!@{$self->acceptors}) {
      $self->app->server($self);
      for my $_ (@{$self->listen}) {
        $self->_listen($_);
      }
    }
    
    # Start accept
    for my $acceptor (@{$self->acceptors}) {
      
      $self->{accept_wg}->add(1);
      Go->go([$self : Mojo::Server::Daemon, $acceptor : Mojo::Connection::Server] method : void () {
        
        Fn->defer([$self : Mojo::Server::Daemon] method : void () {
          $self->{accept_wg}->done;
        });
        
        while (1) {
          $self->{accept_semaphore_ch}->write(1);
          
          my $accepted_handle = (IO::Socket)undef;
          eval {
            $accepted_handle = $acceptor->handle->accept;
            
            # Disable Nagle's algorithm
            $accepted_handle->setsockopt(SOCKET->IPPROTO_TCP, SOCKET->TCP_NODELAY, 1);
          }
          if ($@) {
            $self->{accept_semaphore_ch}->read;
            next;
          }
          
          $self->{accept_wg}->add(1);
          Go->go([$self : Mojo::Server::Daemon, $accepted_handle : IO::Socket] method : void () {
            Fn->defer([$self : Mojo::Server::Daemon] method : void () {
              $self->{accept_semaphore_ch}->read;
              $self->{accept_wg}->done;
            });
            
            eval {
              my $accepted_connection = Mojo::Connection::Stream->new;
              $accepted_connection->set_handle($accepted_handle);
              
              while (1) {
                
                unless ($accepted_connection->tx) {
                  my $tx = $self->_build_tx($accepted_connection);
                  $accepted_connection->set_tx($tx);
                }
                
                my $tx = $accepted_connection->tx;
                
                my $chunk = new_string_len 4096;
                my $chunk_length = length $chunk;
                while (1) {
                  if ($tx->req->is_finished) {
                    last;
                  }
                  
                  my $read_length = $accepted_connection->read($chunk);
                  
                  $tx->server_read(Fn->substr($chunk, 0, $read_length));
                }
                
                # Do process
                my $req = $tx->req;
                
                $self->app->handler($tx);
                
                # Last keep-alive request or corrupted connection
                if (($accepted_connection->requests || 1) >= $self->max_requests) {
                  $tx->res->headers->set_connection("close");
                }
                
                my $output = "";
                while (1) {
                  my $chunk = $tx->server_write;
                  
                  unless (length $chunk) {
                    last;
                  }
                  
                  $accepted_connection->write($chunk);
                }
                
                $self->_finish($accepted_connection);
                
                if ($tx isa Mojo::Transaction::HTTP && !$tx->(Mojo::Transaction::HTTP)->keep_alive) {
                  last;
                }
              }
            };
          });
        }
      });
    }
  }
  
  method stop : void () {
    
    for my $server (@{$self->acceptors}) {
      $server->stop;
    }
    
  }
  
  method _build_tx : Mojo::Transaction::HTTP ($accepted_connection : Mojo::Connection::Stream) {
    
    my $tx = $self->build_tx;
    
    $tx->set_connection($accepted_connection);
    
    $tx->res->headers->set_server("Mojolicious (SPVM)");
    
    my $handle = $accepted_connection->handle;
    
    $accepted_connection->set_timeout($self->inactivity_timeout);
    
    unless ($handle isa IO::Socket::UNIX) {
      $tx->set_local_address($handle->(IO::Socket::IP)->sockhost);
      $tx->set_local_port($handle->(IO::Socket::IP)->sockport);
      $tx->set_remote_address($handle->(IO::Socket::IP)->peerhost);
      $tx->set_remote_port($handle->(IO::Socket::IP)->peerport);
    }
    
    if ($accepted_connection->tls) {
      $tx->req->url->base->set_scheme("https");
    }
    
    # Kept alive if we have more than one request on the connection
    my $requests = $accepted_connection->requests;
    ++$requests;
    
    if ($requests > 1) {
      $tx->set_kept_alive(1);
    }
    
    $accepted_connection->set_requests($requests);
    
    return $tx;
  }
  
  method _finish : void ($accepted_connection : Mojo::Connection::Stream) {
    
    my $tx = $accepted_connection->tx;
    $accepted_connection->set_tx(undef);
    $tx->closed;
    
    # Build new transaction for leftovers
    if (length(my $leftovers = $tx->req->content->leftovers)) {
      $tx = $self->_build_tx($accepted_connection);
      
      $accepted_connection->set_tx($tx);
      
      $tx->server_read($leftovers);
    }
    
    # Keep-alive connection
    unless ($accepted_connection->tx) {
      $accepted_connection->set_timeout($self->keep_alive_timeout);
    }
  }
  
  private static method _peer : string ($handle : IO::Socket) {
    
    my $peer = (string)undef;
    
    if ($handle isa IO::Socket::UNIX) {
      $peer = $handle->(IO::Socket::UNIX)->peerpath;
    }
    else {
      $peer = $handle->(IO::Socket::IP)->peerhost;
    }
    
    return $peer;
  }
  
  private static method _url : string ($tx : Mojo::Transaction) {
    
    return $tx->req->url->to_abs->to_string;
  }
  
  method _listen : void ($listen : string) {
    
    my $url = Mojo::URL->new($listen);
    
    my $proto = $url->protocol;
    unless ($proto eq "http" || $proto eq "https" || $proto eq "http+unix") {
      die "Invalid listen location '$listen'";
    }
    
    my $query   = $url->query;
    my $options = Hash->new;
    
    if (exists $self->{backlog}) {
      $options->{"backlog"} = $self->{backlog};
    }
    
    $options->set("fd" => $query->param("fd"));
    $options->set("reuse" => $query->param("reuse"));
    
    if ($proto eq "http+unix") { $options->set(path => $url->host); }
    else {
      if ((my $host = $url->host) ne "*") { $options->set(address => $host); }
      if (my $port = $url->port) { $options->set(port => $port); }
    }
    
    $options->set(tls_ca => $query->param("ca"));
    
    for my $_ (@{$query->names}) {
      if (my $m = Re->m($_, "^(.*)_(cert|key)$")) {
        my $type = $m->cap1;
        my $name = "tls_" . $m->cap2;
        
        $options->set($name, Hash->new);
        $options->get($name)->(Hash)->set($type, $query->param($_));
      }
    }
    
    if (my $cert = $query->param("cert")) { $options->get("tls_cert")->(Hash)->set("", $cert); }
    if (my $key  = $query->param("key"))  { $options->get("tls_key")->(Hash)->set("", $key); }
    my $ciphers = $query->param("ciphers");
    my $verify = $query->param("verify");
    my $version = $query->param("version");
    
    $options->set(tls_options => Hash->new);
    
    if ($ciphers) {
      $options->get("tls_options")->(Hash)->set(SSL_cipher_list => $ciphers);
    }
    if ($verify) {
      $options->get("tls_options")->(Hash)->set(SSL_verify_mode => Fn->hex($verify));
    }
    if ($version) {
      $options->get("tls_options")->(Hash)->set(SSL_version => $version);
    }
    
    my $tls =  $proto eq "https";
    $options->set(tls => $tls);
    
    my $acceptor = Mojo::Connection::Server->new;
    
    $acceptor->listen($options);
    
    $acceptor->set_timeout($self->inactivity_timeout);
    
    my $acceptors = (List of Mojo::Connection::Server)List->new_ref($self->{acceptors});
    
    $acceptors->push($acceptor);
    
    if ($self->silent) {
      return;
    }
    
    $self->app->log->info("Listening at '" . $url->to_string . "'");
    $query->set_pairs(new string[0]);
    
    if ($url->host eq "*") {
      $url->set_host("127.0.0.1");
    }
    if (!$options->get("path") && !$url->port) {
      $url->set_port($self->ports->[@$self->ports - 1]) ;
    }
    
    say "Web application available at " . ($options->{"path"}->(string) // $url->to_string);
  }

}
