=pod

=encoding utf-8

=head1 NAME

Affix - A Foreign Function Interface eXtension

=head1 SYNOPSIS

    use v5.40;
    use Affix;

    # Load a Library
    my $lib = load_library(libm);    # libm.so / msvcrt.dll

    # Bind a Function
    #    double pow(double x, double y);
    affix $lib, 'pow', [ Double, Double ] => Double;

    # Call it
    say pow( 2.0, 10.0 );    # 1024

    # Allocate 1KiB of raw memory
    my $ptr = Affix::malloc(1024);

    # Write raw data to the pointer
    Affix::memcpy( $ptr, 'test', 4 );

    # Poiner arithmetic creates a new reference (doesn't modify original)
    my $offset_ptr = Affix::ptr_add( $ptr, 12 );
    Affix::memcpy( $offset_ptr, 'test', 4 );

    # Inspect memory with a hex dump to STDOUT
    Affix::dump( $ptr, 32 );

    # Release the memory
    Affix::free($ptr);
=head1 DESCRIPTION

B<Affix> is a high-performance Foreign Function Interface (FFI) for Perl. It allows you to load dynamic libraries
(DLLs, shared objects) and call their functions natively without writing XS code or configuring a C compiler.

It distinguishes itself from other FFI solutions by using L<B<infix>|https://github.com/sanko/infix/>, a custom
lightweight JIT engine. When you bind a function, Affix generates machine code at runtime (a 'trampoline') to handle
the argument marshalling. This results in significantly lower overhead than generic FFI wrappers that rely on dynamic
dispatch per-call.

=head1 EXPORTS

Affix exports standard types (C<Int>, C<Double>, etc.) and core functions (C<affix>, C<wrap>, C<load_library>) by
default.

You can control imports using tags:

    use Affix qw[:all];    # Import everything
    use Affix qw[:lib];    # Library helpers (libc, libm, load_library...)
    use Affix qw[:memory]; # malloc, free, memcpy, cast, dump...
    use Affix qw[:pin];    # Variable binding (pin, unpin)
    use Affix qw[:types];  # Types only (Int, Struct, Pointer...)

=head1 Core API

Affix's API is designed to be expressive. Let's start at the beginning with the eponymous C<affix( ... )> function.

=head2 C<affix( ... )>

Attaches a symbol from a library to a named perl subroutine in the current namespace.

    # Standard: Load from library
    affix $lib, 'pow', [ Double, Double ] => Double;

    # Rename: Load 'pow', install as 'power'
    affix $lib, [ pow => 'power' ], [ Double, Double ] => Double;

    # Raw pointer: Bind a specific memory address (vtables, JIT, dlsym, etc.)
    affix undef, [ $ptr => 'my_func' ], [Int] => Void;

Parameters:

=over

=item C<$lib>

A library handle returned by C<L<load_library( $path )|/load_library( $path )>>, a path string, or C<undef> (searches
the main executable/process).

=item C<$symbol_name>

The name of the function to find. Pass an array list (C<['real_name', 'alias']>) to rename it in Perl.

=item C<$parameters>

An array reference of argument types. See L<Types|/Types> for the full list.

=item C<$return>

A single return type for the function.

=back

On success, C<affix( ... )> installs the subroutine and returns the generated code reference.

=head2 C<wrap( ... )>

Creates a wrapper around a given symbol and returns it as an anonymous C<CODE> reference.

    # From library
    my $pow = wrap $lib, 'pow', [ Double, Double ] => Double;

    # Call the function
    my $result = $pow->( 2, 5 );

    # From a raw pointer
    # Note: Library argument is undef
    my $func = wrap undef, $ptr, [Int] => Void;

Arguments are nearly identical to C<L<affix( ... )|/affix( ... )>> except you cannot provide an alias for the function
name.

=begin :experimental

=head2 C<direct_affix( ... )>

Same as C<affix>, but utilizes the "Direct Marshalling" backend. This generates a highly specialized trampoline that
reads Perl SVs directly from the stack, bypassing some of Affix's safety checks and intermediate processing. This is
experimental but offers maximum performance for simple primitives.

=head2 C<direct_wrap( ... )>

Same as C<wrap>, but uses the "Direct Marshalling" backend.

=end :experimental

=head2 C<pin( ... )>

    my $scalar;
    # Bind $scalar to the global integer variable 'errno' in libc
    pin $scalar, libc(), 'errno', Int;
    $scalar = 0;   # Writes to C memory
    sysopen( ... );
    say $scalar;   # Reads from C memory

Variables exported by a library (global/extern variables) can be accessed using C<pin>. Reading the scalar reads the
memory; writing to it writes to the memory.

Parameters:

=over

=item C<$var>

The scalar to bind.

=item C<$lib>

The library handle.

=item C<$symbol>

Name of the exported variable.

=item C<$type>

The type of data the variable contains.

=back

=head2 C<unpin( ... )>

    unpin $errno;

Removes the magic applied by C<pin( ... )> to a variable. The variable retains its last value but is no longer linked
to C memory.

=head2 C<typedef( ... )>

    typedef MyType => Struct[ name => String, age => Int ];


    # Now use it in signatures
    affix $lib, 'func', [ MyType() ] => Void;

Registers a named type alias. This is required for:

=over

=item 1. B<Recursive Types>: A struct that contains a pointer to itself.

=item 2. B<Reusability>: Defining a complex signature once and using it in multiple functions.

=item 3. B<Smart Enums>: Generating Perl constants in your package.

=back

=head2 C<coerce( $type, $value )>

Used primarily with L<Variadic Functions|/Variadic Functions (VarArgs)>. It wraps a value with type information so
Affix knows how to marshal it when no compile-time signature is available.

    # Hint that we are passing a Float, not a Double
    coerce( Float, 1.5 );

=head2 C<get_last_error_message( )>

Returns a string describing the most recent error that occurred during library loading or symbol lookup.

=head1 Library Utilities

Locating libraries on different platforms can be tricky. These utilities help you load and manage dynamic libraries.

They are exported by default but may be imported specifically with the C<:lib> tag.

=head2 C<load_library( $path )>

    my $lib = load_library( 'user32.dll' );

Locates and loads a dynamic library, returning an opaque (C<Affix::Lib>) handle.

If you pass a name without an extension (e.g., 'm'), Affix applies platform-specific prefixes/suffixes (e.g.,
'libm.so', 'libm.dylib', 'm.dll') and searches standard system paths.

=head2 C<locate_lib( $name, [$version] )>

    my $path = locate_lib('ssl', '1.1');

Searches system paths (C<LD_LIBRARY_PATH>, C<PATH>, C<DYLD_LIBRARY_PATH>, etc.) and returns the full absolute path to
the library file without loading it.

=head2 C<find_symbol( $lib, $name )>

Returns the raw memory address (as an integer) of a symbol. Useful if you need to pass a function pointer B<value> to
C, rather than calling it.

=head2 C<libc()> / C<libm()>

Helpers returning handles to the standard C library and math library.

=head1 Memory Management

Affix uses B<pins> to manage raw memory. A pin is a magical scalar reference holding a memory address and type
information.

=head2 C<malloc( $size )>

    my $ptr = malloc( 1024 );

Allocates C<$size> bytes of uninitialized memory. Returns a C<Pointer[Void]> pin. Memory allocated this way is
B<managed> by Perl (freed automatically when the pin goes out of scope).

=head2 C<calloc( $num, $size_or_type )>

    my $array = calloc( 10, Int );

Allocates memory for an array of C<$count> elements and initializes them to zero. You may pass a Type object (like
C<Int>) or a raw size in bytes.

=head2 C<realloc( $ptr, $new_size )>

    $ptr = realloc( $ptr, $new_size );

Resizes the memory pointed to by C<$ptr>. Returns the new pointer (the original pin is updated automatically).

=head2 C<free( $ptr )>

    free( $ptr );

Releases memory allocated by Affix.

B<Note:> Only use this on memory allocated by C<malloc>, C<calloc>, or C<strdup>. Do not attempt to free pointers
returned by C libraries unless the library documentation explicitly says you own that memory.

=head2 C<cast( $ptr, $type )>

    my $void  = malloc(4);
    my $int   = cast( $void, Int ); # Read immediate value
    my $int_p = cast( $void, Pointer[Int] ); # Return new Pin

Reinterprets a pointer.

=over

=item * B<To value> (C<Int>, etc.): Reads the memory immediately and returns a Perl scalar.

=item * B<To reference> (C<Pointer[Int]>): Returns a new pin aliasing the memory. Dereferencing it (C<$$pin>) reads/writes the value.

=back

=head2 C<own( $ptr, [$bool] )>

    own( $ptr, $bool );

Controls lifecycle management of the pointer.

=over

=item * C<own($p, 1)>: Perl assumes ownership. C<free()> will be called when C<$p> goes out of scope.

=item * C<own($p, 0)>: Perl releases ownership. C<free()> is never called by Perl.

=back

B<Double free warning:> If you call C<own($p, 1)> and then pass C<$p> to a C function that I<also> frees that memory,
your program will crash. Only take ownership if you are sure the C library expects you to free the memory.

=head2 C<address( $ptr )>

Returns the virtual memory address of the pointer as a C<UInt64>.

=head2 Pointer Arithmetic & Utilities

=over

=item C<ptr_add( $ptr, $offset )>

Returns a new unmanaged pin offset by C<$bytes>. If C<$ptr> is an array type, it decays to a pointer type.

=item C<ptr_diff( $ptr1, $ptr2 )>

Returns the difference in bytes (C<$ptr1 - $ptr2>).

=item C<is_null( $ptr )>

Returns true if the pointer is C<NULL> (C<0x0>).

=item C<strdup( $string )>

Allocates memory and copies the Perl string (plus C<NULL> terminator) into it.

=item C<strnlen( $ptr, $maxlen )>

Safe string length calculation.

=back

=head2 Raw Memory Operatoins

Standard C memory operations are available for high-performance manipulation of pins.

=over

=item C<memchr( $ptr, $ch, $count )>

=item C<memcmp( $lhs, $rhs, $count )>

=item C<memset( $dest, $ch, $count )>

=item C<memcpy( $dest, $src, $count )>

=item C<memmove( $dest, $src, $count )>

=back

=head2 C<dump( $ptr, $length )>

Prints a hex dump of the memory at C<$ptr> to C<STDOUT>.

=head1 Introspection

=head2 C<sizeof( $type )>

    my $size = sizeof( Int );
    my $size_rect = sizeof( Struct[ x => Int, y => Int ] );

Returns the size, in bytes, of a Type object.

=head2 C<offsetof( $struct_type, $field_name )>

    my $struct = Struct[ name => String, age => Int ];
    my $offset = offsetof( $struct, 'age' );

Returns the byte offset of a field within a Struct or Union.

=head2 C<alignof( $type )>

Returns the required alignment bytes for a Type.

=head2 C<types()>

Returns a list of all named types currently registered in the system.

=head1 Types

Affix signatures are built using these helper functions

    # Example Signature
    [ Int, String ] => Void

=head2 Primitive Types

Primitives map to native C types.

=begin text

    Type        Description
    ----------------------------------------------------------------------------
    Void        Returns nothing
    Bool        Mapped to Perl true/false
    Char        signed char (8-bit usually)
    UChar       unsigned char
    SChar       Explicitly signed char
    Short       signed short
    UShort      unsigned short
    Int         signed int (platform native, usually 32-bit)
    UInt        unsigned int
    Long        signed long (32-bit on Win64, 64-bit on Linux64)
    ULong       unsigned long
    LongLong    signed long long (guaranteed 64-bit)
    ULongLong   unsigned long long
    Float       32-bit float
    Double      64-bit float
    LongDouble  Platform specific (80-bit or 128-bit)
    Size_t      size_t
    SSize_t     ssize_t

=end text

=begin html

 <table border="1" cellpadding="4" cellspacing="0">
    <thead>
        <tr><th>Type</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td>Void</td><td>Returns nothing</td></tr>
        <tr><td>Bool</td><td>Mapped to Perl true/false</td></tr>
        <tr><td>Char</td><td>signed char (8-bit usually)</td></tr>
        <tr><td>UChar</td><td>unsigned char</td></tr>
        <tr><td>SChar</td><td>Explicitly signed char</td></tr>
        <tr><td>Short</td><td>signed short</td></tr>
        <tr><td>UShort</td><td>unsigned short</td></tr>
        <tr><td>Int</td><td>signed int (platform native, usually 32-bit)</td></tr>
        <tr><td>UInt</td><td>unsigned int</td></tr>
        <tr><td>Long</td><td>signed long (32-bit on Win64, 64-bit on Linux64)</td></tr>
        <tr><td>ULong</td><td>unsigned long</td></tr>
        <tr><td>LongLong</td><td>signed long long (guaranteed 64-bit)</td></tr>
        <tr><td>ULongLong</td><td>unsigned long long</td></tr>
        <tr><td>Float</td><td>32-bit float</td></tr>
        <tr><td>Double</td><td>64-bit float</td></tr>
        <tr><td>LongDouble</td><td>Platform specific (80-bit or 128-bit)</td></tr>
        <tr><td>Size_t</td><td>size_t</td></tr>
        <tr><td>SSize_t</td><td>ssize_t</td></tr>
    </tbody>
 </table>

=end html

=head3 Explicit Width Types

For precise control, use these types which are guaranteed to have specific bit widths across all platforms:

    Int8, UInt8
    Int16, UInt16
    Int32, UInt32
    Int64, UInt64
    Int128, UInt128 (Passed as Decimal Strings)

128-bit integers, if supported by the compiler, must be passed as strings to/from Perl.

=head2 Pointers

Pointers are the glue of C. Affix provides distinct ways to handle them based on intent.

=over

=item Basic Pointers (C<Pointer[Type]>)

When a function expects C<int*> or C<double*>, pass a B<reference to a scalar>.

    # C: void split_float(double val, int* whole, double* frac);
    affix $lib, 'split_float', [ Double, Pointer[Int], Pointer[Double] ] => Void;

    my ($whole, $frac);
    split_float( 3.14, \$whole, \$frac );

Affix automatically:

=over

=item 1. Allocates temporary memory.

=item 2. Copies the Perl value into it (if defined).

=item 3. Passes the pointer to C.

=item 4. Copies the result back into your Perl scalar after the call.

=back

=item Strings (C<String> vs C<Pointer[Char]>)

=over

=item * B<C<String>>: Use this for C<const char*> (input strings). Affix copies the Perl string to a temporary C buffer.

=item * B<C<Pointer[Char]>>: Use this for mutable strings C<char*>. You must ensure the scalar passed has enough pre-allocated capacity (e.g. using C<"\0" x 1024>).

=back

=item Void Pointers (C<Pointer[Void]>)

Used for opaque handles or generic data.

=over

=item * Pass C<undef> to send C<NULL>.

=item * Pass a reference C<\$scalar> to send the address of that scalar.

=item * Pass a B<Pin> (from C<malloc> or C<cast>) to pass that memory address directly.

=back

=back

=head3 Pins (Managed Pointers)

For manual memory management, use C<malloc>, C<calloc>, or C<cast>. These return B<Pins>. A Pin is a reference to a
scalar holding the memory address, blessed with magic.

    my $ptr = malloc(1024);   # Allocate 1024 bytes
    my $view = cast($ptr, Int); # Treat it as an integer

    $$view = 123;             # Write 123 to the memory
    free($ptr);               # Free it manually (optional, GC handles it otherwise)

=head2 Special Types

=over

=item C<Buffer>

Passes a pointer to the raw string buffer of a Perl scalar. Useful for "Zero-Copy" or "Direct-Write" C functions that
populate a buffer.

    # C: void get_data(char *buf, int len);
    affix $lib, 'get_data', [ Buffer, Int ] => Void;

    my $buf = "\0" x 1024; # Pre-allocate
    get_data($buf, 1024);

B<Warning:> The scalar must be writable and have sufficient pre-allocated capacity.

=item C<File>

Represents the standard C C<FILE> structure. Use C<Pointer[File]> to map a Perl filehandle (Glob or IO object) to
C<FILE*>.

    affix $lib, 'fprintf', [ Pointer[File], String ] => Int;
    open my $fh, '>', 'log.txt';
    fprintf($fh, "Hello from Affix!");

=item C<PerlIO>

Represents the internal C<PerlIO> structure. Use C<Pointer[PerlIO]> when the C function expects C<PerlIO*>.

=item C<SockAddr>

Safe marshalling for packed socket addresses (e.g. from C<Socket::pack_sockaddr_in>). Passed to C as C<struct
sockaddr*>.

=item C<String>

Alias for C<const char*>. Affix automatically handles UTF-8 encoding (Perl to C) and decoding (C to Perl).

=item C<StringList>

Maps a Perl Array Reference of strings (C<[ "a", "b" ]>) to a null-terminated C<char**> array (common in C APIs like
C<execve> or C<main(argc, argv)>).

    affix $lib, 'process_args', [ StringList ] => Int;
    process_args( [ "arg1", "arg2" ] );

=item C<SV>

The raw Perl Interpreter Object (C<SV>). Use this if you are writing a function that manipulates Perl internals
directly. Note that this must always be a pointer: C<Pointer[SV]>.

=item C<WString>

Alias for C<const wchar_t*>. Affix handles the complexity of UTF-16 (Windows) vs UTF-32 (Linux/macOS) and Surrogate
Pairs automatically.

=back

=head2 Aggregates

=head3 Structs

Structs are the bread and butter of C APIs. In Affix, they map to B<Perl Hash References>.

    # C: typedef struct { int x; int y; } Point;
    #    void draw_line(Point a, Point b);

    # Define the type (recommended for reuse)
    typedef Point => Struct [
        x => Int,
        y => Int
    ];

    # Bind the function
    affix $lib, 'draw_line', [ Point, Point ] => Void;

    # Call with HashRefs
    draw_line( { x => 0, y => 0 }, { x => 100, y => 100 } );

B<Nested Structs:> Affix handles deep structures automatically.

    typedef Rect => Struct [
        top_left     => Point,
        bottom_right => Point,
        color        => Int
    ];

    draw_rect({
        top_left     => { x => 10, y => 10 },
        bottom_right => { x => 50, y => 50 },
        color        => 0xFF0000
    });

=head3 Unions

Maps to Perl hash references with a single key.

    # C: union Event { int key_code; float pressure; };
    typedef Event => Union [
        key_code => Int,
        pressure => Float
    ];

    # Pass an integer
    handle_event( { key_code => 27 } );

    # Pass a float
    handle_event( { pressure => 0.5 } );

=over

=item C<Packed [ $align, $aggregate ]>

Defines a struct with specific byte alignment (e.g. C<#pragma pack(1)>).

    Packed [ 1,
        Struct[
            name => Pointer[Char],
            # ...etc.
        ]
    ];

=back

=head2 Working with Arrays

=over

=item B<Fixed-Size Arrays (C<Array[Type, N]>)>

Fixed-size C arrays are mapped to Perl Array References. Affix handles the decay to pointers and automatically writes
back changes to your Perl array.

    # C: void process_matrix(int matrix[9]);
    affix $lib, 'process_matrix', [ Array[Int, 9] ] => Void;

    # Pass a reference to a Perl array
    process_matrix( [1..9] );

=item B<Binary Data>

For arrays of bytes (C<Array[UChar]> or C<Array[UInt8]>), Affix treats the data as a raw binary blob. Dereferencing a
Pin of this type yields a binary string, reading exactly the number of bytes specified.

For arrays of characters (C<Array[Char]> or C<Array[SInt8]>), Affix treats the data as a C String, reading until the
first null terminator or the array limit.

=back

=head2 SIMD Vectors

Vectors (e.g. C<__m128> on x86, C<float32x4_t> on ARM) are first-class types in Affix. You can interact with them in
two ways:

=over

=item 1. B<Array References>: Simplest to read and write.

=item 2. B<Packed Strings>: Highest performance (avoids marshalling overhead).

=back

    # C: typedef float v4f __attribute__((vector_size(16)));
    #    v4f add_vecs(v4f a, v4f b);
    affix $lib, 'add_vecs', [ Vector[4, Float], Vector[4, Float] ] => Vector[4, Float];

    # Option 1: Array References (Convenient)
    my $res = add_vecs( [1, 2, 3, 4], [10, 20, 30, 40] );
    # $res is [11.0, 22.0, 33.0, 44.0]

    # Option 2: Packed Strings (Fast)
    # Useful for tight loops, graphics, or physics math
    my $packed_a = pack('f4', 1.0, 2.0, 3.0, 4.0);
    my $packed_b = pack('f4', 10.0, 20.0, 30.0, 40.0);

    # Pass binary strings directly
    my $res_ref = add_vecs( $packed_a, $packed_b );

=head2 Enumerations

    typedef Status => Enum [
        [ OK => 0 ],
        'ERROR',                    # Auto-increments to 1
        [ FLAG_A => 1 << 0 ],       # Bit shifting
        [ FLAG_B => '1 << 1' ],     # String expression
        [ FLAG_C => 'FLAG_B << 1' ] # References previous keys
    ];

Defines a C enum backed by an integer.

=over

=item *

B<Constants>: C<typedef> installs constants (like C<OK>) into your package.

=item *

B<Dualvars:> Values returned from C are dual-typed. C<OK> behaves as the integer C<0> in numeric operations, but prints
as the string C<"OK">.

=item *

B<Calculated Values:> You can use string expressions to define values. These are evaluated at definition time.

=back

=head2 Variadic Functions (VarArgs)

Affix supports C functions that take a variable number of arguments, like C<printf>.

    # C: int printf(const char* format, ...);
    affix libc, 'printf', [ String, VarArgs ] => Int;

When calling a variadic function, Affix performs dynamic type inference at runtime for the extra arguments:

=over

=item * Perl Integers -> C<int64_t>

=item * Perl Floats   -> C<double> (Standard C promotion rules)

=item * Perl Strings  -> C<char*>

=back

    printf("Hello %s, count is %d\n", "World", 123);

=head3 Hinting Types with C<coerce()>

Sometimes standard inference isn't enough (e.g., passing a C<float> instead of C<double>, or passing a Struct by
value). Use C<coerce($type, $value)> to explicitly hint the type.

    # Passing a struct by value to a variadic function
    typedef Point => Struct [ x=>Int, y=>Int ];
    my $p = { x => 10, y => 20 };

    # Without coerce(), $p would likely be treated as an error or generic pointer
    my_variadic_func( "Point: %P", coerce( Point(), $p ) );

=head2 Callbacks

You can pass Perl subroutines to C functions that expect function pointers.

    # C: void set_handler( void (*callback)(int status, const char* msg) );

    affix $lib, 'set_handler',
        [ Callback[ [Int, String] => Void ] ] => Void;

    set_handler(sub ($status, $msg) {
        say "Received status $status: $msg";
    });

B<Note:> The callback is valid only as long as the C function holds onto it. If the C library stores the function
pointer globally, ensure your Perl code keeps the reference alive if necessary (though Affix handles the trampoline
lifecycle automatically for the duration of the call).

=head1 Utilities

=head2 C<errno()>

    my $err = errno();
    die "Error $err: " . int($err);

Access the C<errno> (Linux/Unix) or C<GetLastError> (Windows) from the most recent FFI call. This must be called
immediately after the function invokes to ensure accuracy.

The return value is a B<dualvar>:

=over

=item * B<Numeric context>: Returns the integer error code.

=item * B<String context>: Returns the human-readable system error message (via C<strerror> or C<FormatMessage>).

=back

=head2 C<sv_dump( $sv )>

Dumps the internal flags and structure of a Perl C<SV>.

=head1 Thread Safety & Concurrency

Affix bridges Perl (a single-threaded interpreter, generally) with libraries that may be multi-threaded. This creates
potential hazards that you must manage.

=head2 1. Initialization Phase vs. Execution Phase

Functions that modify Affix's global state are B<not thread-safe>. You must perform all definitions in the main thread
before starting any background threads or loops in the library.

Unsafe operations that you should never call from Callbacks or in a threaded context:

=over

=item * C<affix( ... )> - Binding new functions.

=item * C<typedef( ... )> - Registering new types.

=back

=head2 2. Callbacks

When passing a Perl subroutine as a C<Callback>, avoid performing complex Perl operations like loading modules or
defining subs inside callback triggered on a foreign thread. Such callbacks should remain simple: process data, update
a shared variable, and return.

If the library executes the callback from a background thread (e.g., window managers, audio callbacks), Affix attempts
to attach a temporary Perl context to that thread. This should be sufficient but Perl is gonna be Perl.

=head1 EXAMPLES

See L<The Affix Cookbook|https://github.com/sanko/Affix.pm/discussions/categories/recipes> for comprehensive guides to
using Affix.

=head1 SEE ALSO

L<FFI::Platypus>, L<C::DynaLib>, L<XS::TCC>, L<C::Blocks>

All the heavy lifting is done by L<infix|https://github.com/sanko/infix>, my JIT compiler and type introspection
engine.

=head1 AUTHOR

Sanko Robinson E<lt>sanko@cpan.orgE<gt>

=head1 COPYRIGHT

Copyright (C) 2023-2026 by Sanko Robinson.

This library is free software; you can redistribute it and/or modify it under the terms of the Artistic License 2.0.

=cut
