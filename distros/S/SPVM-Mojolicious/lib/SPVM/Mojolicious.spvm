# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious {
  version "0.041";
  
  use Mojo::Home;
  use Mojo::Loader;
  use Mojo::Log;
  use Mojo::Server;
  use Mojo::Util;
  use Mojolicious::Controller;
  use Mojolicious::Plugins;
  use Mojolicious::Renderer;
  use Mojolicious::Routes;
  use Mojolicious::Sessions;
  use Mojolicious::Static;
  use Mojolicious::Types;
  use Mojo::Transaction;
  use Sys;
  use Mojolicious::Helper::Reply;
  use Mojolicious::Commands;
  use Mojo::File;
  use FindBin;
  use Mojolicious::Plugin;
  use Mojo::UserAgent;
  
  # Fields
  has home : rw Mojo::Home;
  
  has log  : rw Mojo::Log;
  
  has mode : rw string;
  
  has moniker : rw string;
  
  has max_request_size : rw int;
  
  has plugins : rw Mojolicious::Plugins;
  
  has commands : rw Mojolicious::Commands;
  
  has renderer : rw Mojolicious::Renderer;
  
  has routes : rw Mojolicious::Routes;
  
  has secrets : rw string[]
    get {
      unless (exists $self->{secrets}) {
        # Warn developers about insecure default
        $self->log->trace("Your secret passphrase needs to be changed (see FAQ for more)");
        
        # Default to moniker
        return [$self->moniker];
      }
      return $self->{secrets};
    }
  ;
  
  has sessions : rw Mojolicious::Sessions;
  
  has static : rw Mojolicious::Static;
  
  has types : rw Mojolicious::Types;
  
  has config_h : rw Hash;
  
  has defaults_h : rw Hash;
  
  has data_templates : virtual rw string
    get {
      return $self->renderer->data_templates;
    }
    set {
      $self->renderer->set_data_templates($_);
    }
  ;
  
  has ua : rw Mojo::UserAgent;
  
  has exception_format : rw string; 

  # Class Methods
  static method new : Mojolicious () {
    
    my $self = new Mojolicious;
    
    $self->init;
    
    return $self;
  }
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    my $home = Mojo::Home->new;
    $home->detect;
    $self->{home} = $home;
    
    $self->{types} = Mojolicious::Types->new;
    
    $self->{renderer} = Mojolicious::Renderer->new;
    
    $self->{renderer} = Mojolicious::Renderer->new;
    my $renderer_paths = $self->renderer->paths;
    StringList->new_ref($renderer_paths)->push($home->child("templates")->to_string);
    
    $self->{static} = Mojolicious::Static->new;
    my $static_paths = $self->static->paths;
    StringList->new_ref($static_paths)->push($home->child("public")->to_string);
    
    $self->{sessions} = Mojolicious::Sessions->new;
    
    $self->{routes} = Mojolicious::Routes->new;
    
    $self->{commands} = Mojolicious::Commands->new;
    
    $self->{plugins} = Mojolicious::Plugins->new;
    
    $self->{mode} = length (my $_ = Sys->env("SPVM_MOJO_MODE")) ? $_ : "development";
    
    my $log = Mojo::Log->new;
    $log->set_level(length (my $_ = Sys->env("SPVM_MOJO_LOG_LEVEL")) ? $_ : "info");
    $self->{log} = $log;
    
    my $exe = FindBin->Script;
    
    my $moniker = Mojo::File->path($exe)->basename;
    
    Re->s((mutable string)$moniker, "\.(spvm|t)$", "");
    
    $self->set_moniker($moniker);
    
    $self->{defaults_h} = Hash->new;
    
    $self->{config_h} = Hash->new;
    
    $self->{ua} = Mojo::UserAgent->new;
    
    $self->{exception_format} = "html";
  }
  
  method build_controller : Mojolicious::Controller ($tx : Mojo::Transaction) {
    
    unless ($tx) {
      die "The transaction \$tx must be defined.";
    }
    
    # Build default controller
    my $defaults = $self->defaults_h;
    
    my $stash = $defaults->clone;
    
    my $c = Mojolicious::Controller->new;
    $c->set_app($self);
    $c->set_tx($tx);
    $c->set_stash_h($stash);
    
    return $c;
  }
  
  method dispatch : void ($c : Mojolicious::Controller) {
    
    # Try to find a static file
    my $tx = $c->tx;
    unless ($tx->res->code >= 0) {
      $self->static->dispatch($c);
    }
    
    # Routes
    unless ($tx->res->code) {
      my $continue = $self->routes->dispatch($c);
      
      unless ($continue) {
        unless ($tx->res->code) {
          $c->reply->not_found;
        }
      }
    }
  }
  
  method hook : void ($name : string, $cb : Mojo::Callback)  {
    
    $self->plugins->on($name, $cb);
  }
  
  method plugin : void ($plugin : Mojolicious::Plugin, $options : object[] = undef) {
    $self->plugins->register_plugin($plugin, $self, $options);
  }
  
  method handler : void ($tx : Mojo::Transaction) {
    
    # Process with chain
    my $c = $self->build_controller($tx);
    $self->dispatch($c);
  }
  
  method start : void ($argv : string[] = undef) {
    
    unless ($argv) {
      $argv = CommandInfo->ARGV;
    }
    
    $self->commands->set_app($self);
    
    $self->commands->run($argv);
  }
  
  method server : void ($server : Mojo::Server) {
    $self->plugins->emit_hook(before_server_start => $server, $self);
  }
  
  method build_tx : Mojo::Transaction::HTTP () {
    
    my $tx  = Mojo::Transaction::HTTP->new;
    
    if (exists $self->{max_request_size}) {
      my $max = $self->max_request_size;
      $tx->req->set_max_message_size($max);
    }
    
    $self->plugins->emit_hook(after_build_tx => $tx, $self);
    
    return $tx;
  }

  method defaults : object ($name : string) {
    return $self->{defaults_h}{$name};
  }
  
  method set_defaults : void ($name : string, $value : object) {
    
    $self->{defaults_h}{$name} = $value;
  }
  
  method config : object ($name : string) {
    return $self->{config_h}{$name};
  }
  
  method set_config : void ($name : string, $value : object) {
    $self->{config_h}{$name} = $value;
  }
  
}
