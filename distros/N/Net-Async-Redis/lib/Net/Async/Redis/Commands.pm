package Net::Async::Redis::Commands;

use Full::Role qw(:v1);

our $VERSION = '6.001'; # VERSION

=head1 NAME

Net::Async::Redis::Commands - mixin that defines the Redis commands available

=head1 DESCRIPTION

This is autogenerated from the list of commands available in L<https://redis.io/commands>.

It is intended to be loaded by L<Net::Async::Redis> to provide methods
for each available Redis command.

=cut

=head1 PACKAGE VARIABLES

=head2 KEY_FINDER

This maps the argument index for the C<key> information in each command.

=cut

our %KEY_FINDER = (
    'APPEND' => 1,
    'BITCOUNT' => 1,
    'BITFIELD' => 1,
    'BITFIELD RO' => 2,
    'BITFIELD_RO' => 1,
    'BITOP' => 3,
    'BITPOS' => 1,
    'BLMPOP' => 3,
    'BLPOP' => 1,
    'BRPOP' => 1,
    'BZMPOP' => 3,
    'BZPOPMAX' => 1,
    'BZPOPMIN' => 1,
    'CLUSTER' => 3,
    'CLUSTER KEYSLOT' => 2,
    'DECR' => 1,
    'DECRBY' => 1,
    'DEL' => 1,
    'DUMP' => 1,
    'EVAL' => 3,
    'EVAL RO' => 4,
    'EVAL_RO' => 3,
    'EVALSHA' => 3,
    'EVALSHA RO' => 4,
    'EVALSHA_RO' => 3,
    'EXISTS' => 1,
    'EXPIRE' => 1,
    'EXPIREAT' => 1,
    'EXPIRETIME' => 1,
    'FCALL' => 3,
    'FCALL RO' => 4,
    'FCALL_RO' => 3,
    'GEOADD' => 1,
    'GEODIST' => 1,
    'GEOHASH' => 1,
    'GEOPOS' => 1,
    'GEORADIUS' => 1,
    'GEORADIUS RO' => 2,
    'GEORADIUS_RO' => 1,
    'GEORADIUSBYMEMBER' => 1,
    'GEORADIUSBYMEMBER RO' => 2,
    'GEORADIUSBYMEMBER_RO' => 1,
    'GEOSEARCH' => 1,
    'GET' => 1,
    'GETBIT' => 1,
    'GETDEL' => 1,
    'GETEX' => 1,
    'GETRANGE' => 1,
    'GETSET' => 1,
    'HDEL' => 1,
    'HEXISTS' => 1,
    'HGET' => 1,
    'HGETALL' => 1,
    'HINCRBY' => 1,
    'HINCRBYFLOAT' => 1,
    'HKEYS' => 1,
    'HLEN' => 1,
    'HMGET' => 1,
    'HMSET' => 1,
    'HRANDFIELD' => 1,
    'HSCAN' => 1,
    'HSET' => 1,
    'HSETNX' => 1,
    'HSTRLEN' => 1,
    'HVALS' => 1,
    'INCR' => 1,
    'INCRBY' => 1,
    'INCRBYFLOAT' => 1,
    'LINDEX' => 1,
    'LINSERT' => 1,
    'LLEN' => 1,
    'LMPOP' => 2,
    'LPOP' => 1,
    'LPOS' => 1,
    'LPUSH' => 1,
    'LPUSHX' => 1,
    'LRANGE' => 1,
    'LREM' => 1,
    'LSET' => 1,
    'LTRIM' => 1,
    'MEMORY' => 3,
    'MEMORY USAGE' => 2,
    'MGET' => 1,
    'MIGRATE' => 3,
    'MOVE' => 1,
    'MSET' => 1,
    'MSETNX' => 1,
    'OBJECT' => 3,
    'OBJECT ENCODING' => 2,
    'OBJECT FREQ' => 2,
    'OBJECT IDLETIME' => 2,
    'OBJECT REFCOUNT' => 2,
    'PERSIST' => 1,
    'PEXPIRE' => 1,
    'PEXPIREAT' => 1,
    'PEXPIRETIME' => 1,
    'PFADD' => 1,
    'PFCOUNT' => 1,
    'PSETEX' => 1,
    'PSUBSCRIBE' => 1,
    'PTTL' => 1,
    'PUBLISH' => 1,
    'RENAME' => 1,
    'RENAMENX' => 1,
    'RESTORE' => 1,
    'RPOP' => 1,
    'RPUSH' => 1,
    'RPUSHX' => 1,
    'SADD' => 1,
    'SCARD' => 1,
    'SDIFF' => 1,
    'SDIFFSTORE' => 2,
    'SET' => 1,
    'SETBIT' => 1,
    'SETEX' => 1,
    'SETNX' => 1,
    'SETRANGE' => 1,
    'SINTER' => 1,
    'SINTERCARD' => 2,
    'SINTERSTORE' => 2,
    'SISMEMBER' => 1,
    'SMEMBERS' => 1,
    'SMISMEMBER' => 1,
    'SORT' => 1,
    'SORT RO' => 2,
    'SORT_RO' => 1,
    'SPOP' => 1,
    'SRANDMEMBER' => 1,
    'SREM' => 1,
    'SSCAN' => 1,
    'STRLEN' => 1,
    'SUBSCRIBE' => 1,
    'SUBSTR' => 1,
    'SUNION' => 1,
    'SUNIONSTORE' => 2,
    'TOUCH' => 1,
    'TTL' => 1,
    'TYPE' => 1,
    'UNLINK' => 1,
    'WATCH' => 1,
    'XACK' => 1,
    'XADD' => 1,
    'XAUTOCLAIM' => 1,
    'XCLAIM' => 1,
    'XDEL' => 1,
    'XGROUP' => 2,
    'XGROUP CREATE' => 2,
    'XGROUP CREATECONSUMER' => 2,
    'XGROUP DELCONSUMER' => 2,
    'XGROUP DESTROY' => 2,
    'XGROUP SETID' => 2,
    'XINFO' => 2,
    'XINFO CONSUMERS' => 2,
    'XINFO GROUPS' => 2,
    'XINFO STREAM' => 2,
    'XLEN' => 1,
    'XPENDING' => 1,
    'XRANGE' => 1,
    'XREAD' => 3,
    'XREADGROUP' => 5,
    'XREVRANGE' => 1,
    'XSETID' => 1,
    'XTRIM' => 1,
    'ZADD' => 1,
    'ZCARD' => 1,
    'ZCOUNT' => 1,
    'ZDIFF' => 2,
    'ZDIFFSTORE' => 3,
    'ZINCRBY' => 1,
    'ZINTER' => 2,
    'ZINTERCARD' => 2,
    'ZINTERSTORE' => 3,
    'ZLEXCOUNT' => 1,
    'ZMPOP' => 2,
    'ZMSCORE' => 1,
    'ZPOPMAX' => 1,
    'ZPOPMIN' => 1,
    'ZRANDMEMBER' => 1,
    'ZRANGE' => 1,
    'ZRANGEBYLEX' => 1,
    'ZRANGEBYSCORE' => 1,
    'ZRANK' => 1,
    'ZREM' => 1,
    'ZREMRANGEBYLEX' => 1,
    'ZREMRANGEBYRANK' => 1,
    'ZREMRANGEBYSCORE' => 1,
    'ZREVRANGE' => 1,
    'ZREVRANGEBYLEX' => 1,
    'ZREVRANGEBYSCORE' => 1,
    'ZREVRANK' => 1,
    'ZSCAN' => 1,
    'ZSCORE' => 1,
    'ZUNION' => 2,
    'ZUNIONSTORE' => 3,
);

=head1 METHODS - Bitmap

=head2 bitcount

Count set bits in a string.

=over 4

=item * key

=item * [start end [BYTE|BIT]]

=back

L<https://redis.io/commands/bitcount>

=cut

method bitcount (@args) {
    $self->execute_command(qw(BITCOUNT) => @args)
}

=head2 bitfield

Perform arbitrary bitfield integer operations on strings.

=over 4

=item * key

=item * [GET encoding offset]

=item * [SET encoding offset value]

=item * [INCRBY encoding offset increment]

=item * [OVERFLOW WRAP|SAT|FAIL]

=back

L<https://redis.io/commands/bitfield>

=cut

method bitfield (@args) {
    $self->execute_command(qw(BITFIELD) => @args)
}

=head2 bitfield_ro

Perform arbitrary bitfield integer operations on strings. Read-only variant of BITFIELD.

=over 4

=item * key

=item * GET encoding offset

=back

L<https://redis.io/commands/bitfield-ro>

=cut

method bitfield_ro (@args) {
    $self->execute_command(qw(BITFIELD_RO) => @args)
}

=head2 bitop

Perform bitwise operations between strings.

=over 4

=item * operation

=item * destkey

=item * key [key ...]

=back

L<https://redis.io/commands/bitop>

=cut

method bitop (@args) {
    $self->execute_command(qw(BITOP) => @args)
}

=head2 bitpos

Find first bit set or clear in a string.

=over 4

=item * key

=item * bit

=item * [start [end [BYTE|BIT]]]

=back

L<https://redis.io/commands/bitpos>

=cut

method bitpos (@args) {
    $self->execute_command(qw(BITPOS) => @args)
}

=head2 getbit

Returns the bit value at offset in the string value stored at key.

=over 4

=item * key

=item * offset

=back

L<https://redis.io/commands/getbit>

=cut

method getbit (@args) {
    $self->execute_command(qw(GETBIT) => @args)
}

=head2 setbit

Sets or clears the bit at offset in the string value stored at key.

=over 4

=item * key

=item * offset

=item * value

=back

L<https://redis.io/commands/setbit>

=cut

method setbit (@args) {
    $self->execute_command(qw(SETBIT) => @args)
}

=head1 METHODS - Cluster

=head2 asking

Sent by cluster clients after an -ASK redirect.

L<https://redis.io/commands/asking>

=cut

method asking (@args) {
    $self->execute_command(qw(ASKING) => @args)
}

=head2 cluster_addslots

Assign new hash slots to receiving node.

=over 4

=item * slot [slot ...]

=back

L<https://redis.io/commands/cluster-addslots>

=cut

method cluster_addslots (@args) {
    $self->execute_command(qw(CLUSTER ADDSLOTS) => @args)
}

=head2 cluster_addslotsrange

Assign new hash slots to receiving node.

=over 4

=item * start-slot end-slot [start-slot end-slot ...]

=back

L<https://redis.io/commands/cluster-addslotsrange>

=cut

method cluster_addslotsrange (@args) {
    $self->execute_command(qw(CLUSTER ADDSLOTSRANGE) => @args)
}

=head2 cluster_bumpepoch

Advance the cluster config epoch.

L<https://redis.io/commands/cluster-bumpepoch>

=cut

method cluster_bumpepoch (@args) {
    $self->execute_command(qw(CLUSTER BUMPEPOCH) => @args)
}

=head2 cluster_count_failure_reports

Return the number of failure reports active for a given node.

=over 4

=item * node-id

=back

L<https://redis.io/commands/cluster-count-failure-reports>

=cut

method cluster_count_failure_reports (@args) {
    $self->execute_command(qw(CLUSTER COUNT-FAILURE-REPORTS) => @args)
}

=head2 cluster_countkeysinslot

Return the number of local keys in the specified hash slot.

=over 4

=item * slot

=back

L<https://redis.io/commands/cluster-countkeysinslot>

=cut

method cluster_countkeysinslot (@args) {
    $self->execute_command(qw(CLUSTER COUNTKEYSINSLOT) => @args)
}

=head2 cluster_delslots

Set hash slots as unbound in receiving node.

=over 4

=item * slot [slot ...]

=back

L<https://redis.io/commands/cluster-delslots>

=cut

method cluster_delslots (@args) {
    $self->execute_command(qw(CLUSTER DELSLOTS) => @args)
}

=head2 cluster_delslotsrange

Set hash slots as unbound in receiving node.

=over 4

=item * start-slot end-slot [start-slot end-slot ...]

=back

L<https://redis.io/commands/cluster-delslotsrange>

=cut

method cluster_delslotsrange (@args) {
    $self->execute_command(qw(CLUSTER DELSLOTSRANGE) => @args)
}

=head2 cluster_failover

Forces a replica to perform a manual failover of its master.

=over 4

=item * [FORCE|TAKEOVER]

=back

L<https://redis.io/commands/cluster-failover>

=cut

method cluster_failover (@args) {
    $self->execute_command(qw(CLUSTER FAILOVER) => @args)
}

=head2 cluster_flushslots

Delete a node's own slots information.

L<https://redis.io/commands/cluster-flushslots>

=cut

method cluster_flushslots (@args) {
    $self->execute_command(qw(CLUSTER FLUSHSLOTS) => @args)
}

=head2 cluster_forget

Remove a node from the nodes table.

=over 4

=item * node-id

=back

L<https://redis.io/commands/cluster-forget>

=cut

method cluster_forget (@args) {
    $self->execute_command(qw(CLUSTER FORGET) => @args)
}

=head2 cluster_getkeysinslot

Return local key names in the specified hash slot.

=over 4

=item * slot

=item * count

=back

L<https://redis.io/commands/cluster-getkeysinslot>

=cut

method cluster_getkeysinslot (@args) {
    $self->execute_command(qw(CLUSTER GETKEYSINSLOT) => @args)
}

=head2 cluster_info

Provides info about Redis Cluster node state.

L<https://redis.io/commands/cluster-info>

=cut

method cluster_info (@args) {
    $self->execute_command(qw(CLUSTER INFO) => @args)
}

=head2 cluster_keyslot

Returns the hash slot of the specified key.

=over 4

=item * key

=back

L<https://redis.io/commands/cluster-keyslot>

=cut

method cluster_keyslot (@args) {
    $self->execute_command(qw(CLUSTER KEYSLOT) => @args)
}

=head2 cluster_links

Returns a list of all TCP links to and from peer nodes in cluster.

L<https://redis.io/commands/cluster-links>

=cut

method cluster_links (@args) {
    $self->execute_command(qw(CLUSTER LINKS) => @args)
}

=head2 cluster_meet

Force a node cluster to handshake with another node.

=over 4

=item * ip

=item * port

=back

L<https://redis.io/commands/cluster-meet>

=cut

method cluster_meet (@args) {
    $self->execute_command(qw(CLUSTER MEET) => @args)
}

=head2 cluster_myid

Return the node id.

L<https://redis.io/commands/cluster-myid>

=cut

method cluster_myid (@args) {
    $self->execute_command(qw(CLUSTER MYID) => @args)
}

=head2 cluster_nodes

Get Cluster config for the node.

L<https://redis.io/commands/cluster-nodes>

=cut

method cluster_nodes (@args) {
    $self->execute_command(qw(CLUSTER NODES) => @args)
}

=head2 cluster_replicas

List replica nodes of the specified master node.

=over 4

=item * node-id

=back

L<https://redis.io/commands/cluster-replicas>

=cut

method cluster_replicas (@args) {
    $self->execute_command(qw(CLUSTER REPLICAS) => @args)
}

=head2 cluster_replicate

Reconfigure a node as a replica of the specified master node.

=over 4

=item * node-id

=back

L<https://redis.io/commands/cluster-replicate>

=cut

method cluster_replicate (@args) {
    $self->execute_command(qw(CLUSTER REPLICATE) => @args)
}

=head2 cluster_reset

Reset a Redis Cluster node.

=over 4

=item * [HARD|SOFT]

=back

L<https://redis.io/commands/cluster-reset>

=cut

method cluster_reset (@args) {
    $self->execute_command(qw(CLUSTER RESET) => @args)
}

=head2 cluster_saveconfig

Forces the node to save cluster state on disk.

L<https://redis.io/commands/cluster-saveconfig>

=cut

method cluster_saveconfig (@args) {
    $self->execute_command(qw(CLUSTER SAVECONFIG) => @args)
}

=head2 cluster_set_config_epoch

Set the configuration epoch in a new node.

=over 4

=item * config-epoch

=back

L<https://redis.io/commands/cluster-set-config-epoch>

=cut

method cluster_set_config_epoch (@args) {
    $self->execute_command(qw(CLUSTER SET-CONFIG-EPOCH) => @args)
}

=head2 cluster_setslot

Bind a hash slot to a specific node.

=over 4

=item * slot

=item * IMPORTING node-id|MIGRATING node-id|NODE node-id|STABLE

=back

L<https://redis.io/commands/cluster-setslot>

=cut

method cluster_setslot (@args) {
    $self->execute_command(qw(CLUSTER SETSLOT) => @args)
}

=head2 cluster_slaves

List replica nodes of the specified master node.

=over 4

=item * node-id

=back

L<https://redis.io/commands/cluster-slaves>

=cut

method cluster_slaves (@args) {
    $self->execute_command(qw(CLUSTER SLAVES) => @args)
}

=head2 cluster_slots

Get array of Cluster slot to node mappings.

L<https://redis.io/commands/cluster-slots>

=cut

method cluster_slots (@args) {
    $self->execute_command(qw(CLUSTER SLOTS) => @args)
}

=head2 readonly

Enables read queries for a connection to a cluster replica node.

L<https://redis.io/commands/readonly>

=cut

method readonly (@args) {
    $self->execute_command(qw(READONLY) => @args)
}

=head2 readwrite

Disables read queries for a connection to a cluster replica node.

L<https://redis.io/commands/readwrite>

=cut

method readwrite (@args) {
    $self->execute_command(qw(READWRITE) => @args)
}

=head1 METHODS - Connection

=head2 auth

Authenticate to the server.

=over 4

=item * [username]

=item * password

=back

L<https://redis.io/commands/auth>

=cut

method auth (@args) {
    $self->execute_command(qw(AUTH) => @args)
}

=head2 client_caching

Instruct the server about tracking or not keys in the next request.

=over 4

=item * YES|NO

=back

L<https://redis.io/commands/client-caching>

=cut

method client_caching (@args) {
    $self->execute_command(qw(CLIENT CACHING) => @args)
}

=head2 client_getname

Get the current connection name.

L<https://redis.io/commands/client-getname>

=cut

method client_getname (@args) {
    $self->execute_command(qw(CLIENT GETNAME) => @args)
}

=head2 client_getredir

Get tracking notifications redirection client ID if any.

L<https://redis.io/commands/client-getredir>

=cut

method client_getredir (@args) {
    $self->execute_command(qw(CLIENT GETREDIR) => @args)
}

=head2 client_id

Returns the client ID for the current connection.

L<https://redis.io/commands/client-id>

=cut

method client_id (@args) {
    $self->execute_command(qw(CLIENT ID) => @args)
}

=head2 client_info

Returns information about the current client connection.

L<https://redis.io/commands/client-info>

=cut

method client_info (@args) {
    $self->execute_command(qw(CLIENT INFO) => @args)
}

=head2 client_kill

Kill the connection of a client.

=over 4

=item * [ip:port]

=item * [ID client-id]

=item * [TYPE NORMAL|MASTER|SLAVE|REPLICA|PUBSUB]

=item * [USER username]

=item * [ADDR ip:port]

=item * [LADDR ip:port]

=item * [SKIPME yes/no]

=back

L<https://redis.io/commands/client-kill>

=cut

method client_kill (@args) {
    $self->execute_command(qw(CLIENT KILL) => @args)
}

=head2 client_list

Get the list of client connections.

=over 4

=item * [TYPE NORMAL|MASTER|REPLICA|PUBSUB]

=item * [ID client-id [client-id ...]]

=back

L<https://redis.io/commands/client-list>

=cut

method client_list (@args) {
    $self->execute_command(qw(CLIENT LIST) => @args)
}

=head2 client_no_evict

Set client eviction mode for the current connection.

=over 4

=item * ON|OFF

=back

L<https://redis.io/commands/client-no-evict>

=cut

method client_no_evict (@args) {
    $self->execute_command(qw(CLIENT NO-EVICT) => @args)
}

=head2 client_pause

Stop processing commands from clients for some time.

=over 4

=item * timeout

=item * [WRITE|ALL]

=back

L<https://redis.io/commands/client-pause>

=cut

method client_pause (@args) {
    $self->execute_command(qw(CLIENT PAUSE) => @args)
}

=head2 client_reply

Instruct the server whether to reply to commands.

=over 4

=item * ON|OFF|SKIP

=back

L<https://redis.io/commands/client-reply>

=cut

method client_reply (@args) {
    $self->execute_command(qw(CLIENT REPLY) => @args)
}

=head2 client_setname

Set the current connection name.

=over 4

=item * connection-name

=back

L<https://redis.io/commands/client-setname>

=cut

method client_setname (@args) {
    $self->execute_command(qw(CLIENT SETNAME) => @args)
}

=head2 client_tracking

Enable or disable server assisted client side caching support.

=over 4

=item * ON|OFF

=item * [REDIRECT client-id]

=item * [PREFIX prefix [PREFIX prefix ...]]

=item * [BCAST]

=item * [OPTIN]

=item * [OPTOUT]

=item * [NOLOOP]

=back

L<https://redis.io/commands/client-tracking>

=cut

method client_tracking (@args) {
    $self->execute_command(qw(CLIENT TRACKING) => @args)
}

=head2 client_trackinginfo

Return information about server assisted client side caching for the current connection.

L<https://redis.io/commands/client-trackinginfo>

=cut

method client_trackinginfo (@args) {
    $self->execute_command(qw(CLIENT TRACKINGINFO) => @args)
}

=head2 client_unblock

Unblock a client blocked in a blocking command from a different connection.

=over 4

=item * client-id

=item * [TIMEOUT|ERROR]

=back

L<https://redis.io/commands/client-unblock>

=cut

method client_unblock (@args) {
    $self->execute_command(qw(CLIENT UNBLOCK) => @args)
}

=head2 client_unpause

Resume processing of clients that were paused.

L<https://redis.io/commands/client-unpause>

=cut

method client_unpause (@args) {
    $self->execute_command(qw(CLIENT UNPAUSE) => @args)
}

=head2 echo

Echo the given string.

=over 4

=item * message

=back

L<https://redis.io/commands/echo>

=cut

method echo (@args) {
    $self->execute_command(qw(ECHO) => @args)
}

=head2 hello

Handshake with Redis.

=over 4

=item * [protover [AUTH username password] [SETNAME clientname]]

=back

L<https://redis.io/commands/hello>

=cut

method hello (@args) {
    $self->execute_command(qw(HELLO) => @args)
}

=head2 ping

Ping the server.

=over 4

=item * [message]

=back

L<https://redis.io/commands/ping>

=cut

method ping (@args) {
    $self->execute_command(qw(PING) => @args)
}

=head2 quit

Close the connection.

L<https://redis.io/commands/quit>

=cut

method quit (@args) {
    $self->execute_command(qw(QUIT) => @args)
}

=head2 reset

Reset the connection.

L<https://redis.io/commands/reset>

=cut

method reset (@args) {
    $self->execute_command(qw(RESET) => @args)
}

=head2 select

Change the selected database for the current connection.

=over 4

=item * index

=back

L<https://redis.io/commands/select>

=cut

method select (@args) {
    $self->execute_command(qw(SELECT) => @args)
}

=head1 METHODS - Generic

=head2 copy

Copy a key.

=over 4

=item * source

=item * destination

=item * [DB destination-db]

=item * [REPLACE]

=back

L<https://redis.io/commands/copy>

=cut

method copy (@args) {
    $self->execute_command(qw(COPY) => @args)
}

=head2 del

Delete a key.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/del>

=cut

method del (@args) {
    $self->execute_command(qw(DEL) => @args)
}

=head2 dump

Return a serialized version of the value stored at the specified key.

=over 4

=item * key

=back

L<https://redis.io/commands/dump>

=cut

method dump (@args) {
    $self->execute_command(qw(DUMP) => @args)
}

=head2 exists

Determine if a key exists.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/exists>

=cut

method exists (@args) {
    $self->execute_command(qw(EXISTS) => @args)
}

=head2 expire

Set a key's time to live in seconds.

=over 4

=item * key

=item * seconds

=item * [NX|XX|GT|LT]

=back

L<https://redis.io/commands/expire>

=cut

method expire (@args) {
    $self->execute_command(qw(EXPIRE) => @args)
}

=head2 expireat

Set the expiration for a key as a UNIX timestamp.

=over 4

=item * key

=item * unix-time-seconds

=item * [NX|XX|GT|LT]

=back

L<https://redis.io/commands/expireat>

=cut

method expireat (@args) {
    $self->execute_command(qw(EXPIREAT) => @args)
}

=head2 expiretime

Get the expiration Unix timestamp for a key.

=over 4

=item * key

=back

L<https://redis.io/commands/expiretime>

=cut

method expiretime (@args) {
    $self->execute_command(qw(EXPIRETIME) => @args)
}

=head2 keys

Find all keys matching the given pattern.

=over 4

=item * pattern

=back

L<https://redis.io/commands/keys>

=cut

# method keys (@args) {
#     $self->execute_command(qw(KEYS) => @args)
# }

=head2 migrate

Atomically transfer a key from a Redis instance to another one.

=over 4

=item * host

=item * port

=item * key|""

=item * destination-db

=item * timeout

=item * [COPY]

=item * [REPLACE]

=item * [AUTH password]

=item * [AUTH2 username password]

=item * [KEYS key [key ...]]

=back

L<https://redis.io/commands/migrate>

=cut

method migrate (@args) {
    $self->execute_command(qw(MIGRATE) => @args)
}

=head2 move

Move a key to another database.

=over 4

=item * key

=item * db

=back

L<https://redis.io/commands/move>

=cut

method move (@args) {
    $self->execute_command(qw(MOVE) => @args)
}

=head2 object_encoding

Inspect the internal encoding of a Redis object.

=over 4

=item * key

=back

L<https://redis.io/commands/object-encoding>

=cut

method object_encoding (@args) {
    $self->execute_command(qw(OBJECT ENCODING) => @args)
}

=head2 object_freq

Get the logarithmic access frequency counter of a Redis object.

=over 4

=item * key

=back

L<https://redis.io/commands/object-freq>

=cut

method object_freq (@args) {
    $self->execute_command(qw(OBJECT FREQ) => @args)
}

=head2 object_idletime

Get the time since a Redis object was last accessed.

=over 4

=item * key

=back

L<https://redis.io/commands/object-idletime>

=cut

method object_idletime (@args) {
    $self->execute_command(qw(OBJECT IDLETIME) => @args)
}

=head2 object_refcount

Get the number of references to the value of the key.

=over 4

=item * key

=back

L<https://redis.io/commands/object-refcount>

=cut

method object_refcount (@args) {
    $self->execute_command(qw(OBJECT REFCOUNT) => @args)
}

=head2 persist

Remove the expiration from a key.

=over 4

=item * key

=back

L<https://redis.io/commands/persist>

=cut

method persist (@args) {
    $self->execute_command(qw(PERSIST) => @args)
}

=head2 pexpire

Set a key's time to live in milliseconds.

=over 4

=item * key

=item * milliseconds

=item * [NX|XX|GT|LT]

=back

L<https://redis.io/commands/pexpire>

=cut

method pexpire (@args) {
    $self->execute_command(qw(PEXPIRE) => @args)
}

=head2 pexpireat

Set the expiration for a key as a UNIX timestamp specified in milliseconds.

=over 4

=item * key

=item * unix-time-milliseconds

=item * [NX|XX|GT|LT]

=back

L<https://redis.io/commands/pexpireat>

=cut

method pexpireat (@args) {
    $self->execute_command(qw(PEXPIREAT) => @args)
}

=head2 pexpiretime

Get the expiration Unix timestamp for a key in milliseconds.

=over 4

=item * key

=back

L<https://redis.io/commands/pexpiretime>

=cut

method pexpiretime (@args) {
    $self->execute_command(qw(PEXPIRETIME) => @args)
}

=head2 pttl

Get the time to live for a key in milliseconds.

=over 4

=item * key

=back

L<https://redis.io/commands/pttl>

=cut

method pttl (@args) {
    $self->execute_command(qw(PTTL) => @args)
}

=head2 randomkey

Return a random key from the keyspace.

L<https://redis.io/commands/randomkey>

=cut

method randomkey (@args) {
    $self->execute_command(qw(RANDOMKEY) => @args)
}

=head2 rename

Rename a key.

=over 4

=item * key

=item * newkey

=back

L<https://redis.io/commands/rename>

=cut

method rename (@args) {
    $self->execute_command(qw(RENAME) => @args)
}

=head2 renamenx

Rename a key, only if the new key does not exist.

=over 4

=item * key

=item * newkey

=back

L<https://redis.io/commands/renamenx>

=cut

method renamenx (@args) {
    $self->execute_command(qw(RENAMENX) => @args)
}

=head2 restore

Create a key using the provided serialized value, previously obtained using DUMP.

=over 4

=item * key

=item * ttl

=item * serialized-value

=item * [REPLACE]

=item * [ABSTTL]

=item * [IDLETIME seconds]

=item * [FREQ frequency]

=back

L<https://redis.io/commands/restore>

=cut

method restore (@args) {
    $self->execute_command(qw(RESTORE) => @args)
}

=head2 scan

Incrementally iterate the keys space.

=over 4

=item * cursor

=item * [MATCH pattern]

=item * [COUNT count]

=item * [TYPE type]

=back

L<https://redis.io/commands/scan>

=cut

method scan (@args) {
    $self->execute_command(qw(SCAN) => @args)
}

=head2 sort

Sort the elements in a list, set or sorted set.

=over 4

=item * key

=item * [BY pattern]

=item * [LIMIT offset count]

=item * [GET pattern [GET pattern ...]]

=item * [ASC|DESC]

=item * [ALPHA]

=item * [STORE destination]

=back

L<https://redis.io/commands/sort>

=cut

method sort (@args) {
    $self->execute_command(qw(SORT) => @args)
}

=head2 sort_ro

Sort the elements in a list, set or sorted set. Read-only variant of SORT.

=over 4

=item * key

=item * [BY pattern]

=item * [LIMIT offset count]

=item * [GET pattern [GET pattern ...]]

=item * [ASC|DESC]

=item * [ALPHA]

=back

L<https://redis.io/commands/sort-ro>

=cut

method sort_ro (@args) {
    $self->execute_command(qw(SORT_RO) => @args)
}

=head2 touch

Alters the last access time of a key(s). Returns the number of existing keys specified.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/touch>

=cut

method touch (@args) {
    $self->execute_command(qw(TOUCH) => @args)
}

=head2 ttl

Get the time to live for a key in seconds.

=over 4

=item * key

=back

L<https://redis.io/commands/ttl>

=cut

method ttl (@args) {
    $self->execute_command(qw(TTL) => @args)
}

=head2 type

Determine the type stored at key.

=over 4

=item * key

=back

L<https://redis.io/commands/type>

=cut

method type (@args) {
    $self->execute_command(qw(TYPE) => @args)
}

=head2 unlink

Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/unlink>

=cut

method unlink (@args) {
    $self->execute_command(qw(UNLINK) => @args)
}

=head2 wait

Wait for the synchronous replication of all the write commands sent in the context of the current connection.

=over 4

=item * numreplicas

=item * timeout

=back

L<https://redis.io/commands/wait>

=cut

method wait (@args) {
    $self->execute_command(qw(WAIT) => @args)
}

=head1 METHODS - Geo

=head2 geoadd

Add one or more geospatial items in the geospatial index represented using a sorted set.

=over 4

=item * key

=item * [NX|XX]

=item * [CH]

=item * longitude latitude member [longitude latitude member ...]

=back

L<https://redis.io/commands/geoadd>

=cut

method geoadd (@args) {
    $self->execute_command(qw(GEOADD) => @args)
}

=head2 geodist

Returns the distance between two members of a geospatial index.

=over 4

=item * key

=item * member1

=item * member2

=item * [M|KM|FT|MI]

=back

L<https://redis.io/commands/geodist>

=cut

method geodist (@args) {
    $self->execute_command(qw(GEODIST) => @args)
}

=head2 geohash

Returns members of a geospatial index as standard geohash strings.

=over 4

=item * key

=item * member [member ...]

=back

L<https://redis.io/commands/geohash>

=cut

method geohash (@args) {
    $self->execute_command(qw(GEOHASH) => @args)
}

=head2 geopos

Returns longitude and latitude of members of a geospatial index.

=over 4

=item * key

=item * member [member ...]

=back

L<https://redis.io/commands/geopos>

=cut

method geopos (@args) {
    $self->execute_command(qw(GEOPOS) => @args)
}

=head2 georadius

Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point.

=over 4

=item * key

=item * longitude

=item * latitude

=item * radius

=item * M|KM|FT|MI

=item * [WITHCOORD]

=item * [WITHDIST]

=item * [WITHHASH]

=item * [COUNT count [ANY]]

=item * [ASC|DESC]

=item * [STORE key]

=item * [STOREDIST key]

=back

L<https://redis.io/commands/georadius>

=cut

method georadius (@args) {
    $self->execute_command(qw(GEORADIUS) => @args)
}

=head2 georadius_ro

A read-only variant for GEORADIUS.

=over 4

=item * key

=item * longitude

=item * latitude

=item * radius

=item * M|KM|FT|MI

=item * [WITHCOORD]

=item * [WITHDIST]

=item * [WITHHASH]

=item * [COUNT count [ANY]]

=item * [ASC|DESC]

=back

L<https://redis.io/commands/georadius-ro>

=cut

method georadius_ro (@args) {
    $self->execute_command(qw(GEORADIUS_RO) => @args)
}

=head2 georadiusbymember

Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member.

=over 4

=item * key

=item * member

=item * radius

=item * M|KM|FT|MI

=item * [WITHCOORD]

=item * [WITHDIST]

=item * [WITHHASH]

=item * [COUNT count [ANY]]

=item * [ASC|DESC]

=item * [STORE key]

=item * [STOREDIST key]

=back

L<https://redis.io/commands/georadiusbymember>

=cut

method georadiusbymember (@args) {
    $self->execute_command(qw(GEORADIUSBYMEMBER) => @args)
}

=head2 georadiusbymember_ro

A read-only variant for GEORADIUSBYMEMBER.

=over 4

=item * key

=item * member

=item * radius

=item * M|KM|FT|MI

=item * [WITHCOORD]

=item * [WITHDIST]

=item * [WITHHASH]

=item * [COUNT count [ANY]]

=item * [ASC|DESC]

=back

L<https://redis.io/commands/georadiusbymember-ro>

=cut

method georadiusbymember_ro (@args) {
    $self->execute_command(qw(GEORADIUSBYMEMBER_RO) => @args)
}

=head2 geosearch

Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.

=over 4

=item * key

=item * [FROMMEMBER member]

=item * [FROMLONLAT longitude latitude]

=item * [BYRADIUS radius M|KM|FT|MI]

=item * [BYBOX width height M|KM|FT|MI]

=item * [ASC|DESC]

=item * [COUNT count [ANY]]

=item * [WITHCOORD]

=item * [WITHDIST]

=item * [WITHHASH]

=back

L<https://redis.io/commands/geosearch>

=cut

method geosearch (@args) {
    $self->execute_command(qw(GEOSEARCH) => @args)
}

=head2 geosearchstore

Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.

=over 4

=item * destination

=item * source

=item * [FROMMEMBER member]

=item * [FROMLONLAT longitude latitude]

=item * [BYRADIUS radius M|KM|FT|MI]

=item * [BYBOX width height M|KM|FT|MI]

=item * [ASC|DESC]

=item * [COUNT count [ANY]]

=item * [STOREDIST]

=back

L<https://redis.io/commands/geosearchstore>

=cut

method geosearchstore (@args) {
    $self->execute_command(qw(GEOSEARCHSTORE) => @args)
}

=head1 METHODS - Hash

=head2 hdel

Delete one or more hash fields.

=over 4

=item * key

=item * field [field ...]

=back

L<https://redis.io/commands/hdel>

=cut

method hdel (@args) {
    $self->execute_command(qw(HDEL) => @args)
}

=head2 hexists

Determine if a hash field exists.

=over 4

=item * key

=item * field

=back

L<https://redis.io/commands/hexists>

=cut

method hexists (@args) {
    $self->execute_command(qw(HEXISTS) => @args)
}

=head2 hget

Get the value of a hash field.

=over 4

=item * key

=item * field

=back

L<https://redis.io/commands/hget>

=cut

method hget (@args) {
    $self->execute_command(qw(HGET) => @args)
}

=head2 hgetall

Get all the fields and values in a hash.

=over 4

=item * key

=back

L<https://redis.io/commands/hgetall>

=cut

method hgetall (@args) {
    $self->execute_command(qw(HGETALL) => @args)
}

=head2 hincrby

Increment the integer value of a hash field by the given number.

=over 4

=item * key

=item * field

=item * increment

=back

L<https://redis.io/commands/hincrby>

=cut

method hincrby (@args) {
    $self->execute_command(qw(HINCRBY) => @args)
}

=head2 hincrbyfloat

Increment the float value of a hash field by the given amount.

=over 4

=item * key

=item * field

=item * increment

=back

L<https://redis.io/commands/hincrbyfloat>

=cut

method hincrbyfloat (@args) {
    $self->execute_command(qw(HINCRBYFLOAT) => @args)
}

=head2 hkeys

Get all the fields in a hash.

=over 4

=item * key

=back

L<https://redis.io/commands/hkeys>

=cut

method hkeys (@args) {
    $self->execute_command(qw(HKEYS) => @args)
}

=head2 hlen

Get the number of fields in a hash.

=over 4

=item * key

=back

L<https://redis.io/commands/hlen>

=cut

method hlen (@args) {
    $self->execute_command(qw(HLEN) => @args)
}

=head2 hmget

Get the values of all the given hash fields.

=over 4

=item * key

=item * field [field ...]

=back

L<https://redis.io/commands/hmget>

=cut

method hmget (@args) {
    $self->execute_command(qw(HMGET) => @args)
}

=head2 hmset

Set multiple hash fields to multiple values.

=over 4

=item * key

=item * field value [field value ...]

=back

L<https://redis.io/commands/hmset>

=cut

method hmset (@args) {
    $self->execute_command(qw(HMSET) => @args)
}

=head2 hrandfield

Get one or multiple random fields from a hash.

=over 4

=item * key

=item * [count [WITHVALUES]]

=back

L<https://redis.io/commands/hrandfield>

=cut

method hrandfield (@args) {
    $self->execute_command(qw(HRANDFIELD) => @args)
}

=head2 hscan

Incrementally iterate hash fields and associated values.

=over 4

=item * key

=item * cursor

=item * [MATCH pattern]

=item * [COUNT count]

=back

L<https://redis.io/commands/hscan>

=cut

method hscan (@args) {
    $self->execute_command(qw(HSCAN) => @args)
}

=head2 hset

Set the string value of a hash field.

=over 4

=item * key

=item * field value [field value ...]

=back

L<https://redis.io/commands/hset>

=cut

method hset (@args) {
    $self->execute_command(qw(HSET) => @args)
}

=head2 hsetnx

Set the value of a hash field, only if the field does not exist.

=over 4

=item * key

=item * field

=item * value

=back

L<https://redis.io/commands/hsetnx>

=cut

method hsetnx (@args) {
    $self->execute_command(qw(HSETNX) => @args)
}

=head2 hstrlen

Get the length of the value of a hash field.

=over 4

=item * key

=item * field

=back

L<https://redis.io/commands/hstrlen>

=cut

method hstrlen (@args) {
    $self->execute_command(qw(HSTRLEN) => @args)
}

=head2 hvals

Get all the values in a hash.

=over 4

=item * key

=back

L<https://redis.io/commands/hvals>

=cut

method hvals (@args) {
    $self->execute_command(qw(HVALS) => @args)
}

=head1 METHODS - Hyperloglog

=head2 pfadd

Adds the specified elements to the specified HyperLogLog.

=over 4

=item * key

=item * [element [element ...]]

=back

L<https://redis.io/commands/pfadd>

=cut

method pfadd (@args) {
    $self->execute_command(qw(PFADD) => @args)
}

=head2 pfcount

Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/pfcount>

=cut

method pfcount (@args) {
    $self->execute_command(qw(PFCOUNT) => @args)
}

=head2 pfdebug

Internal commands for debugging HyperLogLog values.

L<https://redis.io/commands/pfdebug>

=cut

method pfdebug (@args) {
    $self->execute_command(qw(PFDEBUG) => @args)
}

=head2 pfmerge

Merge N different HyperLogLogs into a single one.

=over 4

=item * destkey

=item * sourcekey [sourcekey ...]

=back

L<https://redis.io/commands/pfmerge>

=cut

method pfmerge (@args) {
    $self->execute_command(qw(PFMERGE) => @args)
}

=head2 pfselftest

An internal command for testing HyperLogLog values.

L<https://redis.io/commands/pfselftest>

=cut

method pfselftest (@args) {
    $self->execute_command(qw(PFSELFTEST) => @args)
}

=head1 METHODS - List

=head2 blmove

Pop an element from a list, push it to another list and return it; or block until one is available.

=over 4

=item * source

=item * destination

=item * LEFT|RIGHT

=item * LEFT|RIGHT

=item * timeout

=back

L<https://redis.io/commands/blmove>

=cut

method blmove (@args) {
    $self->execute_command(qw(BLMOVE) => @args)
}

=head2 blmpop

Pop elements from a list, or block until one is available.

=over 4

=item * timeout

=item * numkeys

=item * key [key ...]

=item * LEFT|RIGHT

=item * [COUNT count]

=back

L<https://redis.io/commands/blmpop>

=cut

method blmpop (@args) {
    $self->execute_command(qw(BLMPOP) => @args)
}

=head2 blpop

Remove and get the first element in a list, or block until one is available.

=over 4

=item * key [key ...]

=item * timeout

=back

L<https://redis.io/commands/blpop>

=cut

method blpop (@args) {
    $self->execute_command(qw(BLPOP) => @args)
}

=head2 brpop

Remove and get the last element in a list, or block until one is available.

=over 4

=item * key [key ...]

=item * timeout

=back

L<https://redis.io/commands/brpop>

=cut

method brpop (@args) {
    $self->execute_command(qw(BRPOP) => @args)
}

=head2 brpoplpush

Pop an element from a list, push it to another list and return it; or block until one is available.

=over 4

=item * source

=item * destination

=item * timeout

=back

L<https://redis.io/commands/brpoplpush>

=cut

method brpoplpush (@args) {
    $self->execute_command(qw(BRPOPLPUSH) => @args)
}

=head2 lindex

Get an element from a list by its index.

=over 4

=item * key

=item * index

=back

L<https://redis.io/commands/lindex>

=cut

method lindex (@args) {
    $self->execute_command(qw(LINDEX) => @args)
}

=head2 linsert

Insert an element before or after another element in a list.

=over 4

=item * key

=item * BEFORE|AFTER

=item * pivot

=item * element

=back

L<https://redis.io/commands/linsert>

=cut

method linsert (@args) {
    $self->execute_command(qw(LINSERT) => @args)
}

=head2 llen

Get the length of a list.

=over 4

=item * key

=back

L<https://redis.io/commands/llen>

=cut

method llen (@args) {
    $self->execute_command(qw(LLEN) => @args)
}

=head2 lmove

Pop an element from a list, push it to another list and return it.

=over 4

=item * source

=item * destination

=item * LEFT|RIGHT

=item * LEFT|RIGHT

=back

L<https://redis.io/commands/lmove>

=cut

method lmove (@args) {
    $self->execute_command(qw(LMOVE) => @args)
}

=head2 lmpop

Pop elements from a list.

=over 4

=item * numkeys

=item * key [key ...]

=item * LEFT|RIGHT

=item * [COUNT count]

=back

L<https://redis.io/commands/lmpop>

=cut

method lmpop (@args) {
    $self->execute_command(qw(LMPOP) => @args)
}

=head2 lpop

Remove and get the first elements in a list.

=over 4

=item * key

=item * [count]

=back

L<https://redis.io/commands/lpop>

=cut

method lpop (@args) {
    $self->execute_command(qw(LPOP) => @args)
}

=head2 lpos

Return the index of matching elements on a list.

=over 4

=item * key

=item * element

=item * [RANK rank]

=item * [COUNT num-matches]

=item * [MAXLEN len]

=back

L<https://redis.io/commands/lpos>

=cut

method lpos (@args) {
    $self->execute_command(qw(LPOS) => @args)
}

=head2 lpush

Prepend one or multiple elements to a list.

=over 4

=item * key

=item * element [element ...]

=back

L<https://redis.io/commands/lpush>

=cut

method lpush (@args) {
    $self->execute_command(qw(LPUSH) => @args)
}

=head2 lpushx

Prepend an element to a list, only if the list exists.

=over 4

=item * key

=item * element [element ...]

=back

L<https://redis.io/commands/lpushx>

=cut

method lpushx (@args) {
    $self->execute_command(qw(LPUSHX) => @args)
}

=head2 lrange

Get a range of elements from a list.

=over 4

=item * key

=item * start

=item * stop

=back

L<https://redis.io/commands/lrange>

=cut

method lrange (@args) {
    $self->execute_command(qw(LRANGE) => @args)
}

=head2 lrem

Remove elements from a list.

=over 4

=item * key

=item * count

=item * element

=back

L<https://redis.io/commands/lrem>

=cut

method lrem (@args) {
    $self->execute_command(qw(LREM) => @args)
}

=head2 lset

Set the value of an element in a list by its index.

=over 4

=item * key

=item * index

=item * element

=back

L<https://redis.io/commands/lset>

=cut

method lset (@args) {
    $self->execute_command(qw(LSET) => @args)
}

=head2 ltrim

Trim a list to the specified range.

=over 4

=item * key

=item * start

=item * stop

=back

L<https://redis.io/commands/ltrim>

=cut

method ltrim (@args) {
    $self->execute_command(qw(LTRIM) => @args)
}

=head2 rpop

Remove and get the last elements in a list.

=over 4

=item * key

=item * [count]

=back

L<https://redis.io/commands/rpop>

=cut

method rpop (@args) {
    $self->execute_command(qw(RPOP) => @args)
}

=head2 rpoplpush

Remove the last element in a list, prepend it to another list and return it.

=over 4

=item * source

=item * destination

=back

L<https://redis.io/commands/rpoplpush>

=cut

method rpoplpush (@args) {
    $self->execute_command(qw(RPOPLPUSH) => @args)
}

=head2 rpush

Append one or multiple elements to a list.

=over 4

=item * key

=item * element [element ...]

=back

L<https://redis.io/commands/rpush>

=cut

method rpush (@args) {
    $self->execute_command(qw(RPUSH) => @args)
}

=head2 rpushx

Append an element to a list, only if the list exists.

=over 4

=item * key

=item * element [element ...]

=back

L<https://redis.io/commands/rpushx>

=cut

method rpushx (@args) {
    $self->execute_command(qw(RPUSHX) => @args)
}

=head1 METHODS - Pubsub

=head2 psubscribe

Listen for messages published to channels matching the given patterns.

=over 4

=item * pattern [pattern ...]

=back

L<https://redis.io/commands/psubscribe>

=cut

# Currently left out until Object::Pad rÃ´les have support for overriding methods
# method psubscribe (@args) {
#     $self->execute_command(qw(PSUBSCRIBE) => @args)
# }

=head2 publish

Post a message to a channel.

=over 4

=item * channel

=item * message

=back

L<https://redis.io/commands/publish>

=cut

method publish (@args) {
    $self->execute_command(qw(PUBLISH) => @args)
}

=head2 pubsub_channels

List active channels.

=over 4

=item * [pattern]

=back

L<https://redis.io/commands/pubsub-channels>

=cut

method pubsub_channels (@args) {
    $self->execute_command(qw(PUBSUB CHANNELS) => @args)
}

=head2 pubsub_numpat

Get the count of unique patterns pattern subscriptions.

L<https://redis.io/commands/pubsub-numpat>

=cut

method pubsub_numpat (@args) {
    $self->execute_command(qw(PUBSUB NUMPAT) => @args)
}

=head2 pubsub_numsub

Get the count of subscribers for channels.

=over 4

=item * [channel [channel ...]]

=back

L<https://redis.io/commands/pubsub-numsub>

=cut

method pubsub_numsub (@args) {
    $self->execute_command(qw(PUBSUB NUMSUB) => @args)
}

=head2 pubsub_shardchannels

List active shard channels.

=over 4

=item * [pattern]

=back

L<https://redis.io/commands/pubsub-shardchannels>

=cut

method pubsub_shardchannels (@args) {
    $self->execute_command(qw(PUBSUB SHARDCHANNELS) => @args)
}

=head2 pubsub_shardnumsub

Get the count of subscribers for shard channels.

=over 4

=item * [channel [channel ...]]

=back

L<https://redis.io/commands/pubsub-shardnumsub>

=cut

method pubsub_shardnumsub (@args) {
    $self->execute_command(qw(PUBSUB SHARDNUMSUB) => @args)
}

=head2 punsubscribe

Stop listening for messages posted to channels matching the given patterns.

=over 4

=item * [pattern [pattern ...]]

=back

L<https://redis.io/commands/punsubscribe>

=cut

method punsubscribe (@args) {
    $self->execute_command(qw(PUNSUBSCRIBE) => @args)
}

=head2 spublish

Post a message to a shard channel.

=over 4

=item * channel

=item * message

=back

L<https://redis.io/commands/spublish>

=cut

method spublish (@args) {
    $self->execute_command(qw(SPUBLISH) => @args)
}

=head2 ssubscribe

Listen for messages published to the given shard channels.

=over 4

=item * channel [channel ...]

=back

L<https://redis.io/commands/ssubscribe>

=cut

# method ssubscribe (@args) {
#     $self->execute_command(qw(SSUBSCRIBE) => @args)
# }

=head2 subscribe

Listen for messages published to the given channels.

=over 4

=item * channel [channel ...]

=back

L<https://redis.io/commands/subscribe>

=cut

# method subscribe (@args) {
#     $self->execute_command(qw(SUBSCRIBE) => @args)
# }

=head2 sunsubscribe

Stop listening for messages posted to the given shard channels.

=over 4

=item * [channel [channel ...]]

=back

L<https://redis.io/commands/sunsubscribe>

=cut

method sunsubscribe (@args) {
    $self->execute_command(qw(SUNSUBSCRIBE) => @args)
}

=head2 unsubscribe

Stop listening for messages posted to the given channels.

=over 4

=item * [channel [channel ...]]

=back

L<https://redis.io/commands/unsubscribe>

=cut

method unsubscribe (@args) {
    $self->execute_command(qw(UNSUBSCRIBE) => @args)
}

=head1 METHODS - Scripting

=head2 eval

Execute a Lua script server side.

=over 4

=item * script

=item * numkeys

=item * [key [key ...]]

=item * [arg [arg ...]]

=back

L<https://redis.io/commands/eval>

=cut

method eval (@args) {
    $self->execute_command(qw(EVAL) => @args)
}

=head2 eval_ro

Execute a read-only Lua script server side.

=over 4

=item * script

=item * numkeys

=item * key [key ...]

=item * arg [arg ...]

=back

L<https://redis.io/commands/eval-ro>

=cut

method eval_ro (@args) {
    $self->execute_command(qw(EVAL_RO) => @args)
}

=head2 evalsha

Execute a Lua script server side.

=over 4

=item * sha1

=item * numkeys

=item * [key [key ...]]

=item * [arg [arg ...]]

=back

L<https://redis.io/commands/evalsha>

=cut

method evalsha (@args) {
    $self->execute_command(qw(EVALSHA) => @args)
}

=head2 evalsha_ro

Execute a read-only Lua script server side.

=over 4

=item * sha1

=item * numkeys

=item * key [key ...]

=item * arg [arg ...]

=back

L<https://redis.io/commands/evalsha-ro>

=cut

method evalsha_ro (@args) {
    $self->execute_command(qw(EVALSHA_RO) => @args)
}

=head2 fcall

Invoke a function.

=over 4

=item * function

=item * numkeys

=item * key [key ...]

=item * arg [arg ...]

=back

L<https://redis.io/commands/fcall>

=cut

method fcall (@args) {
    $self->execute_command(qw(FCALL) => @args)
}

=head2 fcall_ro

Invoke a read-only function.

=over 4

=item * function

=item * numkeys

=item * key [key ...]

=item * arg [arg ...]

=back

L<https://redis.io/commands/fcall-ro>

=cut

method fcall_ro (@args) {
    $self->execute_command(qw(FCALL_RO) => @args)
}

=head2 function_delete

Delete a function by name.

=over 4

=item * library-name

=back

L<https://redis.io/commands/function-delete>

=cut

method function_delete (@args) {
    $self->execute_command(qw(FUNCTION DELETE) => @args)
}

=head2 function_dump

Dump all functions into a serialized binary payload.

L<https://redis.io/commands/function-dump>

=cut

method function_dump (@args) {
    $self->execute_command(qw(FUNCTION DUMP) => @args)
}

=head2 function_flush

Deleting all functions.

=over 4

=item * [ASYNC|SYNC]

=back

L<https://redis.io/commands/function-flush>

=cut

method function_flush (@args) {
    $self->execute_command(qw(FUNCTION FLUSH) => @args)
}

=head2 function_kill

Kill the function currently in execution.

L<https://redis.io/commands/function-kill>

=cut

method function_kill (@args) {
    $self->execute_command(qw(FUNCTION KILL) => @args)
}

=head2 function_list

List information about all the functions.

=over 4

=item * [LIBRARYNAME library-name-pattern]

=item * [WITHCODE]

=back

L<https://redis.io/commands/function-list>

=cut

method function_list (@args) {
    $self->execute_command(qw(FUNCTION LIST) => @args)
}

=head2 function_load

Create a function with the given arguments (name, code, description).

=over 4

=item * engine-name

=item * library-name

=item * [REPLACE]

=item * [DESCRIPTION library-description]

=item * function-code

=back

L<https://redis.io/commands/function-load>

=cut

method function_load (@args) {
    $self->execute_command(qw(FUNCTION LOAD) => @args)
}

=head2 function_restore

Restore all the functions on the given payload.

=over 4

=item * serialized-value

=item * [FLUSH|APPEND|REPLACE]

=back

L<https://redis.io/commands/function-restore>

=cut

method function_restore (@args) {
    $self->execute_command(qw(FUNCTION RESTORE) => @args)
}

=head2 function_stats

Return information about the function currently running (name, description, duration).

L<https://redis.io/commands/function-stats>

=cut

method function_stats (@args) {
    $self->execute_command(qw(FUNCTION STATS) => @args)
}

=head2 script_debug

Set the debug mode for executed scripts.

=over 4

=item * YES|SYNC|NO

=back

L<https://redis.io/commands/script-debug>

=cut

method script_debug (@args) {
    $self->execute_command(qw(SCRIPT DEBUG) => @args)
}

=head2 script_exists

Check existence of scripts in the script cache.

=over 4

=item * sha1 [sha1 ...]

=back

L<https://redis.io/commands/script-exists>

=cut

method script_exists (@args) {
    $self->execute_command(qw(SCRIPT EXISTS) => @args)
}

=head2 script_flush

Remove all the scripts from the script cache.

=over 4

=item * [ASYNC|SYNC]

=back

L<https://redis.io/commands/script-flush>

=cut

method script_flush (@args) {
    $self->execute_command(qw(SCRIPT FLUSH) => @args)
}

=head2 script_kill

Kill the script currently in execution.

L<https://redis.io/commands/script-kill>

=cut

method script_kill (@args) {
    $self->execute_command(qw(SCRIPT KILL) => @args)
}

=head2 script_load

Load the specified Lua script into the script cache.

=over 4

=item * script

=back

L<https://redis.io/commands/script-load>

=cut

method script_load (@args) {
    $self->execute_command(qw(SCRIPT LOAD) => @args)
}

=head1 METHODS - Server

=head2 acl_cat

List the ACL categories or the commands inside a category.

=over 4

=item * [categoryname]

=back

L<https://redis.io/commands/acl-cat>

=cut

method acl_cat (@args) {
    $self->execute_command(qw(ACL CAT) => @args)
}

=head2 acl_deluser

Remove the specified ACL users and the associated rules.

=over 4

=item * username [username ...]

=back

L<https://redis.io/commands/acl-deluser>

=cut

method acl_deluser (@args) {
    $self->execute_command(qw(ACL DELUSER) => @args)
}

=head2 acl_dryrun

Returns whether the user can execute the given command without executing the command.

=over 4

=item * username

=item * command

=item * [arg [arg ...]]

=back

L<https://redis.io/commands/acl-dryrun>

=cut

method acl_dryrun (@args) {
    $self->execute_command(qw(ACL DRYRUN) => @args)
}

=head2 acl_genpass

Generate a pseudorandom secure password to use for ACL users.

=over 4

=item * [bits]

=back

L<https://redis.io/commands/acl-genpass>

=cut

method acl_genpass (@args) {
    $self->execute_command(qw(ACL GENPASS) => @args)
}

=head2 acl_getuser

Get the rules for a specific ACL user.

=over 4

=item * username

=back

L<https://redis.io/commands/acl-getuser>

=cut

method acl_getuser (@args) {
    $self->execute_command(qw(ACL GETUSER) => @args)
}

=head2 acl_list

List the current ACL rules in ACL config file format.

L<https://redis.io/commands/acl-list>

=cut

method acl_list (@args) {
    $self->execute_command(qw(ACL LIST) => @args)
}

=head2 acl_load

Reload the ACLs from the configured ACL file.

L<https://redis.io/commands/acl-load>

=cut

method acl_load (@args) {
    $self->execute_command(qw(ACL LOAD) => @args)
}

=head2 acl_log

List latest events denied because of ACLs in place.

=over 4

=item * [count|RESET]

=back

L<https://redis.io/commands/acl-log>

=cut

method acl_log (@args) {
    $self->execute_command(qw(ACL LOG) => @args)
}

=head2 acl_save

Save the current ACL rules in the configured ACL file.

L<https://redis.io/commands/acl-save>

=cut

method acl_save (@args) {
    $self->execute_command(qw(ACL SAVE) => @args)
}

=head2 acl_setuser

Modify or create the rules for a specific ACL user.

=over 4

=item * username

=item * [rule [rule ...]]

=back

L<https://redis.io/commands/acl-setuser>

=cut

method acl_setuser (@args) {
    $self->execute_command(qw(ACL SETUSER) => @args)
}

=head2 acl_users

List the username of all the configured ACL rules.

L<https://redis.io/commands/acl-users>

=cut

method acl_users (@args) {
    $self->execute_command(qw(ACL USERS) => @args)
}

=head2 acl_whoami

Return the name of the user associated to the current connection.

L<https://redis.io/commands/acl-whoami>

=cut

method acl_whoami (@args) {
    $self->execute_command(qw(ACL WHOAMI) => @args)
}

=head2 bgrewriteaof

Asynchronously rewrite the append-only file.

L<https://redis.io/commands/bgrewriteaof>

=cut

method bgrewriteaof (@args) {
    $self->execute_command(qw(BGREWRITEAOF) => @args)
}

=head2 bgsave

Asynchronously save the dataset to disk.

=over 4

=item * [SCHEDULE]

=back

L<https://redis.io/commands/bgsave>

=cut

method bgsave (@args) {
    $self->execute_command(qw(BGSAVE) => @args)
}

=head2 command

Get array of Redis command details.

L<https://redis.io/commands/command>

=cut

method command (@args) {
    $self->execute_command(qw(COMMAND) => @args)
}

=head2 command_count

Get total number of Redis commands.

L<https://redis.io/commands/command-count>

=cut

method command_count (@args) {
    $self->execute_command(qw(COMMAND COUNT) => @args)
}

=head2 command_docs

Get array of specific Redis command documentation.

=over 4

=item * [command-name [command-name ...]]

=back

L<https://redis.io/commands/command-docs>

=cut

method command_docs (@args) {
    $self->execute_command(qw(COMMAND DOCS) => @args)
}

=head2 command_getkeys

Extract keys given a full Redis command.

L<https://redis.io/commands/command-getkeys>

=cut

method command_getkeys (@args) {
    $self->execute_command(qw(COMMAND GETKEYS) => @args)
}

=head2 command_getkeysandflags

Extract keys given a full Redis command.

L<https://redis.io/commands/command-getkeysandflags>

=cut

method command_getkeysandflags (@args) {
    $self->execute_command(qw(COMMAND GETKEYSANDFLAGS) => @args)
}

=head2 command_info

Get array of specific Redis command details, or all when no argument is given.

=over 4

=item * [command-name [command-name ...]]

=back

L<https://redis.io/commands/command-info>

=cut

method command_info (@args) {
    $self->execute_command(qw(COMMAND INFO) => @args)
}

=head2 command_list

Get an array of Redis command names.

=over 4

=item * [FILTERBY MODULE module-name|ACLCAT category|PATTERN pattern]

=back

L<https://redis.io/commands/command-list>

=cut

method command_list (@args) {
    $self->execute_command(qw(COMMAND LIST) => @args)
}

=head2 config_get

Get the values of configuration parameters.

=over 4

=item * parameter [parameter ...]

=back

L<https://redis.io/commands/config-get>

=cut

method config_get (@args) {
    $self->execute_command(qw(CONFIG GET) => @args)
}

=head2 config_resetstat

Reset the stats returned by INFO.

L<https://redis.io/commands/config-resetstat>

=cut

method config_resetstat (@args) {
    $self->execute_command(qw(CONFIG RESETSTAT) => @args)
}

=head2 config_rewrite

Rewrite the configuration file with the in memory configuration.

L<https://redis.io/commands/config-rewrite>

=cut

method config_rewrite (@args) {
    $self->execute_command(qw(CONFIG REWRITE) => @args)
}

=head2 config_set

Set configuration parameters to the given values.

=over 4

=item * parameter value [parameter value ...]

=back

L<https://redis.io/commands/config-set>

=cut

method config_set (@args) {
    $self->execute_command(qw(CONFIG SET) => @args)
}

=head2 dbsize

Return the number of keys in the selected database.

L<https://redis.io/commands/dbsize>

=cut

method dbsize (@args) {
    $self->execute_command(qw(DBSIZE) => @args)
}

=head2 failover

Start a coordinated failover between this server and one of its replicas.

=over 4

=item * [TO host port [FORCE]]

=item * [ABORT]

=item * [TIMEOUT milliseconds]

=back

L<https://redis.io/commands/failover>

=cut

method failover (@args) {
    $self->execute_command(qw(FAILOVER) => @args)
}

=head2 flushall

Remove all keys from all databases.

=over 4

=item * [ASYNC|SYNC]

=back

L<https://redis.io/commands/flushall>

=cut

method flushall (@args) {
    $self->execute_command(qw(FLUSHALL) => @args)
}

=head2 flushdb

Remove all keys from the current database.

=over 4

=item * [ASYNC|SYNC]

=back

L<https://redis.io/commands/flushdb>

=cut

method flushdb (@args) {
    $self->execute_command(qw(FLUSHDB) => @args)
}

=head2 info

Get information and statistics about the server.

=over 4

=item * [section [section ...]]

=back

L<https://redis.io/commands/info>

=cut

method info (@args) {
    $self->execute_command(qw(INFO) => @args)
}

=head2 lastsave

Get the UNIX time stamp of the last successful save to disk.

L<https://redis.io/commands/lastsave>

=cut

method lastsave (@args) {
    $self->execute_command(qw(LASTSAVE) => @args)
}

=head2 latency_doctor

Return a human readable latency analysis report.

L<https://redis.io/commands/latency-doctor>

=cut

method latency_doctor (@args) {
    $self->execute_command(qw(LATENCY DOCTOR) => @args)
}

=head2 latency_graph

Return a latency graph for the event.

=over 4

=item * event

=back

L<https://redis.io/commands/latency-graph>

=cut

method latency_graph (@args) {
    $self->execute_command(qw(LATENCY GRAPH) => @args)
}

=head2 latency_histogram

Return the cumulative distribution of latencies of a subset of commands or all.

=over 4

=item * [command [command ...]]

=back

L<https://redis.io/commands/latency-histogram>

=cut

method latency_histogram (@args) {
    $self->execute_command(qw(LATENCY HISTOGRAM) => @args)
}

=head2 latency_history

Return timestamp-latency samples for the event.

=over 4

=item * event

=back

L<https://redis.io/commands/latency-history>

=cut

method latency_history (@args) {
    $self->execute_command(qw(LATENCY HISTORY) => @args)
}

=head2 latency_latest

Return the latest latency samples for all events.

L<https://redis.io/commands/latency-latest>

=cut

method latency_latest (@args) {
    $self->execute_command(qw(LATENCY LATEST) => @args)
}

=head2 latency_reset

Reset latency data for one or more events.

=over 4

=item * [event [event ...]]

=back

L<https://redis.io/commands/latency-reset>

=cut

method latency_reset (@args) {
    $self->execute_command(qw(LATENCY RESET) => @args)
}

=head2 lolwut

Display some computer art and the Redis version.

=over 4

=item * [VERSION version]

=back

L<https://redis.io/commands/lolwut>

=cut

method lolwut (@args) {
    $self->execute_command(qw(LOLWUT) => @args)
}

=head2 memory_doctor

Outputs memory problems report.

L<https://redis.io/commands/memory-doctor>

=cut

method memory_doctor (@args) {
    $self->execute_command(qw(MEMORY DOCTOR) => @args)
}

=head2 memory_malloc_stats

Show allocator internal stats.

L<https://redis.io/commands/memory-malloc-stats>

=cut

method memory_malloc_stats (@args) {
    $self->execute_command(qw(MEMORY MALLOC-STATS) => @args)
}

=head2 memory_purge

Ask the allocator to release memory.

L<https://redis.io/commands/memory-purge>

=cut

method memory_purge (@args) {
    $self->execute_command(qw(MEMORY PURGE) => @args)
}

=head2 memory_stats

Show memory usage details.

L<https://redis.io/commands/memory-stats>

=cut

method memory_stats (@args) {
    $self->execute_command(qw(MEMORY STATS) => @args)
}

=head2 memory_usage

Estimate the memory usage of a key.

=over 4

=item * key

=item * [SAMPLES count]

=back

L<https://redis.io/commands/memory-usage>

=cut

method memory_usage (@args) {
    $self->execute_command(qw(MEMORY USAGE) => @args)
}

=head2 module_list

List all modules loaded by the server.

L<https://redis.io/commands/module-list>

=cut

method module_list (@args) {
    $self->execute_command(qw(MODULE LIST) => @args)
}

=head2 module_load

Load a module.

=over 4

=item * path

=item * [arg [arg ...]]

=back

L<https://redis.io/commands/module-load>

=cut

method module_load (@args) {
    $self->execute_command(qw(MODULE LOAD) => @args)
}

=head2 module_unload

Unload a module.

=over 4

=item * name

=back

L<https://redis.io/commands/module-unload>

=cut

method module_unload (@args) {
    $self->execute_command(qw(MODULE UNLOAD) => @args)
}

=head2 monitor

Listen for all requests received by the server in real time.

L<https://redis.io/commands/monitor>

=cut

method monitor (@args) {
    $self->execute_command(qw(MONITOR) => @args)
}

=head2 psync

Internal command used for replication.

=over 4

=item * replicationid

=item * offset

=back

L<https://redis.io/commands/psync>

=cut

method psync (@args) {
    $self->execute_command(qw(PSYNC) => @args)
}

=head2 replconf

An internal command for configuring the replication stream.

L<https://redis.io/commands/replconf>

=cut

method replconf (@args) {
    $self->execute_command(qw(REPLCONF) => @args)
}

=head2 replicaof

Make the server a replica of another instance, or promote it as master.

=over 4

=item * host

=item * port

=back

L<https://redis.io/commands/replicaof>

=cut

method replicaof (@args) {
    $self->execute_command(qw(REPLICAOF) => @args)
}

=head2 restore_asking

An internal command for migrating keys in a cluster.

L<https://redis.io/commands/restore-asking>

=cut

method restore_asking (@args) {
    $self->execute_command(qw(RESTORE-ASKING) => @args)
}

=head2 role

Return the role of the instance in the context of replication.

L<https://redis.io/commands/role>

=cut

method role (@args) {
    $self->execute_command(qw(ROLE) => @args)
}

=head2 save

Synchronously save the dataset to disk.

L<https://redis.io/commands/save>

=cut

method save (@args) {
    $self->execute_command(qw(SAVE) => @args)
}

=head2 shutdown

Synchronously save the dataset to disk and then shut down the server.

=over 4

=item * [NOSAVE|SAVE]

=item * [NOW]

=item * [FORCE]

=item * [ABORT]

=back

L<https://redis.io/commands/shutdown>

=cut

method shutdown (@args) {
    $self->execute_command(qw(SHUTDOWN) => @args)
}

=head2 slaveof

Make the server a replica of another instance, or promote it as master.

=over 4

=item * host

=item * port

=back

L<https://redis.io/commands/slaveof>

=cut

method slaveof (@args) {
    $self->execute_command(qw(SLAVEOF) => @args)
}

=head2 slowlog_get

Get the slow log's entries.

=over 4

=item * [count]

=back

L<https://redis.io/commands/slowlog-get>

=cut

method slowlog_get (@args) {
    $self->execute_command(qw(SLOWLOG GET) => @args)
}

=head2 slowlog_len

Get the slow log's length.

L<https://redis.io/commands/slowlog-len>

=cut

method slowlog_len (@args) {
    $self->execute_command(qw(SLOWLOG LEN) => @args)
}

=head2 slowlog_reset

Clear all entries from the slow log.

L<https://redis.io/commands/slowlog-reset>

=cut

method slowlog_reset (@args) {
    $self->execute_command(qw(SLOWLOG RESET) => @args)
}

=head2 swapdb

Swaps two Redis databases.

=over 4

=item * index1

=item * index2

=back

L<https://redis.io/commands/swapdb>

=cut

method swapdb (@args) {
    $self->execute_command(qw(SWAPDB) => @args)
}

=head2 sync

Internal command used for replication.

L<https://redis.io/commands/sync>

=cut

method sync (@args) {
    $self->execute_command(qw(SYNC) => @args)
}

=head2 time

Return the current server time.

L<https://redis.io/commands/time>

=cut

method time (@args) {
    $self->execute_command(qw(TIME) => @args)
}

=head1 METHODS - Set

=head2 sadd

Add one or more members to a set.

=over 4

=item * key

=item * member [member ...]

=back

L<https://redis.io/commands/sadd>

=cut

method sadd (@args) {
    $self->execute_command(qw(SADD) => @args)
}

=head2 scard

Get the number of members in a set.

=over 4

=item * key

=back

L<https://redis.io/commands/scard>

=cut

method scard (@args) {
    $self->execute_command(qw(SCARD) => @args)
}

=head2 sdiff

Subtract multiple sets.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/sdiff>

=cut

method sdiff (@args) {
    $self->execute_command(qw(SDIFF) => @args)
}

=head2 sdiffstore

Subtract multiple sets and store the resulting set in a key.

=over 4

=item * destination

=item * key [key ...]

=back

L<https://redis.io/commands/sdiffstore>

=cut

method sdiffstore (@args) {
    $self->execute_command(qw(SDIFFSTORE) => @args)
}

=head2 sinter

Intersect multiple sets.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/sinter>

=cut

method sinter (@args) {
    $self->execute_command(qw(SINTER) => @args)
}

=head2 sintercard

Intersect multiple sets and return the cardinality of the result.

=over 4

=item * numkeys

=item * key [key ...]

=item * [LIMIT limit]

=back

L<https://redis.io/commands/sintercard>

=cut

method sintercard (@args) {
    $self->execute_command(qw(SINTERCARD) => @args)
}

=head2 sinterstore

Intersect multiple sets and store the resulting set in a key.

=over 4

=item * destination

=item * key [key ...]

=back

L<https://redis.io/commands/sinterstore>

=cut

method sinterstore (@args) {
    $self->execute_command(qw(SINTERSTORE) => @args)
}

=head2 sismember

Determine if a given value is a member of a set.

=over 4

=item * key

=item * member

=back

L<https://redis.io/commands/sismember>

=cut

method sismember (@args) {
    $self->execute_command(qw(SISMEMBER) => @args)
}

=head2 smembers

Get all the members in a set.

=over 4

=item * key

=back

L<https://redis.io/commands/smembers>

=cut

method smembers (@args) {
    $self->execute_command(qw(SMEMBERS) => @args)
}

=head2 smismember

Returns the membership associated with the given elements for a set.

=over 4

=item * key

=item * member [member ...]

=back

L<https://redis.io/commands/smismember>

=cut

method smismember (@args) {
    $self->execute_command(qw(SMISMEMBER) => @args)
}

=head2 smove

Move a member from one set to another.

=over 4

=item * source

=item * destination

=item * member

=back

L<https://redis.io/commands/smove>

=cut

method smove (@args) {
    $self->execute_command(qw(SMOVE) => @args)
}

=head2 spop

Remove and return one or multiple random members from a set.

=over 4

=item * key

=item * [count]

=back

L<https://redis.io/commands/spop>

=cut

method spop (@args) {
    $self->execute_command(qw(SPOP) => @args)
}

=head2 srandmember

Get one or multiple random members from a set.

=over 4

=item * key

=item * [count]

=back

L<https://redis.io/commands/srandmember>

=cut

method srandmember (@args) {
    $self->execute_command(qw(SRANDMEMBER) => @args)
}

=head2 srem

Remove one or more members from a set.

=over 4

=item * key

=item * member [member ...]

=back

L<https://redis.io/commands/srem>

=cut

method srem (@args) {
    $self->execute_command(qw(SREM) => @args)
}

=head2 sscan

Incrementally iterate Set elements.

=over 4

=item * key

=item * cursor

=item * [MATCH pattern]

=item * [COUNT count]

=back

L<https://redis.io/commands/sscan>

=cut

method sscan (@args) {
    $self->execute_command(qw(SSCAN) => @args)
}

=head2 sunion

Add multiple sets.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/sunion>

=cut

method sunion (@args) {
    $self->execute_command(qw(SUNION) => @args)
}

=head2 sunionstore

Add multiple sets and store the resulting set in a key.

=over 4

=item * destination

=item * key [key ...]

=back

L<https://redis.io/commands/sunionstore>

=cut

method sunionstore (@args) {
    $self->execute_command(qw(SUNIONSTORE) => @args)
}

=head1 METHODS - Sorted-set

=head2 bzmpop

Remove and return members with scores in a sorted set or block until one is available.

=over 4

=item * timeout

=item * numkeys

=item * key [key ...]

=item * MIN|MAX

=item * [COUNT count]

=back

L<https://redis.io/commands/bzmpop>

=cut

method bzmpop (@args) {
    $self->execute_command(qw(BZMPOP) => @args)
}

=head2 bzpopmax

Remove and return the member with the highest score from one or more sorted sets, or block until one is available.

=over 4

=item * key [key ...]

=item * timeout

=back

L<https://redis.io/commands/bzpopmax>

=cut

method bzpopmax (@args) {
    $self->execute_command(qw(BZPOPMAX) => @args)
}

=head2 bzpopmin

Remove and return the member with the lowest score from one or more sorted sets, or block until one is available.

=over 4

=item * key [key ...]

=item * timeout

=back

L<https://redis.io/commands/bzpopmin>

=cut

method bzpopmin (@args) {
    $self->execute_command(qw(BZPOPMIN) => @args)
}

=head2 zadd

Add one or more members to a sorted set, or update its score if it already exists.

=over 4

=item * key

=item * [NX|XX]

=item * [GT|LT]

=item * [CH]

=item * [INCR]

=item * score member [score member ...]

=back

L<https://redis.io/commands/zadd>

=cut

method zadd (@args) {
    $self->execute_command(qw(ZADD) => @args)
}

=head2 zcard

Get the number of members in a sorted set.

=over 4

=item * key

=back

L<https://redis.io/commands/zcard>

=cut

method zcard (@args) {
    $self->execute_command(qw(ZCARD) => @args)
}

=head2 zcount

Count the members in a sorted set with scores within the given values.

=over 4

=item * key

=item * min

=item * max

=back

L<https://redis.io/commands/zcount>

=cut

method zcount (@args) {
    $self->execute_command(qw(ZCOUNT) => @args)
}

=head2 zdiff

Subtract multiple sorted sets.

=over 4

=item * numkeys

=item * key [key ...]

=item * [WITHSCORES]

=back

L<https://redis.io/commands/zdiff>

=cut

method zdiff (@args) {
    $self->execute_command(qw(ZDIFF) => @args)
}

=head2 zdiffstore

Subtract multiple sorted sets and store the resulting sorted set in a new key.

=over 4

=item * destination

=item * numkeys

=item * key [key ...]

=back

L<https://redis.io/commands/zdiffstore>

=cut

method zdiffstore (@args) {
    $self->execute_command(qw(ZDIFFSTORE) => @args)
}

=head2 zincrby

Increment the score of a member in a sorted set.

=over 4

=item * key

=item * increment

=item * member

=back

L<https://redis.io/commands/zincrby>

=cut

method zincrby (@args) {
    $self->execute_command(qw(ZINCRBY) => @args)
}

=head2 zinter

Intersect multiple sorted sets.

=over 4

=item * numkeys

=item * key [key ...]

=item * [WEIGHTS weight [weight ...]]

=item * [AGGREGATE SUM|MIN|MAX]

=item * [WITHSCORES]

=back

L<https://redis.io/commands/zinter>

=cut

method zinter (@args) {
    $self->execute_command(qw(ZINTER) => @args)
}

=head2 zintercard

Intersect multiple sorted sets and return the cardinality of the result.

=over 4

=item * numkeys

=item * key [key ...]

=item * [LIMIT limit]

=back

L<https://redis.io/commands/zintercard>

=cut

method zintercard (@args) {
    $self->execute_command(qw(ZINTERCARD) => @args)
}

=head2 zinterstore

Intersect multiple sorted sets and store the resulting sorted set in a new key.

=over 4

=item * destination

=item * numkeys

=item * key [key ...]

=item * [WEIGHTS weight [weight ...]]

=item * [AGGREGATE SUM|MIN|MAX]

=back

L<https://redis.io/commands/zinterstore>

=cut

method zinterstore (@args) {
    $self->execute_command(qw(ZINTERSTORE) => @args)
}

=head2 zlexcount

Count the number of members in a sorted set between a given lexicographical range.

=over 4

=item * key

=item * min

=item * max

=back

L<https://redis.io/commands/zlexcount>

=cut

method zlexcount (@args) {
    $self->execute_command(qw(ZLEXCOUNT) => @args)
}

=head2 zmpop

Remove and return members with scores in a sorted set.

=over 4

=item * numkeys

=item * key [key ...]

=item * MIN|MAX

=item * [COUNT count]

=back

L<https://redis.io/commands/zmpop>

=cut

method zmpop (@args) {
    $self->execute_command(qw(ZMPOP) => @args)
}

=head2 zmscore

Get the score associated with the given members in a sorted set.

=over 4

=item * key

=item * member [member ...]

=back

L<https://redis.io/commands/zmscore>

=cut

method zmscore (@args) {
    $self->execute_command(qw(ZMSCORE) => @args)
}

=head2 zpopmax

Remove and return members with the highest scores in a sorted set.

=over 4

=item * key

=item * [count]

=back

L<https://redis.io/commands/zpopmax>

=cut

method zpopmax (@args) {
    $self->execute_command(qw(ZPOPMAX) => @args)
}

=head2 zpopmin

Remove and return members with the lowest scores in a sorted set.

=over 4

=item * key

=item * [count]

=back

L<https://redis.io/commands/zpopmin>

=cut

method zpopmin (@args) {
    $self->execute_command(qw(ZPOPMIN) => @args)
}

=head2 zrandmember

Get one or multiple random elements from a sorted set.

=over 4

=item * key

=item * [count [WITHSCORES]]

=back

L<https://redis.io/commands/zrandmember>

=cut

method zrandmember (@args) {
    $self->execute_command(qw(ZRANDMEMBER) => @args)
}

=head2 zrange

Return a range of members in a sorted set.

=over 4

=item * key

=item * min

=item * max

=item * [BYSCORE|BYLEX]

=item * [REV]

=item * [LIMIT offset count]

=item * [WITHSCORES]

=back

L<https://redis.io/commands/zrange>

=cut

method zrange (@args) {
    $self->execute_command(qw(ZRANGE) => @args)
}

=head2 zrangebylex

Return a range of members in a sorted set, by lexicographical range.

=over 4

=item * key

=item * min

=item * max

=item * [LIMIT offset count]

=back

L<https://redis.io/commands/zrangebylex>

=cut

method zrangebylex (@args) {
    $self->execute_command(qw(ZRANGEBYLEX) => @args)
}

=head2 zrangebyscore

Return a range of members in a sorted set, by score.

=over 4

=item * key

=item * min

=item * max

=item * [WITHSCORES]

=item * [LIMIT offset count]

=back

L<https://redis.io/commands/zrangebyscore>

=cut

method zrangebyscore (@args) {
    $self->execute_command(qw(ZRANGEBYSCORE) => @args)
}

=head2 zrangestore

Store a range of members from sorted set into another key.

=over 4

=item * dst

=item * src

=item * min

=item * max

=item * [BYSCORE|BYLEX]

=item * [REV]

=item * [LIMIT offset count]

=back

L<https://redis.io/commands/zrangestore>

=cut

method zrangestore (@args) {
    $self->execute_command(qw(ZRANGESTORE) => @args)
}

=head2 zrank

Determine the index of a member in a sorted set.

=over 4

=item * key

=item * member

=back

L<https://redis.io/commands/zrank>

=cut

method zrank (@args) {
    $self->execute_command(qw(ZRANK) => @args)
}

=head2 zrem

Remove one or more members from a sorted set.

=over 4

=item * key

=item * member [member ...]

=back

L<https://redis.io/commands/zrem>

=cut

method zrem (@args) {
    $self->execute_command(qw(ZREM) => @args)
}

=head2 zremrangebylex

Remove all members in a sorted set between the given lexicographical range.

=over 4

=item * key

=item * min

=item * max

=back

L<https://redis.io/commands/zremrangebylex>

=cut

method zremrangebylex (@args) {
    $self->execute_command(qw(ZREMRANGEBYLEX) => @args)
}

=head2 zremrangebyrank

Remove all members in a sorted set within the given indexes.

=over 4

=item * key

=item * start

=item * stop

=back

L<https://redis.io/commands/zremrangebyrank>

=cut

method zremrangebyrank (@args) {
    $self->execute_command(qw(ZREMRANGEBYRANK) => @args)
}

=head2 zremrangebyscore

Remove all members in a sorted set within the given scores.

=over 4

=item * key

=item * min

=item * max

=back

L<https://redis.io/commands/zremrangebyscore>

=cut

method zremrangebyscore (@args) {
    $self->execute_command(qw(ZREMRANGEBYSCORE) => @args)
}

=head2 zrevrange

Return a range of members in a sorted set, by index, with scores ordered from high to low.

=over 4

=item * key

=item * start

=item * stop

=item * [WITHSCORES]

=back

L<https://redis.io/commands/zrevrange>

=cut

method zrevrange (@args) {
    $self->execute_command(qw(ZREVRANGE) => @args)
}

=head2 zrevrangebylex

Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.

=over 4

=item * key

=item * max

=item * min

=item * [LIMIT offset count]

=back

L<https://redis.io/commands/zrevrangebylex>

=cut

method zrevrangebylex (@args) {
    $self->execute_command(qw(ZREVRANGEBYLEX) => @args)
}

=head2 zrevrangebyscore

Return a range of members in a sorted set, by score, with scores ordered from high to low.

=over 4

=item * key

=item * max

=item * min

=item * [WITHSCORES]

=item * [LIMIT offset count]

=back

L<https://redis.io/commands/zrevrangebyscore>

=cut

method zrevrangebyscore (@args) {
    $self->execute_command(qw(ZREVRANGEBYSCORE) => @args)
}

=head2 zrevrank

Determine the index of a member in a sorted set, with scores ordered from high to low.

=over 4

=item * key

=item * member

=back

L<https://redis.io/commands/zrevrank>

=cut

method zrevrank (@args) {
    $self->execute_command(qw(ZREVRANK) => @args)
}

=head2 zscan

Incrementally iterate sorted sets elements and associated scores.

=over 4

=item * key

=item * cursor

=item * [MATCH pattern]

=item * [COUNT count]

=back

L<https://redis.io/commands/zscan>

=cut

method zscan (@args) {
    $self->execute_command(qw(ZSCAN) => @args)
}

=head2 zscore

Get the score associated with the given member in a sorted set.

=over 4

=item * key

=item * member

=back

L<https://redis.io/commands/zscore>

=cut

method zscore (@args) {
    $self->execute_command(qw(ZSCORE) => @args)
}

=head2 zunion

Add multiple sorted sets.

=over 4

=item * numkeys

=item * key [key ...]

=item * [WEIGHTS weight [weight ...]]

=item * [AGGREGATE SUM|MIN|MAX]

=item * [WITHSCORES]

=back

L<https://redis.io/commands/zunion>

=cut

method zunion (@args) {
    $self->execute_command(qw(ZUNION) => @args)
}

=head2 zunionstore

Add multiple sorted sets and store the resulting sorted set in a new key.

=over 4

=item * destination

=item * numkeys

=item * key [key ...]

=item * [WEIGHTS weight [weight ...]]

=item * [AGGREGATE SUM|MIN|MAX]

=back

L<https://redis.io/commands/zunionstore>

=cut

method zunionstore (@args) {
    $self->execute_command(qw(ZUNIONSTORE) => @args)
}

=head1 METHODS - Stream

=head2 xack

Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group. Return value of the command is the number of messages successfully acknowledged, that is, the IDs we were actually able to resolve in the PEL.

=over 4

=item * key

=item * group

=item * id [id ...]

=back

L<https://redis.io/commands/xack>

=cut

method xack (@args) {
    $self->execute_command(qw(XACK) => @args)
}

=head2 xadd

Appends a new entry to a stream.

=over 4

=item * key

=item * [NOMKSTREAM]

=item * [MAXLEN|MINID [=|~] threshold [LIMIT count]]

=item * *|id

=item * field value [field value ...]

=back

L<https://redis.io/commands/xadd>

=cut

method xadd (@args) {
    $self->execute_command(qw(XADD) => @args)
}

=head2 xautoclaim

Changes (or acquires) ownership of messages in a consumer group, as if the messages were delivered to the specified consumer.

=over 4

=item * key

=item * group

=item * consumer

=item * min-idle-time

=item * start

=item * [COUNT count]

=item * [JUSTID]

=back

L<https://redis.io/commands/xautoclaim>

=cut

method xautoclaim (@args) {
    $self->execute_command(qw(XAUTOCLAIM) => @args)
}

=head2 xclaim

Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer.

=over 4

=item * key

=item * group

=item * consumer

=item * min-idle-time

=item * id [id ...]

=item * [IDLE ms]

=item * [TIME unix-time-milliseconds]

=item * [RETRYCOUNT count]

=item * [FORCE]

=item * [JUSTID]

=back

L<https://redis.io/commands/xclaim>

=cut

method xclaim (@args) {
    $self->execute_command(qw(XCLAIM) => @args)
}

=head2 xdel

Removes the specified entries from the stream. Returns the number of items actually deleted, that may be different from the number of IDs passed in case certain IDs do not exist.

=over 4

=item * key

=item * id [id ...]

=back

L<https://redis.io/commands/xdel>

=cut

method xdel (@args) {
    $self->execute_command(qw(XDEL) => @args)
}

=head2 xgroup_create

Create a consumer group.

=over 4

=item * key

=item * groupname

=item * id|$

=item * [MKSTREAM]

=item * [ENTRIESREAD entries_read]

=back

L<https://redis.io/commands/xgroup-create>

=cut

method xgroup_create (@args) {
    $self->execute_command(qw(XGROUP CREATE) => @args)
}

=head2 xgroup_createconsumer

Create a consumer in a consumer group.

=over 4

=item * key

=item * groupname

=item * consumername

=back

L<https://redis.io/commands/xgroup-createconsumer>

=cut

method xgroup_createconsumer (@args) {
    $self->execute_command(qw(XGROUP CREATECONSUMER) => @args)
}

=head2 xgroup_delconsumer

Delete a consumer from a consumer group.

=over 4

=item * key

=item * groupname

=item * consumername

=back

L<https://redis.io/commands/xgroup-delconsumer>

=cut

method xgroup_delconsumer (@args) {
    $self->execute_command(qw(XGROUP DELCONSUMER) => @args)
}

=head2 xgroup_destroy

Destroy a consumer group.

=over 4

=item * key

=item * groupname

=back

L<https://redis.io/commands/xgroup-destroy>

=cut

method xgroup_destroy (@args) {
    $self->execute_command(qw(XGROUP DESTROY) => @args)
}

=head2 xgroup_setid

Set a consumer group to an arbitrary last delivered ID value.

=over 4

=item * key

=item * groupname

=item * id|$

=item * [ENTRIESREAD entries_read]

=back

L<https://redis.io/commands/xgroup-setid>

=cut

method xgroup_setid (@args) {
    $self->execute_command(qw(XGROUP SETID) => @args)
}

=head2 xinfo_consumers

List the consumers in a consumer group.

=over 4

=item * key

=item * groupname

=back

L<https://redis.io/commands/xinfo-consumers>

=cut

method xinfo_consumers (@args) {
    $self->execute_command(qw(XINFO CONSUMERS) => @args)
}

=head2 xinfo_groups

List the consumer groups of a stream.

=over 4

=item * key

=back

L<https://redis.io/commands/xinfo-groups>

=cut

method xinfo_groups (@args) {
    $self->execute_command(qw(XINFO GROUPS) => @args)
}

=head2 xinfo_stream

Get information about a stream.

=over 4

=item * key

=item * [FULL [COUNT count]]

=back

L<https://redis.io/commands/xinfo-stream>

=cut

method xinfo_stream (@args) {
    $self->execute_command(qw(XINFO STREAM) => @args)
}

=head2 xlen

Return the number of entries in a stream.

=over 4

=item * key

=back

L<https://redis.io/commands/xlen>

=cut

method xlen (@args) {
    $self->execute_command(qw(XLEN) => @args)
}

=head2 xpending

Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged.

=over 4

=item * key

=item * group

=item * [[IDLE min-idle-time] start end count [consumer]]

=back

L<https://redis.io/commands/xpending>

=cut

method xpending (@args) {
    $self->execute_command(qw(XPENDING) => @args)
}

=head2 xrange

Return a range of elements in a stream, with IDs matching the specified IDs interval.

=over 4

=item * key

=item * start

=item * end

=item * [COUNT count]

=back

L<https://redis.io/commands/xrange>

=cut

method xrange (@args) {
    $self->execute_command(qw(XRANGE) => @args)
}

=head2 xread

Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block.

=over 4

=item * [COUNT count]

=item * [BLOCK milliseconds]

=item * STREAMS key [key ...] id [id ...]

=back

L<https://redis.io/commands/xread>

=cut

# method xread (@args) {
#     $self->execute_command(qw(XREAD) => @args)
# }

=head2 xreadgroup

Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block.

=over 4

=item * GROUP group consumer

=item * [COUNT count]

=item * [BLOCK milliseconds]

=item * [NOACK]

=item * STREAMS key [key ...] id [id ...]

=back

L<https://redis.io/commands/xreadgroup>

=cut

# method xreadgroup (@args) {
#     $self->execute_command(qw(XREADGROUP) => @args)
# }

=head2 xrevrange

Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE.

=over 4

=item * key

=item * end

=item * start

=item * [COUNT count]

=back

L<https://redis.io/commands/xrevrange>

=cut

method xrevrange (@args) {
    $self->execute_command(qw(XREVRANGE) => @args)
}

=head2 xsetid

An internal command for replicating stream values.

=over 4

=item * key

=item * last-id

=item * [ENTRIESADDED entries_added]

=item * [MAXDELETEDID max_deleted_entry_id]

=back

L<https://redis.io/commands/xsetid>

=cut

method xsetid (@args) {
    $self->execute_command(qw(XSETID) => @args)
}

=head2 xtrim

Trims the stream to (approximately if '~' is passed) a certain size.

=over 4

=item * key

=item * MAXLEN|MINID [=|~] threshold [LIMIT count]

=back

L<https://redis.io/commands/xtrim>

=cut

method xtrim (@args) {
    $self->execute_command(qw(XTRIM) => @args)
}

=head1 METHODS - String

=head2 append

Append a value to a key.

=over 4

=item * key

=item * value

=back

L<https://redis.io/commands/append>

=cut

method append (@args) {
    $self->execute_command(qw(APPEND) => @args)
}

=head2 decr

Decrement the integer value of a key by one.

=over 4

=item * key

=back

L<https://redis.io/commands/decr>

=cut

method decr (@args) {
    $self->execute_command(qw(DECR) => @args)
}

=head2 decrby

Decrement the integer value of a key by the given number.

=over 4

=item * key

=item * decrement

=back

L<https://redis.io/commands/decrby>

=cut

method decrby (@args) {
    $self->execute_command(qw(DECRBY) => @args)
}

=head2 get

Get the value of a key.

=over 4

=item * key

=back

L<https://redis.io/commands/get>

=cut

# method get (@args) {
#     $self->execute_command(qw(GET) => @args)
# }

=head2 getdel

Get the value of a key and delete the key.

=over 4

=item * key

=back

L<https://redis.io/commands/getdel>

=cut

method getdel (@args) {
    $self->execute_command(qw(GETDEL) => @args)
}

=head2 getex

Get the value of a key and optionally set its expiration.

=over 4

=item * key

=item * [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|PERSIST]

=back

L<https://redis.io/commands/getex>

=cut

method getex (@args) {
    $self->execute_command(qw(GETEX) => @args)
}

=head2 getrange

Get a substring of the string stored at a key.

=over 4

=item * key

=item * start

=item * end

=back

L<https://redis.io/commands/getrange>

=cut

method getrange (@args) {
    $self->execute_command(qw(GETRANGE) => @args)
}

=head2 getset

Set the string value of a key and return its old value.

=over 4

=item * key

=item * value

=back

L<https://redis.io/commands/getset>

=cut

method getset (@args) {
    $self->execute_command(qw(GETSET) => @args)
}

=head2 incr

Increment the integer value of a key by one.

=over 4

=item * key

=back

L<https://redis.io/commands/incr>

=cut

method incr (@args) {
    $self->execute_command(qw(INCR) => @args)
}

=head2 incrby

Increment the integer value of a key by the given amount.

=over 4

=item * key

=item * increment

=back

L<https://redis.io/commands/incrby>

=cut

method incrby (@args) {
    $self->execute_command(qw(INCRBY) => @args)
}

=head2 incrbyfloat

Increment the float value of a key by the given amount.

=over 4

=item * key

=item * increment

=back

L<https://redis.io/commands/incrbyfloat>

=cut

method incrbyfloat (@args) {
    $self->execute_command(qw(INCRBYFLOAT) => @args)
}

=head2 lcs

Find longest common substring.

=over 4

=item * key1

=item * key2

=item * [LEN]

=item * [IDX]

=item * [MINMATCHLEN len]

=item * [WITHMATCHLEN]

=back

L<https://redis.io/commands/lcs>

=cut

method lcs (@args) {
    $self->execute_command(qw(LCS) => @args)
}

=head2 mget

Get the values of all the given keys.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/mget>

=cut

method mget (@args) {
    $self->execute_command(qw(MGET) => @args)
}

=head2 mset

Set multiple keys to multiple values.

=over 4

=item * key value [key value ...]

=back

L<https://redis.io/commands/mset>

=cut

method mset (@args) {
    $self->execute_command(qw(MSET) => @args)
}

=head2 msetnx

Set multiple keys to multiple values, only if none of the keys exist.

=over 4

=item * key value [key value ...]

=back

L<https://redis.io/commands/msetnx>

=cut

method msetnx (@args) {
    $self->execute_command(qw(MSETNX) => @args)
}

=head2 psetex

Set the value and expiration in milliseconds of a key.

=over 4

=item * key

=item * milliseconds

=item * value

=back

L<https://redis.io/commands/psetex>

=cut

method psetex (@args) {
    $self->execute_command(qw(PSETEX) => @args)
}

=head2 set

Set the string value of a key.

=over 4

=item * key

=item * value

=item * [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]

=item * [NX|XX]

=item * [GET]

=back

L<https://redis.io/commands/set>

=cut

method set (@args) {
    $self->execute_command(qw(SET) => @args)
}

=head2 setex

Set the value and expiration of a key.

=over 4

=item * key

=item * seconds

=item * value

=back

L<https://redis.io/commands/setex>

=cut

method setex (@args) {
    $self->execute_command(qw(SETEX) => @args)
}

=head2 setnx

Set the value of a key, only if the key does not exist.

=over 4

=item * key

=item * value

=back

L<https://redis.io/commands/setnx>

=cut

method setnx (@args) {
    $self->execute_command(qw(SETNX) => @args)
}

=head2 setrange

Overwrite part of a string at key starting at the specified offset.

=over 4

=item * key

=item * offset

=item * value

=back

L<https://redis.io/commands/setrange>

=cut

method setrange (@args) {
    $self->execute_command(qw(SETRANGE) => @args)
}

=head2 strlen

Get the length of the value stored in a key.

=over 4

=item * key

=back

L<https://redis.io/commands/strlen>

=cut

method strlen (@args) {
    $self->execute_command(qw(STRLEN) => @args)
}

=head2 substr

Get a substring of the string stored at a key.

=over 4

=item * key

=item * start

=item * end

=back

L<https://redis.io/commands/substr>

=cut

method substr (@args) {
    $self->execute_command(qw(SUBSTR) => @args)
}

=head1 METHODS - Transactions

=head2 discard

Discard all commands issued after MULTI.

L<https://redis.io/commands/discard>

=cut

method discard (@args) {
    $self->execute_command(qw(DISCARD) => @args)
}

=head2 exec

Execute all commands issued after MULTI.

L<https://redis.io/commands/exec>

=cut

method exec (@args) {
    $self->execute_command(qw(EXEC) => @args)
}

=head2 multi

Mark the start of a transaction block.

L<https://redis.io/commands/multi>

=cut

# method multi (@args) {
#     $self->execute_command(qw(MULTI) => @args)
# }

=head2 unwatch

Forget about all watched keys.

L<https://redis.io/commands/unwatch>

=cut

method unwatch (@args) {
    $self->execute_command(qw(UNWATCH) => @args)
}

=head2 watch

Watch the given keys to determine execution of the MULTI/EXEC block.

=over 4

=item * key [key ...]

=back

L<https://redis.io/commands/watch>

=cut

method watch (@args) {
    $self->execute_command(qw(WATCH) => @args)
}


=head1 METHODS - Legacy

These take a subcommand as a parameter and construct the method name by
combining the main command with subcommand - for example, C<< ->xgroup(CREATE => ...) >>
would call C<< ->xgroup_create >>.

=cut

=head2 acl

=cut

method acl ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "acl_" . lc($cmd);
    return $self->$method(@args);
}

=head2 client

=cut

method client ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "client_" . lc($cmd);
    return $self->$method(@args);
}

=head2 client_no

=cut

method client_no ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "client_no_" . lc($cmd);
    return $self->$method(@args);
}

=head2 cluster

=cut

method cluster ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "cluster_" . lc($cmd);
    return $self->$method(@args);
}

=head2 cluster_count

=cut

method cluster_count ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "cluster_count_" . lc($cmd);
    return $self->$method(@args);
}

=head2 cluster_count_failure

=cut

method cluster_count_failure ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "cluster_count_failure_" . lc($cmd);
    return $self->$method(@args);
}

=head2 cluster_set

=cut

method cluster_set ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "cluster_set_" . lc($cmd);
    return $self->$method(@args);
}

=head2 cluster_set_config

=cut

method cluster_set_config ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "cluster_set_config_" . lc($cmd);
    return $self->$method(@args);
}

=head2 config

=cut

method config ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "config_" . lc($cmd);
    return $self->$method(@args);
}

=head2 function

=cut

method function ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "function_" . lc($cmd);
    return $self->$method(@args);
}

=head2 latency

=cut

method latency ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "latency_" . lc($cmd);
    return $self->$method(@args);
}

=head2 memory

=cut

method memory ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "memory_" . lc($cmd);
    return $self->$method(@args);
}

=head2 memory_malloc

=cut

method memory_malloc ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "memory_malloc_" . lc($cmd);
    return $self->$method(@args);
}

=head2 module

=cut

method module ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "module_" . lc($cmd);
    return $self->$method(@args);
}

=head2 object

=cut

method object ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "object_" . lc($cmd);
    return $self->$method(@args);
}

=head2 pubsub

=cut

method pubsub ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "pubsub_" . lc($cmd);
    return $self->$method(@args);
}

=head2 script

=cut

method script ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "script_" . lc($cmd);
    return $self->$method(@args);
}

=head2 slowlog

=cut

method slowlog ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "slowlog_" . lc($cmd);
    return $self->$method(@args);
}

=head2 xgroup

=cut

method xgroup ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "xgroup_" . lc($cmd);
    return $self->$method(@args);
}

=head2 xinfo

=cut

method xinfo ($cmd, @args) {
    $cmd =~ tr/ /_/;
    my $method = "xinfo_" . lc($cmd);
    return $self->$method(@args);
}

1;

__END__

=head1 AUTHOR

Tom Molesworth <TEAM@cpan.org>

=head1 LICENSE

This was autogenerated from the official Redis documentation, which is published
under the L<Creative Commons Attribution-ShareAlike license|https://github.com/redis/redis-doc/blob/master/LICENSE>.

The Perl code is copyright Tom Molesworth 2015-2021, and licensed under the same
terms as Perl itself.

