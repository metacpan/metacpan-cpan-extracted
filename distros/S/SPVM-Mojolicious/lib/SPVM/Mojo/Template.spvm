# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Template {
  version_from Mojolicious;
  
  use Mojo::ByteStream;
  use Mojo::File;
  use Mojo::Util;
  use Native;
  use Native::MethodCall;
  
  # Fields
  has code : rw string;
  
  has unparsed : rw string;
  
  has compiled : rw string;
  
  has capture_end : rw string;
  
  has capture_start : rw string;
  
  has comment_mark : rw string;
  
  has escape_mark : rw string;
  
  has expression_mark : rw string;
  
  has trim_mark : rw string;
  
  has line_start : rw string;
  
  has replace_mark : rw string;
  
  has name : rw string;
  
  has tag_start : rw string;
  
  has tag_end : rw string;
  
  # Undocumented Fields
  has tree : rw string[][];

  # Class Methods
  static method new : Mojo::Template () {
    
    my $self = new Mojo::Template;
    
    $self->{code} = "";
    
    $self->{unparsed} = "";
    
    $self->{capture_end} = "end";
    
    $self->{capture_start} = "begin";
    
    $self->{comment_mark} = "#";
    
    $self->{escape_mark} = "=";
    
    $self->{expression_mark} = "=";
    
    $self->{trim_mark} = "=";
    
    $self->{line_start} = "%";
    
    $self->{replace_mark} = "%";
    
    $self->{name} = "template";
    
    $self->{tag_start} = "<%";
    
    $self->{tag_end} = "%>";
    
    $self->{tree} = new string[][0];
    
    return $self;
  }
  
  static method DEBUG : int () {
    return length(my $_ = Sys->env("SPVM_MOJO_TEMPLATE_DEBUG")) ? (int)$_ : 0;
  }
  
  
  method parse : void ($template : string) {
    
    # Clean start
    $self->set_unparsed($template);
    my $tree = (List of string[])List->new_ref(new string[][0]);
    $self->set_tree($tree->get_array->(string[][]));
    $self->set_compiled(0);
    
    my $tag     = $self->tag_start;
    my $replace = $self->replace_mark;
    my $expr    = $self->expression_mark;
    my $escp    = $self->escape_mark;
    my $cpen    = $self->capture_end;
    my $cmnt    = $self->comment_mark;
    my $cpst    = $self->capture_start;
    my $trim    = $self->trim_mark;
    my $end     = $self->tag_end;
    my $start   = $self->line_start;
    
    my $line_re  = "^(\s*)\Q$start\E(?:(\Q$replace\E)|(\Q$cmnt\E)|(\Q$expr\E))?(.*)$";
    my $token_re = "(\Q$tag\E(?:\Q$replace\E|\Q$cmnt\E)|\Q$tag$expr\E(?:\Q$escp\E)?(?:\s*\Q$cpen\E(?!\w))?|\Q$tag\E(?:\s*\Q$cpen\E(?!\w))?|(?:(?<!\w)\Q$cpst\E\s*)?(?:\Q$trim\E)?\Q$end\E)";
    my $cpen_re = "^\Q$tag\E(?:\Q$expr\E)?(?:\Q$escp\E)?\s*\Q$cpen\E(.*)$";
    my $end_re  = "^(?:(\Q$cpst\E)\s*)?(\Q$trim\E)?\Q$end\E$";
    
    # Split lines
    my $op = "text";
    my $trimming = (string)undef;
    my $capture = 0;
    for my $line (@{Fn->split("\n", $template)}) {
      
      # Turn Perl line into mixed line
      if ($op eq "text" && (my $m = Re->m($line, $line_re))) {
        
        # Escaped start
        if ($m->cap2) { $line = $m->cap1 . $start . $m->cap5; }
        
        # Comment
        elsif ($m->cap3) { $line = $tag . $m->cap3 . "$trim$end"; }
        
        # Expression or code
        else { $line = $m->cap4 ? $m->cap1 . $tag . $m->cap4 . $m->cap5 . $end : $tag . $m->cap5 . "$trim$end"; }
      }
      
      # Escaped line ending
      if (!Re->s((mutable string)$line, "\\\\\\\\$", "\\\\\n")) {
        if (Re->s((mutable string)$line, "\\$", "")) {
          $line .= "\n";
        }
      }
      
      # Mixed line
      for my $token (@{Re->split($token_re, $line)}) {
        
        # Capture end
        if (my $m = Re->m($token, $cpen_re)) {
          $token = $tag . $m->cap1;
          $capture = 1;
        }
        
        # End
        if ($op ne "text" && (my $m = Re->m($token, $end_re))) {
          
          # Capture start
          if ($m->cap1) {
            $tree->splice($tree->length - 1, 0, ["cpst"]);
          }
          
          # Trim left side
          if (($trimming = $m->cap2) && $tree->length > 1) {
            &_trim($tree);
          }
          
          # Hint at end
          $tree->push([$op = "text", ""]);
        }
        
        # Code
        elsif ($token eq $tag) { $op = "code"; }
        
        # Expression
        elsif ($token eq "$tag$expr") { $op = "expr"; }
        
        # Expression that needs to be escaped
        elsif ($token eq "$tag$expr$escp") { $op = "escp"; }
        
        # Comment
        elsif ($token eq "$tag$cmnt") { $op = "cmnt"; }
        
        # Text (comments are just ignored)
        elsif ($op ne "cmnt") {
          
          # Replace
          if ($token eq "$tag$replace") {
            $token = $tag ;
          }
          
          # Trim right side (convert whitespace to line noise)
          if ($trimming && (my $r = Re->s((mutable string)$token, "^(\s+)", ""))) {
            $tree->push(["code", $r->match->cap1]);
            $trimming = 0;
          }
          
          # Token (with optional capture end)
          $tree->push($capture ? ["cpen"] : [$op, $token]);
          $capture = 0;
        }
      }
      
      # Optimize successive text lines separated by a newline
      my $len = $tree->length;
      if ($tree->get($len - 4) && $tree->get($len - 4)->[0] ne "line"
        || (!$tree->get($len - 3) || $tree->get($len - 3)->[0] ne "text" || !Re->m($tree->get($len - 3)->[1], "\n$")
        || ($tree->get($len - 2)->[0] ne "line" || $tree->get($len - 1)->[0] ne "text")))
      {
        $tree->push(["line"]);
        next;
      }
      
      my $_ = $tree->get($len - 3);
      $_->[1] .= $tree->pop->[1];
    }
    
  }
  
  static method _trim : void ($tree : List of string[]) {
    
    # Skip captures
    my $len = $tree->length;
    my $i = $tree->get($len - 2)->[0] eq "cpst" || $tree->get($len - 2)->[0] eq "cpen" ? $len - 3 : $len - 2;
    
    # Only trim text
    unless ($tree->get($i)->[0] eq "text") {
      return;
    }
    
    # Convert whitespace text to line noise
    if (my $r = Re->s((mutable string)$tree->get($i)->[1], "(\s+)$", "")) {
      $tree->splice($i, 0, ["code", $r->match->cap1]);
    }
    
  }
  
  method process : string ($args : object[]) {
    
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
      $self->_compile;
      my $code = $self->code;
      
      unless ($compiled = Native->use_anon_class($code)) {
        # TODO 
        # return Mojo::Exception->new($@)->inspect($self->unparsed, $code)->trace->verbose(1)
        die $self->unparsed;
      }
      
      $self->set_compiled($compiled);
    }
    
    my $output = (string)Native::MethodCall->call_class_method($compiled, "", $args);
    
    return $output;
  }
  
  private method _compile : void () {
    
    my $tree = (List of string[])List->new($self->tree);
    my $escape = 1;
    
    my $blocks = StringList->new;
    my $i = 0;
    my $capture = (string)undef;
    my $multi = 0;
    while (++$i <= $tree->length && (my $next = $tree->get($i))) {
      my $_ = $tree->get($i - 1);
      
      my $op = $_->[0];
      my $value = $_->[1];
      
      if ($op eq "line") {
        $blocks->push("");
        next;
      }
      
      my $value_length = length $value;
      Fn->chomp((mutable string)$value);
      
      my $newline = length $value != $value_length;
      
      # Text (quote and fix line ending)
      if ($op eq "text") {
        if (length $value) {
          my $_ = $blocks->get($blocks->length - 1);
          $_ .= "\$_O .= <<'END_OF_STRING';\n" . $value . "END_OF_STRING\n" ;
          $blocks->set($blocks->length - 1, $_ );
        }
      }
      
      # Code or multi-line expression
      elsif ($op eq "code" || $multi) {
        my $_ = $blocks->get($blocks->length - 1);
        $_ .= $value;
        $blocks->set($blocks->length - 1, $_);
      }
# Capture end
      elsif ($op eq "cpen") {
        my $_ = $blocks->get($blocks->length - 1);
        $_ .= "return Mojo::ByteStream->new(\$_O) }";
        $blocks->set($blocks->length - 1, $_);
        
        # No following code
        my $_ = $blocks->get($blocks->length - 1);
        if ($next->[0] ne "cpst" && (Re->m($next->[1] // "", "^\s*$"))) {
          $_ .= ";" ;
        }
        $blocks->set($blocks->length - 1, $_);
      }
      
      # Expression
      if ($op eq "expr" || $op eq "escp") {

        # Escaped
        if (!$multi && ($op eq "escp" && !$escape || $op eq "expr" && $escape)) {
          my $_ = $blocks->get($blocks->length - 1);
          $_ .= "\$_O .= Mojo::Util->xml_escape($value)";
          $blocks->set($blocks->length - 1, $_);
        }

        # Raw
        elsif (!$multi) {
          my $_ = $blocks->get($blocks->length - 1);
          $_ .= "\$_O .= $value";
          $blocks->set($blocks->length - 1, $_);
        }

        # Multi-line
        $multi = !$next || $next->[0] ne "text";

        # Append semicolon
        my $_ = $blocks->get($blocks->length - 1);
        unless ($multi || $capture) {
          $_ .= ";";
        }
        $blocks->set($blocks->length - 1, $_);
      }

      # Capture start
      if    ($op eq "cpst") { $capture = 1; }
      elsif ($capture) {
        my $_ = $blocks->get($blocks->length - 1);
        $_ .= "method : void () { my \$_O = \"\"; ";
        $blocks->set($blocks->length - 1, $_);
        $capture = 0;
      }
    }
    
    $self->set_code(Fn->join("\n", $blocks->to_array));
    
    $self->set_tree(new string[][0]);
  }
  
  method render : string ($template : string, $args : object[] = undef) {
    
    $self->parse($template);
    
    my $output = $self->process($args);
    
    return $output;
  }
  
  method render_file : string ($path : string, $args : object[] = undef) {
    
    unless ($self->{name}) {
      $self->set_name($path) ;
    }
    my $template = Mojo::File->path($path)->slurp;
    
    return $self->render($template, $args);
  }
  
}
