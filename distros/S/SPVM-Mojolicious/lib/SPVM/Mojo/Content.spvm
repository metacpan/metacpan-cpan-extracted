# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Content extends Mojo::EventEmitter {
  version_from Mojolicious;
  
  allow Mojo::Transaction::HTTP;
  
  use Native::MethodCall;
  use Mojo::SSE;
  use Mojo::SSE::Event;
  use Format;
  
  allow Mojo::Message;
  
  # Class Variables
  our $BOUNDARY_RE : Regex;
  INIT {
    $BOUNDARY_RE = Regex->new("multipart.*boundary\s*=\s*(?:\"([^\"]+)\"|([\w'(),.:?\-+/]+))", "i");
  }
  
  # Fields
  has auto_decompress : rw byte;
  
  has auto_relax : rw byte;
  
  has relaxed : rw byte;
  
  has skip_body : rw byte;
  
  has headers : rw Mojo::Headers;
  
  has max_buffer_size : rw int;
  
  has max_leftover_size : rw int;
  
  # Undocumented Fields
  has eof : byte;
  
  has state : string;
  
  has dynamic : byte;
  
  has buffer : StringBuffer;
  
  has header_buffer : StringBuffer;
  
  has body_buffer : StringBuffer;
  
  has pre_buffer : StringBuffer;
  
  has post_buffer : StringBuffer;
  
  has real_size : int;
  
  has chunk_state : string;
  
  has size : int;
  
  has raw_size : int;
  
  has header_size : int;
  
  has chunked : byte;
  
  has chunks : byte;
  
  has gz : object;
  
  has chunk_len : int;
  
  has body : byte;
  
  has sse : byte;
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    if ($options_h->exists("max_buffer_size")) {
      my $max_buffer_size = $options_h->{"max_buffer_size"}->(int);
      
      unless ($max_buffer_size > 0) {
        die "The value of max_buffer_size option must be a positive value.";
      }
    }
    else {
      $self->{max_buffer_size} = 262144;
    }
    
    if ($options_h->exists("max_leftover_size")) {
      my $max_leftover_size = $options_h->{"max_leftover_size"}->(int);
      
      unless ($max_leftover_size > 0) {
        die "The value of max_leftover_size option must be a positive value.";
      }
    }
    else {
      $self->{max_leftover_size} = 262144;
    }
    
    $self->{buffer} = StringBuffer->new;
    
    $self->{pre_buffer} = StringBuffer->new;
    
    $self->{headers} = Mojo::Headers->new;
    
    $self->{max_buffer_size} = length (my $_ = Sys->env("SPVM_MOJO_MAX_BUFFER_SIZE")) ? (int)$_ : 262144;
    
    $self->{max_leftover_size} = length (my $_ = Sys->env("SPVM_MOJO_MAX_BUFFER_SIZE")) ? (int)$_ : 262144;
  }
  
  method body_contains : int ($chunk : string) { die "Not impelmented"; }
  
  method body_size : int () { die "Not impelmented."; }
  
  method boundary : string () {
    
    my $content_type = $self->headers->content_type;
    unless ($content_type) {
      $content_type = "";
    }
    
    my $boundary = (string)undef;
    if (my $m = $BOUNDARY_RE->match($content_type)) {
      $boundary = $m->cap1;
      unless (length $boundary) {
        $boundary = $m->cap2;
      }
    }
    
    return $boundary;
  }
  
  method clone : Mojo::Content () {
    if ($self->is_dynamic) {
      return undef;
    }
    
    my $clone = (Mojo::Content)Native::MethodCall->new_proto($self, [(object){headers => $self->headers->clone}]);
    
    return $clone;
  }
  
  method generate_body_chunk : string ($offset : int) {
    
    unless ($self->{body_buffer}) {
      $self->{body_buffer} = StringBuffer->new;
    }
    
    if ($self->{body_buffer}->length) {
      my $body_buffer = $self->{body_buffer};
      $self->{body_buffer} = undef;
      return $body_buffer->get_string;
    }
    
    if ($self->{eof}) {
      return "";
    }
    
    my $content_length = $self->headers->content_length;
    
    my $chunk = "";
    eval { Fn->to_int($content_length); }
    if ($@) {
      $chunk = undef;
    }
    
    return $chunk;
  }
  
  method get_body_chunk : string ($offset : int) { die "Not implemented."; }
  
  method get_header_chunk : string ($offset : int) {
    
    $self->_headers;
    
    my $headers = $self->headers;
    
    my $header_buffer = $self->{header_buffer};
    
    my $header_buffer_length = $header_buffer->length;
    
    my $max = ($header_buffer_length <= 131072) ? $header_buffer_length : 131072;
    
    my $chunk = $header_buffer->substr($offset, $max - $offset);
    
    return $chunk;
  }
  
  method header_size : int () {
    
    $self->_headers;
    
    return $self->{header_buffer}->length;
  }
  
  method headers_contain : int ($chunk : string) {
    
    $self->_headers;
    
    my $header_buffer = $self->{header_buffer};
    
    return $header_buffer->index($chunk) >= 0;
  }
  
  method is_chunked : int () {
    return !!$self->headers->transfer_encoding;
  }
  
  method is_compressed : int () {
    
    $self->_headers;
    
    my $content_encoding = Fn->lc($self->headers->content_encoding // "");
    
    return $content_encoding eq "gzip";
  }
  
  method is_dynamic : int () {
  
    return !!$self->{dynamic};
  }
  
  method is_finished : int () {
    
    my $state = $self->{state} // "";
    
    return $state eq "finished";
  }
  
  method is_multipart : int () { return 0; }
  
  method is_parsing_body : int () {
    
    my $state = $self->{state} // "";
    
    return $state eq "body";
  }
  
  method is_sse : int () {
    return ($self->headers->content_type // "") eq "text/event-stream";
  }
  
  method leftovers : string () {
    
    return $self->{buffer}->get_string;
  }
  
  method parse : Mojo::Content ($chunk : string) {
    
    $self->_parse_until_body($chunk);
    
    if ($self->{state} eq "headers") {
      return $self;
    }
    if ($self->is_chunked && $self->{state} ne "headers") {
      $self->_parse_chunked;
      
      my $chunk_state = $self->{chunk_state} // "";
      
      if ($chunk_state eq "finished") {
        $self->{state} = "finished";
      }
    }
    
    # Not chunked, pass through to second buffer
    else {
      $self->{real_size} += $self->{pre_buffer}->length;
      my $limit = $self->is_finished && $self->{buffer}->length > $self->max_leftover_size;
      unless ($limit) {
        $self->{buffer}->push($self->{pre_buffer}->get_string);
        $self->{pre_buffer} = StringBuffer->new;
      }
    }
    # No content
    if ($self->skip_body) {
      $self->{state} = "finished";
      return $self;
    }
    
    # Relaxed parsing
    my $headers = $self->headers;
    my $content_length = $headers->content_length // "";
    
    if ($self->auto_relax && !length $content_length) {
      my $connection = Fn->lc($headers->connection // "");
      
      if ($connection eq "close" || !$connection) {
        $self->{relaxed} = 1 ;
      }
    }
    
    if ($self->is_chunked || $self->relaxed) {
      $self->_decompress($self->{buffer}->get_string);
      $self->{size} += $self->{buffer}->length;
      $self->{buffer} = StringBuffer->new;
      return $self;
    }
    
    # Normal content
    my $len = 0;
    eval { $len = Fn->to_int($content_length); }
    
    if ((my $need = ($len - $self->{size})) > 0) {
      my $len   = $self->{buffer}->length;
      if ($need > $len) {
        $need = $len;
      }
      
      my $chunk = $self->{buffer}->substr(0, $need, "");
      
      $self->_decompress($chunk);
      $self->{size} += length $chunk;
    }
    
    if ($len <= $self->progress) {
      $self->{state} = "finished";
    }
    
    return $self;
  }
  
  method parse_body : void ($chunk : string) {
    
    $self->{state} = "body";
    
    $self->parse($chunk);
  }
  
  method progress : int () {
    
    my $state = $self->{state};
    
    unless ($state) {
      return 0;
    }
    
    unless ($state eq "body" || $state eq "finished") {
      return 0;
    }
    
    my $progress = $self->{raw_size} - $self->{header_size};
    
    return $progress;
  }
  
  method write : void ($chunk : string = undef) {
    
    $self->{dynamic} = 1;
    
    if ($chunk) {
      $self->{body_buffer}->push($chunk);
    }
    
    if ($chunk && !length $chunk) {
      $self->{eof} = 1;
    }
    
  }
  
  method write_chunk : void ($chunk : string = undef) {
    
    unless ($self->{chunked}) {
      $self->headers->set_transfer_encoding("chunked");
    }
    
    $self->{chunked} = 1;
    $self->{dynamic} = 1;
    
    if ($chunk) {
      $self->{body_buffer}->push($self->_build_chunk($chunk));
    }
    
    if ($chunk && !length $chunk) {
      $self->{eof} = 1;
    }
    
  }
  
  method write_sse : void ($event : Mojo::SSE::Event) {
    
    unless ($self->{sse}) {
      $self->headers->set_content_type("text/event-stream");
    }
    
    $self->{sse} = 1;
    
    unless ($event) {
      $self->write;
      return;
    }
    
    $self->write(Mojo::SSE->build_event($event));
  }
  
  protected method _parse_until_body : void ($chunk : string) {
    
    $self->{raw_size} += length($chunk = $chunk // "");
    $self->{pre_buffer} //= StringBuffer->new;
    $self->{pre_buffer}->push($chunk);
    
    $self->{state} = $self->{state} // "headers";
    if ($self->{state} eq "headers") {
      $self->_parse_headers;
    }
    
    if ($self->{state} ne "headers" && !$self->{body}++) {
      $self->emit("body");
    }
  }
  
  private method _build_chunk : string ($chunk : string) {
    
    # End
    unless (length $chunk) {
      return "\x0d\x0a0\x0d\x0a\x0d\x0a";
    }
    
    # First chunk has no leading CRLF
    my $crlf = $self->{chunks}++ ? "\x0d\x0a" : "";
    
    return $crlf . Format->sprintf("%x", [(object)length $chunk]) . "\x0d\x0a$chunk";
  }
  
  private method _decompress : void ($chunk : string) {
    
    # No compression
    unless ($self->auto_decompress && $self->is_compressed) {
      $self->emit(read => $chunk);
      
      return;
    }
    
    # Decompress
    $self->{post_buffer}->push($chunk);
    $self->{gz} = $self->{gz} // &_new_compress_raw_zlib_inflate;
    my $gz     = $self->{gz};
    my $out = (mutable string)copy "";
    my $status = &_inflate($gz, (mutable string)$self->{post_buffer}->get_string, $out);
    if (length $out) {
      $self->emit(read => $out) ;
    }
    
    # Replace Content-Encoding with Content-Length
    if ($status == &Z_STREAM_END) {
      $self->headers->set_content_length(&_total_out($gz));
      $self->headers->remove("Content-Encoding") ;
    }
    
    # Check buffer size
    if ($self->{post_buffer}->length > $self->max_buffer_size) {
      $self->{state} = "finished";
      die "Maximum buffer size exceeded";
    }
  }
  
  private static method Z_STREAM_END : int () {
    
    die "TODO";
    
    # TODO
  }
  
  private static method _new_compress_raw_zlib_inflate : object () {
    
    die "TODO";
    # return Compress::Raw::Zlib::Inflate->new(WindowBits => WANT_GZIP);
  }
  
  private static method _inflate : int ($compress_raw_zlib_inflate : object, $post_buffer : mutable string, $out : mutable string) {
    
    die "TODO";
    # my $status = $gz->inflate(\$self->{post_buffer}, my $out);
    # return $status;
  }
  
  private static method _total_out : int ($compress_raw_zlib_inflate : object) {
    
    die "TODO";
    # $gz->total_out;
    
  }
  
  private method _headers : void () {
    
    if ($self->{header_buffer}) {
      return;
    }
    
    my $headers = $self->headers->to_string;
    
    $self->{header_buffer} = StringBuffer->new;
    $self->{header_buffer}->push($headers ? "$headers\x0d\x0a\x0d\x0a" : "\x0d\x0a");
  }
  
  private method _parse_chunked : void () {
    
    # Trailing headers
    if (($self->{chunk_state} // "") eq "trailing_headers") {
      $self->_parse_chunked_trailing_headers;
      return;
    }
    
    while (my $len = $self->{pre_buffer}->length) {
      # Start new chunk (ignore the chunk extension)
      unless ($self->{chunk_len}) {
        
        my $r = Re->s((mutable string)$self->{pre_buffer}->get_string, "^(?:\x0d?\x0a)?([0-9a-fA-F]+).*\x0a", "");
        
        unless ($r) {
          last;
        }
        
        if ($self->{chunk_len} = Fn->hex($r->match->cap1)) {
          next;
        }
        
        # Last chunk
        $self->{chunk_state} = "trailing_headers";
        last;
      }
      
      # Remove as much as possible from payload
      if ($self->{chunk_len} < $len) {
        $len = $self->{chunk_len};
      }
      
      $self->{buffer}->push($self->{pre_buffer}->substr(0, $len, ""));
      $self->{real_size} += $len;
      $self->{chunk_len} -= $len;
    }
    
    # Trailing headers
    if (($self->{chunk_state} // "") eq "trailing_headers") {
      $self->_parse_chunked_trailing_headers;
    }
    
    # Check buffer size
    if (($self->{pre_buffer} ? $self->{pre_buffer}->length : 0) > $self->max_buffer_size) {
      $self->{state} = "finished";
      die "Maximum buffer size exceeded";
    }
  }
  
  private method _parse_chunked_trailing_headers : void () {
    
    my $pre_buffer = $self->{pre_buffer};
    $self->{pre_buffer} = undef;
    
    my $headers = $self->headers;
    $headers->parse((mutable string)$pre_buffer->get_string);
    
    unless ($headers->is_finished) {
      return;
    }
    
    $self->{chunk_state} = "finished";
    
    # Take care of leftover and replace Transfer-Encoding with Content-Length
    $self->{buffer}->push($headers->leftovers);
    $headers->remove("Transfer-Encoding");
    unless ($headers->content_length) {
      $headers->set_content_length($self->{real_size});
    }
  }
  
  private method _parse_headers : void () {
    
    my $headers = $self->headers;
    my $pre_buffer = $self->{pre_buffer};
    $self->{pre_buffer} = undef;
    
    $headers->parse((mutable string)$pre_buffer->get_string);
    unless ($headers->is_finished) {
      return;
    }
    $self->{state} = "body";
    
    # Take care of leftovers
    $self->{pre_buffer} = StringBuffer->new;
    $self->{pre_buffer}->push($headers->leftovers);
    my $leftovers = $self->{pre_buffer}->get_string;
    $self->{header_size} = $self->{raw_size} - length $leftovers;
    
  }

}
