.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "String::Formatter 3pm"
.TH String::Formatter 3pm "2013-11-09" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
String::Formatter \- build sprintf\-like functions of your own
.SH "VERSION"
.IX Header "VERSION"
version 0.102084
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use String::Formatter stringf => {
\&    \-as   => \*(Aqstr_rf\*(Aq,
\&    codes => {
\&      f => sub { $_ },
\&      b => sub { scalar reverse $_ },
\&      o => \*(AqOkay?\*(Aq,
\&    },
\&  };
\&
\&  print str_rf(\*(AqThis is %10f and this is %\-15b, %o\*(Aq, \*(Aqforward\*(Aq, \*(Aqbackward\*(Aq);
.Ve
.PP
\&...prints...
.PP
.Vb 1
\&  This is    forward and this is drawkcab       , okay?
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
String::Formatter is a tool for building sprintf-like formatting routines.
It supports named or positional formatting, custom conversions, fixed string
interpolation, and simple width-matching out of the box.  It is easy to alter
its behavior to write new kinds of format string expanders.  For most cases, it
should be easy to build all sorts of formatters out of the options built into
String::Formatter.
.PP
Normally, String::Formatter will be used to import a sprintf-like routine
referred to as "\f(CW\*(C`stringf\*(C'\fR", but which can be given any name you like.  This
routine acts like sprintf in that it takes a string and some inputs and returns
a new string:
.PP
.Vb 1
\&  my $output = stringf "Some %a format %s for you to %u.\en", { ... };
.Ve
.PP
This routine is actually a wrapper around a String::Formatter object created by
importing stringf.  In the following code, the entire hashref after \*(L"stringf\*(R"
is passed to String::Formatter's constructor (the \f(CW\*(C`new\*(C'\fR method), save for the
\&\f(CW\*(C`\-as\*(C'\fR key and any other keys that start with a dash.
.PP
.Vb 10
\&  use String::Formatter
\&    stringf => {
\&      \-as => \*(Aqfmt_time\*(Aq,
\&      codes           => { ... },
\&      format_hunker   => ...,
\&      input_processor => ...,
\&    },
\&    stringf => {
\&      \-as => \*(Aqfmt_date\*(Aq,
\&      codes           => { ... },
\&      string_replacer => ...,
\&      hunk_formatter  => ...,
\&    },
\&  ;
.Ve
.PP
As you can see, this will generate two stringf routines, with different
behaviors, which are installed with different names.  Since the behavior of
these routines is based on the \f(CW\*(C`format\*(C'\fR method of a String::Formatter object,
the rest of the documentation will describe the way the object behaves.
.PP
There's also a \f(CW\*(C`named_stringf\*(C'\fR export, which behaves just like the \f(CW\*(C`stringf\*(C'\fR
export, but defaults to the \f(CW\*(C`named_replace\*(C'\fR and \f(CW\*(C`require_named_input\*(C'\fR
arguments.  There's a \f(CW\*(C`method_stringf\*(C'\fR export, which defaults
\&\f(CW\*(C`method_replace\*(C'\fR and \f(CW\*(C`require_single_input\*(C'\fR.  Finally, a \f(CW\*(C`indexed_stringf\*(C'\fR,
which defaults to \f(CW\*(C`indexed_replaced\*(C'\fR and \f(CW\*(C`require_arrayref_input\*(C'\fR.  For more
on these, keep reading, and check out the cookbook.
.PP
String::Formatter::Cookbook provides a number of recipes for ways to put
String::Formatter to use.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.SS "format"
.IX Subsection "format"
.Vb 1
\&  my $result = $formatter\->format( $format_string, @input );
\&
\&  print $formatter\->format("My %h is full of %e.\en", \*(Aqhovercraft\*(Aq, \*(Aqeels\*(Aq);
.Ve
.PP
This does the actual formatting, calling the methods described above, under
\&\f(CW"new"\fR and returning the result.
.SS "format_hunker"
.IX Subsection "format_hunker"
Format hunkers are passed strings and return arrayrefs containing strings (for
fixed content) and hashrefs (for formatting code sections).
.PP
The hashref hunks should contain at least two entries:  \f(CW\*(C`conversion\*(C'\fR for the
conversion code (the s, d, or u in \f(CW%s\fR, \f(CW%d\fR, or \f(CW%u\fR); and \f(CW\*(C`literal\*(C'\fR for the
complete original text of the hunk.  For example, a bare minimum hunker should
turn the following:
.PP
.Vb 1
\&  I would like to buy %d %s today.
.Ve
.PP
\&...into...
.PP
.Vb 7
\&  [
\&    \*(AqI would like to buy \*(Aq,
\&    { conversion => \*(Aqd\*(Aq, literal => \*(Aq%d\*(Aq },
\&    \*(Aq \*(Aq,
\&    { conversion => \*(Aqs\*(Aq, literal => \*(Aq%d\*(Aq },
\&    \*(Aq today.\*(Aq,
\&  ]
.Ve
.PP
Another common entry is \f(CW\*(C`argument\*(C'\fR.  In the format strings expected by
\&\f(CW\*(C`hunk_simply\*(C'\fR, for example, these are free strings inside of curly braces.
These are used extensively other existing helpers for things liked accessing
named arguments or providing method names.
.SS "hunk_simply"
.IX Subsection "hunk_simply"
This is the default format hunker.  It implements the format string semantics
described above.
.PP
This hunker will produce \f(CW\*(C`argument\*(C'\fR and \f(CW\*(C`conversion\*(C'\fR and \f(CW\*(C`literal\*(C'\fR.  Its
other entries are not yet well-defined for public consumption.
.SS "input_processor"
.IX Subsection "input_processor"
The input processor is responsible for inspecting the post-format-string
arguments, validating them, and returning them in a possibly-transformed form.
The processor is passed an arrayref containing the arguments and should return
a scalar value to be used as the input going forward.
.SS "return_input"
.IX Subsection "return_input"
This input processor, the default, simply returns the input it was given with
no validation or transformation.
.SS "require_named_input"
.IX Subsection "require_named_input"
This input processor will raise an exception unless there is exactly one
post-format-string argument to the format call, and unless that argument is a
hashref.  It will also replace the arrayref with the given hashref so
subsequent phases of the format can avoid lots of needless array dereferencing.
.SS "require_arrayref_input"
.IX Subsection "require_arrayref_input"
This input processor will raise an exception unless there is exactly one
post-format-string argument to the format call, and unless that argument is a
arrayref.  It will also replace the input with that single arrayref it found so
subsequent phases of the format can avoid lots of needless array dereferencing.
.SS "require_single_input"
.IX Subsection "require_single_input"
This input processor will raise an exception if more than one input is given.
After input processing, the single element in the input will be used as the
input itself.
.SS "forbid_input"
.IX Subsection "forbid_input"
This input processor will raise an exception if any input is given.  In other
words, formatters with this input processor accept format strings and nothing
else.
.SS "string_replacer"
.IX Subsection "string_replacer"
The string_replacer phase is responsible for adding a \f(CW\*(C`replacement\*(C'\fR entry to
format code hunks.  This should be a string-value entry that will be formatted
and concatenated into the output string.  String replacers can also replace the
whole hunk with a string to avoid any subsequent formatting.
.SS "positional_replace"
.IX Subsection "positional_replace"
This replacer matches inputs to the hunk's position in the format string.  This
is the default replacer, used in the synopsis, above, which should
make its behavior clear.  At present, fixed-string conversions \fBdo not\fR affect
the position of arg matched, meaning that given the following:
.PP
.Vb 6
\&  my $formatter = String::Formatter\->new({
\&    codes => {
\&      f => \*(Aqfixed string\*(Aq,
\&      s => sub { ... },
\&    }
\&  });
\&
\&  $formatter\->format("%s %f %s", 1, 2);
.Ve
.PP
The subroutine is called twice, once for the input \f(CW1\fR and once for the input
\&\f(CW2\fR.  \fBThis behavior may change\fR after some more experimental use.
.SS "named_replace"
.IX Subsection "named_replace"
This replacer should be used with the \f(CW\*(C`require_named_input\*(C'\fR input processor.
It expects the input to be a hashref and it finds values to be interpolated by
looking in the hashref for the brace-enclosed name on each format code.  Here's
an example use:
.PP
.Vb 4
\&  $formatter\->format("This was the %{adj}s day in %{num}d weeks.", {
\&    adj => \*(Aqbest\*(Aq,
\&    num => 6,
\&  });
.Ve
.SS "indexed_replace"
.IX Subsection "indexed_replace"
This replacer should be used with the \f(CW\*(C`require_arrayref_input\*(C'\fR input
processor.  It expects the input to be an arrayref and it finds values to be
interpolated by looking in the arrayref for the brace-enclosed index on each
format code.  Here's an example use:
.PP
.Vb 1
\&  $formatter\->format("This was the %{1}s day in %{0}d weeks.", [ 6, \*(Aqbest\*(Aq ]);
.Ve
.SS "method_replace"
.IX Subsection "method_replace"
This string replacer method expects the input to be a single value on which
methods can be called.  If a value was given in braces to the format code, it
is passed as an argument.
.SS "keyed_replace"
.IX Subsection "keyed_replace"
This string replacer method expects the input to be a single hashref.  Coderef
code values are used as callbacks, but strings are used as hash keys.  If a
value was given in braces to the format code, it is ignored.
.PP
For example if the codes contain \f(CW\*(C`i => \*(Aqident\*(Aq\*(C'\fR then \f(CW%i\fR in the format
string will be replaced with \f(CW\*(C`$input\->{ident}\*(C'\fR in the output.
.SS "hunk_formatter"
.IX Subsection "hunk_formatter"
The hunk_formatter processes each the hashref hunks left after string
replacement and returns a string.  When it is called, it is passed a hunk
hashref and must return a string.
.SS "format_simply"
.IX Subsection "format_simply"
This is the default hunk formatter.  It deals with minimum and maximum width
cues as well as left and right alignment.  Beyond that, it does no formatting
of the replacement string.
.SH "FORMAT STRINGS"
.IX Header "FORMAT STRINGS"
Format strings are generally assumed to look like Perl's sprintf's format
strings:
.PP
.Vb 1
\&  There\*(Aqs a bunch of normal strings and then %s format %1.4c with %% signs.
.Ve
.PP
The exact semantics of the format codes are not totally settled yet \*(-- and they
can be replaced on a per-formatter basis.  Right now, they're mostly a subset
of Perl's astonishingly large and complex system.  That subset looks like this:
.PP
.Vb 4
\&  %    \- a percent sign to begin the format
\&  ...  \- (optional) various modifiers to the format like "\-5" or "#" or "2$"
\&  {..} \- (optional) a string inside braces
\&  s    \- a short string (usually one character) identifying the conversion
.Ve
.PP
Not all format modifiers found in Perl's \f(CW\*(C`sprintf\*(C'\fR are yet supported.
Currently the only format modifiers must match:
.PP
.Vb 3
\&    (\-)?          # left\-align, rather than right
\&    (\ed*)?        # (optional) minimum field width
\&    (?:\e.(\ed*))?  # (optional) maximum field width
.Ve
.PP
Some additional format semantics may be added, but probably nothing exotic.
Even things like \f(CW\*(C`2$\*(C'\fR and \f(CW\*(C`*\*(C'\fR are probably not going to appear in
String::Formatter's default behavior.
.PP
Another subtle difference, introduced intentionally, is in the handling of
\&\f(CW\*(C`%%\*(C'\fR.  With the default String::Formatter behavior, string \f(CW\*(C`%%\*(C'\fR is not
interpreted as a formatting code.  This is different from the behavior of
Perl's \f(CW\*(C`sprintf\*(C'\fR, which interprets it as a special formatting character that
doesn't consume input and always acts like the fixed string \f(CW\*(C`%\*(C'\fR.  The upshot
of this is:
.PP
.Vb 2
\&  sprintf "%%";   # ==> returns "%"
\&  stringf "%%";   # ==> returns "%%"
\&
\&  sprintf "%10%"; # ==> returns "         %"
\&  stringf "%10%"; # ==> dies: unknown format code %
.Ve
.PP
.Vb 7
\&  my $formatter = String::Formatter\->new({
\&    codes => { ... },
\&    format_hunker   => ...,
\&    input_processor => ...,
\&    string_replacer => ...,
\&    hunk_formatter  => ...,
\&  });
.Ve
.PP
This returns a new formatter.  The \f(CW\*(C`codes\*(C'\fR argument contains the formatting
codes for the formatter in the form:
.PP
.Vb 5
\&  codes => {
\&    s => \*(Aqfixed string\*(Aq,
\&    S => \*(Aqdifferent string\*(Aq,
\&    c => sub { ... },
\&  }
.Ve
.PP
Code values (or \*(L"conversions\*(R") should either be strings or coderefs.  This
hashref can be accessed later with the \f(CW\*(C`codes\*(C'\fR method.
.PP
The other four arguments change how the formatting occurs.  Formatting happens
in five phases:
.IP "1." 4
format_hunker \- format string is broken down into fixed and %\-code hunks
.IP "2." 4
input_processor \- the other inputs are validated and processed
.IP "3." 4
string_replacer \- replacement strings are generated by using conversions
.IP "4." 4
hunk_formatter \- replacement strings in hunks are formatted
.IP "5." 4
all hunks, now strings, are recombined; this phase is just \f(CW\*(C`join\*(C'\fR
.PP
The defaults are found by calling \f(CW\*(C`default_WHATEVER\*(C'\fR for each helper that
isn't given.  Values must be either strings (which are interpreted as method
names) or coderefs.  The semantics for each method are described in the
methods' sections, below.
.SH "HISTORY"
.IX Header "HISTORY"
String::Formatter is based on String::Format, written by
Darren Chamberlain.  For a history of the code, check the project's source code
repository.  All bugs should be reported to Ricardo Signes and
String::Formatter.  Very little of the original code remains.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Ricardo Signes <rjbs@cpan.org>
.IP "\(bu" 4
Darren Chamberlain <darren@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by Ricardo Signes <rjbs@cpan.org>.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The GNU General Public License, Version 2, June 1991
.Ve
