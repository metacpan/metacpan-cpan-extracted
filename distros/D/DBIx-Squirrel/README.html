<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:icampbell@eeyore.local" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#IMPORTING">IMPORTING</a>
        <ul>
          <li><a href="#Database-Entity-Helper-Functions">Database Entity Helper Functions</a>
            <ul>
              <li><a href="#Examples">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#CONNECTING-TO-DATABASES">CONNECTING TO DATABASES</a>
        <ul>
          <li><a href="#Cloning-database-connections">Cloning database connections</a></li>
        </ul>
      </li>
      <li><a href="#PREPARING-STATEMENTS">PREPARING STATEMENTS</a>
        <ul>
          <li><a href="#Placeholders">Placeholders</a>
            <ul>
              <li><a href="#Examples1">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#ITERATORS">ITERATORS</a>
        <ul>
          <li><a href="#Basic-Iterators">Basic Iterators</a>
            <ul>
              <li><a href="#How-to-create-a-basic-iterator">How to create a basic iterator</a></li>
            </ul>
          </li>
          <li><a href="#Fancy-Iterators">Fancy Iterators</a>
            <ul>
              <li><a href="#How-to-create-a-fancy-iterator">How to create a fancy iterator</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#TRANSFORMING-RESULTS">TRANSFORMING RESULTS</a>
        <ul>
          <li><a href="#Examples2">Examples</a></li>
        </ul>
      </li>
      <li><a href="#REFERENCE">REFERENCE</a>
        <ul>
          <li><a href="#DBIx::Squirrel-Class-Methods">DBIx::Squirrel Class Methods</a>
            <ul>
              <li><a href="#connect">connect *</a></li>
              <li><a href="#connect_cached">connect_cached *</a></li>
            </ul>
          </li>
          <li><a href="#Database-Handle-Methods">Database Handle Methods</a>
            <ul>
              <li><a href="#do">do *</a></li>
              <li><a href="#iterate">iterate</a></li>
              <li><a href="#prepare">prepare *</a></li>
              <li><a href="#prepare_cached">prepare_cached *</a></li>
              <li><a href="#results">results</a></li>
            </ul>
          </li>
          <li><a href="#Statement-Handle-Methods">Statement Handle Methods</a>
            <ul>
              <li><a href="#bind">bind</a></li>
              <li><a href="#bind_param">bind_param *</a></li>
              <li><a href="#execute">execute *</a></li>
              <li><a href="#iterate1">iterate</a></li>
              <li><a href="#results1">results</a></li>
            </ul>
          </li>
          <li><a href="#Iterator-Objects">Iterator Objects</a>
            <ul>
              <li><a href="#all">all</a></li>
              <li><a href="#buffer_size">buffer_size</a></li>
              <li><a href="#buffer_size_slice">buffer_size_slice</a></li>
              <li><a href="#count">count</a></li>
              <li><a href="#count_fetched">count_fetched</a></li>
              <li><a href="#execute1">execute</a></li>
              <li><a href="#first">first</a></li>
              <li><a href="#iterate2">iterate</a></li>
              <li><a href="#last">last</a></li>
              <li><a href="#last_fetched">last_fetched</a></li>
              <li><a href="#next">next</a></li>
              <li><a href="#one">one</a></li>
              <li><a href="#remaining">remaining</a></li>
              <li><a href="#reset">reset</a></li>
              <li><a href="#rows">rows</a></li>
              <li><a href="#single-or-one">single (or one)</a></li>
              <li><a href="#slice">slice</a></li>
              <li><a href="#slice_buffer_size">slice_buffer_size</a></li>
              <li><a href="#sth">sth</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
  <li><a href="#SUPPORT-WARRANTY">SUPPORT / WARRANTY</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DBIx::Squirrel - A <code>DBI</code> extension</p>

<h1 id="VERSION">VERSION</h1>

<p>version 1.3.4</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code># ------------------
# Import the package
# ------------------

use DBIx::Squirrel;

# We still have the freedom to accomplish tasks the familiar DBI-way.
#
$dbh = DBIx::Squirrel-&gt;connect($dsn, $user, $pass, \%attr);
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE Name=?&#39;);

if ( $sth-&gt;execute(&#39;Acme Rocket&#39;) ) {
    $row = $sth-&gt;fetchrow_hashref
    print $row-&gt;{Name}, &quot;\n&quot;;
    $sth-&gt;finish
}

# ------------------------------
# Import the package (variation)
# ------------------------------

use DBIx::Squirrel database_entities =&gt; [qw/db product/];

# Associate &quot;db&quot; with a database connection, then use &quot;db&quot; to reference
# it in future.
#
db(DBIx::Squirrel-&gt;connect($dsn, $user, $pass, \%attr));

# First, we need to associate &quot;product&quot; with a result set, then use
# &quot;product&quot; to reference it in future. The next time arguments are
# passed, they are treated as bind-values when the statement is
# executed.
#
product(db-&gt;results(&#39;SELECT * FROM product WHERE Name=?&#39;));

# Print the named product if there is one. The &quot;single&quot; method will
# finish the statement automatically.
#
print $_-&gt;Name, &quot;\n&quot; if product(&#39;Acme Rocket&#39;)-&gt;single;

# ----------------------------
# Cloning database connections
# ----------------------------

# Cloning connections created by the DBI, DBIx::Squirrel and
# subclasses is permitted.
#
$dbh = DBI-&gt;connect($dsn, $user, $pass, \%attr);
$clone = DBIx::Squirrel-&gt;connect($dbh);

# -----------------------------------------
# Parameter placeholders and binding values
# -----------------------------------------

# Several commonly used placeholder styles are supported and just work!
#
# Use the style you prefer. DBIx::Squirrel doesn&#39;t care about the DBD
# engine you are using. By the time the statement is prepared, it will
# have been normalised to use the legacy style (&quot;?&quot;) supported by all
# engines.
#
# Oracle
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id=:id&#39;);
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id=:1&#39;);

# Postgres
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id=$1&#39;);

# SQLite
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id=?1&#39;);

# MySQL, MariaDB and legacy
$sth = $dbh-&gt;prepare(&#39;SELECT * FROM product WHERE id=?&#39;);

# Able to bind values to individual parameters for both positional
# and named placeholder schemes.

# Use either of these calling styles when binding a value to a
# named placeholder; both are ok.
#
$sth-&gt;bind_param(id =&gt; &#39;1001099&#39;);
$sth-&gt;bind_param(&#39;:id&#39;, &#39;1001099&#39;);

# Use this calling styles when binding a values to a positional
# placeholder.
#
$sth-&gt;bind_param(1, &#39;1001099&#39;);

# Or, bind all values in one call.
#
$sth-&gt;bind( id =&gt; &#39;1001099&#39;, ... );
$sth-&gt;bind( &#39;:id&#39; =&gt; &#39;1001099&#39;, ... );
$sth-&gt;bind( &#39;1001099&#39;, ... );

# References are ok, too.
#
$sth-&gt;bind( { id =&gt; &#39;1001099&#39;, ... } );
$sth-&gt;bind( { &#39;:id&#39; =&gt; &#39;1001099&#39;, ... } );
$sth-&gt;bind( [ &#39;1001099&#39;, ... ] );

# You can also pass the bind values in the same manner to
# the &quot;execute&quot; and &quot;iterate&quot; methods.
#
$res = $sth-&gt;execute(...);
$res = $itr-&gt;execute(...);
$itr = $itr-&gt;iterate(...);

# --------------------------------------------
# The database connection object&#39;s &quot;do&quot; method
# --------------------------------------------

# WHEN CALLED IN SCALAR-CONTEXT, the &quot;do&quot; method is used exactly as
# it would when working with the DBI. The only difference is that
# the DBIx::Squirrel interface allows for more options in how
# bind-values are passed.
#
$res = $dbh-&gt;do(&#39;SELECT * FROM product WHERE id=?&#39;, &#39;1001099&#39;);
$res = $dbh-&gt;do(&#39;SELECT * FROM product WHERE id=?&#39;, [&#39;1001099&#39;]);
$res = $dbh-&gt;do(&#39;SELECT * FROM product WHERE id=:id&#39;, id =&gt; &#39;1001099&#39;);
$res = $dbh-&gt;do(&#39;SELECT * FROM product WHERE id=:id&#39;, &#39;:id&#39; =&gt; &#39;1001099&#39;);

# You must supply hash reference (or &quot;undef&quot;) as the statement attributes,
# when bind-values are presented as a hash reference.
#
$res = $dbh-&gt;do(
    &#39;SELECT * FROM product WHERE id=:id&#39;,
    undef | \%attr,
    { &#39;:id&#39; =&gt; &#39;1001099&#39;}
);
$res = $dbh-&gt;do(
    &#39;SELECT * FROM product WHERE id=:id&#39;,
    undef | \%attr,
    { id =&gt; &#39;1001099&#39; },
);

# WHEN CALLED IN LIST-CONTEXT, however, the &quot;do&quot; method works as
# described previously, but returns both the statement&#39;s execution
# result and its handle (in that order).
#
($res, $sth) = $dbh-&gt;do(...);

# ---------
# Iterators
# ---------

# Both database and statement objects can be used to generate two
# kinds of iterator.
#
# A basic iterator.
#
$itr = $dbh-&gt;iterate($query, \%attr, ...);
$itr = $sth-&gt;iterate(...);

# A fancy iterator (or result set).
#
$itr = $dbh-&gt;results($query, \%attr, ...);
$itr = $sth-&gt;results(...);

# When we only expect one row, and we require the statement to be
# finished after that row is fetched, we can call the &quot;single&quot;
# method (or its alias &quot;one&quot;).
#
# This method will emit a warning if there are more rows to fetch
# as a reminder to use &quot;LIMIT 1&quot; in your query.
#
$row = $itr-&gt;single(OPTIONAL-NEW-BIND-VALUES)
  or die &quot;No matching row!&quot;;

$row = $itr-&gt;one(OPTIONAL-NEW-BIND-VALUES)
  or die &quot;No matching row!&quot;;

# As above, but won&#39;t whinge if there were unexpectedly more rows
# available to be fetched.
#
$row = $itr-&gt;find(OPTIONAL-NEW-BIND-VALUES)
  or die &quot;No matching row!&quot;;

# Populate an array using &quot;next&quot;.
#
@ary = ();
push @ary, $_ while $itr-&gt;next;

@ary = $itr-&gt;first;
push @ary, $_ while $itr-&gt;next;

# Get everything at once.
#
@ary = $itr-&gt;first;
push @ary, $itr-&gt;remaining;

@ary = $itr-&gt;all;

# Having &quot;all&quot; return a reference is faster!
#
$ary_ref = $itr-&gt;all;

# Get the number of records. More memory efficient than &quot;count_all&quot;,
# since &quot;next&quot; is called after each record is read and discarded.
#
$num = $itr-&gt;count();

# Get the number of records. Not as memory efficient as &quot;count&quot;, since
# all rows are fetched at once and the size of the resulting array
# is returned.
#
$num = $itr-&gt;count_all();

# Reset an iterator so that it will be executed again.
#
$itr = $itr-&gt;reset();

# Reset the iterator. Also set the slice-style.
#
$itr = $itr-&gt;reset({});
$itr = $itr-&gt;reset([]);

# Reset the iterator. Also specify how many rows to slurp at a time.
#
$itr = $itr-&gt;reset(10);

# Reset the iterator. Set the slice style and how slurpy our row fetches
# are.
#
$itr = $itr-&gt;reset($slice, $row_count);
$itr = $itr-&gt;reset($row_count, $slice);

# --------------------
# Working with results
# --------------------

# Accessing column values using basic iterators.
#
$itr = $dbh-&gt;iterate(&#39;SELECT Id, Name FROM product WHERE Name=?&#39;)-&gt;reset([]);
if ($row = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single) {
    print &quot;Id: $row-&gt;[0]\n&quot;
}

$itr = $dbh-&gt;iterate(&#39;SELECT Id, Name FROM product WHERE Name=?&#39;)-&gt;reset({});
if ($row = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single) {
    print &quot;Id: $row-&gt;{Id}\n&quot;
}

# Accessing column values using using fancy iterators can be accomplished
# as shown above. Fancy iterators, however, don&#39;t care how your rows are
# sliced, because they also provide access to column values via on-demand
# accessors. You can use any case for accessors as they all resolve to
# the same column.
#
$itr = $dbh-&gt;results(&#39;SELECT Id, Name FROM product WHERE Name=?&#39;);
if ($row = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single) {
    print &quot;Id: &quot;, $row-&gt;Id, &quot;\n&quot;
}

$itr = $dbh-&gt;results(&#39;SELECT Id, Name FROM product WHERE Name=?&#39;);
if ($row = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single) {
    print &quot;Id: &quot;, $row-&gt;ID, &quot;\n&quot;
}

$itr = $dbh-&gt;results(&#39;SELECT Id, Name FROM product WHERE Name=?&#39;);
if ($row = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single) {
    print &quot;Id: &quot;, $row-&gt;id, &quot;\n&quot;
}

# ---------------
# Transformations
# ---------------

# A transformation is a sequence of one or more trailing code references
# passed to the method that generates the iterator. The initial result
# enters the first stage of the transformation as $_ (and in $_[0]). The
# result of that transformation is passed on to the next stage (or to the
# caller), with an explicit &quot;return&quot; statement or as the result of the
# sfinal expression.
#
# Transformations are a great way to declare, in one place, any common
# processing logic that should be applied automatically to results as
# they are fetched.
#
$itr = $dbh-&gt;iterate(
    &#39;SELECT Id, Name FROM product WHERE Name=?&#39; =&gt; sub {$_-&gt;[0]},
)-&gt;reset([]);
if ($id = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single) {
    print &quot;Id: $id\n&quot;
}

$itr = $dbh-&gt;iterate(
    &#39;SELECT Id, Name FROM product WHERE Name=?&#39; =&gt; sub {$_-&gt;{Id}},
)-&gt;reset({});
if ($id = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single) {
    print &quot;Id: $id\n&quot;
}

$itr = $dbh-&gt;results(
    &#39;SELECT Id, Name FROM product WHERE Name=?&#39; =&gt; sub {$_-&gt;Id},
);
if ($id = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single) {
    print &quot;Id: $id\n&quot;
}

# Transformation squences.
#
$itr = $dbh-&gt;results(
    &#39;SELECT Id, Name FROM product WHERE Name=?&#39; =&gt; sub {
        $_-&gt;Id;
    } =&gt; sub {
        my $result = $_;
        print &quot;Id: $result\n&quot;;
        return $result;
    },
);
$id = $itr-&gt;iterate(&#39;Acme Rocket&#39;)-&gt;single;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The <code>DBIx::Squirrel</code> package extends the <code>DBI</code> by providing a few extra conveniences that are subtle and additive in nature, and, hopefully, quite useful.</p>

<h2 id="IMPORTING">IMPORTING</h2>

<p>In the simplest case, just import the package as you would any other:</p>

<pre><code>use DBIx::Squirrel;</code></pre>

<p>Any symbols and tags that you would typically import from the <code>DBI</code> can also be requested via <code>DBIx::Squirrel</code>:</p>

<pre><code>use DBIx::Squirrel DBI-IMPORT-LIST;</code></pre>

<p>If required (and in addition to any <code>DBI</code> imports), <code>DBIx::Squirrel</code> can create and import Database Entity Helper functions for you:</p>

<pre><code>use DBIx::Squirrel database_entity=&gt;NAME;
use DBIx::Squirrel database_entities=&gt;[NAMES];</code></pre>

<h3 id="Database-Entity-Helper-Functions">Database Entity Helper Functions</h3>

<p>A database entity helper is nothing more than a standard function providing some syntactic sugar in the form of a polymorphic interface for interacting with database entities such as database connections, statements and iterators.</p>

<p>While it is not absolutely necessary to use them&mdash;you could just as easily use scalar references&mdash;helper functions do possess the advantage of being shared more easily among package namespaces than, say, lexical variables.</p>

<p>Helper semantics deal with three common types of interaction:</p>

<ul>

<li><p><b>Establishing an association</b></p>

<p>Before it can be used, a helper must first be associated with a database entity. This is accomplished by passing the function single argument: a reference to the associated object.</p>

<p>Once established, associations are <i>sticky</i> and cannot easily be undone. You should take care to create them once only, in a sensible place.</p>

<p>Use Perl&#39;s standard importing mechanisms (as shown above) to share associations among different package namespaces.</p>

</li>
<li><p><b>Resolving an association</b></p>

<p>Fetching the reference to the associated database entity is accomplished by calling the helper function without any arguments.</p>

<p>When no association exists in this scenario, a helper returns <code>undef</code>.</p>

</li>
<li><p><b>Addressing an association</b></p>

<p>Addressing an association amounts to doing something meaningful with it, and we accomplish this by calling the helper function with one or more arguments.</p>

<p>Once associated with a database entity, a helper function will consume any arguments that are passed to it and send a version of these to the database entity method that imparts meaning to the interaction.</p>

<p>Meaning in this context is determined by the type of association:</p>

<ul>

<li><p>for a database connection, a statement is prepared using the <code>prepare</code> method;</p>

</li>
<li><p>for statements and iterators, these are executed with the <code>execute</code> and <code>iterate</code> methods respectively.</p>

</li>
</ul>

<p><b>Clearly there is a paradox here</b>, and itcentres around those statements and iterators that take no parameters and expect no bind-values. In order to smooth-out this wrinkle, you can opt to enclose arguments inside an anonymous array or hash. When no bind-values are expected, you can coerce the helper into performing the execution by passing an empty ARRAYREF or HASHREF. Alternatively, you could just resolve the association and call the relevant method manually.</p>

</li>
</ul>

<h4 id="Examples">Examples</h4>

<ul>

<li><p>Let us do a full worked example. We will connect to a database, create and work with two result sets, one of which expects a single bind-value. Some concepts will be expanded upon and improved later, but it might be helpful to dip a toe in the water ahead of time:</p>

<pre><code>use DBIx::Squirrel database_entities =&gt; [ qw/db artists artist/ ];

# Associate helper (&quot;db&quot;) with our database connection:

@connect_args = ( &#39;dbi:SQLite:dbname=chinook.db&#39;, &#39;&#39;, &#39;&#39;, { sqlite_unicode =&gt; 1 } );
db( DBIx::Squirrel-&gt;connect(@connection_args) );

# Resolve the database connection helper (&quot;db&quot;), using it to
# associate helpers (&quot;artist&quot; and &quot;artists&quot;) with different
# result sets:

artist( db-&gt;results(&#39;SELECT * FROM artists WHERE Name=? LIMIT 1&#39;) );
artists( db-&gt;results(&#39;SELECT * FROM artists&#39;) );

# Address the helper (&quot;artist&quot;), passing it a bind-value, to get
# the ArtistId of the artist whose name is &quot;Aerosmith&quot;.
#
# We could have called &quot;next&quot; to get the only matching record, but by
# calling &quot;single&quot; (or &quot;first&quot;) we can ensure that there are no warnings
# about dangling active statements emitted when we disconnect from the
# database.

print artist(&#39;Aerosmith&#39;)-&gt;single-&gt;ArtistId, &quot;\n&quot;;

# Iterate over the &quot;artists&quot; result set, printing the Name-column for
# each artist. We don&#39;t need to trigger execution manually because
# the &quot;next&quot; method will do that for us, if it is necessary.

while ( artists-&gt;next ) {
    print $_-&gt;Name, &quot;\n&quot;;
};</code></pre>

</li>
</ul>

<h2 id="CONNECTING-TO-DATABASES">CONNECTING TO DATABASES</h2>

<p>Connecting to a database using <code>DBIx::Squirrel</code> may be done exactly as it would when using the <code>DBI</code>&#39;s <code>connect_cached</code> and <code>connect</code> methods.</p>

<h3 id="Cloning-database-connections">Cloning database connections</h3>

<p>The <code>connect</code> method implemented by the <code>DBIx::Squirrel</code> package offers an alternative form:</p>

<pre><code>$new_dbh = DBIx::Squirrel-&gt;connect($original_dbh, \%attr);</code></pre>

<p>This form clones another connection object and returns a brand new object that is blessed using the same class that invoked the <code>connect</code> method. The method will allow you to clone database connections created by the <code>DBI</code> and any subclasses (<code>DBIx::Squirrel</code> being one).</p>

<h2 id="PREPARING-STATEMENTS">PREPARING STATEMENTS</h2>

<p>Preparing a statement using <code>DBIx::Squirrel</code> may be done exactly as it would be done using the <code>DBI</code>&#39;s <code>prepare_cached</code> and <code>prepare</code> methods.</p>

<h3 id="Placeholders">Placeholders</h3>

<p>A nice quality-of-life improvement offered by <code>DBIx::Squirrel</code>&#39;s own implementation of the <code>prepare_cached</code> and <code>prepare</code> methods is their built-in ability to cope with a number of different placeholder styles:</p>

<ul>

<li><p>named (<code>:name</code>);</p>

</li>
<li><p>positional (<code>:number</code>, <code>$number</code>, <code>?number</code>);</p>

</li>
<li><p>legacy (<code>?</code>)</p>

</li>
</ul>

<p>It does not matter what style your <code>DBD</code>-driver supports, <code>DBIx::Squirrel</code> will happily deal with all of the above styles. Just pick the one that you prefer to work with, or use the one that is most suitable for the task at hand.</p>

<p>By the time your statement is passed to the <code>DBD</code>-driver for execution, both it and its bind-values will have been normalised to use the legacy style (<code>?</code>) supported by all drivers.</p>

<h4 id="Examples1">Examples</h4>

<ul>

<li><p>Legacy placeholders (<code>?</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=? LIMIT 1&#39;);

# Any of the following value-binding styles will work:
$res = $sth-&gt;execute(&#39;Aerosmith&#39;);
$res = $sth-&gt;execute([&#39;Aerosmith&#39;]);</code></pre>

</li>
<li><p>SQLite positional placeholders (<code>?number</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=?1 LIMIT 1&#39;);

# Any of the following value-binding styles will work:
$res = $sth-&gt;execute(&#39;Aerosmith&#39;);
$res = $sth-&gt;execute([&#39;Aerosmith&#39;]);</code></pre>

</li>
<li><p>PostgreSQL positional placeholders (<code>$number</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=$1 LIMIT 1&#39;);

# Any of the following value-binding styles will work:
$res = $sth-&gt;execute(&#39;Aerosmith&#39;);
$res = $sth-&gt;execute([&#39;Aerosmith&#39;]);</code></pre>

</li>
<li><p>Oracle positional placeholders (<code>:number</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=:1 LIMIT 1&#39;);

# Any of the following value-binding styles will work:
$res = $sth-&gt;execute(&#39;Aerosmith&#39;);
$res = $sth-&gt;execute([&#39;Aerosmith&#39;]);</code></pre>

</li>
<li><p>Oracle named placeholders (<code>:name</code>):</p>

<pre><code>$sth = $dbh-&gt;prepare(&#39;SELECT * FROM artists WHERE Name=:Name LIMIT 1&#39;);

# Any of the following value-binding styles will work:
$res = $sth-&gt;execute(Name =&gt; &#39;Aerosmith&#39;);
$res = $sth-&gt;execute( &#39;:Name&#39; =&gt; &#39;Aerosmith&#39;);
$res = $sth-&gt;execute({Name =&gt; &#39;Aerosmith&#39;});
$res = $sth-&gt;execute({&#39;:Name&#39; =&gt; &#39;Aerosmith&#39;});</code></pre>

</li>
</ul>

<h2 id="ITERATORS">ITERATORS</h2>

<p>In addition to statement objects, <code>DBIx::Squirrel</code> provides two kinds of iterator:</p>

<ul>

<li><p>Basic</p>

</li>
<li><p>Fancy, <i>or Result Sets</i></p>

</li>
</ul>

<h3 id="Basic-Iterators">Basic Iterators</h3>

<p>Basic iterators present row data as ARRAYREFs or HASHREFs depending on the slice-style currently in use. Column values are accessed either by column-index when using the ARRAYREF-slicing, or by column-name when using the HASHREF-slicing.</p>

<p>The default, row data is sliced as an ARRAYREF. The iterator &quot;reset&quot; method may be used to alter this behaviour.</p>

<h4 id="How-to-create-a-basic-iterator">How to create a basic iterator</h4>

<pre><code>$itr = $dbh-&gt;iterate(
    $query,
    [undef|\%attr,]
    [@bindvalues,]
    [@transforms]
);

$itr = $sth-&gt;iterate(
    [@bindvalues,]
    [@transforms]
);</code></pre>

<p>The <code>iterate</code> methods may be replaced by either of the <code>it</code> or <code>iterator</code> aliases, if preferred.</p>

<h3 id="Fancy-Iterators">Fancy Iterators</h3>

<p>Fancy iterators behave just like their basic alternatives, but the row data they present is blessed. Column values may continue to be accessed as they would be with basic iterators, but accessor methods may also be used to get column values. Such accessor methods are created the first time they are used.</p>

<h4 id="How-to-create-a-fancy-iterator">How to create a fancy iterator</h4>

<pre><code>$itr = $dbh-&gt;results(
    $query,
    [undef|\%attr,]
    [@bindvalues,]
    [@transforms]
);

$itr = $sth-&gt;results(
    [@bindvalues,]
    [@transforms]
);</code></pre>

<p>The <code>results</code> methods may be replaced by either of the <code>rs</code> or <code>resultset</code> aliases, if preferred.</p>

<h2 id="TRANSFORMING-RESULTS">TRANSFORMING RESULTS</h2>

<p>All <code>DBIx::Squirrel</code> iterators support an optional processing step called <i>transformation</i>.</p>

<p>Transformation can be summarised as the automatic, just-in-time processing, re-shaping or filtering of results, as they are fetched from the database and before they are handed-off to the caller.</p>

<p>A transformation is comprised of one or more processing stages. Each stage receives its version of the result, changes it or does something else it, and finally hands it off to the next stage, or to the caller if there are no more stages.</p>

<p>Recall that there are two kinds of iterator, and two methods to construct each:</p>

<pre><code>Basic Iterators              |  Fancy Iterators
-----------------------------|------------------------------
$itr = $dbh-&gt;iterate(        |  $itr = $dbh-&gt;results(
    $query,                  |      $query,
    [undef|\%attr,]          |      [undef|\%attr,]
    [@bindvalues,]           |      [@bindvalues,]
    [@transforms]            |      [@transforms]
);                           |  );
                             |
$itr = $sth-&gt;iterate(        |  $itr = $sth-&gt;results(
    [@bindvalues,]           |      [@bindvalues,]
    [@transforms]            |      [@transforms]
);                           |  );</code></pre>

<p>The final element of each constructor&#39;s argument-list is the transformation pipeline (<code>[@transforms]</code>). Each stage of this pipeline is an individual processing step, represented by a CODEREF (or a call that returns a CODEREF).</p>

<p>Each stage of a transformation receives the latest version of the result via the argument-list (<code>$_[0]</code> to be precise). For the sake of convenience (and for convention), this result is also available as <code>$_</code>. If you prefer to rely on something like <code>$_</code>, but would like something much less ephemeral, just <code>use DBIx::Squirrel::util &#39;result&#39;</code> and use the <code>result</code> function inside your transformation stage.</p>

<p>Handing off to the next stage, or the caller, is with an explicit <code>return</code> statement, or the result of evaluating the unit&#39;s final expression. Returning nothing&mdash;either <code>()</code>, or a bare <code>return</code>&mdash;from a processing step will filter the result out entirely, and no further processing steps will apply to it.</p>

<h3 id="Examples2">Examples</h3>

<ol>

<li><p>See script <code>examples/transformations/01.pl</code>:</p>

<pre><code>use DBIx::Squirrel database_entities =&gt; [qw/db get_artist_id_by_name/];

db do {
    DBIx::Squirrel-&gt;connect(
        &quot;dbi:SQLite:dbname=./t/data/chinook.db&quot;,
        &quot;&quot;,
        &quot;&quot;,
        {   PrintError     =&gt; !!0,
            RaiseError     =&gt; !!1,
            sqlite_unicode =&gt; !!1,
        },
    );
};

get_artist_id_by_name do {
    db-&gt;results(
        &quot;SELECT ArtistId, Name FROM artists WHERE Name=? LIMIT 1&quot; =&gt; sub {
            my($artist) = @_;
            print &quot;----\n&quot;;
            print &quot;Name: &quot;, $artist-&gt;Name, &quot;\n&quot;;
            return $artist;
        } =&gt; sub {$_-&gt;ArtistId}
    );
};

foreach my $name (&quot;AC/DC&quot;, &quot;Aerosmith&quot;, &quot;Darling West&quot;, &quot;Rush&quot;) {
    if (get_artist_id_by_name($name)-&gt;single) {
        print &quot;ArtistId: $_\n&quot;;
    }
}

db-&gt;disconnect();</code></pre>

<p>The script is comprised of four parts:</p>

<ul>

<li><p><b>Connect to the database</b></p>

<p>Here, I am not just connecting to the database. I am associating the resulting database connection handle with the <code>db</code> helper function, meaning I can refer to it as <code>db</code> in future.</p>

</li>
<li><p><b>Create the <code>get_artist_id_by_name</code> helper function</b></p>

<p>Here, I am constructing a fancy iterator and also associating it with the <code>get_artist_id_by_name</code> helper function. This means I can just call the <code>get_artist_id_by_name</code> function to execute the iterator in future.</p>

<p>Also here, I describe the the kind of processing I want applied to every single result produced by this iterator, expressed as a transformation pipeline that is comprised of two separate stages:</p>

<ul>

<li><p>I want the names of matched artists printed nicely on the console;</p>

</li>
<li><p>I am only intersted in getting back the artist&#39;s id.</p>

</li>
</ul>

</li>
<li><p><b>Query the database and process the results</b></p>

<p>Here, I&#39;m executing the query once for each one of four artists to get and print their artist ids.</p>

</li>
<li><p><b>Disconnect from the database</b></p>

<p>Just as we would with the <code>DBI</code>.</p>

</li>
</ul>

<p>Find the script and run it:</p>

<pre><code>$ perl -Ilib examples/transformations/01.pl
----
Name: AC/DC
ArtistId: 1
----
Name: Aerosmith
ArtistId: 3
----
Name: Rush
ArtistId: 128</code></pre>

<p>Notice that we got nothing back for one of our artists? That&#39;s because the artist in question is not in our database and we cannot apply a transformation to nothing, so nothing is returned.</p>

</li>
</ol>

<h2 id="REFERENCE">REFERENCE</h2>

<p>This section describes the <code>DBIx::Squirrel</code> interface.</p>

<p>Many of the methods (*) presented below may seem familiar to the experienced <code>DBI</code> user, and they should. They are documented here because <code>DBIx::Squirrel</code> makes subtle changes to their interfaces.</p>

<p>Such changes are additive and unobtrusive in nature, in most cases, resulting in additional calling forms rather than any change in outcome. Unless a documented deviation from the standard <code>DBI</code> behaviour exists, one may safely assume that the <code>DBI</code> documentation still applies.</p>

<p>Other parts of the <code>DBI</code> interface remain unaltered, as well as being accessible via <code>DBIx::Squirrel</code>.</p>

<h3 id="DBIx::Squirrel-Class-Methods">DBIx::Squirrel Class Methods</h3>

<h4 id="connect"><code>connect</code> *</h4>

<pre><code>$dbh = DBIx::Squirrel-&gt;connect($data_source, $username, $password)
            or die $DBIx::Squirrel::errstr;
$dbh = DBIx::Squirrel-&gt;connect($data_source, $username, $password, \%attr)
            or die $DBIx::Squirrel::errstr;
$clone_dbh = DBIx::Squirrel-&gt;connect($dbh)
            or die $DBIx::Squirrel::errstr;
$clone_dbh = DBIx::Squirrel-&gt;connect($dbh, \%attr)
            or die $DBIx::Squirrel::errstr;</code></pre>

<h4 id="connect_cached"><code>connect_cached</code> *</h4>

<pre><code>$dbh = DBIx::Squirrel-&gt;connect_cached($data_source, $username, $password)
            or die $DBIx::Squirrel::errstr;
$dbh = DBIx::Squirrel-&gt;connect_cached($data_source, $username, $password, \%attr)
            or die $DBIx::Squirrel::errstr;</code></pre>

<h3 id="Database-Handle-Methods">Database Handle Methods</h3>

<h4 id="do"><code>do</code> *</h4>

<pre><code>$rows = $dbh-&gt;do($statement)
            or die $dbh-&gt;errstr;
$rows = $dbh-&gt;do($statement, \%attr)
            or die ...;
$rows = $dbh-&gt;do($statement, \%attr, @bind_values)
            or die ...;
$rows = $dbh-&gt;do($statement, \%attr, %bind_mappings)
            or die ...;
$rows = $dbh-&gt;do($statement, \%attr, \@bind_values)
            or die ...;
$rows = $dbh-&gt;do($statement, \%attr, \%bind_mappings)
            or die ...;
$rows = $dbh-&gt;do($statement, @bind_values)
            or die ...;
$rows = $dbh-&gt;do($statement, %bind_mappings)
            or die ...;
$rows = $dbh-&gt;do($statement, \@bind_values)
            or die ...;
$rows = $dbh-&gt;do($statement, undef, \%bind_mappings)
            or die ...;</code></pre>

<p>Calling <code>do</code> in scalar-context works just as it does when using the <code>DBI</code>, although there are a few more calling forms.</p>

<p>Calling <code>do</code> in list-context, however, is new behaviour and results in the return of a list comprised of two elements: the number of rows affected by the statement, as well as the statement handle:</p>

<pre><code>($rows, $sth) = $dbh-&gt;do($statement)
            or die $dbh-&gt;errstr;
($rows, $sth) = $dbh-&gt;do($statement, \%attr)
            or die ...;
($rows, $sth) = $dbh-&gt;do($statement, \%attr, @bind_values)
            or die ...;
($rows, $sth) = $dbh-&gt;do($statement, \%attr, %bind_mappings)
            or die ...;
($rows, $sth) = $dbh-&gt;do($statement, \%attr, \@bind_values)
            or die ...;
($rows, $sth) = $dbh-&gt;do($statement, \%attr, \%bind_mappings)
            or die ...;
($rows, $sth) = $dbh-&gt;do($statement, @bind_values)
            or die ...;
($rows, $sth) = $dbh-&gt;do($statement, %bind_mappings)
            or die ...;
($rows, $sth) = $dbh-&gt;do($statement, \@bind_values)
            or die ...;
($rows, $sth) = $dbh-&gt;do($statement, undef, \%bind_mappings)
            or die ...;</code></pre>

<h4 id="iterate"><code>iterate</code></h4>

<pre><code>$itor = $dbh-&gt;iterate($statement)
            or die $dbh-&gt;errstr;
$itor = $dbh-&gt;iterate($statement, @transforms)
            or die $dbh-&gt;errstr;
$itor = $dbh-&gt;iterate($statement, \%attr)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, @transforms)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, @bind_values)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, @bind_values, @transforms)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, %bind_mappings)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, %bind_mappings, @transforms)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, \@bind_values)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, [@bind_values, @transforms])
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, \%bind_mappings)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \%attr, \%bind_mappings, @transforms)
            or die ...;
$itor = $dbh-&gt;iterate($statement, @bind_values)
            or die ...;
$itor = $dbh-&gt;iterate($statement, @bind_values, @transforms)
            or die ...;
$itor = $dbh-&gt;iterate($statement, %bind_mappings)
            or die ...;
$itor = $dbh-&gt;iterate($statement, %bind_mappings, @transforms)
            or die ...;
$itor = $dbh-&gt;iterate($statement, \@bind_values)
            or die ...;
$itor = $dbh-&gt;iterate($statement, [@bind_values, @transforms])
            or die ...;
$itor = $dbh-&gt;iterate($statement, undef, \%bind_mappings)
            or die ...;
$itor = $dbh-&gt;iterate($statement, undef, \%bind_mappings, @transforms)
            or die ...;</code></pre>

<h4 id="prepare"><code>prepare</code> *</h4>

<pre><code>$sth = $dbh-&gt;prepare($statement)          or die $dbh-&gt;errstr;
$sth = $dbh-&gt;prepare($statement, \%attr)  or die $dbh-&gt;errstr;</code></pre>

<p>The <code>prepare</code> method interface is identical in form to that provided by the <code>DBI</code>.</p>

<p><code>DBIx::Squirrel</code> permits the use of one of a number of valid placeholder styles (<code>:name</code>, <code>:number</code>, <code>$number</code>, <code>?number</code>, <code>?</code>) within the statement-string.</p>

<p>Statement-strings will be &quot;normalised&quot; to use the legacy <code>?</code> style, before being handed-off to the <code>DBI</code> method of the same name. In spite of this, you should still use key-value bindings if you opted for named placeholders.</p>

<h4 id="prepare_cached"><code>prepare_cached</code> *</h4>

<pre><code>$sth = $dbh-&gt;prepare_cached($statement)
$sth = $dbh-&gt;prepare_cached($statement, \%attr)
$sth = $dbh-&gt;prepare_cached($statement, \%attr, $if_active)</code></pre>

<p>The <code>prepare_cached</code> method interface is identical in form to that provided by the <code>DBI</code>.</p>

<p><code>DBIx::Squirrel</code> permits the use of one of a number of valid placeholder styles (<code>:name</code>, <code>:number</code>, <code>$number</code>, <code>?number</code>, <code>?</code>) within the statement-string.</p>

<p>Statement-strings will be &quot;normalised&quot; to use the legacy <code>?</code> style, before being handed-off to the <code>DBI</code> method of the same name. In spite of this, you should still use key-value bindings if you opted for named placeholders.</p>

<p>It is the normalised form of the statement that is cached by the <code>DBI</code>.</p>

<h4 id="results"><code>results</code></h4>

<pre><code>$itor = $dbh-&gt;results($statement)
            or die $dbh-&gt;errstr;
$itor = $dbh-&gt;results($statement, @transforms)
            or die $dbh-&gt;errstr;
$itor = $dbh-&gt;results($statement, \%attr)
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, @transforms)
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, @bind_values)
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, @bind_values, @transforms)
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, %bind_mappings)
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, %bind_mappings, @transforms)
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, \@bind_values)
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, [@bind_values, @transforms])
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, \%bind_mappings)
            or die ...;
$itor = $dbh-&gt;results($statement, \%attr, \%bind_mappings, @transforms)
            or die ...;
$itor = $dbh-&gt;results($statement, @bind_values)
            or die ...;
$itor = $dbh-&gt;results($statement, @bind_values, @transforms)
            or die ...;
$itor = $dbh-&gt;results($statement, %bind_mappings)
            or die ...;
$itor = $dbh-&gt;results($statement, %bind_mappings, @transforms)
            or die ...;
$itor = $dbh-&gt;results($statement, \@bind_values)
            or die ...;
$itor = $dbh-&gt;results($statement, [@bind_values, @transforms])
            or die ...;
$itor = $dbh-&gt;results($statement, undef, \%bind_mappings)
            or die ...;
$itor = $dbh-&gt;results($statement, undef, \%bind_mappings, @transforms)
            or die ...;</code></pre>

<h3 id="Statement-Handle-Methods">Statement Handle Methods</h3>

<h4 id="bind"><code>bind</code></h4>

<pre><code>$sth-&gt;bind(@bind_values);
$sth-&gt;bind(\@bind_values);
$sth-&gt;bind(%bind_mappings);
$sth-&gt;bind(\%bind_mappings);</code></pre>

<h4 id="bind_param"><code>bind_param</code> *</h4>

<pre><code>$sth-&gt;bind_param($p_num, $bind_value);
$sth-&gt;bind_param($p_num, $bind_value, \%attr);
$sth-&gt;bind_param($p_num, $bind_value, $bind_type);
$sth-&gt;bind_param($p_name, $bind_value);
$sth-&gt;bind_param($p_name, $bind_value, \%attr);
$sth-&gt;bind_param($p_name, $bind_value, $bind_type);</code></pre>

<h4 id="execute"><code>execute</code> *</h4>

<pre><code>$rv = $sth-&gt;execute;
$rv = $sth-&gt;execute(@bind_values);
$rv = $sth-&gt;execute(\@bind_values);
$rv = $sth-&gt;execute(%bind_mappings);
$rv = $sth-&gt;execute(\%bind_mappings);</code></pre>

<h4 id="iterate1"><code>iterate</code></h4>

<pre><code>$itor = $sth-&gt;iterate
            or die $dbh-&gt;errstr;
$itor = $sth-&gt;iterate(@bind_values)
            or die ...;
$itor = $sth-&gt;iterate(@transforms)
            or die $dbh-&gt;errstr;
$itor = $sth-&gt;iterate(@bind_values, @transforms)
            or die ...;
$itor = $sth-&gt;iterate(%bind_mappings)
            or die ...;
$itor = $sth-&gt;iterate(%bind_mappings, @transforms)
            or die ...;
$itor = $sth-&gt;iterate(\@bind_values)
            or die ...;
$itor = $sth-&gt;iterate([@bind_values, @transforms])
            or die ...;
$itor = $sth-&gt;iterate(\%bind_mappings)
            or die ...;
$itor = $sth-&gt;iterate(\%bind_mappings, @transforms)
            or die ...;</code></pre>

<h4 id="results1"><code>results</code></h4>

<pre><code>$itor = $sth-&gt;results
            or die $dbh-&gt;errstr;
$itor = $sth-&gt;results(@bind_values)
            or die ...;
$itor = $sth-&gt;results(@transforms)
            or die $dbh-&gt;errstr;
$itor = $sth-&gt;results(@bind_values, @transforms)
            or die ...;
$itor = $sth-&gt;results(%bind_mappings)
            or die ...;
$itor = $sth-&gt;results(%bind_mappings, @transforms)
            or die ...;
$itor = $sth-&gt;results(\@bind_values)
            or die ...;
$itor = $sth-&gt;results([@bind_values, @transforms])
            or die ...;
$itor = $sth-&gt;results(\%bind_mappings)
            or die ...;
$itor = $sth-&gt;results(\%bind_mappings, @transforms)
            or die ...;</code></pre>

<h3 id="Iterator-Objects">Iterator Objects</h3>

<h4 id="all"><code>all</code></h4>

<pre><code>@results = $itor-&gt;all;
$results_or_undef = $itor-&gt;all;</code></pre>

<p>Executes the iterator&#39;s underlying statement handle object.</p>

<p>When called in list-context, the <code>all</code> method returns an array of all matching row objects.</p>

<p>When called in scalar-context, this method returns a reference to an array of all matching row objects. Where no rows are matched, <code>undef</code> would be returned.</p>

<h4 id="buffer_size"><code>buffer_size</code></h4>

<pre><code>$buffer_size = $itor-&gt;buffer_size;
$itor = $itor-&gt;buffer_size($buffer_size);</code></pre>

<p>May be used to determine how many results the iterator makes available to fetch following each trip to the database.</p>

<p>To change this property, simply provide the new value as the argument. When used to change the buffer-size, a reference to the iterator is returned.</p>

<p>Normally, an iterator&#39;s buffer-size is set to a low initial value, greater than 1. It is usually gradually increased by a factor of two, up to a maximum, after every database read. This is done to improve performance when fetching large result sets.</p>

<p>Manually setting the iterator&#39;s buffer-size has the side-effect of fixing it at that value, preventing the kind of automatic adjustment described above.</p>

<p>The following package globals define the relevant default settings:</p>

<pre><code>$DBIx::Squirrel::it::DEFAULT_BUFFER_SIZE = 2;   # initial buffer-size
$DBIx::Squirrel::it::BUFFER_SIZE_LIMIT   = 64;  # maximum buffer-size</code></pre>

<h4 id="buffer_size_slice"><code>buffer_size_slice</code></h4>

<pre><code>($buffer_size, $slice) = $itor-&gt;buffer_size_slice();
$itor = $itor-&gt;buffer_size_slice($slice, $buffer_size);
$itor = $itor-&gt;buffer_size_slice($buffer_size, $slice);</code></pre>

<p>May be used to determine (a) how the iterator slices the results it fetches from the database, and (b) how many results it makes available to fetch following each trip to the database.</p>

<p>When called with no arguments, a list comprised of the following two iterator properties is returned:</p>

<ul>

<li><p><code>$buffer_size</code></p>

<p>The current size of the results buffer. That is, the current maximum number of results that are processed and ready to fetch after each trip to the database.</p>

</li>
<li><p><code>$slice</code></p>

<p>The how the iterator slices results fetched from the database. This may be an ARRAYREF or a HASHREF.</p>

</li>
</ul>

<p>To change these properties, simply provide the new values in the argument list. When used to change these properties, a reference to the iterator is returned.</p>

<p>Normally, an iterator&#39;s buffer-size is set to a low initial value, greater than 1. It is usually gradually increased by a factor of two, up to a maximum, after every database read. This is done to improve performance when fetching large result sets.</p>

<p>Manually setting the iterator&#39;s buffer-size has the side-effect of fixing it at that value, preventing the kind of automatic adjustment described above.</p>

<p>The following package globals define the relevant default settings:</p>

<pre><code>$DBIx::Squirrel::it::DEFAULT_SLICE       = [];  # slicing strategy
$DBIx::Squirrel::it::DEFAULT_BUFFER_SIZE = 2;   # initial buffer-size
$DBIx::Squirrel::it::BUFFER_SIZE_LIMIT   = 64;  # maximum buffer-size</code></pre>

<h4 id="count"><code>count</code></h4>

<pre><code>$count = $itor-&gt;count;</code></pre>

<p>Returns the total number of rows in the result set.</p>

<p>If the iterator&#39;s statement has not yet been executed, it will be, and <code>undef</code> will be returned if the statement was not executed successfully.</p>

<p>Any results remaining to be fetched are then fetched, counted and discarded, and the final count is returned.</p>

<p><i><b>BEWARE</b> that you should not use <code>next</code> after this method has been used!</i></p>

<h4 id="count_fetched"><code>count_fetched</code></h4>

<pre><code>$count = $itor-&gt;count_fetched;</code></pre>

<p>Returns the number of results fetched so far.</p>

<p>If the iterator&#39;s statement has not yet been executed, it will be. Zero will be returned if the statement executed successfully, otherwise <code>undef</code> is returned.</p>

<h4 id="execute1"><code>execute</code></h4>

<pre><code>$rv_or_undef = $itor-&gt;execute
$rv_or_undef = $itor-&gt;execute(@bind_values)
$rv_or_undef = $itor-&gt;execute(@transforms)
$rv_or_undef = $itor-&gt;execute(@bind_values, @transforms)
$rv_or_undef = $itor-&gt;execute(%bind_mappings)
$rv_or_undef = $itor-&gt;execute(%bind_mappings, @transforms)
$rv_or_undef = $itor-&gt;execute(\@bind_values)
$rv_or_undef = $itor-&gt;execute([@bind_values, @transforms])
$rv_or_undef = $itor-&gt;execute(\%bind_mappings)
$rv_or_undef = $itor-&gt;execute(\%bind_mappings, @transforms)</code></pre>

<p>Executes the iterator&#39;s underlying statement, as well as resetting the iterator&#39;s internal state.</p>

<p>When called with no arguments, any bind-values and transformations passed to the iterator at the time of construction will be honoured.</p>

<h4 id="first"><code>first</code></h4>

<pre><code>$result = $itor-&gt;first;</code></pre>

<p>Returns the first result in the result set, or <code>undef</code> if there were no results.</p>

<p>If the iterator&#39;s statement has not yet been executed, it will be, and <code>undef</code> will be returned if the statement was not executed successfully.</p>

<p>If the first result hasn&#39;t yet been fetched, it will be and the first result is fetched and cached. The cached value is returned.</p>

<p>The result of the statement&#39;s execution will be returned.</p>

<h4 id="iterate2"><code>iterate</code></h4>

<pre><code>$itor_or_undef = $itor-&gt;iterate
$itor_or_undef = $itor-&gt;iterate(@bind_values)
$itor_or_undef = $itor-&gt;iterate(@transforms)
$itor_or_undef = $itor-&gt;iterate(@bind_values, @transforms)
$itor_or_undef = $itor-&gt;iterate(%bind_mappings)
$itor_or_undef = $itor-&gt;iterate(%bind_mappings, @transforms)
$itor_or_undef = $itor-&gt;iterate(\@bind_values)
$itor_or_undef = $itor-&gt;iterate([@bind_values, @transforms])
$itor_or_undef = $itor-&gt;iterate(\%bind_mappings)
$itor_or_undef = $itor-&gt;iterate(\%bind_mappings, @transforms)</code></pre>

<p>Executes the iterator&#39;s underlying statement, as well as resetting the iterator&#39;s internal state.</p>

<p>When called with no arguments, any bind-values and transformations passed to the iterator at the time of construction will be honoured.</p>

<p>A reference to the iterator is returned if the statement was successfully executed, otherwise the method returns <code>undef</code>.</p>

<h4 id="last"><code>last</code></h4>

<pre><code>$result = $itor-&gt;last;</code></pre>

<p>Returns the last result in the result set.</p>

<p>If the iterator&#39;s statement has not yet been executed, it will be, and <code>undef</code> will be returned if the statement was not executed successfully.</p>

<p>Any results remaining to be fetched are then fetched and discarded, and the last result fetched is returned.</p>

<p><i><b>BEWARE</b> that you should not use <code>next</code> after this method has been used!</i></p>

<h4 id="last_fetched"><code>last_fetched</code></h4>

<pre><code>$result = $itor-&gt;last_fetched;</code></pre>

<p>Returns the last result fetched.</p>

<p>If the iterator&#39;s statement has not yet been executed, it will be, then <code>undef</code> is returned regardless of the statement execution&#39;s outcome.</p>

<p>If the statement was previously executed then the last result fetched is always cached. The cached value is returned.</p>

<h4 id="next"><code>next</code></h4>

<pre><code>$result = $itor-&gt;next;</code></pre>

<p>Returns the next result in the result set.</p>

<p>If the iterator&#39;s statement has not yet been executed, it will be, and <code>undef</code> will be returned if the statement was not executed successfully.</p>

<p>There are two potential side-effects that could result from a call to <code>next</code>:</p>

<ul>

<li><p>The first time it is called, the result returned will be cached and returned in any subsequent call to <code>first</code>.</p>

</li>
<li><p>Every time it is called, the most recent result returned will be cached and returned in any call to <code>last_fetched</code>, or <code>last</code> if it was the final result in the result set.</p>

</li>
</ul>

<h4 id="one"><code>one</code></h4>

<p>Alias (see <code>single</code>).</p>

<h4 id="remaining"><code>remaining</code></h4>

<pre><code>@results = $itor-&gt;remaining;
$results_or_undef = $itor-&gt;remaining;</code></pre>

<h4 id="reset"><code>reset</code></h4>

<pre><code>$itor = $itor-&gt;reset;</code></pre>

<p>Executes the iterator&#39;s underlying statement handle object and resets any internal state.</p>

<p>A reference to the iterator is always returned.</p>

<h4 id="rows"><code>rows</code></h4>

<pre><code>$rows = $itor-&gt;rows;</code></pre>

<p>Returns the number of rows aftected by non-SELECT statements.</p>

<h4 id="single-or-one"><code>single</code> (or <code>one</code>)</h4>

<pre><code>$result = $itor-&gt;single;</code></pre>

<p>Returns the first result in the result set, or <code>undef</code> if there were no results.</p>

<p>If the iterator&#39;s statement has not yet been executed, it will be, and <code>undef</code> will be returned if the statement was not executed successfully.</p>

<p>If the first result hasn&#39;t yet been fetched, it will be and the first result is fetched and cached. The cached value is returned.</p>

<p>If the result returned is one of many buffered, a warning will be issued:</p>

<pre><code>Query would yield more than one result...</code></pre>

<p>The warning is a reminder to include a LIMIT 1 constraint in the statement.</p>

<h4 id="slice"><code>slice</code></h4>

<pre><code>$slice = $itor-&gt;slice;
$itor = $itor-&gt;slice($slice);</code></pre>

<p>May be used to determine how the iterator slices the results it fetches from the database. This may be an ARRAYREF or a HASHREF.</p>

<p>To change this property, simply provide the new value as the argument. When used to change the slicing strategy, a reference to the iterator is returned.</p>

<p>The following package global defines the default setting:</p>

<pre><code>$DBIx::Squirrel::it::DEFAULT_SLICE       = [];  # slicing strategy</code></pre>

<h4 id="slice_buffer_size"><code>slice_buffer_size</code></h4>

<pre><code>($slice, $buffer_size) = $itor-&gt;slice_buffer_size;
$itor = $itor-&gt;slice_buffer_size($slice, $buffer_size);
$itor = $itor-&gt;slice_buffer_size($buffer_size, $slice);</code></pre>

<p>May be used to determine (a) how the iterator slices the results it fetches from the database, and (b) how many results it makes available to fetch following each trip to the database.</p>

<p>When called with no arguments, a list comprised of the following two iterator properties is returned:</p>

<ul>

<li><p><code>$slice</code></p>

<p>The how the iterator slices results fetched from the database. This may be an ARRAYREF or a HASHREF.</p>

</li>
<li><p><code>$buffer_size</code></p>

<p>The current size of the results buffer. That is, the current maximum number of results that are processed and ready to fetch after each trip to the database.</p>

</li>
</ul>

<p>To change these properties, simply provide the new values in the argument list. When used to change these properties, a reference to the iterator is returned.</p>

<p>Normally, an iterator&#39;s buffer-size is set to a low initial value, greater than 1. It is usually gradually increased by a factor of two, up to a maximum, after every database read. This is done to improve performance when fetching large result sets.</p>

<p>Manually setting the iterator&#39;s buffer-size has the side-effect of fixing it at that value, preventing the kind of automatic adjustment described above.</p>

<p>The following package globals define the relevant default settings:</p>

<pre><code>$DBIx::Squirrel::it::DEFAULT_SLICE       = [];  # slicing strategy
$DBIx::Squirrel::it::DEFAULT_BUFFER_SIZE = 2;   # initial buffer-size
$DBIx::Squirrel::it::BUFFER_SIZE_LIMIT   = 64;  # maximum buffer-size</code></pre>

<h4 id="sth"><code>sth</code></h4>

<pre><code>$sth = $itor-&gt;sth;</code></pre>

<p>Returns the iterator&#39;s underlying statement handle object.</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>The DBIx::Squirrel module is Copyright (c) 2020-2014 Iain Campbell. All rights reserved.</p>

<p>You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the Perl 5.10.0 README file.</p>

<h1 id="SUPPORT-WARRANTY">SUPPORT / WARRANTY</h1>

<p>DBIx::Squirrel is free Open Source software. IT COMES WITHOUT WARRANTY OF ANY KIND.</p>


</body>

</html>


