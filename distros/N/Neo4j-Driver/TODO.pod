
=encoding utf8

=head1 TODO

This software has pre-release quality. The interface is not yet stable.

=head2 L<Neo4j::Driver>

=over

=item * Write tests.

=item * Remove C<close> method.

=item * Consider if the 6 second timeout is too long. It should in fact be as
short as reasonably possible.

=item * The driver should accept a setting that specifies the expected server
version. The driver could use this to work around server bugs or known
differences between versions, such as the Cypher parameter syntax. If not used,
the default should be to use the most recent version. Neo4j appears to use
SemVer versioning, but in order to avoid a C<SemVer> dependency here, it's
probably best to rely just on C<< version->declare >>. (The exact behaviour
must be documented.) That could look like this:
C<< $d = Neo4j::Driver->new; $d->{server} = 'v3.2.1'; >>

=item * An C<option> method could be provided to supply rarely needed settings
to the driver or session, such as the network timeout, the expected server
version or whether or not to request graph results. So far, such settings are
set using attributes. An C<option> method would be chainable by returning
C<$self>. Using it could look like this:
C<< $d = Neo4j::Driver->new->option(timeout => 10)->basic_auth('neo4j', 'neo4j') >>

=back

=head2 L<Neo4j::Driver::Session>

=over

=item * Remove C<close> method. L<Neo4j::Bolt::Cxn> automatically closes the
connection in the destructor, and HTTP transactions are rolled back on timeout,
so an explicit C<close> method quite simply is superfluous.

=item * Sessions of some of the official drivers can have at most one
transaction running at a time. This restriction is not necessary for this Perl
driver when HTTP is used, but perhaps we should implement it anyway for
consistency.

=item * L<DBI> uses C<begin_work> in place of C<begin_transaction> as a method
name. Even though C<begin_work> is shorter, it should not be the main method
name because C<begin_transaction> is well established in the official Neo4j
drivers, and after all this is I<not> C<DBI>. However, as this is the only
(almost) exact equivalence with C<DBI> that we have, we should perhaps offer
C<begin_work> as an experimental alias at least.

=item * Consider whether to offer
L<transaction functions|https://neo4j.com/docs/driver-manual/current/sessions-transactions/#driver-transactions-transaction-functions>.
If available, these should consist of subrefs passed to methods called
C<write_transaction> and C<read_transaction>. These access modes are only an
optimisation for Enterprise features. We don't target those at present, but
C<read_transaction> could then eventually be routed to a high-performance
read-only server once clusters are supported. It would make sense to offer
both methods right away even though initially they'd work exactly the same.

=back

=head2 L<Neo4j::Driver::Transaction>

=over

=item * The option to send multiple statements at once should no longer be
exposed to the client. It should only be used internally for running statements
lazily.

=item * Consider unrolling C<deep_bless> recursion. Based on initial profiling,
this may save up to about 5% CPU time (for a specific HTTP test query cached in
RAM, performance went from about 2700/s to 2850/s when skipping the call to
C<deep_bless> entirely). However, when accessing the database, the bottleneck
is typically I/O (querying Neo4j itself instead of the RAM-cached response let
the performance for the very same query drop down to 650/s when executed over
HTTP). So this optimisation may not be worth it (OTOH, Bolt performance was
something like 7000/s, so optimising C<deep_bless> may be more useful there).

=item * An alternative to using C<< $client->{_res}->status_line >>
(to get the HTTP error message) might be to call
C<< $client->getUseragent->add_handler(response_header => sub { $status_line = shift->status_line }) >>.
However, this is probably slower and would likely need to be run for each and
every POST including those with C<2xx> status codes, which might not be
acceptable.

=item * Disabling C<die_on_error> probably makes errors harder to find, but has
no clear advantages. In particular, errors are often missing the proper header
fields for the commit URL etc., so it's likely the failed request doesn't
produce useful return values and the next request will fail anyway with a
misleading error message due to the URLs being corrupted. This feature is not
present in the official drivers anyway; it was inspired by Neo4p and should
probably be removed completely.

=item * Consider supporting re-using C<Record> objects for query parameters in
C<run>. The Java and C# drivers do this.

=item * Profile whether C<Tie::IxHash> or sorting C<JSON:PP> is quicker and
adjust the code accordingly. Note, however, that the testing simulator requires
fully sorted JSON, so C<Tie::IxHash> may not be enough.

=item * Investigate which JSON module is the best. While C<Cpanel::JSON::XS>
may have some advantages in terms of correctness (I think?), maybe
C<JSON::MaybeXS> is more compatible.

=item * Run statements lazily: Just like with the official drivers, statements
passed to C<run> should be gathered until their results are actually accessed.
Then, and only then, all statements gathered so far should be sent to the
server using a single request. Challenges of this approach include that
notifications are not associated with a single statement, so there must be an
option to disable this behaviour; indeed, disabled should probably be the
default when stats are requested. Additionally, there are some bugs with
multiple statements (see tests C<non-arrayref individual statement> and
C<include empty statement>). Since stats are now requested by default,
this item might mean investing time in developing an optimisation
feature that is almost never used. Since the server is often run on localhost
anyway where latency is very close to zero, this item should not have high
priority.

=item * Replace old C<{}> parameter style with new C<$> style; see
L<https://neo4j.com/docs/cypher-manual/current/deprecations-additions-removals-compatibility/>.

=back

=head2 L<Neo4j::Driver::StatementResult>

=over

=back

=head2 L<Neo4j::Driver::Record>

=over

=item * B<Bugfix:> C<get> should croak if the call is ambiguous (i. e., there's
more than one field but the field to get is not specified by argument). Note,
though, that the Python driver intentionally does deliver the first field only
in this exact scenario (though its method is called C<value> instead of
C<get>).

=item * Consider whether to implement methods to query the list of fields for
this record (C<keys>, C<has>, C<size>) and/or a mapping function for all fields
(C<map>/C<forEach>). Given that this data should easily be available through
the StatementResult object, these seem slightly superfluous though.

=item * Implement C<graph>; see
L<https://github.com/neo4j/neo4j/blob/3.5/community/server/src/main/java/org/neo4j/server/rest/transactional/GraphExtractionWriter.java>,
L<https://github.com/neo4j/neo4j-python-driver/wiki/1.6-changelog#160a1>.

=back

=head2 L<Neo4j::Driver::ResultColumns>

=over

=item * B<Bugfix:> The C<get> method behaves unpredictably for queries
that have fields with conflicting indexes and keys such as C<RETURN 1, 0>.
It would technically be possible to distinguish between a key and an index
by inspecting the scalar's FLAGS (namely, C<POK>/C<IOK>; see
L<https://metacpan.org/pod/Devel::Peek#EXAMPLES> and C<JSON::PP>'s
C<_looks_like_number>). Then C<get(0)> would mean I<index> C<0> and C<get('0')>
would mean I<key> C<0>. Not sure if this is the best approach though.
(FWIW, it's exactly what the JS driver does.)

=item * The C<list> implementation is quite ugly and probably has bugs with
regards to index/key collisions.

=back

=head2 L<Neo4j::Driver::ResultSummary>

=over

=item * Profile the server-side performance penalty of requesting stats for
various kinds of queries. If the penalty turns out to be high, stats should
perhaps have to be requested explicitly by clients (rather than being
obtained by default, as with 0.13 and higher). However, using Bolt always
provides stats, and different APIs for HTTP and Bolt seem like a bad idea.

=item * Add timers.

=back

=head2 L<Neo4j::Driver::SummaryCounters>

=over

=item * C<use Class::Accessor::Fast 0.34;>

=back

=head2 Neo4j::Driver::Type::*

=over

=item * Implement spatial and temporal types.

=item * The C<eq> and C<ne> operators should be overloaded to allow
for ID comparison on nodes and relationships.

=item * Consider whether to use C<use overload '%{}'> to allow direct
access to e. g. properties using the pre-0.13 hashref syntax. See
L<https://metacpan.org/pod/overload#Two-face-References> for an example.

=back
