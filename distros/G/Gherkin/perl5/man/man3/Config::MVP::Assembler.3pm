.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Config::MVP::Assembler 3pm"
.TH Config::MVP::Assembler 3pm "2021-01-10" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::MVP::Assembler \- multivalue\-property config\-loading state machine
.SH "VERSION"
.IX Header "VERSION"
version 2.200012
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
First, you should probably read the example of using
Config::MVP.  If you already know how it works, keep
going.
.PP
Config::MVP::Assembler is a helper for constructing a Config::MVP::Sequence
object.  It's a very simple state machine that lets you signal what kind of
events you've encountered while reading configuration.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "sequence_class"
.IX Subsection "sequence_class"
This attribute stores the name of the class to be used for the assembler's
sequence.  It defaults to Config::MVP::Sequence.
.SS "section_class"
.IX Subsection "section_class"
This attribute stores the name of the class to be used for sections created by
the assembler.  It defaults to Config::MVP::Section.
.SS "sequence"
.IX Subsection "sequence"
This is the sequence that the assembler is assembling.  It defaults to a new
instance of the assembler's \f(CW\*(C`sequence_class\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "begin_section"
.IX Subsection "begin_section"
.Vb 1
\&  $assembler\->begin_section($package_moniker, $name);
\&
\&  $assembler\->begin_section($package_moniker);
\&
\&  $assembler\->begin_section( \e$package );
.Ve
.PP
This method tells the assembler that it should begin work on a new section with
the given identifier.  If it is already working on a section, an error will be
raised.  See \f(CW"change_section"\fR for a method to begin a new section, ending
the current one if needed.
.PP
The package moniker is expanded by the \f(CW"expand_package"\fR method.  The name,
if not given, defaults to the package moniker.  These data are used to create a
new section and the section is added to the end of the sequence.  If the
package argument is a reference, it is used as the literal value for the
package, and no expansion is performed.  If it is a reference to undef, a
section with no package is created.
.SS "end_section"
.IX Subsection "end_section"
.Vb 1
\&  $assembler\->end_section;
.Ve
.PP
This ends the current section.  If there is no current section, an exception is
raised.
.SS "change_section"
.IX Subsection "change_section"
.Vb 1
\&  $assembler\->change_section($package_moniker, $name);
\&
\&  $assembler\->change_section($package_moniker);
.Ve
.PP
This method calls \f(CW\*(C`begin_section\*(C'\fR, first calling \f(CW\*(C`end_section\*(C'\fR if needed.
.SS "add_value"
.IX Subsection "add_value"
.Vb 1
\&  $assembler\->add_value( $name => $value );
.Ve
.PP
This method tells the assembler that it has encountered a named value and
should add it to the current section.  If there is no current section, an
exception is raised.  (If this is not the first time we've seen the name in the
section and it's not a multivalue property, the section class will raise an
exception on its own.)
.SS "expand_package"
.IX Subsection "expand_package"
This method is passed a short identifier for a package and is expected to
return the full name of the module to load and package to interrogate.  By
default it simply returns the name it was passed, meaning that package names
must be given whole to the \f(CW\*(C`change_section\*(C'\fR method.
.SS "current_section"
.IX Subsection "current_section"
This returns the section object onto which the assembler is currently adding
values.  If no section has yet been created, this method will return false.
.SH "TYPICAL USE"
.IX Header "TYPICAL USE"
.Vb 1
\&  my $assembler = Config::MVP::Assembler\->new;
\&
\&  # Maybe you want a starting section:
\&  my $starting_section = $assembler\->section_class\->new({ name => \*(Aq_\*(Aq });
\&  $assembler\->sequence\->add_section($section_starting);
\&
\&  # We\*(Aqll add some values, which will go to the starting section:
\&  $assembler\->add_value(x => 10);
\&  $assembler\->add_value(y => 20);
\&
\&  # Change to a new section...
\&  $assembler\->change_section($moniker);
\&
\&  # ...and add values to that section.
\&  $assembler\->add_value(x => 100);
\&  $assembler\->add_value(y => 200);
.Ve
.PP
The code above creates an assembler and populates it step by step.  In the end,
to get values, you could do something like this:
.PP
.Vb 1
\&  my @output;
\&
\&  for my $section ($assembler\->sequence\->sections) {
\&    push @output, [ $section\->name, $section\->package, $section\->payload ];
\&  }
.Ve
.PP
When changing sections, the given section \*(L"moniker\*(R" is used for the new section
name.  The result of passing that moniker to the assembler's
\&\f(CW"expand_package"\fR method is used as the section's package name.  (By
default, this method does nothing.)  The new section's \f(CW\*(C`multivalue_args\*(C'\fR and
\&\f(CW\*(C`aliases\*(C'\fR are determined by calling the \f(CW\*(C`mvp_multivalue_args\*(C'\fR and
\&\f(CW\*(C`mvp_aliases\*(C'\fR methods on the package.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2021 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
