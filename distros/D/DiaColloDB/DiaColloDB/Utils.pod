##========================================================================
## POD DOCUMENTATION, auto-generated by podextract.perl

##========================================================================
## NAME
=pod

=head1 NAME

DiaColloDB::Utils - diachronic collocation database, generic utilities

=cut

##========================================================================
## SYNOPSIS
=pod

=head1 SYNOPSIS

 ##========================================================================
 ## PRELIMINARIES
 
 use DiaColloDB::Utils;
 
 ##========================================================================
 ## Functions: Fcntl
 
 $flags = PACKAGE::fcflags($flags);
 $flags = PACKAGE::fcgetfl($fh);
 $bool = fcread($flags);
 $bool = fcwrite($flags);
 $bool = fctrunc($flags);
 $bool = fccreat($flags);
 $fh_or_undef = fcopen($file,$flags);
 
 ##========================================================================
 ## JSON: load
 
 $data = PACKAGE::loadJsonString( $string,%opts);
 $data = PACKAGE::loadJsonFile($filename_or_handle,%opts);
 
 ##========================================================================
 ## JSON: save
 
 $str = PACKAGE::saveJsonString($data);
 $bool = PACKAGE::saveJsonFile($data,$filename_or_handle,%opts);
 
 ##========================================================================
 ## Functions: env
 
 \%setenv = PACKAGE::env_set(%setenv);
 \%restored = PACKAGE::env_pop(%setenv);
 
 ##========================================================================
 ## Functions: run
 
 $fh_or_undef = PACKAGE::opencmd($cmd);
 $bool = crun(@IPC_Run_args);
 $bool = csort_to(\@sortargs, \&catcher);
 $bool = csortuc_to(\@sortargs, \&catcher);
 $cmd = sortCmd();

 ##========================================================================
 ## Functions: pack filters
 
 $len = PACKAGE::packsize($packfmt);
 \&filter_sub = PACKAGE::packFilterStore($pack_template);
 \&filter_sub = PACKAGE::packFilterFetch($pack_template);
 
 ##========================================================================
 ## Math stuff
 
 $log2 = log2($x);
 $max2 = max2($x,$y);
 $min2 = min2($x,$y);
 
 ##========================================================================
 ## Functions: lists
 
 \@l_uniq        = luniq(\@l);
 \@l_sorted_uniq = sluniq(\@l_sorted);
 \@l_uniq        = xluniq(\@l,\&keyfunc);
 
 ##========================================================================
 ## Functions: regexes
 
 $re = regex($re_str);
 
 ##========================================================================
 ## Functions: html
 
 $escaped = htmlesc($str);
 
 ##========================================================================
 ## Functions: time
 
 $hms     = PACKAGE::s2hms($seconds,$sfmt="%06.3f");
 $timestr = PACKAGE::s2timestr($seconds,$sfmt="%f");
 $rfc_timestamp = PACAKGE->timestamp();
 
 ##========================================================================
 ## Functions: file
 
 $mtime = PACKAGE->file_mtime($file_or_fh);
 $timestamp = PACKAGE->file_timestamp($file_or_fh);
 
 $nbytes = du_file(@filenames_or_fh);
 $nbytes = du_glob(@globs);
 
 $bool = PACKAGE->copyto  ($src_filename_or_array, $dstdir, %opts);
 $bool = PACKAGE->copyto_a($src_filename_or_array, $dstdir, %opts);
 $bool = PACKAGE->moveto  ($src_filename_or_array, $dstdir, %opts);
 $bool = PACKAGE->cp_a    ($src_filename_or_array, $dstdir);
 
 ##========================================================================
 ## Utils: SI
 
 $str = si_str($float);
 
 ##========================================================================
 ## Functions: pdl: setops
 
 $pi = CLASS::_intersect_p($p1,$p2);
 $pu = CLASS::_union_p($p1,$p2);
 $pneg = CLASS::_complement_p($p,$N);
 $pdiff = CLASS::_setdiff_p($a,$b,$N);
 
 ##========================================================================
 ## Functions: pdl
 
 $pdl_or_undef = CLASS->readPdlFile($basename, %opts);
 $bool = CLASS->writePdlFile($pdl_or_undef, $basename, %opts);
 $bool = CLASS->writePdlHeader($filename, $type, $ndims, @dims);
 $bool = CLASS->writeCcsHeader($filename, $itype, $vtype, $pdims, %opts);
 
 $pdl  = mmzeroes($file?, $type?, @dims, \%opts?);
 $bool = mmunlink(@mmfiles);
 
 $type   = CLASS->mintype($pdl,    @types);
 $maxval = $type->maxval();
 ($vals,$counts) = $pdl->valcounts();
 
 ##========================================================================
 ## Functions: temporaries
 
 $tmpdir = CLASS->tmpdir();
 $fh = CLASS->tmpfh();
 $filename = CLASS->tmpfile();
 \@tmparray = CLASS->tmparray($template, %opts);
 \@tmparrayp = CLASS->tmparrayp($template, $packas, %opts);
 \%tmphash = CLASS->tmphash($class, $template, %opts);
 
 ##========================================================================
 ## Functions: parallelization
 
 $ncores   = CLASS->nCores();
 $njobs    = CLASS->nJobs();
 $sortjobs = CLASS->sortJobs();
 

=cut

##========================================================================
## DESCRIPTION
=pod

=head1 DESCRIPTION

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Globals
=pod

=head2 Globals

=over 4

=item Variable: @ISA

DiaColloDB::Utils
inherits from
L<Exporter|Exporter>
and
L<DiaColloDB::Logger|DiaColloDB::Logger>.

=item Variable: %EXPORT_TAGS

Exportable tags:

 fcntl => [qw(fcflags fcgetfl fcread fcwrite fctrunc fccreat fcperl fcopen)],
 json  => [qw(loadJsonString loadJsonFile saveJsonString saveJsonFile)],
 sort  => [qw(csort_to csortuc_to sortCmd)],
 run   => [qw(crun opencmd)],
 env   => [qw(env_set env_push env_pop)],
 pack  => [qw(packsize packsingle packFilterFetch packFilterStore)],
 math  => [qw($LOG2 log2 min2 max2)],
 list  => [qw(luniq sluniq xluniq)],
 regex => [qw(regex)],
 html  => [qw(htmlesc)],
 time  => [qw(s2hms s2timestr timestamp)],
 file  => [qw(file_mtime file_timestamp du_file du_glob copyto copyto_a moveto cp_a fh_flush fh_reopen)],
 si    => [qw(si_str)],
 pdl   => [qw(_intersect_p _union_p _complement_p _setdiff_p),
	   qw(readPdlFile writePdlFile writePdlHeader writeCcsHeader mmzeroes mmtemp),
	   qw(maxval mintype),
          ],
 temp  => [qw($TMPDIR tmpdir tmpfh tmpfile tmparray tmparrayp tmphash)],
 jobs  => [qw(nCores nJobs sortJobs)],


=item Variable: @EXPORT_OK

All symbols in %EXPORT_TAGS are exportable

=item Variable: @EXPORT

All symbols in %EXPORT_TAGS are exported by default.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: Fcntl
=pod

=head2 Functions: Fcntl

=over 4

=item fcflags

 $flags = PACKAGE::fcflags($flags);

returns L<Fcntl|Fcntl> flags for symbolic string $flags

=item fcgetfl

 $flags = PACKAGE::fcgetfl($fh);

returns L<Fcntl|Fcntl> flags for filehandle $fh

=item fcread

 $bool = fcread($flags);

returns true if any read-bits are set for $flags

=item fcwrite

 $bool = fcwrite($flags);

returns true if any write-bits are set for $flags

=item fctrunc

 $bool = fctrunc($flags);

returns true if truncate-bits are set for $flags

=item fccreat

 $bool = fccreat($flags);

returns true iff creation flag is set for $flags.

=item fcperl

 $str = fcperl($flags);

returns perl mode-string corresponding to $flags.

=item fcopen

 $fh_or_undef = fcopen($file,$flags);
 $fh_or_undef = fcopen($file,$flags,$mode,$perms)

opens $file with L<Fcntl|Fcntl>-style flags $flags.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: JSON: load
=pod

=head2 JSON: load

=over 4

=item loadJsonString

 $data = PACKAGE::loadJsonString( $string,%opts);
 $data = PACKAGE::loadJsonString(\$string,%opts)

decodes JSON string.
%opts are passed to L<JSON::from_json()|JSON/from_json>.

=item loadJsonFile

 $data = PACKAGE::loadJsonFile($filename_or_handle,%opts);

loads JSON data from a file or filehandle.
%opts are passed to loadJsonString().

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: JSON: save
=pod

=head2 JSON: save

=over 4

=item saveJsonString

 $str = PACKAGE::saveJsonString($data);
 $str = PACKAGE::saveJsonString($data,%opts);

Encode data as a JSON string.
%opts are passed to L<JSON::to_json()|JSON/to_json>, e.g. (pretty=E<gt>0, canonical=E<gt>0)'.

=item saveJsonFile

 $bool = PACKAGE::saveJsonFile($data,$filename_or_handle,%opts);

Save JSON data to a file.
%opts are passed to saveJsonString().

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: env
=pod

=head2 Functions: env

=over 4

=item Variable: @env_stack

Stack of temporary environment variables.

=item env_set

 \%setenv = PACKAGE::env_set(%setenv);

Set or clear environment variables.

=item env_push

 \%oldvals = PACKAGE::env_push(%setenv);

Push old values for keys(%setenv) to @env_stack
and calls env_set(%setenv).

=item env_pop

 \%restored = PACKAGE::env_pop(%setenv);

Pops the most recent variable bindings from @env_stack
and restores them to the environment.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: run
=pod

=head2 Functions: run

=over 4

=item opencmd

 $fh_or_undef = PACKAGE::opencmd($cmd);
 $fh_or_undef = PACKAGE::opencmd($mode,@argv);

does log trace at level $TRACE_RUNCMD

=item crun

 $bool = crun(@IPC_Run_args);

wrapper for IPC::Run::run(@IPC_Run_args) with $ENV{LC_ALL}='C'

=item csort_to

 $bool = csort_to(\@sortargs, \&catcher);

runs system sort and feeds resulting lines to \&catcher

=item csortuc_to

 $bool = csortuc_to(\@sortargs, \&catcher);

runs system sort | uniq -c and feeds resulting lines to \&catcher

=item sortCmd

 $cmd = sortCmd();
 $cmd = sortCmd($nJobs);

Returns command-line prefix (command and initial optopins) for GNU-like B<sort> command.
This method just returns the value of the C<DIACOLLO_SORT> environment variable if it is set,
otherwise the value of the C<SORT> environment variable if that is set.  If neither
C<DIACOLLO_SORT> nor C<SORT> are set, it returns the string B<sort> with the parallelization
options returned by L</sortJobs> appended.  You can use the environment variable hooks e.g. to
reduce the amount of RAM and/or CPU cores used by subordinate system sort calls by setting
them appropriately, e.g.

 env SORT="/bin/sort --parallel=4 --buffer-size=1G"

to request that GNU sort use at most 4 CPU cores and a maximum RAM buffer size of 1GB.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: pack filters
=pod

=head2 Functions: pack filters

=over 4

=item packsize

 $len = PACKAGE::packsize($packfmt);
 $len = PACKAGE::packsize($packfmt,@args);

get pack-size for $packfmt with args @args

=item packFilterStore

 \&filter_sub = PACKAGE::packFilterStore($pack_template);
 \&filter_sub = PACKAGE::packFilterStore([$pack_template_store, $pack_template_fetch]);
 \&filter_sub = PACKAGE::packFilterStore([\&pack_code_store,   \&pack_code_fetch]);

returns a L<DB_File|DB_File>-style STORE-filter sub for transparent packing of data to $pack_template

=item packFilterFetch

 \&filter_sub = PACKAGE::packFilterFetch($pack_template);
 \&filter_sub = PACKAGE::packFilterFetch([$pack_template_store, $pack_template_fetch]);
 \&filter_sub = PACKAGE::packFilterFetch([\&pack_code_store,   \&pack_code_fetch]);

returns a L<DB_File|DB_File>-style FETCH-filter sub for transparent unpacking of data from $pack_template.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Math stuff
=pod

=head2 Math stuff

=over 4

=item Variable: $LOG2

constant: C<log(2)> for binary logarithms.

=item log2

 $log2 = log2($x);

binary logarithm function.

=item max2

 $max2 = max2($x,$y);

maximum

=item min2

 $min2 = min2($x,$y);

minimum

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: lists
=pod

=head2 Functions: lists

=over 4

=item luniq

 \@l_uniq = luniq(\@l);

returns sorted list of unique defined elements of @l; @l need not be sorted.

=item sluniq

 \@l_sorted_uniq = sluniq(\@l_sorted);

returns unique defined elements of pre-sorted list @l_sorted.

=item xluniq

 \@l_uniq = xluniq(\@l,\&keyfunc);

returns elements of @l with unique defined keys according to C<\&keyfunc> (default=C<\&L<overload::StrVal|overload/StrVal>>);
returned list is sorted by C<\&keyfunc>.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: regexes
=pod

=head2 Functions: regexes

=over 4

=item regex

 $re = regex($re_str);

parses regex $re_str, which can optionally be "/"-quoted.
parses modifiers /[gimsadlu].
/g modifier is parsed a la ddc (match whole word).

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: html
=pod

=head2 Functions: html

=over 4

=item htmlesc

 $escaped = htmlesc($str);

escape an HTML string.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: time
=pod

=head2 Functions: time

=over 4

=item s2hms

 $hms       = PACKAGE::s2hms($seconds,$sfmt="%06.3f");
 ($h,$m,$s) = PACKAGE::s2hms($seconds,$sfmt="%06.3f");

convert a time value in seconds to HH:MM:SS.SSSS format

=item s2timestr

 $timestr = PACKAGE::s2timestr($seconds,$sfmt="%f");

convert a time value in seconds to H?M?S.SSSS format

=item timestamp

 $rfc_timestamp = PACAKGE->timestamp();
 $rfc_timestamp = PACAKGE->timestamp($time);

Return a UTC ISO-8601 timestamp format "%Y-%m-%dT%H:%M%SZ" for the UNIX time $time.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: file
=pod

=head2 Functions: file

=over 4

=item file_mtime

 $mtime = PACKAGE->file_mtime($file_or_fh);

get mtime (last modification time) for $file_or_fh.

=item file_timestamp

 $timestamp = PACKAGE->file_timestamp($file_or_fh);

get an ISO-8601 timestamp for mtime of $file_or_fh.

=item du_file

 $nbytes = du_file(@filenames_or_fhs);

return number of bytes used by @filesnames_or_fhs

=item du_glob

 $nbytes = du_glob(@globs);

return number of bytes used by files matching and $glob in @globs

=item copyto

 $bool = PACKAGE->moveto($src_filename_or_array, $dstdir, %opts);

Copies source file(s) to C<$dstdir>, creating C<$dstdir> if it doesn't already exist.
Argument C<$src_filename_or_array> may be either a ARRAY-ref of filenames to be copied or
a single scalar filename.
By default, files are copied using L<File::Copy::copy()|File::copy/copy>.
Options %opts:

 from   => $from,      ##-- replace prefix $from in file(s) with $todir; default=undef: flat copy to $todir
 method => \&method,   ##-- use CODE-ref \&method as underlying copy routing; default=\&File::Copy::copy
 label  => $label,     ##-- report errors as '$label'; (default='copyto()')

=item copyto_a

 $bool = PACKAGE->copyto_a($src_filename_or_array, $dstdir, %opts);

Wrapper for C<L<PACKAGE-E<gt>copyto|/copyto>($src_filename_or_array, $dstdir, %opts, method=E<gt>\&L<cp_a|/cp_a>, label=E<gt>'moveto()')>.

=item moveto

 $bool = PACKAGE->moveto($src_filename_or_array, $dstdir, %opts);

Wrapper for C<L<PACKAGE-E<gt>copyto|/copyto>($src_filename_or_array, $dstdir, %opts, method=E<gt>\&L<File::Copy::move|File::Copy/move>, label=E<gt>'moveto()')>.

=item cp_a

 $bool = PACKAGE->cp_a($src,$dst);

Copies a single file C<$src> to C<$dst>, attempting to preserve ownership, permissions, and timestamps;
used by L<copyto_a()|/copyto_a>.
Uses L<File::Copy::syscopy()|File::Copy/syscopy> if available and distinct from
L<File::Copy::copy()|File::Copy/copy>, otherwise first copies the file using
L<File::Copy::copy()|File::Copy/copy> and subsequently propagates file attributes using
the core perl functions
L<chown()|perlfunc/chown>,
L<chmod()|perlfunc/chmod>,
and L<utime()|perlfunc/utime>.

=item fh_flush

 $fh_or_undef = PACKAGE->fh_flush($fh);

flushes filehandle $fh using its flush() method if available

=item fh_reopen

 $fh_or_undef = PACKAGE->fh_reopen($fh,$file);

closes and re-opens filehandle $fh, should be an expensive flush even if system doesn't
support the IO::Handle::flush method.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Utils: SI
=pod

=head2 Utils: SI

=over 4

=item si_str

 $str = si_str($float);

returns an SI string for $float.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: pdl: setops
=pod

=head2 Functions: pdl

=over 4

=item _intersect_p

 $pi = CLASS::_intersect_p($p1,$p2);
 $pi = CLASS->_intersect_p($p1,$p2);

computes intersection of 2 piddles; undef is treated as the universal set;
argument piddles MUST be sorted in ascending order.

=item _union_p

 $pu = CLASS::_union_p($p1,$p2);
 $pu = CLASS-E<gt>_intersect_p($p1,$p2);

computes union of 2 piddles; undef is treated as the universal set;
argument piddles MUST be sorted in ascending order.

=item _complement_p

 $pneg = CLASS::_complement_p($p,$N);
 $pneg = CLASS-E<gt>_complement_p($p,$N);

computes complement of an index-piddle C<$p>; undef is treated as the universal set;
C<$N> is the total number of elements in the index-universe.

=item _setdiff_p

 $pdiff = CLASS::_setdiff_p($a,$b,$N);
 $pdiff = CLASS-E<gt>_setdiff_p($a,$b,$N);

index-piddle difference; undef is treated as the universal set.
C<$N> is the total number of elements in the index-universe.

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: pdl: I/O
=pod

=item readPdlFile

 $pdl_or_undef = CLASS->readPdlFile($basename, %opts);

Load or mmap a PDL file from disk using L<PDL::IO::FastRaw|PDL::IO::FastRaw>;
%opts:

 class=>$class,    # one of qw(PDL PDL::CCS::Nd)
 mmap =>$bool,     # use mapfraw() (default=1)
 log  =>$level,    # log-level (default=undef: off)
 #...              # other keys passed to CLASS->mapfraw() rsp. CLASS->readfraw()

=item writePdlFile

 $bool = CLASS->writePdlFile($pdl_or_undef, $basename, %opts);

Write a PDL file to disk using L<PDL::IO::FastRaw|PDL::IO::FastRaw>.
Unlinks target file(s) if C<$pdl_or_undef> is not defined.
%opts:

 log => $bool,       # log-level (default=undef: off)
 #...                # other keys passed to $pdl->writefraw()

=item writePdlHeader

 $bool = CLASS->writePdlHeader($filename, $type, $ndims, @dims);

writes a L<PDL::IO::FastRaw|PDL::IO::FastRaw>-style header C<$filename> (e.g. C<"pdl.hdr">);
adapted from PDL::IO::FastRaw::_writefrawhdr().
Arguments:

 $type   ##-- PDL::Type or integer
 $ndims  ##-- number of piddle dimensions
 @dims   ##-- dimension size list, piddle, or ARRAY-ref

=item writeCcsHeader

 $bool = CLASS->writeCcsHeader($filename, $itype, $vtype, $pdims, %opts);

writes a L<PDL::CCS::IO::FastRaw|PDL::CCS::IO::FastRaw>-style header C<$filename> (e.g. C<"pdl.hdr">).
Arguments:

 $itype,          ##-- PDL::Type for index (default: PDL::CCS::Utils::ccs_indx())
 $vtype,          ##-- PDL::Type for values (default: $PDL::IO::Misc::deftype)
 $pdims,          ##-- dimension piddle or ARRAY-ref
 %opts            ##-- passed to PDL::CCS::Nd-E<gt>newFromWich

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: pdl: mmap temporaries
=pod

=item mmzeroes

 $pdl = mmzeroes      ($file?, $type?, @dims, \%opts?);
 $pdl = $pdl->mmzeroes($file?, $type?,        \%opts?);

create a (temporary) mmap()ed pdl using L<DiaColloDB::PDL::MM|DiaColloDB::PDL::MM>;
wraps L<DiaColloDB::PDL::MM-E<gt>new()|DiaColloDB::PDL::MM/new>.
%opts:

 file => $template,   ##-- file basename or File::Temp template; default='pdlXXXX'
 suffix => $suffix,   ##-- File::Temp::tempfile() suffix (default='.pdl')
 log  => $level,      ##-- logging verbosity (default=undef: off)
 temp => $bool,       ##-- delete on END (default: $file =~ /X{4}/)

=item mmtemp

 $pdl = mmtemp      ($file?, $type?, @dims, \%opts?);
 $pdl = $pdl->mmtemp($file?, $type?,        \%opts?);

Like L<mmzeroes()|/mmzeroes>,
but wraps L<DiaColloDB::PDL::MM-E<gt>mmtemp()|DiaColloDB::PDL::MM/mmtemp>,
implicitly setting C<$opts-E<gt>{temp}=1>.

=item mmunlink

 $bool = mmunlink(@mmfiles);
 $bool = mmunlink($mmpdl,@mmfiles);

unlinks file(s) generated by
L<mmzeroes($basename)|/mmzeroes>
or L<mmtemp($basename)|/mmtemp>;
wraps L<DiaColloDB::PDL::MM::unlink()|DiaColloDB::PDL::MM/unlink>.

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: pdl: misc
=pod

=item mintype

 $type = CLASS->mintype    ($pdl,    @types);
 $type = CLASS->mintype($maxval, @types);

returns minimum L<PDL::Types|PDL::Types> type from C<@types> required for representing C<$maxval>,
which in turn defaults to C<$maxval-E<gt>max> if C<$maxval> is passed as a PDL;
C<@types> defaults to all known PDL types.

=item maxval

 $maxval = $type->maxval();
 $maxval = CLASS::maxval($type_or_name)

returns maximum value representable by L<PDL::Type|PDL::Type> C<$type> (first form) or C<$type_or_name> (second form);
really only meaningful for integer types.

=item valcounts

 ($vals,$counts) = $pdl->valcounts();

wrapper for $pdl-E<gt>flat-E<gt>qsort-E<gt>rle() with masking of zero-counts lifted from MUDL::PDL::Smooth.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: temporaries
=pod

=head2 Functions: temporaries

=over 4

=item Variable: $TMPDIR

Global temp directory to use.
If undefined (the default), L<File::Spec::tmpdir()|File::Spec/tmpdir> will be used.

=item Variable: @TMPFILES

list of temporary files created by this process to be unlinked in an END block.

=item tmpdir

 $tmpdir = CLASS->tmpdir();
 $tmpdir = CLASS-t>tmpdir($template, %opts);

in first form, get name of global tempdir ($TMPDIR || File::Spec::tmpdir()).
in second form, create and return a new temporary directory via File::Temp::tempdir().

=item tmpfh

 $fh = CLASS->tmpfh();
 $fh = CLASS->tmpfh($template_or_filename, %opts);

get a new temporary filehandle or C<undef> on error;
in list context, returns C<($fh,$filename)> or empty list on error.
C<$template_or_filename> defaults to C<"tmpXXXXX">.
uses L<File::Temp::tempfile()|File::Temp/tempfile> if $template_or_filename
contains at least 4 C<"X"> characters, otherwise uses literal $template_or_filename,
honoring the C<DIR>, C<TMPDIR>, C<SUFFIX>, and C<UNLINK> options in C<%opts>, which are interpreted
as for L<File::Temp::tempfile()|File::Temp/tempfile>.

=item tmpfile

 $filename = CLASS->tmpfile();
 $filename = CLASS->tmpfile($template, %opts);

Wrapper for L<tmpfh|/tmpfh> which returns only the filename.

=item tmparray

 \@tmparray = CLASS->tmparray($template, %opts);

ties a new temporary array via L<DiaColloDB::Temp::Array|DiaColloDB::Temp::Array>
and returns a reference to the newly tied array.
wraps
C<L<tmpfile|/tmpfile>($template,%opts)>
C<tie(my @tmparray, 'L<DiaColloDB::Temp::Array|DiaColloDB::Temp::Array>', $tmpfilename, %opts)>.

=item tmparrayp

 \@tmparrayp = CLASS->tmparrayp($template, $packas, %opts);

ties a new temporary integer-array via L<DiaColloDB::PackedFile|DiaColloDB::PackedFile>
and returns a reference to the newly tied array.
wraps
C<L<tmpfile|/tmpfile>($template,%opts)>
and C<tie(my @tmparray, 'L<DiaColloDB::PackedFile|DiaColloDB::PackedFile>', $tmpfilename, %opts)>.

=item tmphash

 \%tmphash = CLASS->tmphash($template, %opts);

ties a new temporary hash via L<DiaColloDB::Temp::Hash|DiaColloDB::Temp::Hash>
and returns a reference to the newly tied hash.
wraps
C<L<tmpfile|/tmpfile>($template,%opts)>
and C<tie(my %tmphash, 'L<DiaColloDB::Temp::Hash|DiaColloDB::Temp::Hash>', $tmpfilename, %opts)>.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: DiaColloDB::Utils: Functions: parallelization
=pod

=head2 Functions: parallelization

=over 4

=item Variable: %NCORES

Cache for L<nCores()|/nCores> utility: C<($cpuinfo_file=E<gt>$n, ...)>

=item nCores

 $ncores = PACKAGE::nCores();
 $ncores = PACKAGE::nCores($proc_cpuinfo_filename);

Returns the number of CPU cores on the system according to
the file $proc_cpuinfo_filename (by default F</proc/cpuinfo>) if available,
otherwise according to the external program C<nproc> if that is avaialble,
and otherwise zero.
Caches result as C<$NCORES{$proc_cpuinfo_filename}>.

=item nJobs

 $njobs = PACKAGE::nJobs();
 $njobs = PACKAGE::nJobs($njobsRequest);

Gets non-negative number of parallel jobs (threads) for user request C<$njobsRequest>,
which defaults to the current value of the package variable C<$DiaColloDB::NJOBS>,
or -1 if it is undefined.

If C<$njobsRequest> is negative,
returns the number of CPU cores on the system via L<nCores()|/nCores>.
Otherwise, if (0 E<lt> $njobsRequest E<lt> 1), 
$njobsRequest is interpreted as the desired fraction of the number of available CPU cores
to be used, and returns C<($njobsRequest*nCores())>.
In all other cases, C<$njobsRequest> is interpreted as an exact number of jobs to use,
ans is returned as C<int($njobs+0)>.

=item sortJobs

 $sort_parallel_option = sortJobs();
 $sort_parallel_option = sortJobs($njobsRequest);

Returns an appropriate C<--parallel> option for external C<sort> system command
calls to use <$njobsRequest> parallel jobs (assuming C<sort> calling conventions
as for GNU coreutils).

=back

=cut



##========================================================================
## END POD DOCUMENTATION, auto-generated by podextract.perl

##======================================================================
## Footer
##======================================================================
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@cpan.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2015-2020 by Bryan Jurish

This package is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.2 or,
at your option, any later version of Perl 5 you may have available.

=head1 SEE ALSO

L<DiaColloDB(3pm)|DiaColloDB>,
L<perl(1)|perl>,
...



=cut
