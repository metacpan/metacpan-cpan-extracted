# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Transaction::HTTP extends Mojo::Transaction {
  version_from Mojolicious;
  
  use Mojo::Message::Response;
  use Mojo::Message::Request;
  use Mojo::Headers;
  use Mojo::Content;
  
  # Field
  has previous : rw Mojo::Transaction::HTTP;
  
  # Undocumented Fields
  has offset : int;
  
  has write : int;
  
  has http_state : string;
  
  has handled : byte;
  
  # Class Methods
  static method new : Mojo::Transaction::HTTP () {
    
    my $self = new Mojo::Transaction::HTTP;
    
    $self->init;
    
    return $self;
  }
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    $self->SUPER::init;
  }
  
  method client_read : void ($chunk : string) {
    
    my $res = $self->res;
    if (Fn->uc($self->req->method eq "HEAD")) {
      $res->content->{skip_body} = 1 ;
    }
    
    $res->parse($chunk);
    
    unless ($res->is_finished) {
      return;
    }
    
    if (!$res->is_info || $res->headers->upgrade) {
      $self->completed;
      return;
    }
    
    $self->{res} = Mojo::Message::Response->new;
    
    $self->emit(unexpected => $res);
    
    my $leftovers = $res->content->leftovers;
    
    unless (length $leftovers) {
      return;
    }
    
    $self->client_read($leftovers);
  }
  
  method client_write : string ($is_server : int) {
    
    $self->_write(0);
  }
  
  method is_empty : int () {
    return !!(Fn->uc($self->req->method) eq "HEAD" || $self->res->is_empty);
  }
  
  method keep_alive : int () {
    
    my $req = $self->req;
    my $res = $self->res;
    
    my $req_conn = $req->headers->connection;
    unless ($req_conn) {
      $req_conn = "";
    }
    $req_conn = Fn->lc($req_conn);
    
    my $res_conn = $res->headers->connection;
    unless ($res_conn) {
      $res_conn = "";
    }
    $res_conn = Fn->lc($res_conn);
    
    if ($req_conn eq "close" || $res_conn eq "close") {
      return 0;
    }
    
    if ($res->version eq "1.0") {
      return $res_conn eq "keep-alive";
    }
    
    if ($req->version eq "1.0") {
      return $req_conn eq "keep-alive";
    }
    
    return 1;
  }
  
  method redirects : Mojo::Transaction::HTTP[] () {
    my $previous = $self;
    
    my $redirects = (List of Mojo::Transaction::HTTP)List->new(new Mojo::Transaction::HTTP[0]);
    
    while ($previous = $previous->previous) {
      $redirects->unshift($previous);
    }
    
    return $redirects->to_array;
  }
  
  method server_read : void ($chunk : string) {
    
    my $req = $self->req;
    
    $req->parse($chunk);
    
    if ($req->is_finished) {
      unless ($self->{handled}++) {
        $self->emit("request");
      }
    }
    
  }
  
  method server_write : string () {
    
    my $chunk = $self->_write(1);
    
    return $chunk;
  }
  
  private method _start_line : string ($msg : Mojo::Message) {
    
    my $chunk = $msg->get_start_line_chunk($self->{offset});
    
    my $written = length $chunk;
    
    $self->{write}  -= $written;
    $self->{offset} += $written;
    
    if ($self->{write} <= 0) {
      $self->{http_state} = "headers";
      $self->{write} = $msg->header_size;
      $self->{offset} = 0;
    }
    
    return $chunk;
  }
  
  private method _headers : string ($msg : Mojo::Message, $is_server : int) {
    
    my $chunk = $msg->get_header_chunk($self->{offset});
    
    my $written = 0;
    if ($chunk) {
      $written = length $chunk;
    }
    
    $self->{write}  -= $written;
    $self->{offset} += $written;
    
    if ($self->{write} <= 0) {
      $self->{http_state} = "body";
      $self->{offset} = 0;
      
      if ($is_server && $self->is_empty) {
        $self->completed;
        $self->{http_state} = "empty";
      }
    }
    
    return $chunk;
  }
  
  private method _body : string ($msg : Mojo::Message, $is_server : int) {
    
    # Prepare body chunk
    my $chunk = $msg->get_body_chunk($self->{offset});
    
    if ($chunk) {
      $self->{offset} += length $chunk;
    }
    
    if ($is_server) {
      if ($chunk && !length $chunk) {
        $self->completed;
      }
    }
    
    unless ($chunk) {
      $chunk = "";
    }
    
    return $chunk;
  }
  
  private method _write : string ($is_server : int) {
    
    my $msg = (Mojo::Message)undef;
    if ($is_server) {
      $msg = $self->res;
    }
    else {
      $msg = $self->req;
    }
    
    unless ($self->{http_state}) {
      $self->{http_state} = "start_line";
      $self->{write} = $msg->start_line_size;
    }
    
    # Start-line
    my $chunk = StringBuffer->new;
    if ($self->{http_state} eq "start_line") {
      my $chunk_ = $self->_start_line($msg);
      $chunk->push($chunk_);
    }
    
    # Headers
    if ($self->{http_state} eq "headers") {
      my $chunk_ = $self->_headers($msg, $is_server);
      $chunk->push($chunk_);
    }
    
    # Body
    if ($self->{http_state} eq "body") {
      my $chunk_ = $self->_body($msg, $is_server);
      $chunk->push($chunk_);
    }
    
    return $chunk->get_string;
  }
  
}
