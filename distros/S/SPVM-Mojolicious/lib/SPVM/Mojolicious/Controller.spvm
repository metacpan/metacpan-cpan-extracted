# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Controller {
  version_from Mojolicious;
  
  use Digest::SHA;
  use Mojo::ByteStream;
  use Mojo::URL;
  use Mojo::Util;
  use Mojolicious::Routes::Match;
  use Mojolicious;
  use Mojo::Transaction;
  use Mojo::Message::Request;
  use Mojo::Message::Response;
  use Mojo::Log;
  use Mojo::Callback;
  use Mojo::UserAgent;
  use Mojo::ByteStream;
  use Mojo::Collection;
  
  our $ABSOLUTE : string;
  INIT {
    $ABSOLUTE = "^(?:[^:/?#]+:|//|#)";
  }
  
  has app : rw Mojolicious
    set {
      $self->{app} = $_;
      weaken $self->{app};
    }
  ;
  
  has tx : rw Mojo::Transaction
    set {
      $self->{tx} = $_;
      weaken $self->{tx};
    }
  ;
  
  has match : rw Mojolicious::Routes::Match
    get {
      unless (exists $self->{match}) {
        my $match = Mojolicious::Routes::Match->new;
        
        $match->set_root($self->app->routes);
        
        $self->{match} = $match;
      }
      
      return $self->{match};
    }
  ;
  
  has stash_h : rw Hash;
  
  has session_h : virtual ro Hash
    get {
      my $stash = $self->stash_h;
      unless ($stash->{"mojo.active_session"}->(int)) {
        $self->app->sessions->load($self);
      }
      
      unless ($self->stash_h->exists("mojo.session")) {
        $self->stash_h->{"mojo.session"} = Hash->new;
      }
      
      return $self->stash_h->{"mojo.session"}->(Hash);
    }
  ;
  
  # Fields that is originally stash mojo.xxx
  has log : rw Mojo::Log
    get {
      unless (exists $self->{log}) {
        $self->{log} = $self->app->log->context("[" . $self->req->request_id . "]");
      }
      
      return $self->{log};
    }
  ;
  
  static method new : Mojolicious::Controller () {
    
    my $self = new Mojolicious::Controller;
    
    $self->{stash_h} = Hash->new;
    
    return $self;
  }
  
  # Instance Methods
  method req : Mojo::Message::Request () {
    
    my $tx = $self->tx;
    
    unless ($tx) {
      die "Transaction already destroyed";
    }
    
    return $tx->req;
  }
  
  method res : Mojo::Message::Response () {
    
    my $tx = $self->tx;
    
    unless ($tx) {
      die "Transaction already destroyed";
    }
    
    return $tx->res;
  }
  
  method cookie : string ($name : string) {
    
    # Request cookies
    my $cookie = $self->req->cookie($name);
    unless ($cookie) {
      return undef;
    }
    
    return $cookie->value;
  }
  
  method set_cookie : void ($name : string, $value : string, $attrs : object[] = undef) {
    
    # Response cookie
    # Cookie too big
    my $cookie = Mojo::Cookie::Response->new(Fn->merge_options({name => $name, value => $value}, $attrs));
    
    if (length $cookie->value > 4096) {
      $self->log->error("Cookie '$name' is bigger than 4KiB") ;
    }
    
    $self->res->set_cookies($name, [$cookie]);
  }
  
  method every_cookie : string[] ($name : string) {
    
    my $every_cookies = $self->req->every_cookie($name);
    
    my $every_cookies_length = @$every_cookies;
    
    my $values = new string[$every_cookies_length];
    
    for (my $i = 0; $i < $every_cookies_length; $i++) {
      $values->[$i] = $every_cookies->[$i]->value;
    }
    
    return $values;
  }
  
  method every_param : string[] ($name : string) {
    
    # Captured unreserved values
    $self->stash_h->{"mojo.captures"} //= Hash->new;
    
    my $captures = $self->stash_h->{"mojo.captures"}->(Hash);
    
    if ($captures->exists($name) && !$self->app->routes->is_reserved($name)) {
      my $value = $captures->get("$name");
      
      return $value isa string[] ? (string[])$value : [(string)$value];
    }
    
    my $req = $self->req;
    
    return $req->every_param($name);
  }
  
  method every_upload : Mojo::Upload[] ($name : string) {
    
    my $uploads = $self->req->every_upload($name);
    
    return $uploads;
  }
  
  method upload : Mojo::Upload ($name : string) {
    
    my $every_upload = $self->every_upload($name);
    
    my $upload = @$every_upload ? $self->every_upload($name)->[-1] : undef;
    
    return $upload;
  }
  
  method signed_cookie : string ($name : string) {
    
    # Request cookie
    my $every_signed_cookie = $self->every_signed_cookie($name);
    
    my $value = @$every_signed_cookie ? $every_signed_cookie->[-1] : undef;
    
    return $value;
  }
  
  method set_signed_cookie : string ($name : string, $value : string = undef, $options : object[] = undef) {
    
    # Response cookie
    my $sum = Digest::SHA->hmac_sha256_hex("$name=$value", $self->app->secrets->[0]);
    
    $self->set_cookie($name, "$value--$sum", $options);
  }
  
  method every_signed_cookie : string[] ($name : string) {
    
    my $secrets = $self->app->secrets;
    my $results = StringList->new;
    for my $value (@{$self->every_cookie($name)}) {
      
      unless (is_read_only $value) {
        $value = copy $value;
      }
      
      # Check signature with rotating secrets
      if (my $rep = Re->s((mutable string)$value, "--([^\-]+)$", "")) {
        my $signature = $rep->match->cap1;
        
        my $valid = 0;
        for my $secret (@$secrets) {
          my $check = Digest::SHA->hmac_sha256_hex("$name=$value", $secret);
          if (Mojo::Util->secure_compare($signature, $check)) {
            $valid = 1;
            last;
          }
        }
        if ($valid) {
          $results->push($value);
        }
        else {
          $self->log->trace("Cookie \"$name\" has bad signature.");
        }
      }
      
      else {
        $self->log->trace("Cookie \"$name\" is not signed.");
      }
    }
    
    return $results->get_array;
  }
  
  method finish : void ($code : int = 0, $reason : string = undef) {
    
    my $tx = $self->tx;
    unless ($tx) {
      die "Transaction already destroyed";
    }
    
    # WebSocket
    if ($tx->is_websocket) {
      $tx->(Mojo::Transaction::WebSocket)->finish($code, $reason);
      unless ($tx->(Mojo::Transaction::WebSocket)->established) {
        $self->rendered(101);
      }
    }
    else {
      die "finish method is only for WebSocket. Use finish_stream method for long polling stream.";
    }
  }
  
  method finish_stream : void ($chunk : string = undef) {
    
    my $tx = $self->tx;
    unless ($tx) {
      die "Transaction already destroyed.";
    }
    
    # Chunked stream
    if ($tx->res->content->is_chunked) {
      if ($chunk) {
        $self->write_chunk($chunk);
      }
      $self->write_chunk("");
    }
    # Normal stream
    else {
      if ($chunk) {
        $self->write($chunk);
      }
      $self->write("");
    }
  }
  
  method on : void ($name : string, $cb : Mojo::Callback) {
  
    my $tx = $self->tx;
    unless ($tx) {
      die "Transaction already destroyed.";
    }
    
    if ($tx->is_websocket && !$tx->(Mojo::Transaction::WebSocket)->established) {
      $self->rendered(101);
    }
    
    my $cb_with_instance = (Mojo::Callback)undef;
    if ($cb) {
      $cb_with_instance = [$self : Mojolicious::Controller, $cb : Mojo::Callback] method : void ($that : object, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
        $cb->($self, $arg1, $arg2, $arg3);
      };
    }
    
    $tx->on($name => $cb_with_instance);
  }

  method param : string ($name : string) {
    
    my $every_param = $self->every_param($name);
    
    my $value = @$every_param ? $self->every_param($name)->[-1] : undef;
    
    return $value;
  }
  
  method set_param : void ($name : string, $value : string|string[]) {
    
    my $value_ = (string|string[])undef;
    if ($value) {
      if ($value isa string) {
        $value_ = (string)$value;
      }
      elsif ($value isa string[]) {
        $value_ = (string[])$value;
      }
      else {
        die "The type of the value \$value must be string or string[]";
      }
    }
    
    $self->stash_h->{"mojo.captures"}->(Hash)->{$name} = $value_;
  }
  
  method render : Mojo::ByteStream ($template : string|Hash|object[] = undef, $options : Hash|object[] = undef) {
    
    my $template_ = (string)undef;
    if ($template isa string) {
      $template_ = $template->(string);
    }
    else {
      $options = $template;
      $template = undef;
    }
    
    my $options = Fn->to_hash($options);
    
    if ($template_) {
      $options->{"template"} = $template_;
    }
    
    my $app = $self->app;
    my $plugins = $app->plugins;
    my $render_to_string = $options->{"mojo.string"}->(int);
    
    unless ($render_to_string) {
      $plugins->emit_hook(before_render => $self, $options);
    }
    
    my $renderer = $app->renderer;
    my $_ = $renderer->render($self, $options);
    my $output = $_->[0];
    my $format = $_->[1];
    
    if ($render_to_string) {
      return $output ? Mojo::ByteStream->new($output) : undef;
    }
    
    $plugins->emit_hook(after_render => $self, my $_ = [$output], $format);
    $output = $_->[0];
    
    unless ($output) {
      die "Rendering output must be define.";
    }
    
    $renderer->respond($self, $output, $format, $options->{"status"});
  }
  
  method render_to_string : Mojo::ByteStream ($options : Hash|object[] = undef) {
    
    my $options = Fn->to_hash($options);
    $options->merge_options({"mojo.string" => 1});
    my $string = $self->render($options);
    
    return $string;
  }
  
  method rendered : void ($status : int = 0) {
    
    # Make sure we have a status
    if ($status) {
      $self->res->set_code($status);
    }
    
    # Finish transaction
    my $stash = $self->stash_h;
    if (!$stash->{"mojo.finished"}->(int)) {
      $stash->{"mojo.finished"} = 1;
      
      my $res = $self->res;
      if (!$status && !$res->code) {
        $res->set_code(200) ;
      }
      
      my $app = $self->app;
      $app->plugins->emit_hook_reverse(after_dispatch => $self);
      
      $app->sessions->store($self);
    }
  }
  
  method send : void ($msg : string|object[]|Mojo::WebSocket::Frame, $cb : Mojo::Callback = undef) {
    my $tx = $self->tx;
    
    unless ($tx) {
      die "Transaction already destroyed.";
    }
    
    unless ($tx->is_websocket) {
      die "No WebSocket connection to send message to.";
    }
    
    my $cb_with_instance = (Mojo::Callback)undef;
    if ($cb) {
      $cb_with_instance = [$self : Mojolicious::Controller, $cb : Mojo::Callback] method : void ($that : object, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
        $cb->($self, $arg1, $arg2, $arg3);
      };
    }
    
    $tx->(Mojo::Transaction::WebSocket)->send($msg, $cb_with_instance);
    
    unless ($tx->(Mojo::Transaction::WebSocket)->established) {
      $self->rendered(101);
    }
  }
  
  method session : object ($name : string) {
    
    return $self->session_h->{$name};
  }
  
  method set_session : void ($name : string, $value : object) {
    
    $self->session_h->{$name} = $value;
  }
  
  method stash : object ($name : string) {
    return $self->{stash_h}{$name};
  }
  
  method set_stash : void ($name : string, $value : object) {
    $self->{stash_h}{$name} = $value;
  }
  
  method url_for : Mojo::URL ($target : string|Mojo::URL)  {
    
    # Absolute URL
    if ($target isa Mojo::URL) {
      return $target->(Mojo::URL);
    }
    
    my $target = (string)$target;
    
    if (Re->m($target, $ABSOLUTE)) {
      return Mojo::URL->new($target);
    }
    
    # Base
    my $url  = Mojo::URL->new;
    my $req  = $self->req;
    $url->set_base($req->url->base->clone);
    my $base = $url->base;
    $base->set_userinfo(undef);
    
    # Relative URL
    my $path = $url->path;
    if (Re->m($target, "^/")) {
      if (my $prefix = $self->stash_h->{"path"}->(string)) {
        my $real = $req->url->path->to_route;
        Re->s((mutable string)$real, "/?\Q$prefix\E$", "$target");
        $target = $real;
      }
      $url->parse($target);
    }
    
    # Make path absolute
    my $base_path = $base->path;
    StringList->new_ref($path->parts)->unshift_($base_path->parts);
    $base_path->set_parts(new string[0]);
    $base_path->set_trailing_slash(0);
    
    return $url;
  }
  
  method url_for_asset : Mojo::URL ($target : string) {
    
    unless (Re->m($target, $ABSOLUTE)) {
      $target = $self->app->static->asset_path($target);
    }
    
    return $self->url_for($target);
  }

  method url_for_file : Mojo::URL ($target : string) {
    
    unless (Re->m($target, $ABSOLUTE)) {
      $target = $self->app->static->file_path($target);
    }
    
    return $self->url_for($target);
  }

  method write : void ($chunk : string, $cb : Mojo::Callback = undef) {
    
    my $cb_with_instance = (Mojo::Callback)undef;
    if ($cb) {
      $cb_with_instance = [$self : Mojolicious::Controller, $cb : Mojo::Callback] method : void ($that : object, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
        $cb->($self, $arg1, $arg2, $arg3);
      };
    }
    
    $self->res->content->write($chunk, $cb_with_instance);
    
    $self->rendered;
  }

  method write_chunk : void ($chunk : string, $cb : Mojo::Callback = undef) {
    
    my $cb_with_instance = (Mojo::Callback)undef;
    if ($cb) {
      $cb_with_instance = [$self : Mojolicious::Controller, $cb : Mojo::Callback] method : void ($that : object, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
        $cb->($self, $arg1, $arg2, $arg3);
      };
    }
    
    $self->res->content->write_chunk($chunk, $cb_with_instance);
    
    $self->rendered;
  }
  
  method write_sse : void ($event : Mojo::SSE::Event, $cb : Mojo::Callback = undef) {
    
    my $cb_with_instance = (Mojo::Callback)undef;
    if ($cb) {
      $cb_with_instance = [$self : Mojolicious::Controller, $cb : Mojo::Callback] method : void ($that : object, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
        $cb->($self, $arg1, $arg2, $arg3);
      };
    }
    
    $self->res->content->write_sse($event, $cb_with_instance);
   
   $self->rendered;
  }
  
  method reply : Mojolicious::Helper::Reply () {
    
    my $reply = Mojolicious::Helper::Reply->new;
    $reply->set_controller($self);
    
    return $reply;
  }
  
  method include : Mojo::ByteStream ($options : Hash|object[] = undef) {
    
    return $self->render_to_string($options);
  }
  
  method content : Mojo::ByteStream ($name : string = undef) {
    
    unless ($name) {
      $name = "content";
    }
    
    my $hash = $self->stash_h->{"mojo.content"}->(Hash) // Hash->new;
    
    my $content = $hash->{$name}->(string);
    
    return Mojo::ByteStream->new($content // "");
  }
  
  method flash : object ($name : string) {
    
    # Check old flash
    my $session = $self->session_h;
    
    return $session->{"flash"} ? $session->{"flash"}->(Hash)->{$name}->(object) : undef;
  }
  
  method set_flash : void ($name : string, $value : object) {
    
    my $session = $self->session_h;
    
    unless ($session->{"new_flash"}) {
      $session->{"new_flash"} = Hash->new;
    }
    
    $session->{"new_flash"}->(Hash)->{$name} = $value;
  }
  
  method ua : Mojo::UserAgent () {
    return $self->app->ua;
  }
  
  method config : object ($name : string) {
    return $self->app->config($name);
  }
  
  method c : Mojo::Collection ($array : object[] = undef) {
    return Mojo::Collection->new($array);
  }
  
  method b : Mojo::ByteStream ($bytes : string) {
    return Mojo::ByteStream->new($bytes);
  }
  
  method layout : string () {
    $self->stash("layout")->(string);
  }
  
  method set_layout : void ($layout : string) {
    $self->set_stash(layout => $layout);
  }
  
  method title : string () {
    $self->stash("title")->(string);
  }
  
  method set_title : void ($title : string) {
    $self->set_stash(title => $title);
  }
  
  method accepts : string[] ($preferences : string[] = undef) {
    $self->app->renderer->accepts($self, $preferences);
  }
  
}

__END__

TODO: DefaultHelper

sub register {
  my ($self, $app) = @_;
  
  $app->helper($_ => $self->can("_$_"))
    for qw(csrf_token current_route exception_format inactivity_timeout is_fresh),
    qw(redirect_to respond_to url_with);
  
  $app->helper("reply.$_" => $self->can("_$_")) for qw(asset file static);
  
  $app->helper('reply.exception',      => sub { shift->helpers->reply->http_exception(@_) });
  $app->helper('reply.not_found',      => sub { shift->helpers->reply->http_not_found() });
  $app->helper('reply.http_exception', => \&_http_exception);
  $app->helper('reply.http_not_found', => \&_http_not_found);
  $app->helper('reply.html_exception'  => sub { _development('exception', @_) });
  $app->helper('reply.html_not_found'  => sub { _development('not_found', @_) });
  $app->helper('reply.json_exception', => \&_json_exception);
  $app->helper('reply.json_not_found', => \&_json_not_found);
  $app->helper('reply.txt_exception',  => \&_txt_exception);
  $app->helper('reply.txt_not_found',  => \&_txt_not_found);

  $app->helper('timing.begin'         => \&_timing_begin);
  $app->helper('timing.elapsed'       => \&_timing_elapsed);
  $app->helper('timing.rps'           => \&_timing_rps);
  $app->helper('timing.server_timing' => \&_timing_server_timing);
}

