# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Renderer {
  version_from Mojolicious;
  
  use Mojo::File;
  use Mojo::Util;
  use Mojo::Template;
  use Mojolicious::Renderer::Callback;
  
  use Sys;
  use JSON;
  
  # Fields
  has paths : rw string[];
  
  has handlers : rw Hash of Mojolicious::Renderer::Callback;
  
  has default_handler : rw string;
  
  has default_format : rw string;
  
  has data_templates : rw string;
  
  has compress : rw byte;
  
  has min_compress_size : rw int;
  
  # Class Methods
  static method new : Mojolicious::Renderer () {
    
    my $self = new Mojolicious::Renderer;
    
    $self->{compress} = 1;
    
    $self->{default_format} = "html";
    
    $self->{default_handler} = "ep";
    
    $self->{handlers} = Hash->new;
    
    $self->{min_compress_size} = 860;
    
    $self->{paths} = new string[0];
    
    $self->add_handler("ep" => method : void ($renderer : Mojolicious::Renderer, $c : Mojolicious::Controller, $output_ref : string[]) {
      
      $renderer->_render_ep($c, $output_ref);
    });
    
    return $self;
  }
  
  method accepts : string[] ($c : Mojolicious::Controller, $preferences : string[] = undef) {
    
    # List representations
    my $req   = $c->req;
    my $fmt = $req->param("_format");
    my $exts_list = StringList->new;
    if ($fmt) {
      $exts_list->push($fmt);
    }
    $exts_list->push_($c->app->types->detect($req->headers->accept));
    
    $preferences //= new string[0];
    unless (@$preferences) {
      return $exts_list->to_array;
    }
    
    # Find best representation
    for (my $i = 0; $i < $exts_list->length; $i++) {
      my $ext = $exts_list->get($i);
      
      for my $_ (@$preferences) {
        if ($ext eq $_) {
          return [$ext];
        }
      }
    }
    
    return $exts_list->length ? new string[0] : [$preferences->[0]];
  }
  
  method add_handler : void ($name : string, $cb : Mojo::Callback) {
    
    $self->{handlers}->set($name, $cb);
  }
  
  private method get_data_template : string ($options : object[]) {
    
    my $template_name = $self->template_name($options);
    
    unless ($template_name) {
      return undef;
    }
    
    # Split files
    my $files = StringList->new(Re->split(["^@@\s*(.+?)\s*\r?\n", "m"], $self->data_templates));
    if (@$files) {
      $files->shift;
    }
    
    # Find data
    my $template = (string)undef;
    while (1) {
      
      unless (@$files) {
        last;
      }
     
      my $_ = $files->splice(0, 2);
      my $name = $_->[0];
      my $data = $_->[1];
      
      if (Re->s((mutable string)$name, "\s*\(\s*base64\s*\)$", "")) {
        $data = Mojo::Util->b64_decode($data);
      }
      
      if ($name eq $template_name) {
        $template = $data;
        last;
      }
    }
    
    return $template;
  }
  
  method template_name : string ($options : Hash|object[]) {
    
    my $options = Fn->to_hash($options);
    
    my $template = $options->{"template"}->(string);
    unless ($template) {
      return undef;
    }
    
    my $format = $options->{"format"}->(string);
    unless ($format) {
      return undef;
    }
    
    $template .= ".$format";
    
    my $handler = $options->{"handler"}->(string);
    
    return $handler ? "$template.$handler" : $template;
  }
  
  method render : string[] ($c : Mojolicious::Controller, $options : Hash|object[] = undef) {
    
    my $options = Fn->to_hash($options);
    
    # Localize stash
    my $stash = $c->stash_h;
    my $stash_save = $stash->clone;
    Fn->defer([$c : Mojolicious::Controller, $stash_save : Hash] method : void () {
      $c->set_stash_h($stash_save);
    });
    
    # All other arguments just become part of the stash
    for my $name (@{$options->keys}) {
      $stash->{$name} = $options->{$name};
    }
    
    my $format = $stash->{"format"}->(string) // $self->default_format;
    $stash->{"format"} = $format;
    
    # Data
    if ($stash->{"data"}) {
      return [$stash->{"data"}->(string), $format];
    }
    
    # Text
    elsif ($stash->{"text"}) {
      return [$stash->{"text"}->(string), $format];
    }
    
    # JSON
    elsif ($stash->{"json"}) {
      return [JSON->new->encode($stash->{"json"}), "json"];
    }
    
    # Template
    my $template = $stash->{"template"}->(string);
    my $handler = $stash->{"handler"}->(string) // $self->default_handler;
    $stash->{"handler"} = $handler;
    
    my $renderer = $self->handlers->get($handler);
    
    unless ($renderer) {
      die "No handler for '$handler' found.";
    }
    
    $renderer->($self, $c, my $_ = [(string)undef]);
    my $output = $_->[0];
    
    unless ($output) {
      return [$output, undef];
    }
    
    # Layout
    my $layout = $stash->{"layout"}->(string);
    if ($layout) {
      my $layout_template = "layouts/$layout";
      my $layout_stash = $stash->{"mojo.layout"}->(Hash) // Hash->new;
      my $layout_handler = $layout_stash->{"handler"}->(string) // $self->default_handler;
      my $layout_format = $layout_stash->{"format"}->(string) // $self->default_format;
      
      $stash->{"handler"} = $layout_handler;
      $stash->{"format"} = $layout_format;
      $stash->{"template"} = $layout_template;
      $stash->{"mojo.content"} // Hash->new;
      $stash->{"mojo.content"}->(Hash)->{"content"} = $output;
      
      my $layout_renderer = $self->handlers->get($layout_handler);
      
      unless ($layout_renderer) {
        die "No handler for '$handler' found.";
      }
      
      $renderer->($self, $c, my $_ = [(string)undef]);
      $output = $_->[0];
    }
    
    return [$output, $format];
  }
  
  method respond : void ($c : Mojolicious::Controller, $output : string, $format : string, $status : int) {
    
    if ($c->stash_h->{"mojo.respond"}->(int)) {
      die "A response has already been rendered.";
    }
    $c->stash_h->{"mojo.respond"} = 1;
    
    # Gzip compression
    my $res = $c->res;
    if ($self->compress && length($output) >= $self->min_compress_size) {
      my $headers = $res->headers;
      $headers->append(Vary => "Accept-Encoding");
      my $gzip = Re->m($c->req->headers->accept_encoding // "", ["gzip". "i"]);
      if ($gzip && !length $headers->content_encoding) {
        $headers->set_content_encoding("gzip");
        $output = Mojo::Util->gzip($output);
      }
    }
    
    $res->set_body($output);
    $c->app->types->content_type($c, {ext => $format});
    
    $c->rendered($status);
  }
  
  method template_path : string ($options : Hash|object[] = undef) {
    
    my $options = Fn->to_hash($options);
    
    my $name = $self->template_name($options);
    
    unless ($name) {
      return undef;
    }
    
    my $parts = Fn->split("/", $name);
    
    for my $path (@{$self->paths}) {
      
      my $abs_path = Mojo::File->path(Array->merge_string([$path], $parts));
      
      if (Sys->r($abs_path->to_string)) {
        return $path;
      }
      
    }
    
    return undef;
  }
  
  private method _render_ep : void ($c : Mojolicious::Controller, $output_ref : string[]) {
    
    my $inline = $c->stash("inline")->(string);
    
    my $options = {
      template => $c->stash("template")->(string),
      format => $c->stash("format")->(string),
      handler => $c->stash("handler")->(string),
    };
    
    my $name = $inline ? Mojo::Util->md5_sum($inline) : $self->template_name($options);
    
    unless ($name) {
      die "Template name is not resolved.";
    }
    
    my $mt = Mojo::Template->new;
    $mt->set_auto_escape(1);
    
    # Inline
    my $output = (string)undef;
    if ($inline) {
      $c->log->trace("Rendering inline template \"$name\"");
      $mt->set_name("inline template $name");
      $output = $mt->render($inline, undef, $c);
    }
    
    # File
    else {
      # Try template
      if (my $path = $self->template_path($options)) {
        $c->log->trace("Rendering template \"$name\"");
        my $file = "$path/$name";
        $mt->set_name($name);
        $output = $mt->render_file($file, undef, $c);
      }
      
      # Try DATA section
      elsif (my $d = $self->get_data_template($options)) {
        $c->log->trace("Rendering template \"$name\" from DATA section");
        $mt->set_name("template $name from data templates");
        $output = $mt->render($d, undef, $c);
      }
      
      # No template
      else {
        $c->log->trace("Template \"$name\" not found");
      }
    }
    
    $output_ref->[0] = $output;
  }
  
}
