/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.40 from the
 * contents of mysql.xs. Do not edit this file, edit mysql.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "mysql.xs"
/* Hej, Emacs, this is -*- C -*- mode!

   Copyright (c) 2003      Rudolf Lippan
   Copyright (c) 1997-2003 Jochen Wiedmann

   You may distribute under the terms of either the GNU General Public
   License or the Artistic License, as specified in the Perl README file.

*/


#include "dbdimp.h"
#include "constants.h"

#include <errno.h>
#include <string.h>

#if MYSQL_ASYNC
#  define ASYNC_CHECK_XS(h)\
    if(imp_dbh->async_query_in_flight) {\
        do_error(h, 2000, "Calling a synchronous function on an asynchronous handle", "HY000");\
        XSRETURN_UNDEF;\
    }
#else
#  define ASYNC_CHECK_XS(h)
#endif


DBISTATE_DECLARE;


#line 42 "mysql.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 186 "mysql.c"

/* INCLUDE:  Including 'mysql.xsi' from 'mysql.xs' */

#include "Driver_xst.h"
#if defined(dbd_st_execute_iv)
#undef dbd_st_execute
#define dbd_st_execute dbd_st_execute_iv
#endif
#if defined(dbd_st_rows_iv)
#undef dbd_st_rows
#define dbd_st_rows dbd_st_rows_iv
#endif
#if defined(dbd_db_do4_iv)
#undef dbd_db_do4
#define dbd_db_do4 dbd_db_do4_iv
#endif

XS_EUPXS(XS_DBD__mysql__dr_dbixs_revision); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr_dbixs_revision)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 57 "./mysql.xsi"
    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));
#line 215 "mysql.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_discon_all
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_DBD__mysql__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr_discon_all_)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0)
;
#line 69 "./mysql.xsi"
    D_imp_drh(drh);
    PERL_UNUSED_VAR(ix);
    ST(0) = dbd_discon_all(drh, imp_drh) ? &PL_sv_yes : &PL_sv_no;
#line 239 "mysql.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_DBD__mysql__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "drh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 83 "./mysql.xsi"
    {
        D_imp_drh(drh);
        AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 281 "mysql.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__mysql__db__login); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db__login)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dbh, dbname, username, password, attribs=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	dbname = ST(1)
;
	SV *	username = ST(2)
;
	SV *	password = ST(3)
;
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 113 "./mysql.xsi"
    {
    D_imp_dbh(dbh);
#if !defined(dbd_db_login6_sv)
    STRLEN lna;
    char *u = (SvOK(username)) ? SvPV(username,lna) : (char*)"";
    char *p = (SvOK(password)) ? SvPV(password,lna) : (char*)"";
#endif
#ifdef dbd_db_login6_sv
    ST(0) = dbd_db_login6_sv(dbh, imp_dbh, dbname, username, password, attribs) ? &PL_sv_yes : &PL_sv_no;
#elif defined(dbd_db_login6)
    ST(0) = dbd_db_login6(dbh, imp_dbh, SvPV_nolen(dbname), u, p, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    PERL_UNUSED_ARG(attribs);
    ST(0) = dbd_db_login( dbh, imp_dbh, SvPV_nolen(dbname), u, p) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 329 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_selectall_arrayref)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    {
#line 134 "./mysql.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *tmp_sv;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 349 "mysql.c"
#line 141 "./mysql.xsi"
    if (items > 2) {
        attr = ST(2);
        if (SvROK(attr) &&
                (DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
        ) {
            /* fallback to perl implementation */
            SV *tmp =dbixst_bounce_method("DBD::mysql::db::SUPER::selectall_arrayref", items);
            SPAGAIN;
            ST(0) = tmp;
            XSRETURN(1);
        }
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth))
            XSRETURN_UNDEF;
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    tmp_sv = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
    SPAGAIN;
    ST(0) = tmp_sv;
#line 396 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_selectrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 193 "./mysql.xsi"
    int is_selectrow_array = (ix == 1);
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 417 "mysql.c"
#line 198 "./mysql.xsi"
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        /* --- prepare --- */
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth)) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
        if (GIMME == G_SCALAR)
            PUSHs(&PL_sv_undef);
    }
    else if (is_selectrow_array) {
        int i;
        int num_fields = AvFILL(row_av)+1;
        if (GIMME == G_SCALAR)
            num_fields = 1; /* return just first field */
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(row_av)[i]);
        }
    }
    else {
        PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 473 "mysql.c"
	PUTBACK;
	return;
    }
}

#if defined(dbd_db_do6) || defined(dbd_db_do4)
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_DBD__mysql__db_do); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_do)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "dbh, statement, params = Nullsv, ...");
    {
	SV *	dbh = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2)
;
	}
#line 262 "./mysql.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
#ifdef dbd_db_do6
    /* items is a number of arguments passed to XSUB, supplied by xsubpp compiler */
    /* ax contains stack base offset used by ST() macro, supplied by xsubpp compiler */
    retval = dbd_db_do6(dbh, imp_dbh, statement, params, items-3, ax+3);
#else
    if (items > 3)
        croak_xs_usage(cv,  "dbh, statement, params = Nullsv");
    retval = dbd_db_do4(dbh, imp_dbh, SvPV_nolen(statement), params); /* might be dbd_db_do4_iv via macro */
#endif
    /* remember that dbd_db_do* must return <= -2 for error     */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
    }
#line 523 "mysql.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_DBD__mysql__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_last_insert_id)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 6)
       croak_xs_usage(cv,  "dbh, catalog=&PL_sv_undef, schema=&PL_sv_undef, table=&PL_sv_undef, field=&PL_sv_undef, attr=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	catalog;
	SV *	schema;
	SV *	table;
	SV *	field;
	SV *	attr;

	if (items < 2)
	    catalog = &PL_sv_undef;
	else {
	    catalog = ST(1)
;
	}

	if (items < 3)
	    schema = &PL_sv_undef;
	else {
	    schema = ST(2)
;
	}

	if (items < 4)
	    table = &PL_sv_undef;
	else {
	    table = ST(3)
;
	}

	if (items < 5)
	    field = &PL_sv_undef;
	else {
	    field = ST(4)
;
	}

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5)
;
	}
#line 297 "./mysql.xsi"
    {
    D_imp_dbh(dbh);
    ST(0) = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    }
#line 587 "mysql.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__mysql__db_commit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_commit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 309 "./mysql.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 608 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_rollback)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 319 "./mysql.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
#line 628 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_disconnect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
#line 329 "./mysql.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
        XSRETURN_YES;
    }
    /* Check for disconnect() being called whilst refs to cursors       */
    /* still exists. This possibly needs some more thought.             */
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !PL_dirty) {
        STRLEN lna;
        char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? (char*)"" : (char*)"s";
        warn("%s->disconnect invalidates %d active statement handle%s %s",
            SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
            "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &PL_sv_yes : &PL_sv_no;
    DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
#line 659 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, keysv, valuesv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 352 "./mysql.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 686 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_FETCH)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, keysv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
#line 366 "./mysql.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;    /* dbd_db_FETCH_attrib did sv_2mortal   */
#line 709 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
#line 377 "./mysql.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_dbh(dbh);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_dbh) && !PL_dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(dbh,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_dbh)) {            /* wants ineffective destroy */
            DBIc_ACTIVE_off(imp_dbh);
            if (DBIc_DBISTATE(imp_dbh)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_dbh), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(dbh));
        }
        if (DBIc_ACTIVE(imp_dbh)) {
            if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
                /* Application is using transactions and hasn't explicitly disconnected.
                    Some databases will automatically commit on graceful disconnect.
                    Since we're about to gracefully disconnect as part of the DESTROY
                    we want to be sure we're not about to implicitly commit changes
                    that are incomplete and should be rolled back. (The DESTROY may
                    be due to a RaiseError, for example.) So we rollback here.
                    This will be harmless if the application has issued a commit,
                    XXX Could add an attribute flag to indicate that the driver
                    doesn't have this problem. Patches welcome.
                */
                if (DBIc_WARN(imp_dbh) /* only warn if likely to be useful... */
                &&  DBIc_is(imp_dbh, DBIcf_Executed) /* has not just called commit/rollback */
            /*  && !DBIc_is(imp_dbh, DBIcf_ReadOnly) -- is not read only */
                && (!PL_dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
                ) {
                    warn("Issuing rollback() due to DESTROY without explicit disconnect() of %s handle %s",
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "ImplementorClass", 16, 1)),
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "Name", 4, 1))
                    );
                }
                dbd_db_rollback(dbh, imp_dbh);                  /* ROLLBACK! */
            }
            dbd_db_disconnect(dbh, imp_dbh);
            DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
        }
        dbd_db_destroy(dbh, imp_dbh);
    }
#line 772 "mysql.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_DBD__mysql__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_take_imp_data)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	SV *	h = ST(0)
;
#line 430 "./mysql.xsi"
    D_imp_xxh(h);
    /* dbd_take_imp_data() returns &sv_no (or other defined but false value)
     * to indicate "preparations complete, now call SUPER::take_imp_data" for me.
     * Anything else is returned to the caller via sv_2mortal(sv), typically that
     * would be &sv_undef for error or an SV holding the imp_data.
     */
    SV *sv = dbd_take_imp_data(h, imp_xxh, NULL);
    if (SvOK(sv) && !SvTRUE(sv)) {
        SV *tmp = dbixst_bounce_method("DBD::mysql::db::SUPER::take_imp_data", items);
        SPAGAIN;
        ST(0) = tmp;
    } else {
        ST(0) = sv_2mortal(sv);
    }
#line 806 "mysql.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_DBD__mysql__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 454 "./mysql.xsi"
    {
        D_imp_dbh(dbh);
        AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 848 "mysql.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__mysql__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st__prepare)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, statement, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2)
;
	}
#line 483 "./mysql.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
#ifdef dbd_st_prepare_sv
    ST(0) = dbd_st_prepare_sv(sth, imp_sth, statement, attribs) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_prepare(sth, imp_sth, SvPV_nolen(statement), attribs) ? &PL_sv_yes : &PL_sv_no;
#endif
    }
#line 885 "mysql.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_DBD__mysql__st_rows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_rows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 500 "./mysql.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 906 "mysql.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAH 1


XS_EUPXS(XS_DBD__mysql__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_bind_col)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, col, ref, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	col = ST(1)
;
	SV *	ref = ST(2)
;
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 515 "./mysql.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
        mg_get(ref);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:     ST(0) = &PL_sv_yes;        /* job done completely */
                break;
    case 1:     /* fallback to DBI default */
                ST(0) = (DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs))
                    ? &PL_sv_yes : &PL_sv_no;
                break;
    default:    ST(0) = &PL_sv_no;         /* dbd_st_bind_col has called set_err */
                break;
    }
    }
#line 966 "mysql.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */

XS_EUPXS(XS_DBD__mysql__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_bind_param)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, param, value, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value = ST(2)
;
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 553 "./mysql.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 1015 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_bind_param_inout)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "sth, param, value_ref, maxlen, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value_ref = ST(2)
;
	IV	maxlen = (IV)SvIV(ST(3))
;
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 583 "./mysql.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
        croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
        croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
                ? &PL_sv_yes : &PL_sv_no;
    }
#line 1070 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_execute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_execute)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "sth, ...");
    {
	SV *	sth = ST(0)
;
#line 614 "./mysql.xsi"
    D_imp_sth(sth);
    IV retval;
    if (items > 1) {    /* need to bind params */
        if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
            XSRETURN_UNDEF;
        }
    }
    /* XXX this code is duplicated in selectrow_arrayref above  */
    DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth); /* might be dbd_st_execute_iv via macro */
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 1103 "mysql.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAI 1


XS_EUPXS(XS_DBD__mysql__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_execute_for_fetch)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, fetch_tuple_sub, tuple_status = Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	fetch_tuple_sub = ST(1)
;
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2)
;
	}
#line 641 "./mysql.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    }
#line 1136 "mysql.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_st_last_insert_id
#define XSubPPtmpAAAJ 1


XS_EUPXS(XS_DBD__mysql__st_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_last_insert_id)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 6)
       croak_xs_usage(cv,  "sth, catalog=&PL_sv_undef, schema=&PL_sv_undef, table=&PL_sv_undef, field=&PL_sv_undef, attr=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	catalog;
	SV *	schema;
	SV *	table;
	SV *	field;
	SV *	attr;

	if (items < 2)
	    catalog = &PL_sv_undef;
	else {
	    catalog = ST(1)
;
	}

	if (items < 3)
	    schema = &PL_sv_undef;
	else {
	    schema = ST(2)
;
	}

	if (items < 4)
	    table = &PL_sv_undef;
	else {
	    table = ST(3)
;
	}

	if (items < 5)
	    field = &PL_sv_undef;
	else {
	    field = ST(4)
;
	}

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5)
;
	}
#line 660 "./mysql.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_last_insert_id(sth, imp_sth, catalog, schema, table, field, attr);
    }
#line 1200 "mysql.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__mysql__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_fetchrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 674 "./mysql.xsi"
    D_imp_sth(sth);
    AV *av;
    PERL_UNUSED_VAR(ix);
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 1223 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_fetchrow_array)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 687 "./mysql.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
        int i;
        int num_fields = AvFILL(av)+1;
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(av)[i]);
        }
        PERL_UNUSED_VAR(ix);
    }
#line 1254 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_fetchall_arrayref)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef");
    {
	SV *	sth = ST(0)
;
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1)
;
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2)
;
	}
#line 707 "./mysql.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        SV *tmp = dbixst_bounce_method("DBD::mysql::st::SUPER::fetchall_arrayref", 3);
        SPAGAIN;
        ST(0) = tmp;
    }
    else {
        SV *tmp = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
        SPAGAIN;
        ST(0) = tmp;
    }
#line 1297 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_finish); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_finish)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 723 "./mysql.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
        /* No active statement to finish        */
        XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
        /* Either an explicit disconnect() or global destruction        */
        /* has disconnected us from the database. Finish is meaningless */
        DBIc_ACTIVE_off(imp_sth);
        XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &PL_sv_yes : &PL_sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &PL_sv_yes : &PL_sv_no;
#endif
#line 1330 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_blob_read)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "sth, field, offset, len, destrv=Nullsv, destoffset=0");
    {
	SV *	sth = ST(0)
;
	int	field = (int)SvIV(ST(1))
;
	long	offset = (long)SvIV(ST(2))
;
	long	len = (long)SvIV(ST(3))
;
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4)
;
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5))
;
	}
#line 751 "./mysql.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 1376 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sth, keysv, valuesv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 767 "./mysql.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 1403 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_FETCH_attrib)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "sth, keysv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
#line 784 "./mysql.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    PERL_UNUSED_VAR(ix);
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;    /* dbd_st_FETCH_attrib did sv_2mortal   */
#line 1429 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 797 "./mysql.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_sth(sth);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_sth) && !PL_dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_sth),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) {  /* wants ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
            if (DBIc_DBISTATE(imp_sth)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_sth), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(sth));
        }
        if (DBIc_ACTIVE(imp_sth)) {
            D_imp_dbh_from_sth;
            if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
                dbd_st_finish3(sth, imp_sth, 1);
#else
                dbd_st_finish(sth, imp_sth);
#endif
            }
            else {
                DBIc_ACTIVE_off(imp_sth);
            }
        }
        dbd_st_destroy(sth, imp_sth);
    }
#line 1478 "mysql.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'mysql.xs' from 'mysql.xsi' */


XS_EUPXS(XS_DBD__mysql_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql_constant)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "name, arg");
    {
	char*	name = (char *)SvPV_nolen(ST(0))
;
	char*	arg = (char *)SvPV_nolen(ST(1))
;
	double	RETVAL;
	dXSTARG;
#line 43 "mysql.xs"
    RETVAL = mysql_constant(name, arg);
#line 1503 "mysql.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__dr__ListDBs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr__ListDBs)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 5)
       croak_xs_usage(cv,  "drh, host=NULL, port=NULL, user=NULL, password=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0)
;
	char *	host;
	char *	port;
	char *	user;
	char *	password;

	if (items < 2)
	    host = NULL;
	else {
	    host = (char *)SvPV_nolen(ST(1))
;
	}

	if (items < 3)
	    port = NULL;
	else {
	    port = (char *)SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    user = NULL;
	else {
	    user = (char *)SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    password = NULL;
	else {
	    password = (char *)SvPV_nolen(ST(4))
;
	}
#line 58 "mysql.xs"
{
    MYSQL mysql;
    MYSQL* sock = mysql_dr_connect(drh, &mysql, NULL, host, port, user, password,
				   NULL, NULL);
    if (sock != NULL)
    {
      MYSQL_ROW cur;
      MYSQL_RES* res = mysql_list_dbs(sock, NULL);
      if (!res)
      {
        do_error(drh, mysql_errno(sock), mysql_error(sock), mysql_sqlstate(sock));
      }
      else
      {
	EXTEND(sp, mysql_num_rows(res));
	while ((cur = mysql_fetch_row(res)))
        {
	  PUSHs(sv_2mortal((SV*)newSVpvn(cur[0], strlen(cur[0]))));
	}
	mysql_free_result(res);
      }
      mysql_close(sock);
    }
}
#line 1578 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__dr__admin_internal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr__admin_internal)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 8)
       croak_xs_usage(cv,  "drh, dbh, command, dbname=NULL, host=NULL, port=NULL, user=NULL, password=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	drh = ST(0)
;
	SV*	dbh = ST(1)
;
	char*	command = (char *)SvPV_nolen(ST(2))
;
	char*	dbname;
	char*	host;
	char*	port;
	char*	user;
	char*	password;

	if (items < 4)
	    dbname = NULL;
	else {
	    dbname = (char *)SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    host = NULL;
	else {
	    host = (char *)SvPV_nolen(ST(4))
;
	}

	if (items < 6)
	    port = NULL;
	else {
	    port = (char *)SvPV_nolen(ST(5))
;
	}

	if (items < 7)
	    user = NULL;
	else {
	    user = (char *)SvPV_nolen(ST(6))
;
	}

	if (items < 8)
	    password = NULL;
	else {
	    password = (char *)SvPV_nolen(ST(7))
;
	}
#line 95 "mysql.xs"
{
  MYSQL mysql;
  int retval;
  MYSQL* sock;
#if MYSQL_VERSION_ID >= 50709
  const char *shutdown = "SHUTDOWN";
#endif

  /*
   *  Connect to the database, if required.
 */
  if (SvOK(dbh)) {
    D_imp_dbh(dbh);
    sock = imp_dbh->pmysql;
  }
  else
  {
    sock = mysql_dr_connect(drh, &mysql, NULL, host, port, user,  password, NULL, NULL);
    if (sock == NULL)
    {
      do_error(drh, mysql_errno(&mysql), mysql_error(&mysql),
               mysql_sqlstate(&mysql));
      XSRETURN_NO;
    }
  }

  if (strEQ(command, "shutdown"))
#if MYSQL_VERSION_ID < 40103
    retval = mysql_shutdown(sock);
#else
#if MYSQL_VERSION_ID < 50709
    retval = mysql_shutdown(sock, SHUTDOWN_DEFAULT);
#else
    retval = mysql_real_query(sock, shutdown, strlen(shutdown));
#endif
#endif
  else if (strEQ(command, "reload"))
    retval = mysql_reload(sock);
  else if (strEQ(command, "createdb"))
  {
#if MYSQL_VERSION_ID < 40000
    retval = mysql_create_db(sock, dbname);
#else
    char* buffer = malloc(strlen(dbname)+50);
    if (buffer == NULL)
    {
      do_error(drh, JW_ERR_MEM, "Out of memory" ,NULL);
      XSRETURN_NO;
    }
    else
    {
      strcpy(buffer, "CREATE DATABASE ");
      strcat(buffer, dbname);
      retval = mysql_real_query(sock, buffer, strlen(buffer));
      free(buffer);
    }
#endif
  }
  else if (strEQ(command, "dropdb"))
  {
#if MYSQL_VERSION_ID < 40000
    retval = mysql_drop_db(sock, dbname);
#else
    char* buffer = malloc(strlen(dbname)+50);
    if (buffer == NULL)
    {
      do_error(drh, JW_ERR_MEM, "Out of memory" ,NULL);
      XSRETURN_NO;
    }
    else
    {
      strcpy(buffer, "DROP DATABASE ");
      strcat(buffer, dbname);
      retval = mysql_real_query(sock, buffer, strlen(buffer));
      free(buffer);
    }
#endif
  }
  else
  {
    croak("Unknown command: %s", command);
  }
  if (retval)
  {
    do_error(SvOK(dbh) ? dbh : drh, mysql_errno(sock),
             mysql_error(sock) ,mysql_sqlstate(sock));
  }

  if (SvOK(dbh))
  {
    mysql_close(sock);
  }
  if (retval)
    XSRETURN_NO;
  else 
    XSRETURN_YES;
}
#line 1738 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_type_info_all); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_type_info_all)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 201 "mysql.xs"
{
  /* 	static AV* types = NULL; */
  /* 	if (!types) { */
  /* 	    D_imp_dbh(dbh); */
  /* 	    if (!(types = dbd_db_type_info_all(dbh, imp_dbh))) { */
  /* 	        croak("Cannot create types array (out of memory?)"); */
  /* 	    } */
  /* 	} */
  /* 	ST(0) = sv_2mortal(newRV_inc((SV*) types)); */
  D_imp_dbh(dbh);
  ASYNC_CHECK_XS(dbh);
  ST(0) = sv_2mortal(newRV_noinc((SV*) dbd_db_type_info_all(dbh,
                                                            imp_dbh)));
  XSRETURN(1);
}
#line 1772 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db__ListDBs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db__ListDBs)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 222 "mysql.xs"
  MYSQL_RES* res;
  MYSQL_ROW cur;

  D_imp_dbh(dbh);

  ASYNC_CHECK_XS(dbh);

  res = mysql_list_dbs(imp_dbh->pmysql, NULL);
  if (!res  &&
      (!mysql_db_reconnect(dbh)  ||
       !(res = mysql_list_dbs(imp_dbh->pmysql, NULL))))
{
  do_error(dbh, mysql_errno(imp_dbh->pmysql),
           mysql_error(imp_dbh->pmysql), mysql_sqlstate(imp_dbh->pmysql));
}
else
{
  EXTEND(sp, mysql_num_rows(res));
  while ((cur = mysql_fetch_row(res)))
  {
    PUSHs(sv_2mortal((SV*)newSVpvn(cur[0], strlen(cur[0]))));
  }
  mysql_free_result(res);
}
#line 1815 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_do); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_do)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "dbh, statement, attr=Nullsv, ...");
    {
	SV *	dbh = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	attr;

	if (items < 3)
	    attr = Nullsv;
	else {
	    attr = ST(2)
;
	}
#line 255 "mysql.xs"
{
  D_imp_dbh(dbh);
  int num_params= 0;
  int retval;
  struct imp_sth_ph_st* params= NULL;
  MYSQL_RES* result= NULL;
  SV* async = NULL;
#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
  int next_result_rc;
#endif
#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
  STRLEN slen;
  char            *str_ptr, *buffer;
  int             has_binded;
  int             buffer_length= slen;
  int             buffer_type= 0;
  int             use_server_side_prepare= 0;
  int             disable_fallback_for_server_prepare= 0;
  MYSQL_STMT      *stmt= NULL;
  MYSQL_BIND      *bind= NULL;
#endif
    ASYNC_CHECK_XS(dbh);
#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
    while (mysql_next_result(imp_dbh->pmysql)==0)
    {
      MYSQL_RES* res = mysql_use_result(imp_dbh->pmysql);
      if (res)
        mysql_free_result(res);
      }
#endif
#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION

  /*
   * Globally enabled using of server side prepared statement
   * for dbh->do() statements. It is possible to force driver
   * to use server side prepared statement mechanism by adding
   * 'mysql_server_prepare' attribute to do() method localy:
   * $dbh->do($stmt, {mysql_server_prepared=>1});
  */

  use_server_side_prepare = imp_dbh->use_server_side_prepare;
  if (attr)
  {
    SV** svp;
    DBD_ATTRIBS_CHECK("do", dbh, attr);
    svp = DBD_ATTRIB_GET_SVP(attr, "mysql_server_prepare", 20);

    use_server_side_prepare = (svp) ?
      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;

    svp = DBD_ATTRIB_GET_SVP(attr, "mysql_server_prepare_disable_fallback", 37);
    disable_fallback_for_server_prepare = (svp) ?
      SvTRUE(*svp) : imp_dbh->disable_fallback_for_server_prepare;

    svp   = DBD_ATTRIB_GET_SVP(attr, "async", 5);
    async = (svp) ? *svp : &PL_sv_no;
  }
  if (DBIc_DBISTATE(imp_dbh)->debug >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                  "mysql.xs do() use_server_side_prepare %d, async %d\n",
                  use_server_side_prepare, SvTRUE(async));

  (void)hv_store((HV*)SvRV(dbh), "Statement", 9, SvREFCNT_inc(statement), 0);

  if(SvTRUE(async)) {
#if MYSQL_ASYNC
    if (disable_fallback_for_server_prepare)
    {
      do_error(dbh, ER_UNSUPPORTED_PS,
               "Async option not supported with server side prepare", "HY000");
      XSRETURN_UNDEF;
    }
    use_server_side_prepare = FALSE; /* for now */
    imp_dbh->async_query_in_flight = imp_dbh;
#else
    do_error(dbh, 2000,
             "Async support was not built into this version of DBD::mysql", "HY000");
    XSRETURN_UNDEF;
#endif
  }

  if (use_server_side_prepare)
  {
    str_ptr= SvPV(statement, slen);

    stmt= mysql_stmt_init(imp_dbh->pmysql);

    if ((mysql_stmt_prepare(stmt, str_ptr, strlen(str_ptr)))  &&
        (!mysql_db_reconnect(dbh) ||
         (mysql_stmt_prepare(stmt, str_ptr, strlen(str_ptr)))))
    {
      /*
        For commands that are not supported by server side prepared
        statement mechanism lets try to pass them through regular API
      */
      if (!disable_fallback_for_server_prepare && mysql_stmt_errno(stmt) == ER_UNSUPPORTED_PS)
      {
        use_server_side_prepare= 0;
      }
      else
      {
        do_error(dbh, mysql_stmt_errno(stmt), mysql_stmt_error(stmt)
                 ,mysql_stmt_sqlstate(stmt));
        retval=-2;
      }
      mysql_stmt_close(stmt);
      stmt= NULL;
    }
    else
    {
      /*
        'items' is the number of arguments passed to XSUB, supplied
        by xsubpp compiler, as listed in manpage for perlxs
      */
      if (items > 3)
      {
        /*
          Handle binding supplied values to placeholders assume user has
          passed the correct number of parameters
        */
        int i;
        num_params= items - 3;
        Newz(0, bind, (unsigned int) num_params, MYSQL_BIND);

        for (i = 0; i < num_params; i++)
        {
          int defined= 0;
          SV *param= ST(i+3);

          if (param)
          {
            if (SvMAGICAL(param))
              mg_get(param);
            if (SvOK(param))
              defined= 1;
          }
          if (defined)
          {
            buffer= SvPV(param, slen);
            buffer_length= slen;
            buffer_type= MYSQL_TYPE_STRING;
          }
          else
          {
            buffer= NULL;
            buffer_length= 0;
            buffer_type= MYSQL_TYPE_NULL;
          }

          bind[i].buffer_type = buffer_type;
          bind[i].buffer_length= buffer_length;
          bind[i].buffer= buffer;
        }
        has_binded= 0;
      }
      retval = mysql_st_internal_execute41(dbh,
                                           num_params,
                                           &result,
                                           stmt,
                                           bind,
                                           &has_binded);
      if (bind)
        Safefree(bind);

      mysql_stmt_close(stmt);
      stmt= NULL;

      if (retval == -2) /* -2 means error */
      {
        SV *err = DBIc_ERR(imp_dbh);
        if (!disable_fallback_for_server_prepare && SvIV(err) == ER_UNSUPPORTED_PS)
        {
          use_server_side_prepare = 0;
        }
      }
    }
  }

  if (! use_server_side_prepare)
  {
#endif
    if (items > 3)
    {
      /*  Handle binding supplied values to placeholders	   */
      /*  Assume user has passed the correct number of parameters  */
      int i;
      num_params= items-3;
      Newz(0, params, sizeof(*params)*num_params, struct imp_sth_ph_st);
      for (i= 0;  i < num_params;  i++)
      {
        params[i].value= ST(i+3);
        params[i].type= SQL_VARCHAR;
      }
    }
    retval = mysql_st_internal_execute(dbh, statement, attr, num_params,
                                       params, &result, imp_dbh->pmysql, 0);
#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  }
#endif
  if (params)
    Safefree(params);

  if (result)
  {
    mysql_free_result(result);
    result= 0;
  }
#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
  if (retval != -2 && !SvTRUE(async)) /* -2 means error */
    {
      /* more results? -1 = no, >0 = error, 0 = yes (keep looping) */
      while ((next_result_rc= mysql_next_result(imp_dbh->pmysql)) == 0)
      {
        result = mysql_use_result(imp_dbh->pmysql);
          if (result)
            mysql_free_result(result);
          }
          if (next_result_rc > 0)
          {
            if (DBIc_DBISTATE(imp_dbh)->debug >= 2)
              PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                            "\t<- do() ERROR: %s\n",
                            mysql_error(imp_dbh->pmysql));

              do_error(dbh, mysql_errno(imp_dbh->pmysql),
                       mysql_error(imp_dbh->pmysql),
                       mysql_sqlstate(imp_dbh->pmysql));
              retval= -2;
          }
    }
#endif
  /* remember that dbd_st_execute must return <= -2 for error	*/
  if (retval == 0)		/* ok with no rows affected	*/
    XST_mPV(0, "0E0");	/* (true but zero)		*/
  else if (retval < -1)	/* -1 == unknown number of rows	*/
    XST_mUNDEF(0);		/* <= -2 means error   		*/
  else
    XST_mIV(0, retval);	/* typically 1, rowcount or -1	*/
}
#line 2081 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_ping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_ping)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV*	dbh = ST(0)
;
	SV *	RETVAL;
#line 501 "mysql.xs"
    {
      int retval;

      D_imp_dbh(dbh);
      ASYNC_CHECK_XS(dbh);
      retval = (mysql_ping(imp_dbh->pmysql) == 0);
      if (!retval) {
	if (mysql_db_reconnect(dbh)) {
	  retval = (mysql_ping(imp_dbh->pmysql) == 0);
	}
      }
      RETVAL = boolSV(retval);
    }
#line 2111 "mysql.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_quote); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_quote)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, str, type=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
	SV*	str = ST(1)
;
	SV*	type;

	if (items < 3)
	    type = NULL;
	else {
	    type = ST(2)
;
	}
#line 526 "mysql.xs"
    {
        SV* quoted;

        D_imp_dbh(dbh);
        ASYNC_CHECK_XS(dbh);

        quoted = dbd_db_quote(dbh, str, type);
	ST(0) = quoted ? sv_2mortal(quoted) : str;
	XSRETURN(1);
    }
#line 2151 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_mysql_fd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_mysql_fd)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV*	dbh = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 540 "mysql.xs"
    {
        D_imp_dbh(dbh);
        RETVAL = imp_dbh->pmysql->net.fd;
    }
#line 2174 "mysql.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_mysql_async_result); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_mysql_async_result)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 550 "mysql.xs"
    {
#if MYSQL_ASYNC
        int retval;

        retval = mysql_db_async_result(dbh, NULL);

        if(retval > 0) {
            XSRETURN_IV(retval);
        } else if(retval == 0) {
            XSRETURN_PV("0E0");
        } else {
            XSRETURN_UNDEF;
        }
#else
        do_error(dbh, 2000, "Async support was not built into this version of DBD::mysql", "HY000");
        XSRETURN_UNDEF;
#endif
    }
#line 2211 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_mysql_async_ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_mysql_async_ready)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 572 "mysql.xs"
    {
#if MYSQL_ASYNC
        int retval;

        retval = mysql_db_async_ready(dbh);
        if(retval > 0) {
            XSRETURN_YES;
        } else if(retval == 0) {
            XSRETURN_NO;
        } else {
            XSRETURN_UNDEF;
        }
#else
        do_error(dbh, 2000, "Async support was not built into this version of DBD::mysql", "HY000");
        XSRETURN_UNDEF;
#endif
    }
#line 2247 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db__async_check); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db__async_check)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 593 "mysql.xs"
    {
        D_imp_dbh(dbh);
        ASYNC_CHECK_XS(dbh);
        XSRETURN_YES;
    }
#line 2271 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__st_more_results); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_more_results)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 605 "mysql.xs"
{
#if (MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION)
  D_imp_sth(sth);
  if (dbd_st_more_results(sth, imp_sth))
  {
    RETVAL=1;
  }
  else
  {
    RETVAL=0;
  }
#endif
}
#line 2303 "mysql.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_dataseek); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_dataseek)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "sth, pos");
    {
	SV*	sth = ST(0)
;
	int	pos = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 627 "mysql.xs"
{
  D_imp_sth(sth);
#if (MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION)
  if (imp_sth->use_server_side_prepare)
  {
    if (imp_sth->use_mysql_use_result || 1)
    {
      if (imp_sth->result && imp_sth->stmt)
      {
        mysql_stmt_data_seek(imp_sth->stmt, pos);
        imp_sth->fetch_done=0;
        RETVAL = 1;
      }
      else
      {
        RETVAL = 0;
        do_error(sth, JW_ERR_NOT_ACTIVE, "Statement not active" ,NULL);
      }
    }
    else
    {
      RETVAL = 0;
      do_error(sth, JW_ERR_NOT_ACTIVE, "No result set" ,NULL);
    }
  }
  else
  {
#endif
  if (imp_sth->result) {
    mysql_data_seek(imp_sth->result, pos);
    RETVAL = 1;
  } else {
    RETVAL = 0;
    do_error(sth, JW_ERR_NOT_ACTIVE, "Statement not active" ,NULL);
  }
#if (MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION) 
  }
#endif
}
#line 2363 "mysql.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_rows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_rows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV*	sth = ST(0)
;
#line 673 "mysql.xs"
    D_imp_sth(sth);
    char buf[64];
#if MYSQL_ASYNC
    D_imp_dbh_from_sth;
    if(imp_dbh->async_query_in_flight) {
        if(mysql_db_async_result(sth, &imp_sth->result) < 0) {
            XSRETURN_UNDEF;
        }
    }
#endif

  /* fix to make rows able to handle errors and handle max value from 
     affected rows.
     if mysql_affected_row returns an error, it's value is 18446744073709551614,
     while a (my_ulonglong)-1 is  18446744073709551615, so we have to add 1 to
     imp_sth->row_num to know if there's an error
  */
  if (imp_sth->row_num+1 ==  (my_ulonglong) -1)
    sprintf(buf, "%d", -1);
  else
    sprintf(buf, "%llu", imp_sth->row_num);

  ST(0) = sv_2mortal(newSVpvn(buf, strlen(buf)));
#line 2403 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_mysql_async_result); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_mysql_async_result)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV*	sth = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 700 "mysql.xs"
    {
#if MYSQL_ASYNC
        D_imp_sth(sth);
        int retval;

        retval= mysql_db_async_result(sth, &imp_sth->result);

        if(retval > 0) {
            imp_sth->row_num = retval;
            XSRETURN_IV(retval);
        } else if(retval == 0) {
            imp_sth->row_num = retval;
            XSRETURN_PV("0E0");
        } else {
            XSRETURN_UNDEF;
        }
#else
        do_error(sth, 2000,
                 "Async support was not built into this version of DBD::mysql", "HY000");
        XSRETURN_UNDEF;
#endif
    }
#line 2443 "mysql.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_mysql_async_ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_mysql_async_ready)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	sth = ST(0)
;
#line 728 "mysql.xs"
    {
#if MYSQL_ASYNC
        int retval;

        retval = mysql_db_async_ready(sth);
        if(retval > 0) {
            XSRETURN_YES;
        } else if(retval == 0) {
            XSRETURN_NO;
        } else {
            XSRETURN_UNDEF;
        }
#else
        do_error(sth, 2000,
                 "Async support was not built into this version of DBD::mysql", "HY000");
        XSRETURN_UNDEF;
#endif
    }
#line 2480 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__st__async_check); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st__async_check)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	sth = ST(0)
;
#line 750 "mysql.xs"
    {
        D_imp_sth(sth);
        D_imp_dbh_from_sth;
        ASYNC_CHECK_XS(sth);
        XSRETURN_YES;
    }
#line 2505 "mysql.c"
	PUTBACK;
	return;
    }
}

#define SQL_CATALOG_NAME_SEPARATOR 41
#define SQL_CATALOG_TERM 42
#define SQL_DBMS_VER 18
#define SQL_IDENTIFIER_QUOTE_CHAR 29
#define SQL_MAXIMUM_STATEMENT_LENGTH 105
#define SQL_MAXIMUM_TABLES_IN_SELECT 106
#define SQL_MAX_TABLE_NAME_LEN 35
#define SQL_SERVER_NAME 13
#define SQL_ASYNC_MODE 10021
#define SQL_MAX_ASYNC_CONCURRENT_STATEMENTS 10022
#define SQL_AM_NONE       0
#define SQL_AM_CONNECTION 1
#define SQL_AM_STATEMENT  2

XS_EUPXS(XS_DBD__mysql__GetInfo_dbd_mysql_get_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__GetInfo_dbd_mysql_get_info)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, sql_info_type");
    {
	SV*	dbh = ST(0)
;
	SV*	sql_info_type = ST(1)
;
#line 787 "mysql.xs"
    D_imp_dbh(dbh);
    IV type = 0;
    SV* retsv=NULL;
#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50709
/* MariaDB 10 is not MySQL source level compatible so this only applies to MySQL*/
    IV buffer_len;
#endif 

    if (SvMAGICAL(sql_info_type))
        mg_get(sql_info_type);

    if (SvOK(sql_info_type))
    	type = SvIV(sql_info_type);
    else
    	croak("get_info called with an invalied parameter");

    switch(type) {
    	case SQL_CATALOG_NAME_SEPARATOR:
	    /* (dbc->flag & FLAG_NO_CATALOG) ? WTF is in flag ? */
	    retsv = newSVpvn(".",1);
	    break;
	case SQL_CATALOG_TERM:
	    /* (dbc->flag & FLAG_NO_CATALOG) ? WTF is in flag ? */
	    retsv = newSVpvn("database",8);
	    break;
	case SQL_DBMS_VER:
	    retsv = newSVpvn(
	        imp_dbh->pmysql->server_version,
		strlen(imp_dbh->pmysql->server_version)
	    );
	    break;
	case SQL_IDENTIFIER_QUOTE_CHAR:
	    retsv = newSVpvn("`", 1);
	    break;
	case SQL_MAXIMUM_STATEMENT_LENGTH:
#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50709
        /* MariaDB 10 is not MySQL source level compatible so this
           only applies to MySQL*/
	    /* mysql_get_option() was added in mysql 5.7.3 */
	    /* MYSQL_OPT_NET_BUFFER_LENGTH was added in mysql 5.7.9 */
	    mysql_get_option(NULL, MYSQL_OPT_NET_BUFFER_LENGTH, &buffer_len);
	    retsv = newSViv(buffer_len);
#else
	    /* before mysql 5.7.9 use net_buffer_length macro */
	    retsv = newSViv(net_buffer_length);
#endif
	    break;
	case SQL_MAXIMUM_TABLES_IN_SELECT:
	    /* newSViv((sizeof(int) > 32) ? sizeof(int)-1 : 31 ); in general? */
	    retsv= newSViv((sizeof(int) == 64 ) ? 63 : 31 );
	    break;
	case SQL_MAX_TABLE_NAME_LEN:
	    retsv= newSViv(NAME_LEN);
	    break;
	case SQL_SERVER_NAME:
	    retsv= newSVpvn(imp_dbh->pmysql->host_info,strlen(imp_dbh->pmysql->host_info));
	    break;
        case SQL_ASYNC_MODE:
#if MYSQL_ASYNC
            retsv = newSViv(SQL_AM_STATEMENT);
#else
            retsv = newSViv(SQL_AM_NONE);
#endif
            break;
        case SQL_MAX_ASYNC_CONCURRENT_STATEMENTS:
#if MYSQL_ASYNC
            retsv = newSViv(1);
#else
            retsv = newSViv(0);
#endif
            break;
    	default:
 		croak("Unknown SQL Info type: %i", mysql_errno(imp_dbh->pmysql));
    }
    ST(0) = sv_2mortal(retsv);
#line 2612 "mysql.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_DBD__mysql); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_DBD__mysql)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("DBD::mysql::dr::dbixs_revision", XS_DBD__mysql__dr_dbixs_revision);
#if XSubPPtmpAAAA
        cv = newXS_deffile("DBD::mysql::dr::discon_all_", XS_DBD__mysql__dr_discon_all_);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("DBD::mysql::dr::disconnect_all", XS_DBD__mysql__dr_discon_all_);
        XSANY.any_i32 = 1;
#endif
#if XSubPPtmpAAAB
        newXS_deffile("DBD::mysql::dr::data_sources", XS_DBD__mysql__dr_data_sources);
#endif
        newXS_deffile("DBD::mysql::db::_login", XS_DBD__mysql__db__login);
        newXS_deffile("DBD::mysql::db::selectall_arrayref", XS_DBD__mysql__db_selectall_arrayref);
        cv = newXS_deffile("DBD::mysql::db::selectrow_array", XS_DBD__mysql__db_selectrow_arrayref);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("DBD::mysql::db::selectrow_arrayref", XS_DBD__mysql__db_selectrow_arrayref);
        XSANY.any_i32 = 0;
#if XSubPPtmpAAAC
        newXS_deffile("DBD::mysql::db::do", XS_DBD__mysql__db_do);
#endif
#if XSubPPtmpAAAD
        newXS_deffile("DBD::mysql::db::last_insert_id", XS_DBD__mysql__db_last_insert_id);
#endif
        newXS_deffile("DBD::mysql::db::commit", XS_DBD__mysql__db_commit);
        newXS_deffile("DBD::mysql::db::rollback", XS_DBD__mysql__db_rollback);
        newXS_deffile("DBD::mysql::db::disconnect", XS_DBD__mysql__db_disconnect);
        newXS_deffile("DBD::mysql::db::STORE", XS_DBD__mysql__db_STORE);
        newXS_deffile("DBD::mysql::db::FETCH", XS_DBD__mysql__db_FETCH);
        newXS_deffile("DBD::mysql::db::DESTROY", XS_DBD__mysql__db_DESTROY);
#if XSubPPtmpAAAE
        newXS_deffile("DBD::mysql::db::take_imp_data", XS_DBD__mysql__db_take_imp_data);
#endif
#if XSubPPtmpAAAF
        newXS_deffile("DBD::mysql::db::data_sources", XS_DBD__mysql__db_data_sources);
#endif
        newXS_deffile("DBD::mysql::st::_prepare", XS_DBD__mysql__st__prepare);
#if XSubPPtmpAAAG
        newXS_deffile("DBD::mysql::st::rows", XS_DBD__mysql__st_rows);
#endif
#if XSubPPtmpAAAH
        newXS_deffile("DBD::mysql::st::bind_col", XS_DBD__mysql__st_bind_col);
#endif
        newXS_deffile("DBD::mysql::st::bind_param", XS_DBD__mysql__st_bind_param);
        newXS_deffile("DBD::mysql::st::bind_param_inout", XS_DBD__mysql__st_bind_param_inout);
        newXS_deffile("DBD::mysql::st::execute", XS_DBD__mysql__st_execute);
#if XSubPPtmpAAAI
        newXS_deffile("DBD::mysql::st::execute_for_fetch", XS_DBD__mysql__st_execute_for_fetch);
#endif
#if XSubPPtmpAAAJ
        newXS_deffile("DBD::mysql::st::last_insert_id", XS_DBD__mysql__st_last_insert_id);
#endif
        cv = newXS_deffile("DBD::mysql::st::fetch", XS_DBD__mysql__st_fetchrow_arrayref);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("DBD::mysql::st::fetchrow_arrayref", XS_DBD__mysql__st_fetchrow_arrayref);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("DBD::mysql::st::fetchrow", XS_DBD__mysql__st_fetchrow_array);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("DBD::mysql::st::fetchrow_array", XS_DBD__mysql__st_fetchrow_array);
        XSANY.any_i32 = 0;
        newXS_deffile("DBD::mysql::st::fetchall_arrayref", XS_DBD__mysql__st_fetchall_arrayref);
        newXS_deffile("DBD::mysql::st::finish", XS_DBD__mysql__st_finish);
        newXS_deffile("DBD::mysql::st::blob_read", XS_DBD__mysql__st_blob_read);
        newXS_deffile("DBD::mysql::st::STORE", XS_DBD__mysql__st_STORE);
        cv = newXS_deffile("DBD::mysql::st::FETCH", XS_DBD__mysql__st_FETCH_attrib);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("DBD::mysql::st::FETCH_attrib", XS_DBD__mysql__st_FETCH_attrib);
        XSANY.any_i32 = 0;
        newXS_deffile("DBD::mysql::st::DESTROY", XS_DBD__mysql__st_DESTROY);
        newXS_deffile("DBD::mysql::constant", XS_DBD__mysql_constant);
        newXS_deffile("DBD::mysql::dr::_ListDBs", XS_DBD__mysql__dr__ListDBs);
        newXS_deffile("DBD::mysql::dr::_admin_internal", XS_DBD__mysql__dr__admin_internal);
        newXS_deffile("DBD::mysql::db::type_info_all", XS_DBD__mysql__db_type_info_all);
        newXS_deffile("DBD::mysql::db::_ListDBs", XS_DBD__mysql__db__ListDBs);
        (void)newXSproto_portable("DBD::mysql::db::do", XS_DBD__mysql__db_do, file, "$$;$@");
        (void)newXSproto_portable("DBD::mysql::db::ping", XS_DBD__mysql__db_ping, file, "$");
        (void)newXSproto_portable("DBD::mysql::db::quote", XS_DBD__mysql__db_quote, file, "$$;$");
        newXS_deffile("DBD::mysql::db::mysql_fd", XS_DBD__mysql__db_mysql_fd);
        newXS_deffile("DBD::mysql::db::mysql_async_result", XS_DBD__mysql__db_mysql_async_result);
        newXS_deffile("DBD::mysql::db::mysql_async_ready", XS_DBD__mysql__db_mysql_async_ready);
        newXS_deffile("DBD::mysql::db::_async_check", XS_DBD__mysql__db__async_check);
        newXS_deffile("DBD::mysql::st::more_results", XS_DBD__mysql__st_more_results);
        (void)newXSproto_portable("DBD::mysql::st::dataseek", XS_DBD__mysql__st_dataseek, file, "$$");
        newXS_deffile("DBD::mysql::st::rows", XS_DBD__mysql__st_rows);
        newXS_deffile("DBD::mysql::st::mysql_async_result", XS_DBD__mysql__st_mysql_async_result);
        newXS_deffile("DBD::mysql::st::mysql_async_ready", XS_DBD__mysql__st_mysql_async_ready);
        newXS_deffile("DBD::mysql::st::_async_check", XS_DBD__mysql__st__async_check);
        newXS_deffile("DBD::mysql::GetInfo::dbd_mysql_get_info", XS_DBD__mysql__GetInfo_dbd_mysql_get_info);

    /* Initialisation Section */

#line 39 "./mysql.xsi"
    PERL_UNUSED_VAR(items);
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::mysql::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::mysql::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::mysql::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#line 2763 "mysql.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

