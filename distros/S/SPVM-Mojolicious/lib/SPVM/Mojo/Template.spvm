# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Template {
  version_from Mojolicious;
  
  use Mojo::ByteStream;
  use Mojo::File;
  use Mojo::Util;
  use Native;
  use Native::MethodCall;
  
  # Fields
  has code : rw string;
  
  has unparsed : rw string;
  
  has compiled : rw string;
  
  has capture_end : rw string;
  
  has capture_start : rw string;
  
  has comment_mark : rw string;
  
  has escape_mark : rw string;
  
  has expression_mark : rw string;
  
  has trim_mark : rw string;
  
  has line_start : rw string;
  
  has replace_mark : rw string;
  
  has name : rw string;
  
  has tag_start : rw string;
  
  has tag_end : rw string;
  
  has auto_escape : rw byte;
  
  # Undocumented Fields
  has tree : rw string[][];

  # Class Methods
  static method new : Mojo::Template () {
    
    my $self = new Mojo::Template;
    
    $self->{code} = "";
    
    $self->{unparsed} = "";
    
    $self->{tag_start} = "<%";
    
    $self->{tag_end} = "%>";
    
    $self->{line_start} = "%";
    
    $self->{expression_mark} = "=";
    
    $self->{capture_end} = "end";
    
    $self->{capture_start} = "begin";
    
    $self->{comment_mark} = "#";
    
    $self->{escape_mark} = "=";
    
    $self->{trim_mark} = "=";
    
    $self->{replace_mark} = "%";
    
    $self->{name} = "template";
    
    $self->{tree} = new string[][0];
    
    return $self;
  }
  
  static method DEBUG : int () {
    return length(my $_ = Sys->env("SPVM_MOJO_TEMPLATE_DEBUG")) ? (int)$_ : 0;
  }
  
  
  method parse : void ($template : string) {
    
    $self->set_unparsed($template);
    $self->set_compiled(undef);
    
    my $tree = $self->tokenize($template);
    
    $tree = $self->check($tree);
    
    $self->set_tree($tree);
  }
  
  private method tokenize : string[][] ($template : string) {
    
    my $tree = (List of string[])List->new(new string[][0]);
    
    my $line_start = $self->line_start;           # %
    my $tag_start = $self->tag_start;             # <%
    my $replace_mark = $self->replace_mark;       # %
    my $comment_mark = $self->comment_mark;       # #
    my $expression_mark = $self->expression_mark; # =
    my $escape_mark = $self->escape_mark;         # =
    
    my $trim_mark = $self->trim_mark;             # =
    my $tag_end = $self->tag_end;                 # %>
    
    my $capture_start = $self->capture_start;     # begin
    my $capture_end = $self->capture_end;         # end
    
    my $line_code_re  = "^(\s*)\Q$line_start\E(?:(\Q$replace_mark\E)|(\Q$comment_mark\E)|(\Q$expression_mark\E))?(.*)$";
    
    my $code_re = "(\Q$tag_start\E(?:\Q$replace_mark\E|\Q$comment_mark\E)|\Q$tag_start$expression_mark\E(?:\Q$escape_mark\E)?(?:\s*\Q$capture_end\E\b)?|\Q$tag_start\E(?:\s*\Q$capture_end\E\b)?|(?:\b\Q$capture_start\E\s*(?:\([^\)]*\))?\s*)?(?:\Q$trim_mark\E)?\Q$tag_end\E)";
    
    my $tag_end_re  = "^(?:(\Q$capture_start\E)\s*(\([^\)]*\))?\s*)?(\Q$trim_mark\E)?\Q$tag_end\E$";
    my $capture_end_re = "^\Q$tag_start\E(?:\Q$expression_mark\E)?(?:\Q$escape_mark\E)?\s*\Q$capture_end\E(.*)$";
    
    # Split lines
    my $lines = Fn->split("\n", $template);
    
    my $op = "text";
    my $is_capture_end = 0;
    for (my $line_index = 0; $line_index < @$lines; $line_index++) {
      
      my $line = $lines->[$line_index];
      
      $tree->push(["line_start", undef, $line_index + 1]);
      
      if (is_read_only $line) {
        $line = copy $line;
      }
      
      # Turn Perl line into mixed line
      if ($op eq "text" && (my $m = Re->m($line, $line_code_re))) {
        
        # Escaped start
        if (length $m->cap2) { $line = $m->cap1 . $line_start . $m->cap5; }
        
        # Comment
        elsif (length $m->cap3) { $line = $tag_start . $m->cap3 . "$trim_mark$tag_end"; }
        
        # Expression or code
        else { $line = length $m->cap4 ? $m->cap1 . $tag_start . $m->cap4 . $m->cap5 . $tag_end : $tag_start . $m->cap5 . "$trim_mark$tag_end"; }
      }
      
      # Escaped line ending
      my $escape_line_ending = 0;
      if (!Re->s((mutable string)$line, "\\\\\\\\$", "\\")) {
        if (Re->s((mutable string)$line, "\\\\$", "")) {
          $escape_line_ending = 1;
        }
      }
      
      # Mixed line
      my $tokens = Re->split($code_re, $line);
      for my $token (@$tokens) {
        # Capture end
        if (my $m = Re->m($token, $capture_end_re)) {
          $token = $tag_start . $m->cap1;
          $is_capture_end = 1;
        }
        
        # Tag End
        if ($op ne "text" && (my $m = Re->m($token, $tag_end_re))) {
          
          # Capture start
          if (length $m->cap1) {
            $tree->push(["capture_start", $m->cap2, $line_index + 1]);
          }
          
          my $trim = (string)undef;
          if (length $m->cap3) {
            $trim = "trim";
          }
          $tree->push(["tag_end", $trim, $line_index + 1]);
          
          $op = "text";
        }
        
        # Tag start - Comment
        elsif ($token eq "$tag_start$comment_mark") {
          $op = "cmnt";
          $tree->push(["tag_start", $op, $line_index + 1]);
        }
        
        # Tag start - Expression that needs to be escaped
        elsif ($token eq "$tag_start$expression_mark$escape_mark") {
          $op = "excaped_expression";
          $tree->push(["tag_start", $op, $line_index + 1]);
        }
        
        # Tag start - Expression
        elsif ($token eq "$tag_start$expression_mark") {
          $op = "expression";
          $tree->push(["tag_start", $op, $line_index + 1]);
        }
        
        # Tag start
        elsif ($token eq $tag_start) {
          $op = "code";
          $tree->push(["tag_start", $op, $line_index + 1]);
        }
        
        # Text
        else {
          # Token (with optional capture end)
          if ($is_capture_end) {
            $tree->push(["capture_end", undef, $line_index + 1]);
          }
          else {
            # Replace
            if ($token eq "$tag_start$replace_mark") {
              $token = $tag_start ;
            }
            
            $tree->push([$op, $token, $line_index + 1]);
          }
          $is_capture_end = 0;
        }
      }
      
      unless ($escape_line_ending) {
        $tree->push([$op, "\n", $line_index + 1]);
        $tree->push(["line_end", undef, $line_index + 1]);
      }
    }
    
    return $tree->to_array;
  }
  
  private method check : string[][] ($tree : string[][]) {
    
    my $tree = (string[][])Array->copy_object_address($tree);
    
    # Process trim mark
    for (my $tree_index = 0; $tree_index < @$tree; $tree_index++) {
      
      my $token = $tree->[$tree_index];
      
      my $op = $token->[0];
      
      if ($op eq "tag_end") {
        my $trim = $token->[1];
        
        if ($trim) {
          # Remove previous spaces
          my $tag_start_index = -1;
          for (my $tree_index_prev = $tree_index - 1; $tree_index_prev >= 0; $tree_index_prev--) {
            my $token_prev = $tree->[$tree_index_prev];
            my $op_prev = $token_prev->[0];
            
            if ($op_prev eq "tag_start") {
              $tag_start_index = $tree_index_prev;
              last;
            }
          }
          
          if ($tag_start_index >= 0) {
            for (my $tree_index_prev = $tag_start_index - 1; $tree_index_prev >= 0; $tree_index_prev--) {
              my $token_prev = $tree->[$tree_index_prev];
              my $op_prev = $token_prev->[0];
              
              if ($op_prev eq "text") {
                if (my $m = Re->m($token_prev->[1], "(.*?)\s+$")) {
                  $token_prev->[1] = $m->cap1;
                }
                if (length $token_prev->[1]) {
                  last;
                }
              }
              else {
                last;
              }
            }
          }
          
          # Remove later spaces
          for (my $tree_index_later = $tree_index + 1; $tree_index_later < @$tree; $tree_index_later++) {
            my $token_later = $tree->[$tree_index_later];
            
            my $op_later = $token_later->[0];
            unless ($op_later eq "text" | $op_later eq "line_end") {
              last;
            }
            
            if ($op_later eq "text") {
              if (my $m = Re->m($token_later->[1], "^\s+(.*)")) {
                $token_later->[1] = $m->cap1;
              }
              if (length $token_later->[1]) {
                last;
              }
            }
            else {
              last;
            }
          }
        }
      }
    }
    
    # Merge text and expression
    for my $target_op (@{["text", "excaped_expression", "expression"]}) {
      my $tree_index = 0;
      while (1) {
        
        if ($tree_index == @$tree) {
          last;
        }
        
        my $base_tree_index = -1;
        
        my $token = $tree->[$tree_index];
        my $op = $token->[0];
        
        if ($op eq $target_op) {
          $base_tree_index = $tree_index;
          my $next = 0;
          while (1) {
            $tree_index++;
            if ($tree_index + 2 < @$tree && $tree->[$tree_index][0] eq "line_end" && $tree->[$tree_index + 1][0] eq "line_start" && $tree->[$tree_index + 2][0] eq $target_op) {
              $tree->[$base_tree_index][1] .= $tree->[$tree_index + 2][1];
              $tree->[$tree_index][0] = "none";
              $tree->[$tree_index][1] = "";
              $tree->[$tree_index + 1][0] = "none";
              $tree->[$tree_index + 1][1] = "";
              $tree->[$tree_index + 2][0] = "none";
              $tree->[$tree_index + 2][1] = "";
              $tree_index += 2;
            }
            elsif ($tree->[$tree_index][0] eq $target_op) {
              $tree->[$base_tree_index][1] .= $tree->[$tree_index][1];
              $tree->[$tree_index][0] = "none";
              $tree->[$tree_index][1] = "";
            }
            else {
              $next = 1;
              last;
            }
          }
          
          if ($next) {
            next;
          }
        }
        
        $tree_index++;
      }
    }
    
    my $new_tree = (List of string[])List->new(new string[][0]);
    for (my $tree_index = 0; $tree_index < @$tree; $tree_index++) {
      
      my $token = $tree->[$tree_index];
      
      my $op = $token->[0];
      
      unless ($op eq "none") {
        $new_tree->push($token);
      }
    }
    
    return $new_tree->to_array;
  }
  
  method process : string ($args : Hash|object[] = undef, $c : Mojolicious::Controller = undef) {
    
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
    
      $self->_compile;
      
      my $code = $self->code;
      
      eval { $compiled = Native->use_anon_class($code); }
      if ($@) {
        my $name = $self->name;
        die "$@\n[Template:$name]\n" . $self->unparsed . "\n[Code]\n$code";
      }
      
      $self->set_compiled($compiled);
    }
    
    my $output = (string)Native::MethodCall->call_class_method($compiled, "code", [(object)$args, $c]);
    
    return $output;
  }
  
  private method _compile : void () {
    
    my $tree = (List of string[])List->new($self->tree);
    my $escape = $self->auto_escape;
    
    my $name = $self->name;
    
    my $code = StringBuffer->new;
    
    $code->push("#file \"$name\"\n");
    $code->push("class {\n");
    $code->push("  use Mojo::Util;\n");
    $code->push("  use Mojo::ByteStream;\n");
    $code->push("  use Mojolicious::Controller;\n");
    $code->push("static method code : string (\$args : Hash = undef, \$c : Mojolicious::Controller = undef) {\n");
    $code->push("my \$_O = \"\";\n");
    
    my $i = 0;
    my $capture = (string)undef;
    
    for (my $i = 0; $i < @$tree; $i++) {
      
      my $token = $tree->[$i];
      my $op = $token->[0];
      my $value = $token->[1];
      my $line = $token->[2];
      
      # Text
      if ($op eq "text") {
        my $lines = Fn->split("\n", $value, -1);
        
        $code->push("\$_O .= <<'END_OF_STRING';\n");
        
        for my $line (@$lines) {
          $code->push("$line\n");
        }
        
        $code->push("END_OF_STRING\n");
        
        $code->push("Fn->chomp((mutable string)\$_O);\n");
      }
      
      # Code
      elsif ($op eq "code") {
        $code->push("#line $line\n");
        $code->push("$value\n");
      }
      # Expression or escapaced expr
      elsif ($op eq "expression" || $op eq "excaped_expression") {
        
        $code->push("#line $line\n");
        
        # Escaped
        if ($op eq "excaped_expression" && !$escape || $op eq "expression" && $escape) {
          $code->push("my \$_ = (object)$value;\$_O .= \$_ isa Mojo::ByteStream ? \$_->(Mojo::ByteStream)->to_string : Mojo::Util->xml_escape(\$_ isa Stringable ? \$_->(Stringable)->to_string : (string)\$_);\n");
        }
        
        # Raw
        else {
          $code->push("\$_O .= $value;\n");
        }
      }
      elsif ($op eq "capture_start") {
        my $capture_args = $value;
        unless (length $capture_args) {
          $capture_args = "()";
        }
        $code->push("[\$c : Mojolicious::Controller] method : string $capture_args {\n");
        $code->push("my \$_O = \"\";\n");
      }
      elsif ($op eq "capture_end") {
        $code->push("return \$_O;\n");
        $code->push("};\n");
      }
    }
    
    $code->push("return \$_O;\n");
    $code->push("} # End of method\n");
    $code->push("} # End of class\n");
    
    $self->set_code($code->get_string);
  }
  
  method render : string ($template : string, $args : Hash|object[] = undef, $c : Mojolicious::Controller = undef) {
    
    $self->parse($template);
    
    my $output = $self->process($args, $c);
    
    return $output;
  }
  
  method render_file : string ($path : string, $args : Hash|object[] = undef, $c : Mojolicious::Controller = undef) {
    
    unless ($self->{name}) {
      $self->set_name($path) ;
    }
    my $template = Mojo::File->path($path)->slurp;
    
    return $self->render($template, $args, $c);
  }
  
}
