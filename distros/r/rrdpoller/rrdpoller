#!/usr/bin/perl

use strict;
use Error qw(:try);

# $Id: rrdpoller,v 1.19 2005/02/28 17:42:35 rs Exp $
$main::VERSION = "1.5.0";

=pod

=head1 NAME

rrdpoller - Retrieve RRD file data and apply some threshold algorithm

=head1 SYNOPSIS

B<rrdpoller> [B<OPTIONS>] B<list|ls> I<filename>

B<rrdpoller> [B<OPTIONS>] B<get> I<filename> I<datasource> [B<offset>=I<time>]
[B<cf>=I<func-name>] [and|or command...]

B<rrdpoller> [B<OPTIONS>] B<exact> I<filename> I<datasource> I<value> [and|or command...]

B<rrdpoller> [B<OPTIONS>] B<boundaries> I<filename> I<datasource> [B<min>=I<number>]
[B<max>=I<number>] [and|or command...]

B<rrdpoller> [B<OPTIONS>] B<relation> I<filename> I<datasource> [I<E<lt>>|I<E<gt>>]I<threshold>[I<%>]
[B<target>=I<filename>] [B<compare-ds>=I<datasource>] [B<offset>=I<time>] [and|or command...]

B<rrdpoller> [B<OPTIONS>] B<quotient> I<filename> I<datasource> [I<E<lt>>|I<E<gt>>]I<threshold>[I<%>]
[B<target>=I<filename>] [B<target-ds>=I<datasource>] [B<offset>=I<time>] [and|or command...]

B<rrdpoller> [B<OPTIONS>] B<hunt> I<filename> I<datasource> I<roll> [B<parent>=I<filename>]
[B<parent-ds>=I<datasource>] [and|or command...]

=head1 DESCRIPTION

B<rrdpoller> allows you to poll RRD files and get current value of a
given datasource. Additionally it implement some advanced checks able
to use past values to decide if the current one is out of threshold or
not.

The main purpose of this tool is to do the interface between an
existing monitoring system like BigBrother, Nagios or Mon and a set of
RRD graphs generated by some specialized data collectors like
rrdcollect, Cricket and such. Thus you can build a very modular
monitoring/trend architecture without the need of double polling.

=head1 EXAMPLES

Those examples are fictive, they doesn't represent real numbers. It's
just to let you figure out what you can do with each algorithm.

=over 4

=item B<rrdpoller> B<ls> host1-net.rrd

Returns the whole list of datasources contained in the file.

=item B<rrdpoller> B<get> host1-load.rrd 1min_avg

Get the current value of the I<1min_avg> datasource of the
I<host1-load.rrd> file.

=item B<rrdpoller> B<--proxy> http://xmlrpc.monserver.com:8080/ B<get> host1-load.rrd 1min_avg

Same as precedent but querying a remove daemon (see L<rrdpollerd>).

=item B<rrdpoller> B<exact> host1-service.rrd http 1

Get the current value of the I<http> datasource of the
I<host1-load.rrd> file and return false if not equal to 1.

=item B<rrdpoller> B<boundaries> host1-load.rrd 5min_avg B<max>=15

Get the current value of the I<5min_avg> datasource of the
I<host1-load.rrd> file and return false if greater than I<15>.

=item B<rrdpoller> B<relation> host1-disk.rrd usage 100000 B<offset>=1min

Compare the current I<usage> datasource value of the I<host1-disk.rrd>
file with the same datasource 1 minute ago and return false if the
delta is greater than 100000.

=item B<rrdpoller> B<quotient> host1-mem.rrd usage 90% B<target-ds>=total

Compare the current I<usage> datasource of the I<host1-mem.rrd> file
and divide it by the I<total> datasource of the same file. The command
returns false if the obtained percentage is greater than I<90%>.

=item B<rrdpoller> B<hunt> pop2.rrd users 40 B<target>=pop1.rrd

If the I<users> datasource of the I<pop2.rrd> file is non-zero and the
same datasource of the I<pop1.rrd> hasn't yet reach I<40>, the command
will return false.

=item B<rrdpoller> B<quotient> host1-mem.rrd high_mem,low_mem,+ 90% B<target-ds>=low_total,high_total,+

Same as former B<quotient> example but using RPN datasource
feature. Here the high_mem and the low_mem datasources will be summed
then the low_total and the high_total too before to do the quotient
computation.

=item B<rrdpoller> B<different> mysql-slave.rrd insert,update,delete,+ 0 B<or> B<equal> mysql-master.rrd insert,update,delete,+ 0

First test will fail if the sum of inserts, updates and deletes is equal to 0.
If failed, the second test will verify if the same sum is also equal to 0 on
the master and will finally fail if not. Thus we can verify that the MySQL
replication is running.

=back

=head1 COMMAND SYNTAX

The rrdpoller is followed by one of its sub-command and related arguments (See below).
Sub-commands arguments are B<key>=I<value> pair and can alternatively be written as
B<--key> I<value> pair for backward compatibility. Since version 1.5.0, several sub-commands
can be chained together with special keywords C<and> and C<or>. Each sub-commands return
a result, one by line in the order they have been  called. When several sub-commands are
chained, all sub-commands are executed, even if the first have failed and the second was
chained with the C<and> keyword. You can change this behavior with the B<--lazy> option,
but don't expect to see the result of sub-commands that doesn't have been executed then.

=head1 COMMON OPTIONS

=head2 B<--proxy> I<URL>

If you use this option, the rrdpoller command will turn into an XML-RPC
client and will ask send all RRD queries to a remote rrdpoller daemon
(see L<rrdpollerd> for more information).

=head2 B<--max-last> I<seconds>

If this option is specified with an integer, the test will return false if the last
updated row is older than X I<seconds>. The exit code will be 2 if this test fails
instead of 1 for normal tests.

=head2 B<--lazy>

If several sub-commands are chained with the C<and> or C<or> keywords, don't exec all
sub-command if the expression doesn't need it.

=head2 B<--quiet>

Don't print sub-command results. Implies B<--lazy>

=cut

my @margs;
my @margv;
my $index = 0;
my @cond;
my $_arg;
my @single_opts = qw(lazy quiet);
while(@ARGV)
{
    $_arg = shift;
    if(index($_arg, '--') == 0)
    {
        # remove "--"
        $_arg = substr($_arg, 2);
        if(grep($_arg, @single_opts))
        {
            $margs[$index]->{$_arg} = 1;
        }
        else
        {
            $margs[$index]->{$_arg} = shift || usage();
        }
    }
    elsif($_arg =~ /^([a-z-]+)=(.*)$/)
    {
        $margs[$index]->{$1} = $2;
    }
    elsif($_arg eq 'and')
    {
        push(@cond, 1);
        $index++;
    }
    elsif($_arg eq 'or')
    {
        push(@cond, 0);
        $index++;
    }
    else
    {
        push(@{$margv[$index]}, $_arg);
    }
}

my $proxy = delete($margs[0]->{proxy});
my $max_last = delete($margs[0]->{'max-last'});
my $lazy  = delete($margs[0]->{lazy});
my $quiet = delete($margs[0]->{quiet});
$lazy = 1 if $quiet; # --quiet implies --lazy

# let us to cache the Error::RRD::Feature even if not loaded
push(@Error::RRD::Feature::ISA, 'Error::Simple');

my(@argv, %args, $command, $filename, $datasource, @rv);
for($index = 0; $index < @margv; $index++)
{
    @argv = @{$margv[$index] || []};
    %args = %{$margs[$index] || {}};
    
    $command = shift(@argv) || usage();
    if($command !~ /^(list|ls|get|exact|boundaries|relation|quotient|hunt)$/)
    {
        usage();
    }

    $filename = shift(@argv) || usage();
    if($command ne 'list' and $command ne 'ls')
    {
        $datasource = shift(@argv) || usage();
    }

    # check if last update is in the allowed interval
    if(defined $max_last)
    {
        my($last) = call('last', $filename);
        if(time() - $last > $max_last)
        {
            exit 2;
        }
    }

    {
        no strict qw(refs);
        try
        {
            if($lazy)
            {
                _eval_cond(&{$command});
            }
            else
            {
                push(@rv, &{$command});
            }
        }
        catch Error::RRD::Feature with
        {
            print STDERR "You need the Math::RPN module to use RPN datasources\n";
            exit 255;
        };
    }
}

my $rv;
while(defined($rv = shift(@rv)))
{
    _eval_cond($rv);
}

sub _eval_cond
{
    my $rv = shift;

    if(!@cond)
    {
        exit($rv ? 0 : 1);
    }
    if($rv != shift(@cond))
    {
        exit(1);
    }
}

usage();

=pod

=head1 SUB-COMMANDS

All sub-commands needs at least the too first arguments I<filename>
and I<datasource> (except for list command). Except for the B<get> and
B<list> commands (which doesn't perform a test), all sub-command will
change the rrdpoller return code to false (1) if the test fails. All
sub-commands will print the given I<datasource> value of the given
I<filename> on the standard output.

The I<datasource> can be an RPN expression (see L<Math::RPN>) as well
as all other datasource options. Note that the Math::RPN module have
to be installed in order to use this feature.

=head2 B<list|ls> I<filename>

This command list all datasources of the given file.

=cut

sub ls {return list(@_)}
sub list
{
    (@argv || %args) && usage();

    my($list) = call('list', $filename);
    print(join("\n", @$list), "\n");
    return 1;
}

=pod

=head2 B<get> I<filename> I<datasource> B<[OPTIONS]>

This sub-command the last inserted value in the given I<datasource> of
the given RRD I<filename>. You can get an older value by giving an
offset that will be expressed as: <last_inserted_time> - <offset>.

=head3 options:

=over 4

=item B<offset>=I<time>

Makes the B<get> command to retrieve an earlier value. It substract
the value of I<time> to the timestamp of the last value inserted in
the I<datasource>. The I<time> can be expressed in second (ie I<60>)
or in RRD time reference specification format (see L<rrdfetch/"TIME
REFERENCE SPECIFICATION">).

=item B<cf>=I<func-name>

Default consolidation function is AVERAGE. This option allow you to
change it to whichever you want.

=back

=cut

sub get
{
    my $offset = delete($args{offset}) || 0;
    my $cf = delete($args{cf});
    (@argv || %args) && usage();

    my($value) = call('fetch', $filename, $datasource, offset => $offset, cf => $cf);
    print "$value\n" unless $quiet;
    return 1;
}

=pod

=head2 B<exact> I<filename> I<datasource> I<exact>

This threshold allows you to monitor the I<datasource> for an I<exact>
match. This is useful in cases where an enumerated (or boolean) SNMP
object instruments a condition where a transition to a specific state
requires attention. For example, a datasource might return either
true(1) or false(2), depending on whether or not a power supply has
failed.

=cut

sub exact
{
    my $exact = shift(@argv);
    (@argv || %args) && usage();

    my($value, $bool) = call('exact', $filename, $datasource, $exact);
    print "$value\n" unless $quiet;
    return $bool;
}

=pod

=head2 B<boundaries> I<filename> I<datasource> B<[OPTIONS]>

This threshold takes too optional values, a I<min>imum and a
I<max>imum value. If the I<datasource> strays outside of this
interval, the test fail.

=head3 options:

=over 4

=item B<min>=I<number>

If current value is lower than I<number>, the test fail

=item B<max>=I<number>

If current value is greater than I<number>, the test fail

=back

=cut

sub boundaries
{
    my $min = delete($args{min});
    my $max = delete($args{max});
    (@argv || %args) && usage();

    my %opt;
    $opt{min} = $min if defined $min;
    $opt{max} = $max if defined $max;
    my($value, $bool) = call('boundaries', $filename, $datasource, %opt);
    print "$value\n" unless $quiet;
    return $bool;
}

=pod

=head2 B<relation> I<filename> I<datasource> I<[E<lt>|E<gt>]threshold[%]> B<[OPTIONS]>

A relation threshold considers the difference between two
I<datasources> (possibly from different RRD I<files>), or
alternatively, the difference between two temporally distinct values
for the same I<datasource>. The difference can be expressed as
absolute value, or as a percentage of the second I<datasource>
(comparison) value. This difference is compared to a I<threshold>
argument with either the greater than (>) or lesser than (<)
operator. The criteria fails when the expression (<absolute or
relative difference> <either greater-than or less-than> <threshold>)
evaluates to false.

The I<threshold> number, optionally preceded by the greater than (>)
or less than (<) symbol, and optionally followed by the symbol percent
(%). If omitted, greater than is used by default and the expression:
difference > threshold, is evaluated. "<10%", ">1000", "50%", and
"500" are all examples of valid thresholds.

=head3 options:

=over 4

=item B<target>=I<filename>

The path of the comparison RRD I<file>. This argument is optional and
if omitted the first RRD I<file> is also taken as the comparison target.

=item B<target-ds>=I<datasource>

The name of the comparison I<datasource>. This I<datasource> must
belong to the comparison RRD file. This argument is optional and if
omitted the first I<datasource> name is also taken as the comparison
datasource name. If the value is a number, the value is considered as
a fix value and is taked for the comparison.

=item B<offset>=I<time>

The temporal I<offset> to go back from the first value to fetch the
comparison datasource value. Note that a data source value must exist
in the RRD file for that exact offset. If This argument is optional
and if omitted, it is set to 0. The I<time> value can be expressed in
second (ie I<60>) or in RRD time reference specification format (see
L<rrdfetch/"TIME REFERENCE SPECIFICATION">).

=back

=cut

sub relation
{
    my $threshold = shift(@argv) || usage();
    my $target_file = delete($args{target});
    my $target_ds = delete($args{'target-ds'});
    my $offset = delete($args{offset});
    (@argv || %args) && usage();

    my %opt;
    $opt{cmp_rrdfile} = $target_file if defined $target_file;
    $opt{cmp_ds} = $target_ds if defined $target_ds;
    $opt{offset} = $offset if defined $offset;
    my($value, $bool) = call('relation', $filename, $datasource, $threshold, %opt);
    print "$value\n" unless $quiet;
    return $bool;
}

=pod

=head2 B<quotient> I<filename> I<datasource> I<[E<lt>|E<gt>]threshold[%]> B<[OPTIONS]>

Quotient thresholds are similar to relation thresholds, except that
they consider the quotient of two data sources, or alternatively, the
same data source at two different time points. For a quotient monitor
threshold, the value of the first data source is computed as a
percentage of the second data source value (such as 10 (first
datasource) is 50% of 20 (second datasource)). This percentage is then
compared to a threshold argument with either the greater than (>) or
less than (<) operator. The criteria fails when the expression
(<percentage> <either greater-than or less-than> <threshold>)
evaluates to false.

The I<threshold> number, optionally preceded by the greater than (>)
or less than (<) symbol and followed by the symbol percent (%). If
omitted, greater than is used by default and the expression:
difference > threshold, is evaluated. "<10%" and "50%" are all
examples of valid thresholds.

=head3 options:

=over 4

=item B<target>=I<filename>

The path of the comparison RRD I<file>. This argument is optional and
if omitted the first RRD I<file> is also taken as the comparison target.

=item B<target-ds>=I<datasource>

The name of the comparison I<datasource>. This I<datasource> must
belong to the comparison RRD file. This argument is optional and if
omitted the first I<datasource> name is also taken as the comparison
datasource name. If the value is a number, the value is considered as
a fix value and is taked for the comparison.

=item B<offset>=I<time>

The temporal I<offset> to go back from the first value to fetch the
comparison datasource value. Note that a data source value must exist
in the RRD file for that exact offset. If This argument is optional
and if omitted, it is set to 0. The I<time> value can be expressed in
second (ie I<60>) or in RRD time reference specification format (see
L<rrdfetch/"TIME REFERENCE SPECIFICATION">).

=back

=cut

sub quotient
{
    my $threshold = shift(@argv) || usage();
    my $target_file = delete($args{target});
    my $target_ds = delete($args{'target-ds'});
    my $offset = delete($args{offset});
    (@argv || %args) && usage();

    my %opt;
    $opt{cmp_rrdfile} = $target_file if defined $target_file;
    $opt{cmp_ds} = $target_ds if defined $target_ds;
    $opt{offset} = $offset if defined $offset;
    my($value, $bool) = call('quotient', $filename, $datasource, $threshold, %opt);
    print "$value\n" unless $quiet;
    return $bool;
}

=pod

=head2 B<hunt> I<roll> B<[OPTIONS]>

The hunt threshold is designed for the situation where the data source
serves as an overflow for another data source; that is, if one data
source (the parent) is at or near capacity, then traffic will begin to
appear on this (the monitored) data source. One application of hunt
monitor thresholds is to identify premature rollover in a set of modem
banks configured to hunt from one to the next. Specifically, the
criteria of the hunt monitor threshold fails if the value of the
monitored data source is non-zero and the current value of the parent
data source falls below a specified capacity threshold.

The I<roll> argument is the threshold of the parent data
source. Generally this should be slightly less than the maximum
capacity of the target.

=head3 options:

=over 4

=item B<parent>=I<filename>

The path of the comparison RRD I<file>. This argument is optional and
if omitted the first RRD I<file> is also taken as the comparison target.

=item B<parent-ds>=I<datasource>

The name of the comparison I<datasource>. This I<datasource> must
belong to the comparison RRD file. This argument is optional and if
omitted the first I<datasource> name is also taken as the comparison
datasource name. If the value is a number, the value is considered as
a fix value and is taked for the comparison.

=back

=cut

sub hunt
{
    my $roll = shift(@argv) || usage();
    my $parent_file = delete($args{parent});
    my $parent_ds = delete($args{'parent-ds'});
    (@argv || %args) && usage();

    my %opt;
    $opt{cmp_rrdfile} = $parent_file if defined $parent_file;
    $opt{cmp_ds} = $parent_ds if defined $parent_ds;
    my($value, $bool) = call('hunt', $filename, $datasource, %opt);
    print "$value\n" unless $quiet;
    return $bool;
}

# Utilities functions

sub call
{
    my($method, @args) = @_;

    if(defined $proxy)
    {
        return _remote_call($method, @args);
    }
    elsif(grep($_ eq $method, qw(last list fetch)))
    {
        if(!eval {require RRD::Query; 1})
        {
            print(STDERR "Can't load RRD::Query module\n");
            exit 225;
        }
        my $rrd = new RRD::Query(shift(@args));
        return $rrd->$method(@args);
    }
    else
    {
        if(!eval {require RRD::Threshold; 1})
        {
            print(STDERR "Can't load RRD::Threshold module\n");
            exit 225;
        }
        my $rt = new RRD::Threshold();
        return $rt->$method(@args);
    }
}

sub _remote_call
{
    if(!eval {require XMLRPC::Lite; 1})
    {
        print(STDERR "Can't load XMLRPC::Lite module\n");
        exit 225;
    }

    my $result = XMLRPC::Lite->proxy($proxy)->call(@_)->result();

    unless(defined $result)
    {
        print(STDERR "Remote method call failed\n");
        exit 225;
    }

    if($result->{success})
    {
        use Data::Dumper;
        return(@{$result->{value}});
    }
    else
    {
        if($result->{error}->{class} ne 'Error::Simple')
        {
            # GRUIG! behave like an Error::* object even if not loaded
            no strict qw(refs);
            push(@{$result->{error}->{class} . "::ISA"}, 'Error::Simple');
        }
        my $error = bless($result->{error}->{content}, $result->{error}->{class});
        $error->throw();
    }
}

sub usage
{
    print STDERR <<EOT;
Syntax:

rrdpoller [OPTIONS] list|ls <filename>

rrdpoller [OPTIONS] get <filename> <datasource> offset=<time> cf=<func-name>

rrdpoller [OPTIONS] exact <filename> <datasource> <value>

rrdpoller [OPTIONS] boundaries <filename> <datasource> [min=<number>] [max=<number>]

rrdpoller [OPTIONS] relation <filename> <datasource> <[<|>]threshold[%]> [target=<filename>]
  [compare-ds=<datasource>] [offset=<time>]

rrdpoller [OPTIONS] quotient <filename> <datasource> <[<|>]threshold[%]> [target=<filename>]
  [target-ds=<datasource>] [offset=<time>]

rrdpoller [OPTIONS] hunt <filename> <datasource> <roll> [target=<filename>]
  [target-ds=<datasource>]

OPTIONS:

    --proxy             IP address of the rrdpoller daemon
    --max-last          Max number of seconds allowed for the last update from now

EOT
    exit;
}

=pod

=head1 EXIT STATUS

=over 4

=item B<0>

Successful test

=item B<1>

Performed test returned a false value

=item B<2>

The max-last was reached

=item B<255>

An exception was thrown

=back

=head1 AUTHOR

Olivier Poitrey E<lt>rs@rhapsodyk.netE<gt>

=head1 LICENCE

rrdpoller retrieves RRD file data and apply some threshold algorithm.
Copyright (C) 2004  Olivier Poitrey

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA

=head1 SEE ALSO

L<RRD::Query>, L<RRD::Threshold>, L<rrdtool>, L<RRDs>, L<rrdpollerd>

=cut
