<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Complex Event Processing with Triceps CEP v2.0</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Complex Event Processing with Triceps CEP v2.0"><div class="titlepage"><div><div><h1 class="title"><a name="GUIDE"></a>
			Complex Event Processing with Triceps CEP v2.0
		</h1></div><div><h2 class="subtitle">
			Developer's Guide
		</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Sergey</span> <span class="othername">A.</span> <span class="surname">Babkin</span></h3></div></div><div><p class="copyright">Copyright © 2014 Sergey A. Babkin</p></div><div><div class="legalnotice" title="Legal Notice"><a name="id456634"></a><p>
			All rights reserved.
			</p><p>
			This manual is a part of the Triceps project. It is covered
			by the same Triceps version of the LGPL v3 license as Triceps
			itself.
			</p><p>
			The author can be contacted by e-mail at 
			&lt;babkin@users.sf.net&gt; or &lt;sab123@hotmail.com&gt;.
			</p><p>
			Many of the designations used by the manufacturers and sellers
			to distinguish their products are claimed as trademarks. Where those
			designations appear in this manual, and the author was aware of a
			trademark claim, the designations have been printed in caps or
			initial caps.
			</p><p>
			While every precaution has been taken in the preparation of this manual,
			the author assumes no responsibility for errors or omissions, or for
			damages resulting from the use of the information contained herein.
			</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#ch_preface">Preface</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_about_manual">1. About the manual</a></span></dt><dt><span class="sect1"><a href="#sc_preface_concepts">2. Some concepts</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_field">1. The field of CEP</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_what_is_cep">1.1. What is the CEP?</a></span></dt><dt><span class="sect1"><a href="#sc_uses_of_cep">1.2. The uses of CEP</a></span></dt><dt><span class="sect1"><a href="#sc_landscape">1.3. Surveying the CEP langscape</a></span></dt><dt><span class="sect1"><a href="#sc_1950s">1.4. We're not in 1950s any more, or are we?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_enter_triceps">2. Enter Triceps</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_triceps_reasons">2.1. What led to it</a></span></dt><dt><span class="sect1"><a href="#sc_hello_world">2.2. Hello, world!</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_build">3. Building Triceps</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_build_download">3.1. Downloading Triceps</a></span></dt><dt><span class="sect1"><a href="#sc_build_refenv">3.2. The reference environment</a></span></dt><dt><span class="sect1"><a href="#sc_build_basic">3.3. The basic build</a></span></dt><dt><span class="sect1"><a href="#sc_build_run_doc">3.4. Building the documentation</a></span></dt><dt><span class="sect1"><a href="#sc_build_run_simple">3.5. Running the examples and simple programs</a></span></dt><dt><span class="sect1"><a href="#sc_build_locale">3.6. Locale dependency</a></span></dt><dt><span class="sect1"><a href="#sc_build_install_perl">3.7. Installation of the Perl library</a></span></dt><dt><span class="sect1"><a href="#sc_build_install_cpp">3.8. Installation of the C++ library</a></span></dt><dt><span class="sect1"><a href="#sc_build_disambig_cpp">3.9. Disambiguation of the C++ library</a></span></dt><dt><span class="sect1"><a href="#sc_build_config">3.10. Build configuration settings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_api_fund">4. API Fundamentals</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_api_lang">4.1. Languages and layers</a></span></dt><dt><span class="sect1"><a href="#sc_confessions">4.2. Errors, deaths and confessions</a></span></dt><dt><span class="sect1"><a href="#sc_memory_fund">4.3. Memory management fundamentals</a></span></dt><dt><span class="sect1"><a href="#sc_code">4.4. Code references and snippets</a></span></dt><dt><span class="sect1"><a href="#sc_constants">4.5. Triceps constants</a></span></dt><dt><span class="sect1"><a href="#sc_objprint">4.6. Printing the object contents</a></span></dt><dt><span class="sect1"><a href="#sc_hungarian">4.7. The Hungarian notation</a></span></dt><dt><span class="sect1"><a href="#sc_perl_libex">4.8. The Perl libraries and examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_Rows">5. Rows</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_SimpleTypes">5.1. Simple types</a></span></dt><dt><span class="sect1"><a href="#sc_RowTypes">5.2. Row types</a></span></dt><dt><span class="sect1"><a href="#sc_RowTypesEquiv">5.3. Row types equivalence</a></span></dt><dt><span class="sect1"><a href="#sc_Rows">5.4. Rows</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_LabelsRowops">6. Labels and Row Operations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_Labels">6.1. Labels basics</a></span></dt><dt><span class="sect1"><a href="#sc_Label_construction">6.2. Label construction</a></span></dt><dt><span class="sect1"><a href="#sc_LabelOther">6.3. Other label methods</a></span></dt><dt><span class="sect1"><a href="#sc_Rowop">6.4. Row operations</a></span></dt><dt><span class="sect1"><a href="#sc_opcodes">6.5. Opcodes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_scheduling">7. Scheduling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_sched_intro">7.1. Introduction to the scheduling</a></span></dt><dt><span class="sect1"><a href="#sc_sched_compar">7.2. Comparative scheduling in the various CEP systems</a></span></dt><dt><span class="sect1"><a href="#sc_sched_unit_basics">7.3. Execution unit basics</a></span></dt><dt><span class="sect1"><a href="#sc_sched_tray">7.4. Trays</a></span></dt><dt><span class="sect1"><a href="#sc_sched_unwind">7.5. Error handling during the execution</a></span></dt><dt><span class="sect1"><a href="#sc_sched_no_bundling">7.6. No bundling</a></span></dt><dt><span class="sect1"><a href="#sc_sched_topo_loops">7.7. Topological loops</a></span></dt><dt><span class="sect1"><a href="#sc_sched_mainloop">7.8. The main loop</a></span></dt><dt><span class="sect1"><a href="#sc_sched_mainloop_socket">7.9. Main loop with a socket</a></span></dt><dt><span class="sect1"><a href="#sc_sched_tracing">7.10. Tracing the execution</a></span></dt><dt><span class="sect1"><a href="#sc_sched_detail">7.11. The gritty details of Triceps scheduling</a></span></dt><dt><span class="sect1"><a href="#sc_sched_loop">7.12. The gritty details of Triceps loop scheduling</a></span></dt><dt><span class="sect1"><a href="#sc_sched_recursion">7.13. Recursion control</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_memory">8. Memory Management</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_ref_cycles">8.1. Reference cycles</a></span></dt><dt><span class="sect1"><a href="#sc_memory_labels">8.2. Clearing of the labels</a></span></dt><dt><span class="sect1"><a href="#sc_clearing_labels">8.3. The clearing labels</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_tables">9. Tables</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_table_hello">9.1. Hello, tables!</a></span></dt><dt><span class="sect1"><a href="#sc_table_label">9.2. Tables and labels</a></span></dt><dt><span class="sect1"><a href="#sc_table_iteration">9.3. Basic iteration through the table</a></span></dt><dt><span class="sect1"><a href="#sc_table_delete">9.4. Deleting a row</a></span></dt><dt><span class="sect1"><a href="#sc_table_RowHandle">9.5. A closer look at the RowHandles</a></span></dt><dt><span class="sect1"><a href="#sc_table_fifo">9.6. A window is a FIFO</a></span></dt><dt><span class="sect1"><a href="#sc_table_secondary">9.7. Secondary indexes</a></span></dt><dt><span class="sect1"><a href="#sc_table_sorted">9.8. Sorted index</a></span></dt><dt><span class="sect1"><a href="#sc_table_ordered">9.9. Ordered index</a></span></dt><dt><span class="sect1"><a href="#sc_table_indextree">9.10. The index tree</a></span></dt><dt><span class="sect1"><a href="#sc_table_idx_intro">9.11. Table and index type introspection</a></span></dt><dt><span class="sect1"><a href="#sc_table_copy_tray">9.12. The copy tray</a></span></dt><dt><span class="sect1"><a href="#sc_table_wrapup">9.13. Table wrap-up</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_templates">10. Templates</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_template_intro">10.1. Comparative modularity</a></span></dt><dt><span class="sect1"><a href="#sc_template_variety">10.2. Template variety</a></span></dt><dt><span class="sect1"><a href="#sc_template_wrapper">10.3. Simple wrapper templates</a></span></dt><dt><span class="sect1"><a href="#sc_template_intercon">10.4. Templates of interconnected components</a></span></dt><dt><span class="sect1"><a href="#sc_template_options">10.5. Template options</a></span></dt><dt><span class="sect1"><a href="#sc_template_codegen">10.6. Code generation in the templates</a></span></dt><dt><span class="sect1"><a href="#sc_template_result">10.7. Result projection in the templates</a></span></dt><dt><span class="sect1"><a href="#sc_template_wrapfess">10.8. Error reporting in the templates</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_aggregation">11. Aggregation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_aggregation_vwap">11.1. The ubiquitous VWAP</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_manual">11.2. Manual aggregation</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_proper">11.3. Introducing the proper aggregation</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_window">11.4. Tricks with aggregation on a sliding window</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_optimized">11.5. Optimized DELETEs</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_additive">11.6. Additive aggregation</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_args">11.7. Computation function arguments</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_multi_idx">11.8. Using multiple indexes</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_simple">11.9. SimpleAggregator</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_simple_guts">11.10. The guts of SimpleAggregator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_joins">12. Joins</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_joins_variety">12.1. Joins variety</a></span></dt><dt><span class="sect1"><a href="#sc_joins_hello">12.2. Hello, joins!</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookup_manual">12.3. The lookup join, done manually</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookupjoin">12.4. The LookupJoin template</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookupjoin_iter">12.5. Manual iteration with LookupJoin</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookupjoin_keys">12.6. The key fields of LookupJoin</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookupjoin_inside">12.7. A peek inside LookupJoin</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo">12.8. JoinTwo joins two tables</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo_keys">12.9. The key field duplication in JoinTwo</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo_override">12.10. The override options in JoinTwo</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo_inputfilter">12.11. JoinTwo input event filtering</a></span></dt><dt><span class="sect1"><a href="#sc_joins_self_jointwo">12.12. Self-join done with JoinTwo</a></span></dt><dt><span class="sect1"><a href="#sc_joins_self_manual">12.13. Self-join done manually</a></span></dt><dt><span class="sect1"><a href="#sc_joins_self_lookupjoin">12.14. Self-join done with a LookupJoin</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo_glimpse">12.15. A glimpse inside JoinTwo and the hidden options of LookupJoin</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_time">13. Time processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_time_limited">13.1. Time-limited propagation</a></span></dt><dt><span class="sect1"><a href="#sc_time_periodic">13.2. Periodic updates</a></span></dt><dt><span class="sect1"><a href="#sc_time_issues">13.3. The general issues of time processing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_other">14. The other templates and solutions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_other_diamond">14.1. The dreaded diamond</a></span></dt><dt><span class="sect1"><a href="#sc_other_collapse">14.2. Collapsed updates</a></span></dt><dt><span class="sect1"><a href="#sc_other_chunks_del">14.3. Large deletes in small chunks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_strf">15. Streaming functions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_strf_intro">15.1. Introduction to streaming functions</a></span></dt><dt><span class="sect1"><a href="#sc_strf_collapse">15.2. Streaming functions by example, another version of Collapse</a></span></dt><dt><span class="sect1"><a href="#sc_strf_keyed_collapse">15.3. Collapse with grouping by key with streaming functions</a></span></dt><dt><span class="sect1"><a href="#sc_strf_translation">15.4. Table-based translation with streaming functions</a></span></dt><dt><span class="sect1"><a href="#sc_strf_loops">15.5. Streaming functions and loops</a></span></dt><dt><span class="sect1"><a href="#sc_strf_pipelines">15.6. Streaming functions and pipelines</a></span></dt><dt><span class="sect1"><a href="#sc_strf_tables">15.7. Streaming functions and tables</a></span></dt><dt><span class="sect1"><a href="#sc_strf_templates">15.8. Streaming functions and template results</a></span></dt><dt><span class="sect1"><a href="#sc_strf_recursion">15.9. Streaming functions and recursion</a></span></dt><dt><span class="sect1"><a href="#sc_strf_more_recursion">15.10. Streaming functions and more recursion</a></span></dt><dt><span class="sect1"><a href="#sc_strf_units">15.11. Streaming functions and unit boundaries</a></span></dt><dt><span class="sect1"><a href="#sc_strf_call">15.12. The ways to call a streaming function</a></span></dt><dt><span class="sect1"><a href="#sc_strf_scheduling">15.13. The gritty details of streaming functions scheduling</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_mt">16. Multithreading</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_mt_concepts">16.1. Triceps multithreading concepts</a></span></dt><dt><span class="sect1"><a href="#sc_mt_triead_life">16.2. The Triead lifecycle</a></span></dt><dt><span class="sect1"><a href="#sc_mt_pipeline">16.3. Multithreaded pipeline</a></span></dt><dt><span class="sect1"><a href="#sc_mt_objects">16.4. Object passing between threads</a></span></dt><dt><span class="sect1"><a href="#sc_mt_files">16.5. Threads and file descriptors</a></span></dt><dt><span class="sect1"><a href="#sc_mt_dynamic_server">16.6. Dynamic threads and fragments in a socket server</a></span></dt><dt><span class="sect1"><a href="#sc_mt_threaded_server">16.7. ThreadedServer implementation, and the details of thread harvesting</a></span></dt><dt><span class="sect1"><a href="#sc_mt_threaded_client">16.8. ThreadedClient, a Triceps Expect</a></span></dt><dt><span class="sect1"><a href="#sc_mt_main_timeouts">16.9. Thread main loop and timeouts in the guts of ThreadedClient</a></span></dt><dt><span class="sect1"><a href="#sc_mt_main_reorder">16.10. The threaded dreaded diamond and data reordering</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_tql">17. TQL, Triceps Trivial Query Language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_tql_intro">17.1. Introduction to TQL</a></span></dt><dt><span class="sect1"><a href="#sc_tql_syntax">17.2. TQL syntax</a></span></dt><dt><span class="sect1"><a href="#sc_tql_commands">17.3. TQL commands</a></span></dt><dt><span class="sect1"><a href="#sc_tql_single">17.4. TQL in a single-threaded server</a></span></dt><dt><span class="sect1"><a href="#sc_tql_multi">17.5. TQL in a multi-threaded server</a></span></dt><dt><span class="sect1"><a href="#sc_tql_join_internals">17.6. Internals of a TQL join</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_perf">18. Performance</a></span></dt><dt><span class="chapter"><a href="#ch_ref">19. Triceps Perl API Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_ref_toplevel">19.1. Top-level functions reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_code">19.2. Code helpers reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_unit">19.3. Unit and FrameMark reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_table_type">19.4. TableType reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_index_type">19.5. IndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_agg_type">19.6. AggregatorType reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_simple_agg">19.7. SimpleAggregator reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_table">19.8. Table reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_rowhandle">19.9. RowHandle reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_aggcontext">19.10. AggregatorContext reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_opt">19.11. Opt reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_fields">19.12. Fields reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_lookupjoin">19.13. LookupJoin reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_jointwo">19.14. JoinTwo reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_collapse">19.15. Collapse reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_braced">19.16. Braced reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_fnreturn">19.17. FnReturn reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_fnbinding">19.18. FnBinding reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_autofnbind">19.19. AutoFnBind reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_app">19.20. App reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sc_ref_app_inst_management">19.20.1. App instance management</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_resolution">19.20.2. App resolution</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_introspection">19.20.3. App introspection</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_harvester">19.20.4. App harvester control</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_state">19.20.5. App state management</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_drain">19.20.6. App drain control</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_start_timeout">19.20.7. App start timeout</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_fd">19.20.8. File descriptor transfer through an App</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_build">19.20.9. App build</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sc_ref_triead">19.21. Triead reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_triead_owner">19.22. TrieadOwner reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sc_ref_triead_owner_construct">19.22.1. TrieadOwner construction</a></span></dt><dt><span class="sect2"><a href="#sc_ref_triead_owner_general">19.22.2. TrieadOwner general methods</a></span></dt><dt><span class="sect2"><a href="#sc_ref_triead_owner_drains">19.22.3. TrieadOwner drains</a></span></dt><dt><span class="sect2"><a href="#sc_ref_triead_owner_interrupt">19.22.4. TrieadOwner file interrruption</a></span></dt><dt><span class="sect2"><a href="#sc_ref_triead_owner_tracked_file">19.22.5. TrackedFile</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sc_ref_nexus">19.23. Nexus reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_facet">19.24. Facet reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_autodrain">19.25. AutoDrain reference</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_cpp_ref">20. Triceps C++ API Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_cpp_intro">20.1. C++ API Introduction</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_const">20.2. The const-ness in C++</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_mem">20.3. Memory management in the C++ API and the Autoref reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_copy">20.4. The many ways to do a copy</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_string">20.5. String utilities</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_perl">20.6. Perl wrapping for the C++ objects</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_errors">20.7. Error reporting and Errors reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_exception">20.8. Exception reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_init">20.9. Initialization templates</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_types">20.10. Types reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_types_simple">20.11. Simple types reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_rowtype">20.12. RowType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_row">20.13. Row and Rowref reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_tabtype">20.14. TableType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_nameset">20.15. NameSet reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_idxtype">20.16. IndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_idx">20.17. Index reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_fifoidx">20.18. FifoIndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_hashidx">20.19. HashedIndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_sortidx">20.20. SortedIndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_gadget">20.21. Gadget reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_table">20.22. Table reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sc_cpp_table_dump">20.22.1. Data dump</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_table_sticky">20.22.2. Sticky errors</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sc_cpp_rowhandle">20.23. RowHandle and Rhref reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_aggregator">20.24. Aggregator classes reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sc_cpp_aggregator_type">20.24.1. AggregatorType reference</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_aggregator_gadget">20.24.2. AggregatorGadget reference</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_aggregator_obj">20.24.3. Aggregator reference</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_aggregator_basic">20.24.4. BasicAggregatorType reference</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_aggregator_example">20.24.5. Aggegator example</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sc_cpp_unit">20.25. Unit reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_unit_tracer">20.26. Unit Tracer reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_label">20.27. Label reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_rowop">20.28. Rowop reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_tray">20.29. Tray reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_framemark">20.30. FrameMark reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_rowset">20.31. RowSetType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_fnreturn">20.32. FnReturn reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_fnbind">20.33. FnBinding reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_autofn">20.34. ScopeFnBind and AutoFnBind reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_app">20.35. App reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_triead">20.36. Triead reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_triead_owner">20.37. TrieadOwner reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_nexus">20.38. Nexus reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_facet">20.39. Facet reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_autodrain">20.40. AutoDrain reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_sigusr2">20.41. Sigusr2 reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_triead_join">20.42. TrieadJoin reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_file_interrupt">20.43. FileInterrupt reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_basic_pthread">20.44. BasicPthread reference</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch_relnotes">21. Release Notes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sc_notes_2_0_1">21.1. Release 2.0.1</a></span></dt><dt><span class="sect1"><a href="#sc_notes_2_0_0">21.2. Release 2.0.0</a></span></dt><dt><span class="sect1"><a href="#sc_notes_1_0_1">21.3. Release 1.0.1</a></span></dt><dt><span class="sect1"><a href="#sc_notes_1_0_0">21.4. Release 1.0.0</a></span></dt><dt><span class="sect1"><a href="#sc_notes_0.99">21.5. Release 0.99</a></span></dt></dl></dd><dt><span class="bibliography"><a href="#id497239">Bibliography</a></span></dt><dt><span class="index"><a href="#id416225">Index</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>6.1. <a href="#fig_label_chain">Stateful elements with chained labels.</a></dt><dt>7.1. <a href="#fig_sched_loop">Labels forming a topological loop.</a></dt><dt>7.2. <a href="#fig_sched_mark">Proper calls in a loop.</a></dt><dt>9.1. <a href="#fig_idx_legend">Drawings legend.</a></dt><dt>9.2. <a href="#fig_idx_one">One index type.</a></dt><dt>9.3. <a href="#fig_idx_nested">Straight nesting.</a></dt><dt>9.4. <a href="#fig_idx_nested_begin"><code class="computeroutput">begin()</code>, <code class="computeroutput">beginIdx($itA)</code> and <code class="computeroutput">beginIdx($itB)</code> work the same for this table.</a></dt><dt>9.5. <a href="#fig_idx_nested_findidx"><code class="computeroutput">findIdx($itA, $rh)</code> goes through A and then switches to the <code class="computeroutput">beginIdx()</code> logic.</a></dt><dt>9.6. <a href="#fig_idx_nested_firstOfGroupIdx"><code class="computeroutput">firstOfGroupIdx($itB, $rh)</code>.</a></dt><dt>9.7. <a href="#fig_idx_nested_nextGroupIdx"><code class="computeroutput">nextGroupIdx($itB, $rh)</code>.</a></dt><dt>9.8. <a href="#fig_idx_2pri">Two top-level index types.</a></dt><dt>9.9. <a href="#fig_idx_prisec">A <span class="quote">&#8220;<span class="quote">primary</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">secondary</span>&#8221;</span> index type.</a></dt><dt>9.10. <a href="#fig_idx_nestfork">Two index types nested under one.</a></dt><dt>14.1. <a href="#fig_other_diamond">The diamond topology.</a></dt><dt>15.1. <a href="#fig_strf_fmac">The difference between the function and macro calls.</a></dt><dt>15.2. <a href="#fig_strf_query">The query patterns and streaming functions.</a></dt><dt>16.1. <a href="#fig_mt_overview">Triceps multithreaded application.</a></dt><dt>16.2. <a href="#fig_mt_chat">Chat server internal structure.</a></dt><dt>17.1. <a href="#fig_tql_multi">Multithreaded TQL application structure.</a></dt><dt>19.1. <a href="#seq784immed">The use of immediate import.</a></dt></dl></div><div class="preface" title="Preface"><div class="titlepage"><div><div><h2 class="title"><a name="ch_preface"></a>Preface</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_about_manual">1. About the manual</a></span></dt><dt><span class="sect1"><a href="#sc_preface_concepts">2. Some concepts</a></span></dt></dl></div><div class="sect1" title="1. About the manual"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_about_manual"></a>1. About the manual</h2></div></div></div><p>
		Before starting on the subject of the Triceps CEP itself,
		I want to tell some things about the organization of this manual.
		</p><p>
		It had grown quite large, and if it were printed on paper,
		I would have divided it into at least three volumes.
		But in the electronic form it's more convenient as a single
		document, this way the cross-references between any parts
		of it work seamlessly.
		</p><p>
		The manual keeps living and growing together with Triceps
		itself. As things change in Triceps, they change in the manual,
		but sometimes it's difficult to track down and update all
		the mentions of the changed subject. I've been spending
		a huge effort on tracking all such instances down but
		sometimes things slip through. Keep this in mind and
		don't be too scared when some paragraph says something
		contradictory.
		</p><p>
		A known issue with this manual is that it tends to describe
		the subjects in the bottom-up fashion, starting from the
		low-level details and then building up to the high-level
		concepts. This is partially because the manual has been
		growing together with Triceps, which is being built from
		the ground up. And partially it's because I like the details.
		When I read about a product, I want to understand, how
		exactly it works. When I write, I want to convey this
		information. I rewrote some of the chapters to put the
		high-level descriptions up front. But it's a huge work
		that will take some time to complete for the whole manual.
		In the meantime, I'd rather not delay the releases for it,
		they've been already slowed a lot by the documentation work.
		So it will get better with time, and in the meantime,
		if you feel that some details are too much for you,
		feel free to skip over them.
		</p><p>
		There are great many other improvements that can be done
		to the manual, and they will eventually be done. But my take on
		it is that it's better to have an imperfect manual now than
		a perfect one in some distant future. It had already been too
		long in the works, writing the manual for the version 2.0
		had taken a whole year.
		</p></div><div class="sect1" title="2. Some concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_preface_concepts"></a>2. Some concepts</h2></div></div></div><a class="indexterm" name="id467214"></a><p>
		When talking about the CEP programs, I often use the term <span class="quote">&#8220;<span class="quote">model</span>&#8221;</span>.
		What is a model? It's basically a CEP program. And more about the models
		and about what is the CEP itself is described in
		<a class="xref" href="#ch_field" title="Chapter 1. The field of CEP">Chapter 1</a> .
		</p><p>
		Many of the examples are built around the world of stock trading.
		In the modern times almost everyone is probably familiar with the
		basics of this area. But if case if you're not, let me tell the
		most fundamental thing needed for understanding the examples:
		what is a <span class="emphasis"><em>symbol</em></span>.
		</p><p>
		When the stock shares of some company are traded on an exchange,
		this company gets assigned a short identifier. This identifier
		is known as the stock symbol for this company. This word is also
		often used to mean not just the identifier but also the shares
		denoted by it. If a company has multiple classes of shares, each
		class would have its own symbol. And if a company is traded on
		multiple exchanges, each exchange may have its own identifier for
		its shares. The options and other derivative financial
		products also have their own symbols.
		</p></div></div><div class="chapter" title="Chapter 1. The field of CEP"><div class="titlepage"><div><div><h2 class="title"><a name="ch_field"></a>Chapter 1. The field of CEP</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_what_is_cep">1.1. What is the CEP?</a></span></dt><dt><span class="sect1"><a href="#sc_uses_of_cep">1.2. The uses of CEP</a></span></dt><dt><span class="sect1"><a href="#sc_landscape">1.3. Surveying the CEP langscape</a></span></dt><dt><span class="sect1"><a href="#sc_1950s">1.4. We're not in 1950s any more, or are we?</a></span></dt></dl></div><div class="sect1" title="1.1. What is the CEP?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_what_is_cep"></a>1.1. What is the CEP?</h2></div></div></div><p>
		CEP stands for the Complex Event Processing.  If you look at Wikipedia,
		it has separate articles for the Event Stream Processing and the
		Complex Event Processing. In reality it's all the same thing, with the
		naming driven by the marketing. I would not be surprised if someone
		invents yet another name, and everyone will start jumping on that
		bandwagon too.
		</p><a class="indexterm" name="id423597"></a><a class="indexterm" name="id477385"></a><p>
		In general a CEP system can be thought of as a black box, where the
		input events come in, propagate in some way through that black box, and
		come out as the processed output events. There is also an idea that the
		processing should happen fast, though the definitions of <span class="quote">&#8220;<span class="quote">fast</span>&#8221;</span> vary
		widely.
		</p><p>
		If we open the lid on the box, there are at least three ways to think
		of its contents:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		a spreadsheet on steroids
		</li><li class="listitem">
		a data flow machine
		</li><li class="listitem">
		a database driven by triggers
		</li></ul></div><a class="indexterm" name="id470896"></a><a class="indexterm" name="id471854"></a><a class="indexterm" name="id484561"></a><a class="indexterm" name="id470757"></a><p>
		Hopefully you've seen a spreadsheet before. The cells in it are tied
		together by formulas. You change one cell, and the machine goes and
		recalculates everything that depends on it. So does a CEP system. If we
		look closer, we can discern the CEP engine (which is like the
		spreadsheet software), the CEP model (like the formulas in the
		spreadheet) and the state (like the current values in the
		spreadsheet). An incoming event is like a change in an input
		cell, and the outgoing events are the updates of the values in the
		spreadsheet. 
		</p><p>
		Only a typical CEP system is bigger: it can handle some very complicated
		formulas and many millions of records. There actually are products that
		connect the Excel spreadsheets with the behind-the-curtain computations
		in a CEP system, with the results coming back to the spreadsheet
		cells. Pretty much every commercial CEP provider has a product
		that does that through the Excel RT interface. The way these models are
		written are not exactly pretty, but the results are, combining the nice
		presentation of spreadsheets and the speed and power of CEP.
		</p><p>
		A data flow machine, where the processing elements are exchanging
		messages, is your typical academical look at CEP. The events
		represented as data rows are the messages, and the CEP model describes
		the connections between the processing elements and their internal
		logic. This approach naturally maps to the multiprocessing, with each
		processing element becoming a separate thread. The hiccup is that the
		research in the dataflow machines tends to prefer the non-looped
		topologies. The loops in the connections complicate the things.
		</p><p>
		And many real-world relational databases already work very similarly to
		the CEP systems. They have the constraints and triggers propagating these
		constraints. A trigger propagates an update on one table to an update
		on another table. It's like a formula in a spreasheet or a logical
		connection in a dataflow graph.  Yet the databases usually miss two
		things: the propagation of the output events and the notion of being
		<span class="quote">&#8220;<span class="quote">fast</span>&#8221;</span>.
		</p><p>
		The lack of propagation of the output events is totally baffling to me:
		the RDBMS engines already write the output event stream as the redo
		log. Why not send them also in some generalized format, XML or
		something? Then people realize that yes, they do want to get the output
		events and start writing some strange add-ons and aftermarket solutions
		like the log scrubbers. This has been a mystery to me for some 15
		years. I mean, how more obvious can it be? But nobody budges. Well,
		with the CEP systems gaining popularity and the need to connect them to
		the databases, I think it will eventually grow on the database vendors
		that a decent event feed is a competitive advantage, and I think it
		will happen somewhere soon. 
		</p><p>
		The feeling of <span class="quote">&#8220;<span class="quote">fast</span>&#8221;</span> or lack thereof has
		to do with the databases being stored on disks. The growth of CEP has
		coincided with the growth in RAM sizes, and the data is usually kept
		completely in memory. People who deploy CEP tend to want the
		performance not of hundreds or thousands but hundreds of thousands
		events per second. The second part of <span class="quote">&#8220;<span class="quote">fast</span>&#8221;</span> is connected with the
		transactions. In a traditional RDBMS a single event with all its
		downstream effects is one transaction. Which is safe but may cause lots
		of conflicts. The CEP systems usually allow to break up the logic into
		multiple loosely-dependent layers, thus cutting on the overhead.
		</p></div><div class="sect1" title="1.2. The uses of CEP"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_uses_of_cep"></a>1.2. The uses of CEP</h2></div></div></div><p>
		Despite what Wikipedia says (and honestly, the Wikipedia articles on
		CEP and ESP are not exactly connected with reality), the pattern detection is <span class="bold"><strong>not</strong></span> your
		typical usage, by a wide, wide margin. The typical usage is for the
		data aggregation: lots and lots of individual events come in, and you
		want to aggregate them to keep a concise and consistent picture for the
		decision-making. The actual decision making can be done by humans
		or again by the CEP systems. It may involve some pattern recognition
		but usually even when it does, it doesn't look like patterns, it looks
		like conditions and joins on the historical chains of events.
		</p><p>
		The usage in the cases I know of includes the
		ad-click aggregation, the decisions to make a market trade, the
		watching whether the bank's end-of-day balance falls within the
		regulations, the choosing the APR for lending.
		</p><p>
		A related use would be for the general alert consoles. The data
		aggregation is what they do too. The last time I worked with it up close
		(around 2006), the processing in the BMC Patrol and Nagios was just
		plain inadequate for anything useful, and I had to hand-code the data
		collection and console logic. I've been touching this issue recently
		again at Google, and apparently nothing has changed much since then.
		All the real monitoring is done with the systems developed in-house.
		</p><a class="indexterm" name="id476467"></a><p>
		But the CEP would have been just the
		ticket. I think, the only reason why it has not been widespread yet is
		that the commercial CEP licenses had cost a lot. But with the
		all-you-can-eat pricing of Sybase, and with the Open Source systems,
		this is gradually changing.
		</p><p>
		Well, and there is also the pattern matching. It has been lagging
		behind the aggregation but growing too.
		</p></div><div class="sect1" title="1.3. Surveying the CEP langscape"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_landscape"></a>1.3. Surveying the CEP langscape</h2></div></div></div><a class="indexterm" name="id476497"></a><a class="indexterm" name="id476507"></a><a class="indexterm" name="id476517"></a><a class="indexterm" name="id476526"></a><p>
		What do we have in the CEP area now? The scene is pretty much dominated
		by Sybase (combining the former competitors Aleri and Coral8) and StreamBase.
		</p><a class="indexterm" name="id484014"></a><p>
		There seem to be two major approaches to the execution model. One was
		used by Aleri, another by Coral8 and StreamBase. I'm not hugely
		familiar with StreamBase, but that's how it seems to me. Since I'm much
		more familiar with Coral8, I'll be calling the second model the Coral8
		model. If you find StreamBase substantially different, let me know.
		</p><a class="indexterm" name="id488002"></a><a class="indexterm" name="id422433"></a><p>
		The Aleri idea is to collect and keep all the data. The relational
		operators get applied on the data, producing the derived data
		("materialized views") and eventually the results. So, even though the
		Aleri models were usually expressed in XML (though an SQL compiler was
		also available), fundamentally it's a very relational and SQLy
		approach.
		</p><p>
		This creates a few nice properties. All the steps of execution can be
		pipelined and executed in parallel. For persistence, it's fundamentally
		enough to keep only the input data (what has been called BaseStreams
		and then SourceStreams), and all the derived computations can be easily
		reprocessed on restart (it's funny but it turns out that often it's
		faster to read a small state from the disk and recalculate the rest
		from scratch in memory than to load a large state from the disk).
		</p><a class="indexterm" name="id422456"></a><p>
		It also has issues. It doesn't allow loops, and the procedural
		calculations aren't always easy to express. And keeping all the state
		requires more memory. The issues of loops and procedural computations
		have been addressed in Aleri by FlexStreams: modules that would perform the
		procedural computations instead of relational operations, written in
		SPLASH &#8212; a vaguely C-ish or Java-ish language. However this tends to
		break the relational properties: once you add a FlexStream,
		usually you do it for the reasons that prevent the derived
		calculations from being re-done, creating issues with saving and
		restoring the state. Mind you, you can write a FlexStream that doesn't
		break any of them, but then it would probably be doing something that
		can be expressed without it in the first place.
		</p><a class="indexterm" name="id422476"></a><p>
		Coral8 has grown from the opposite direction: the idea has been to
		process the incoming data while keeping a minimal state in the variables
		and short-term <span class="emphasis"><em>windows</em></span> (limited sliding recordings of the incoming
		data). The language (CCL) is very SQL-like. It relies on the state of
		variables and windows being pretty much global (module-wide), and
		allows the statements to be connected in loops. Which means that the
		execution order matters a lot. Which means that there are some quite
		extensive rules, determining this order. The logic ends up being very
		much procedural, but written in the peculiar way of SQL statements and
		connecting streams.
		</p><p>
		The good thing is that all this allows to control the execution order
		very closely and write things that are very difficult to express in
		the pure un-ordered relational operators. Which allows to aggregate the
		data early and creatively, keeping less data in memory.
		</p><p>
		The bad news is that it limits the execution to a single thread. If you
		want a separate thread, you must explicitly make a separate module, and
		program the communications between the modules, which is not exactly
		easy to get right. There are lots of people who do it the easy way and
		then wonder, why do they get the occasional data corruption. Also, the
		ordering rules for execution inside a module are quite tricky. Even for
		some fairly simple logic, it requires writing a lot of code, some of which
		is just bulky (try enumerating 90 fields in each statement), and some
		of which is tricky to get right.
		</p><p>
		The summary is that everything is not what it seems: the Aleri models
		aren't usually written in SQL but are very declarative in their
		meaning, while the Coral8/StreamBase models are written in an SQL-like
		language but in reality are totally procedural.
		</p><p>
		Sybase is also striking for a middle ground, combining the features
		inherited from Aleri and Coral8 in its CEP R5 and later: use the CCL
		language but relax the execution order rules to the Aleri level, except
		for the explicit single-threaded sections where the order is important.
		Include the SPLASH fragments for where the outright procedural logic is
		easy to use. Even though it sounds hodgy-podgy, it actually came
		together pretty nicely. Forgive me for saying so myself since I've done
		a fair amount of design and the execution logic implementation for it
		before I've left Sybase.
		</p><p>
		Still, not everything is perfect in this merged world. The SQLy syntax
		still requires you to drag around all your 90 fields into nearly every
		statement. The single-threaded order of execution is still non-obvious.
		It's possible to write the procedural code directly in SPLASH but the
		boundary where the data passes between the SQLy and C-ish code still
		has a whole lot of its own kinks (less than in Aleri but still a lot).
		And worst of all, there is still no modular programming. Yeah, there
		are <span class="quote">&#8220;<span class="quote">modules</span>&#8221;</span> but they are not really reusable. They are
		tied too tightly to the schema of the data. What is needed, is more
		like C++ templates. Only preferrably something more flexible and
		less difficult to debug than the C++ templates.
		</p><p>
		Let me elaborate a little on the point of <span class="quote">&#8220;<span class="quote">dragging around all your
		fields</span>&#8221;</span>. Here is a typical example: you have a stream of data
		and you want to pass through only the rows that find a match in some
		reference table. Which is reasonable to do with something like:
		</p><pre class="programlisting">insert into filtered_data
select
  incoming_data.*
from
  incoming_data as d left join reference_table as r
  on d.key_field = r.key_field;</pre><p>
		Only you can't write <code class="computeroutput">incoming_data.*</code> in their syntax,
		you have to list every single field of it explicitly. If the data
		has 90 fields, that becomes quite a drag.
		</p><p>
		StreamBase does have modules with parametrizable arguments (<span class="quote">&#8220;<span class="quote">
		capture fields</span>&#8221;</span>), somewhat like the C++ templates. The limitation
		is that you can say <span class="quote">&#8220;<span class="quote">and carry any additional fields through 
		unchanged</span>&#8221;</span> but can't really specify subsets of fields
		for a particular usage (<span class="quote">&#8220;<span class="quote">and use these fields as a key</span>&#8221;</span>).
		Or at least that's my understanding. I haven't used it in practice
		and don't understand StreamBase too well.
		</p></div><div class="sect1" title="1.4. We're not in 1950s any more, or are we?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_1950s"></a>1.4. We're not in 1950s any more, or are we?</h2></div></div></div><a class="indexterm" name="id497481"></a><p>
		Part of the complexity with CCL programming is that the CCL programs
		tend to feel very broken-up, with the flow of the logic jumping all
		over the place.
		</p><p>
		Consider a simple example: some incoming financial information may
		identify the securities by either RIC (Reuters identifier) or SEDOL
		or ISIN, and before processing it further we want to convert them
		all to ISIN (since the fundamentally same security may be identified in
		multiple ways when it's traded in multiple countries, ISIN is the
		common denominator). 
		</p><p>
		This can be expressed in CCL approximately like this (no guarantees
		about the correctness of this code, since I don't have a compiler to
		try it out):
		</p><pre class="programlisting">// the incoming data
create schema s_incoming (
  id_type string, // identifier type: RIC, SEDOL or ISIN
  id_value string, // the value of the identifier
  // add another 90 fields of payload...
);

// the normalized data
create schema s_normalized (
  isin string, // the identity is normalized to ISIN
  // add another 90 fields of payload...
);

// schema for the identifier translation tables
create schema s_translation (
  from string, // external id value (RIC or SEDOL)
  isin string, // the translation to ISIN
);

// the windows defining the translations from RIC and SEDOL to ISIN
create window w_trans_ric schema s_translation
  keep last per from;
create window w_trans_sedol schema s_translation
  keep last per from;

create input stream i_incoming schema s_incoming;
create stream incoming_ric  schema s_incoming;
create stream incoming_sedol  schema s_incoming;
create stream incoming_isin  schema s_incoming;
create output stream o_normalized schema s_normalized;

insert
  when id_type = 'RIC' then incoming_ric
  when id_type = 'SEDOL' then incoming_sedol
  when id_type = 'ISIN' then incoming_isin
select *
from i_incoming;

insert into o_normalized
select
  w.isin,
  i. ... // the other 90 fields
from
  incoming_ric as i join w_tranc_ric as w
    on i.id_value =  w.from;

insert into o_normalized
select
  w.isin,
  i. ... // the other 90 fields
from
  incoming_sedol as i join w_tranc_sedol as w
    on i.id_value =  w.from;

insert into o_normalized
select
  i.id_value,
  i. ... // the other 90 fields
from
  incoming_isin;</pre><p>
		Not exactly easy, is it, even with the copying of payload data skipped?
		You may notice that what it does could also be expressed as procedural
		pseudo-code:
		</p><pre class="programlisting">// the incoming data
struct s_incoming (
  string id_type, // identifier type: RIC, SEDOL or ISIN
  string id_value, // the value of the identifier
  // add another 90 fields of payload...
);

// schema for the identifier translation tables
struct s_translation (
  string from, // external id value (RIC or SEDOL)
  string isin, // the translation to ISIN
);

// the windows defining the translations from RIC and SEDOL to ISIN
table s_translation w_trans_ric
  key from;
table s_translation w_trans_sedol
  key from;

s_incoming i_incoming;
string isin;

if (i_incoming.id_type == 'RIC') {
  isin = lookup(w_trans_ric,
    w_trans_ric.from == i_incoming.id_value
  ).isin;
} elsif (i_incoming.id_type == 'SEDOL') {
  isin = lookup(w_trans_sedol,
    w_trans_sedol.from == i_incoming.id_value
  ).isin;
} elsif (i_incoming.id_type == 'ISIN') {
  isin = i_incoming.id_value;
}

if (isin != NULL) {
  output o_ normalized(isin,
    i_incoming.(* except (id_type, id_value))
  );
}</pre><a class="indexterm" name="id497545"></a><a class="indexterm" name="id497554"></a><a class="indexterm" name="id497564"></a><p>
		Basically, writing in CCL feels like programming in Fortran in the 50s:
		lots of labels, lots of GOTOs. Each stream is essentially a label, when
		looking from the procedural standpoint. It's actually worse than
		Fortran, since all the labels have to be pre-defined (with types!). And
		there isn't even the normal sequential flow, each statement must be
		followed by a GOTO, like on those machines with magnetic-drum main
		memory.
		</p><p>
		This is very much like the example in my book 
		[<a href="#Babkin10" class="biblioref" title="[Babkin10]">Babkin10</a>],
		in section 6.4. <span class="emphasis"><em>Queues as the sole synchronization
		mechanism</em></span>. You can alook at the draft text online at <a class="ulink" href="http://web.newsguy.com/sab123/tpopp/06odata.txt" target="_top">http://web.newsguy.com/sab123/tpopp/06odata.txt</a>. This
		similarity is not accidental: the CCL streams are queues, and they are
		the only communication mechanism in CCL.
		</p><a class="indexterm" name="id497598"></a><p>
		The SQL statement structure also adds to the confusion: each statement
		has the destination followed by the source of the data, so each
		statement reads like it flows backwards.
		</p></div></div><div class="chapter" title="Chapter 2. Enter Triceps"><div class="titlepage"><div><div><h2 class="title"><a name="ch_enter_triceps"></a>Chapter 2. Enter Triceps</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_triceps_reasons">2.1. What led to it</a></span></dt><dt><span class="sect1"><a href="#sc_hello_world">2.2. Hello, world!</a></span></dt></dl></div><div class="sect1" title="2.1. What led to it"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_triceps_reasons"></a>2.1. What led to it</h2></div></div></div><p>
		It had happened that I've worked for a while on and with the Complex Event
		Processing (CEP) systems. I've worked for a few years on the internals
		of the Aleri CEP engine, then after Aleri acquired Coral8, some on the
		Coral8 engine, then after Sybase gobbled up them both, I've designed
		and did the early implementation of a fair bit of the Sybase CEP R5.
		After that I've moved on to Deutsche Bank and got the experience from
		the other side: using the CEP systems, primarily the former Coral8,
		now known as Sybase CEP R4.
		</p><p>
		This made me feel that writing the CEP models is unnecessarily
		difficult. Even the essentially simple things take too much effort.
		I've had this feeling before as well, but one thing is to have it in
		abstract, and another is to grind against it every day. 
		</p><p>
		Which in turn led me to thinking about making my own Open Source CEP
		system, where I could try out the ideas I get, and make the streaming
		models easier to write. I aim to do better than the 1950's style, to
		bring the advances of the structured programming into the CEP world.
		</p><p>
		Thus the Triceps project was born. For a while
		it was called Biceps, until I've learned of the existence of a recearch
		project called BiCEP. It's spelled differently, and is in a
		substantially differnt area of CEP work, but it's easier to avoid
		confusion, so I went one better and renamed mine Triceps.
		</p><p>
		Since then I've moved on from DB, and I'm currently not using any CEP
		at work (though you never know what would happen), but Triceps has
		already gained momentum by itself.
		</p><p>
		The Triceps development has been largely shaped by two considerations:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		It has to be different from the Sybase products on which I worked.
		This is helpful from both legal standpoint and from marketing
		standpoint: Sybase and StreamBase already have similar products that
		compete head to head. There is no use getting into the same fray
		without some major resources.
		</li><li class="listitem">
		It has to be small. I can't spend the same amount of effort on Triceps
		as a large company, or even as a small one. Not only this saves time
		but also allows the modifications to be easy and fast. The point of
		Triceps is to experiment with the CEP language to make it easy to use:
		try out the ideas, make sure that they work well, or replace them with
		other ideas. The companies with a large established product can't
		really afford the radical changes: they have invested much effort into
		the product, and are stuck with supporting it and providing
		compatibility into the future.
		</li></ul></div><a class="indexterm" name="id464215"></a><p>
		Both of these considerations point into the same direction: an
		embeddable CEP system. Adapting an integrated system for an embedded
		usage is not easy, so it's a good open niche. Yeah, this niche
		is not empty either.  There already is Esper.  But from a cursory look, it
		seems to have the same issues as Coral8/StreamBase. It's also
		Java-centric, and Triceps is aimed for embeddability into different 
		languages.
		</p><p>
		And an embeddable system saves on a lot of components.
		</p><p>
		For starters, no IDE. Anyway, I find the IDEs pretty useless for
		development in general, and especially for the CEP development. Though
		it comes handy once in a while for the analysis of the code and
		debugging.
		</p><p>
		No new language, no need to develop compilers, virtual machines,
		function libraries, external callout APIs. Well, the major goal of
		Triceps actually is the development of a new and better language. But
		it's one of these paradoxes: Aleri does the relational logic looking
		like procedural, Coral8 and StreamBase do the procedural logic looking
		like relational, and Triceps is a design of a language without a
		language. Eventually there probably will be a language, to be mixed
		with the parent one. But for now a lot can be done by simply using the
		Triceps library in an existing scripting language. The existing
		scripting languages are already powerful, fast, and also support the
		dynamic compilation.
		</p><p>
		No separate server executable, no need to control it, and no custom
		network protocols: the users can put the code directly into their
		executables and devise any protocols they please. Well, it's not a
		real good answer for the protocols, since it means that everyone who
		wants to communicate the streaming data for Triceps over the network
		has to implement these protocols from scratch. So eventually Triceps
		will provide a default implementation. But it doesn't have to be done
		right away.
		</p><p>
		No data persistence for now either. It's a nice feature, and I have
		some ideas about it too, but it requires a large amount of work, and
		doesn't really affect the API. 
		</p><p>
		The language used to implement Triceps is C++, and the scripting
		language is Perl. Nothing really prevents embedding Triceps into other
		languages but it's not going to happen anywhere soon. The reason being
		that extra code adds weight and makes the changes more difficult.
		</p><p>
		The multithreading support has been a major consideration from the
		start. All the C++ code has been written with the multithreading in
		mind. However for the first release the multithreading did not
		propagate into the Perl API yet.
		</p><p>
		Even though Triceps is a system aimed for quick experimentation, that does not imply
		that it's of a toy quality. The code is written in production quality
		to start with, with a full array of unit tests. In fact, the only way
		you can do the quick experimentation is by setting up the proper
		testing from the scratch. The idea of <span class="quote">&#8220;<span class="quote">move fast and break
		things</span>&#8221;</span> is complete rubbish.
		</p></div><div class="sect1" title="2.2. Hello, world!"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_hello_world"></a>2.2. Hello, world!</h2></div></div></div><p>
		Let's finally get to business: write a simple <span class="quote">&#8220;<span class="quote">Hello, world!</span>&#8221;</span> program with
		Triceps. Since Triceps is an embeddable library, naturally, the
		smallest <span class="quote">&#8220;<span class="quote">Hello, world!</span>&#8221;</span> program would be in the host language without
		Triceps, but it would not be interesting. So here is the a bit
		contrived but more interesting Perl program that passes some data
		through the Triceps machinery:
		</p><pre class="programlisting">use Triceps;

$hwunit = Triceps::Unit-&gt;new("hwunit");
$hw_rt = Triceps::RowType-&gt;new(
  greeting =&gt; "string",
  address =&gt; "string",
);

my $print_greeting = $hwunit-&gt;makeLabel($hw_rt, "print_greeting", undef, sub {
  my ($label, $rowop) = @_;
  printf("%s!\n", join(', ', $rowop-&gt;getRow()-&gt;toArray()));
} );

$hwunit-&gt;call($print_greeting-&gt;makeRowop(&amp;Triceps::OP_INSERT,
  $hw_rt-&gt;makeRowHash(
    greeting =&gt; "Hello",
    address =&gt; "world",
  )
));</pre><a class="indexterm" name="id472547"></a><p>
		What happens there? First, we import the Triceps module.
		Then we create a Triceps execution unit. An execution unit keeps the
		Triceps context and controls the execution for one logical thread.
		</p><p>
		The argument of the constructor is the name of the unit, that can be used
		in printing messages about it. It doesn't have to be the same as the
		name of the variable that keeps the reference to the unit, but it's a
		convenient convention to make the debugging easier. This is a common
		idiom of Triceps: when you create something, you give it a name. If
		any errors occur later with this object, the name will be present int
		the error message, and you'll be able to find easily, which object has
		the issue and where it was created.
		</p><a class="indexterm" name="id467140"></a><a class="indexterm" name="id476877"></a><p>
		If something goes wrong, the Triceps methods will confess. To be precise,
		call <code class="computeroutput">Carp::confess</code>, which is like Perl's <code class="computeroutput">die</code>
		but also prints the stack trace. Triceps also includes its own high-level
		call stack into this trace.
		</p><a class="indexterm" name="id493906"></a><p>
		The next statement creates the type for rows. For the simplest
		example, one row type is enough. It contains two string fields. A row
		type does not belong to an execution unit. It may be used in parallel
		by multiple threads. Once a row type is created, it's immutable, and
		that's the story for pretty much all the Triceps objects that can be
		shared between multiple threads: they are created, they become
		immutable, and then they can be shared. (Of course, the containers
		that facilitate the passing of data between the threads would have to
		be an exception to this rule).
		</p><a class="indexterm" name="id483678"></a><a class="indexterm" name="id483688"></a><p>
		Then we create a label.
		The <span class="quote">&#8220;<span class="quote">label</span>&#8221;</span> is the Triceps term for the
		same kind of stream processing elements as in the other CEP systems.
		The Coral8 term for the same concept is <span class="quote">&#8220;<span class="quote">stream</span>&#8221;</span>.
		The <span class="quote">&#8220;<span class="quote">SQLy vs procedural</span>&#8221;</span> example in
		<a class="xref" href="#sc_1950s" title="1.4. We're not in 1950s any more, or are we?">Section 1.4: &#8220;We're not in 1950s any more, or are we?&#8221; </a>
		shows why these elements are analogs of labels in the procedural programming,
		and Triceps generally follows the procedural terminology.
		</p><p>
		Of course,
		now, in the days of the structured programming, we don't create labels
		for GOTOs all over the place. But we still use labels. The function
		names are essentially labels, the loops in Perl may have labels. So a Triceps
		label can often be seen kind of like a function definition, but
		only kind of. It takes a data row as a parameter and does something
		with it. But unlike a proper function it has no way to return the
		processed data back to the caller. It has to either pass the processed
		data to other labels or collect it in some hardcoded data structure,
		from which the caller can later extract it back.
		Thus a Triceps label is still much more like a GOTO label.
		</p><p>
		Triceps has the streaming functions too, where the caller does provide
		the way to return the result. These are more than the ordinary labels.
		</p><p>
		A basic label takes a row type for the rows it accepts, a name (again,
		purely for the ease of debugging) and a reference to a Perl function
		that will be handling the data. Extra arguments for the function can
		be specified as well, but there is no use for them in this example. 
		</p><p>
		Here it's a simple unnamed Perl function. Though of course a reference
		to a named function can be used instead, and the same function may be
		reused for multiple labels. Whenever the label gets a row operation to
		process, its function gets called with the reference to the label
		object, the row operation object, and whatever extra arguments were
		specified at the label creation (none in this example). The example
		just prints a message combined from the data in the row.
		</p><a class="indexterm" name="id483750"></a><a class="indexterm" name="id464548"></a><p>
		Note that the label's handler function doesn't just get a row as an
		argument.  It gets a row operation (<span class="quote">&#8220;<span class="quote">rowop</span>&#8221;</span> as it's
		called throughout the code). It's an important distinction. A row just
		stores some data. As the row gets passed around, it gets referenced
		and unreferenced, but it just stays the same until the last reference
		to it disappears, and then it gets destroyed. It doesn't know what
		happens with the data, it just stores them. A row may be shared
		between multiple threads. On the other hand, a row operation says
		<span class="quote">&#8220;<span class="quote">take these data and do such and such a thing with them</span>&#8221;</span>.
		A row operation is a combination of a row of data, an operation code,
		and a label that has to carry out the operation. 
		Since the row operation object is also immutable,
		a reference to a row operation may
		be kept and reused again and again.
		</p><a class="indexterm" name="id464574"></a><a class="indexterm" name="id464584"></a><p>
		Triceps has the explicit operation codes, very much like Aleri/Sybase R5 (only
		Aleri doesn't differentiate between a row and row operation, every row
		there has an opcode in it). It
		might be just my background, but let me tell you: the CEP systems
		without the explicit opcodes are a pain. The visible opcodes make life
		a lot easier. However unlike Aleri, there is no UPDATE opcode. The
		available opcodes are INSERT, DELETE and NOP (no-operation). If you
		want to update something, you send two operations: first DELETE for
		the old value, then INSERT for the new value. All this will be
		described in more detail later.
		</p><p>
		For this simple example, the opcode doesn't really matter, so the
		label handler function quietly ignores it. It gets the row from the
		row operation and extracts the data from it into the Perl
		representation, then prints them. The Triceps row data may be
		represented in Perl in two ways: an array and a hash. In the array
		format, the array contains the values of the fields in the order they
		are defined in the row type. The hash format consists of name-value
		pairs, which may be stored either in an actual hash or in an array.
		The conversion from a row to a hash actually returns an array of
		values which becomes a real hash if it gets stored into a hash
		variable.
		</p><p>
		As a side note, this also suggests, how the systems without explicit
		opcodes came to be: they've been initially built on the simple
		stateless examples. And when the more complex examples have turned up,
		they've been aready stuck on this path, and could not afford too deep
		a retrofit.
		</p><p>
		The final part of the example is the creation of a row operation for
		our label, with an INSERT opcode and a row created from hash-formatted
		Perl data, and calling it through the execution unit. The row type
		provides a method to construct the rows, and the label provides a
		method to construct the row operations for it. The <code class="computeroutput">call()</code>
		method of the execution unit does exactly what its name implies: it
		evaluates the label function right now, and returns after all its
		processing its done.
		</p><p>
		This is a very simple example, so it does only one call. The real
		Triceps programs get a stream of incoming data, and do the
		calls to handle each row of it.
		</p></div></div><div class="chapter" title="Chapter 3. Building Triceps"><div class="titlepage"><div><div><h2 class="title"><a name="ch_build"></a>Chapter 3. Building Triceps</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_build_download">3.1. Downloading Triceps</a></span></dt><dt><span class="sect1"><a href="#sc_build_refenv">3.2. The reference environment</a></span></dt><dt><span class="sect1"><a href="#sc_build_basic">3.3. The basic build</a></span></dt><dt><span class="sect1"><a href="#sc_build_run_doc">3.4. Building the documentation</a></span></dt><dt><span class="sect1"><a href="#sc_build_run_simple">3.5. Running the examples and simple programs</a></span></dt><dt><span class="sect1"><a href="#sc_build_locale">3.6. Locale dependency</a></span></dt><dt><span class="sect1"><a href="#sc_build_install_perl">3.7. Installation of the Perl library</a></span></dt><dt><span class="sect1"><a href="#sc_build_install_cpp">3.8. Installation of the C++ library</a></span></dt><dt><span class="sect1"><a href="#sc_build_disambig_cpp">3.9. Disambiguation of the C++ library</a></span></dt><dt><span class="sect1"><a href="#sc_build_config">3.10. Build configuration settings</a></span></dt></dl></div><div class="sect1" title="3.1. Downloading Triceps"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_download"></a>3.1. Downloading Triceps</h2></div></div></div><a class="indexterm" name="id461279"></a><p>
		The official Triceps site is located at SourceForge.
		</p><p>
		<a class="ulink" href="http://triceps.sf.net" target="_top">http://triceps.sf.net</a> is the high-level page.
		</p><p>
		<a class="ulink" href="http://sf.net/projects/triceps" target="_top">http://sf.net/projects/triceps</a> is the SourceForge project page.
		</p><p>
		The official releases of Triceps can be downloaded from SourceForge and CPAN. The CPAN
		location is:
		</p><p>
		<a class="ulink" href="http://search.cpan.org/~babkin/triceps/" target="_top">http://search.cpan.org/~babkin/triceps/</a>
		</p><p>
		The Developer's Guide can also be found in the Kindle format on Amazon web site,
		for the Amazon's minimal price of $1.
		</p><p>
		The release policy of Triceps is aimed towards the ease of development.
		As the new features are added (or sometimes removed), they are checked into
		the SVN repository and documented in the blog form at
		<a class="ulink" href="http://babkin-cep.blogspot.com/" target="_top">http://babkin-cep.blogspot.com/</a>. Periodically 
		the documentation updates are collected from the blog into this manual,
		and the official releases are produced.
		</p><p>
		If you want to try out the most bleeding-edge features that have been
		described on the blog but not officially released yet, you can get the
		most recent code directly from the SVN repository.  The SVN code can be
		checked out with
		</p><pre class="programlisting">svn co http://svn.code.sf.net/p/triceps/code/trunk</pre><p>
		You don't need any login for check-out. You can keep it current with
		latest changes by periodically running <code class="computeroutput">svn update</code>. After
		you've checked out the trunk, you can build it as usual. If you do have
		a login and SSH key, you can use then as well:
		</p><pre class="programlisting">svn co svn+ssh://your_username@svn.code.sf.net/p/triceps/code/trunk</pre></div><div class="sect1" title="3.2. The reference environment"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_refenv"></a>3.2. The reference environment</h2></div></div></div><a class="indexterm" name="id479094"></a><p>
		The tested reference build environment is where I do the Triceps development,
		and currently it is Linux Fedora 11. The build should work
		automatically on the other Linux systems as well, and the testing reports
		from CPAN show that it usually works.
		</p><p>
		The build should work on the other Unix environments too but may
		require some manual configuration for the available libraries.
		The test reports from CPAN show that the BSD varieties (FreeBSD, OpenBSD,
		MidnightBSD) usually do well.
		</p><p>
		Currently you must use the GNU Linux toolchain: GNU make, GNU C++ 
		compiler (version 4.4.1 has been tested), glibc, valgrind. You can build
		without valgrind by running only the non-valgrind tests.
		</p><p>
		The older GNU compiler 4.1 and the newer compiler versions have been reported 
		to work as well. But if you build the trunk code checked out from SVN
		(or otherwise in the directory named <span class="quote">&#8220;<span class="quote"><code class="computeroutput">trunk</code></span>&#8221;</span>),
		there is a catch with the warning flags. This kind of build treats almost all
		warnings as errors, and this causes varying results
		with the different compiler versions. The version 4.1
		doesn't have the option <code class="computeroutput">-Wno-sign-conversion</code> and
		will fail on it. The newer compiler versions may have some extra warnings
		that will be treated as errors (and since my reference compiler doesn't
		check for them, the code may trigger them). The fix for this situation is
		to edit <code class="computeroutput">cpp/Makefile.inc</code> and change the
		variable <code class="computeroutput">CFLAGS_WARNINGS</code>, or just clear it altogether. In the release form
		this is not an issue, in the release directory the warnings are not treated
		as errors and no warning options are used.
		</p><p>
		GCC 4.1 is also known to have complaints about the construct 
		<code class="computeroutput">sizeof(field)</code>. I've modified the
		reported occurrences but more might creep up in the future. If this
		stops your build, change them to
		<code class="computeroutput">sizeof(TypeOfField)</code>.
		</p><p>
		The tested Perl versions are 5.10.0 and 5.19.0, and should work on any recent version
		as well. With the earlier versions your luck may vary. The Makefile.PL
		has been configured to require at least 5.8.0. The older versions
		have a different threading module and definitely won't work.
		</p><p>
		The threads support in the Perl interpreter is needed to run
		the multithreaded API. If your Perl is built without threads, the single-threaded
		part is still usable but all the tests related to multithreading will fail.
		The last version of Triceps with no threads support at all is 1.0.1,
		and it's the last resort if you want to run without threads.
		</p><p>
		I am interested in hearing the reports about builds in various environments.
		</p><p>
		The normal build expectation is for the 64-bit machines. The 32-bit
		machines should work (and the code even includes the special cases for
		them) but have been untested at the moment. Some of the tests might fail
		on the 32-bit and/or big-endian machines due to the different computation
		of the hash values, and thus producing a different row order in the result.
		</p></div><div class="sect1" title="3.3. The basic build"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_basic"></a>3.3. The basic build</h2></div></div></div><a class="indexterm" name="id493758"></a><p>
		If everything works, the basic build is simple, go to the Triceps
		directory and run:
		</p><pre class="programlisting">make all
make test</pre><p>
		That would build and test both the C++ and Perl portions of Triceps.
		The C++ libraries will be created under <code class="computeroutput">cpp/build</code>.
		The Perl libraries will be created under <code class="computeroutput">perl/Triceps/blib</code>.
		</p><p>
		The tests are normally run with valgrind for the C++ part, without valgrind
		for the Perl part. The reason is that Perl produces lots of false positives,
		and the suppressions depend on particular Perl versions and are not
		exactly reliable.
		</p><p>
		If your system differs substantially, you may need to adjust the
		configurable settings manually, since there is no <code class="computeroutput">./configure</code> script
		in the Triceps build yet. More information about them is in the
		<a class="xref" href="#sc_build_config" title="3.10. Build configuration settings">Section 3.10: &#8220;Build configuration settings&#8221; </a>.
		</p><p>
		The other interesting <code class="computeroutput">make</code> targets are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">clean</code></span></dt><dd>
			Remove all the built files.
			</dd><dt><span class="term"><code class="computeroutput">clobber</code></span></dt><dd>
			Remove the object files, forcing the libraries to be
			rebuilt next time.
			</dd><dt><span class="term"><code class="computeroutput">vtest</code></span></dt><dd>
			Run the unit tests with valgrind, checking for leaks and
			memory corruption.
			</dd><dt><span class="term"><code class="computeroutput">qtest</code></span></dt><dd>
			Run the unit tests quickly, without valgrind.
			</dd><dt><span class="term"><code class="computeroutput">release</code></span></dt><dd>
			Export from SVN a clean copy of the code and create
			a release package. The package name will be triceps-<span class="emphasis"><em>version</em></span>.tgz,
			where the <span class="emphasis"><em>version</em></span> is taken from the SVN directory name, from
			where the current directory is checked out. This includes the build
			of the documentation.
			</dd></dl></div></div><div class="sect1" title="3.4. Building the documentation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_run_doc"></a>3.4. Building the documentation</h2></div></div></div><a class="indexterm" name="id489714"></a><p>
		If you have downloaded the release package of Triceps, the documentation
		is already included it in the built form. The PDF and HTML versions are
		available in <code class="computeroutput">doc/pdf</code> and <code class="computeroutput">doc/html</code>. It is also available online from
		<a class="ulink" href="http://triceps.sf.net" target="_top">http://triceps.sf.net</a>.
		</p><a class="indexterm" name="id489749"></a><p>
		The documentation is formatted in DocBook, that produces the PDF
		and HTML outputs.
		If you check out the source from SVN and want to build the documentation,
		you need to download the DocBook tools needed to build it. 
		I hate the dependency situations, when to build something you need
		to locate, build and download dozens of other packages firsti,
		and then the versions turn out to be updated, and don't want
		to work together, and all kinds of hell break loose.
		To make things easier, I've collected the set of packages that
		I've used for the build and that are known to work.
		They've collected in <a class="ulink" href="http://downloads.sourceforge.net/project/triceps/docbook-for-1.0/" target="_top">http://downloads.sourceforge.net/project/triceps/docbook-for-1.0/</a>.
		The DocBook packages come originally from <a class="ulink" href="http://docbook.sf.net" target="_top">http://docbook.sf.net</a>,
		plus a few extra packages that by now I forgot where I've got from.
		An excellent book on the DocBook tools and their configuration is
		[<a href="#Stayton07" class="biblioref" title="[Stayton07]">Stayton07</a>]. And if you're interested, the
		text formatting in Docbook is described in
		[<a href="#Walsh99" class="biblioref" title="[Walsh99]">Walsh99</a>].
		</p><p>
		DocBook is great in the way it takes cary of great many things
		automatically but configuring it is plainly a bitch. Fortunately,
		it's all already taken care of. I've reused the infrastructure I've
		built for my book [<a href="#Babkin10" class="biblioref" title="[Babkin10]">Babkin10</a>] for Triceps.
		Though some elements got dropped and some added.
		</p><p>
		Downloading and extraction of the DocBook tools gets taken care of
		by running
		</p><pre class="programlisting">make -C doc/dbtools</pre><p>
		These tools are written in Java, and the packages are already the
		compiled binaries, so they don't need to be built. As long as
		you have the Java runtime environment, they just run. However
		like many Java packages, they are sloppy and often don't return
		the correct return codes on errors. So the results of the build
		have to be checked visually afterwards.
		</p><p>
		The build also uses Ghostscript for converting the figues
		from the EPS format. The luck with Ghostscript versions
		also varies. The version 8.70 works for me.
		I've seen some versions crash on this conversion.
		Fortunately, it was crashing after the conversion actually
		succeeded, so a workaround was to ignore the exit code
		from Ghostscript.
		</p><p>
		After the tools have been extracted, the build is done by
		</p><pre class="programlisting">make -C doc/src</pre><p>
		The temporary files are cleaned with
		</p><pre class="programlisting">make -C doc/src cleanwork</pre><p>
		The results will be in <code class="computeroutput">doc/pdf</code> and <code class="computeroutput">doc/html</code>. 
		</p><p>
		If like me you plan to use the DocBook tools repeatedly
		to build the docs for different versions of Triceps,
		you can download and extract them once in some other
		directory and then set the exported variable 
		<code class="computeroutput">TRICEPS_TOOLS_BASE</code> to point to it.
		</p></div><div class="sect1" title="3.5. Running the examples and simple programs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_run_simple"></a>3.5. Running the examples and simple programs</h2></div></div></div><a class="indexterm" name="id500312"></a><p>
		Overall, the examples live together with unit tests.
		The primary target language for Triceps is Perl, so the examples
		from the manual are the Perl examples located in
		<code class="computeroutput">perl/Triceps/t</code>. The files with names starting with <span class="quote">&#8220;<span class="quote"><code class="computeroutput">x</code></span>&#8221;</span> contain
		the examples as such, like <code class="computeroutput">xWindow.t</code>. 
		Usually there are multiple related examples in the same file. 
		</p><p>
		The examples as shown in the manual usually read the inputs from stdin
		and print their results on stdout.
		The actual examples in <code class="computeroutput">perl/Triceps/t</code> are not quite exactly the same
		because they are plugged into the unit test infrastructure. 
		The difference is limited to the input/output functions: 
		rather than reading and writing on the stdin and
		stdout, they take the inputs from variables, put the results into
		variables, and have the results checked for correctness.
		This way the examples stay working and do not experience the 
		bit rot when something changes.
		</p><p>
		Speaking of the examples outputs, the common convention in this manual
		is to show the lines entered from stdin as bold and the lines printed
		on stdout as regular font. This way they can be easily told apart,
		and the effects can be connected to their causes. Like this:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
lbAverage OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
  id="3" symbol="AAA" price="20" size="20"
lbAverage OP_INSERT symbol="AAA" id="3" price="15"</pre><p>
		The other unit tests in the <code class="computeroutput">.t</code> files are interesting too, since they
		contain absolutely all the possible usages of everything, and can be
		used as a reference. However they tend to be much more messy and hard
		to read, exactly because they contain in them lots of tiny snippets
		that do everything.
		</p><p>
		The easiest way to start trying out your own small programs is to place
		them into the same directory <code class="computeroutput">perl/Triceps/t</code> and run them from
		there. Just name them with the suffix <code class="computeroutput">.pl</code>, so that they would
		not be picked up by the Perl unit test infrastructre (or if you do want
		to run them as a part of unit tests, use the suffix <code class="computeroutput">.t</code>).
		</p><p>
		To make your programs find the Triceps modules, start them with
		</p><pre class="programlisting">use ExtUtils::testlib;
use Triceps;
use Carp;</pre><p>
		The module <code class="computeroutput">ExtUtils::testlib</code> takes care of setting the
		include paths to find Triceps. You can run them from the parent
		directory, like:
		</p><pre class="programlisting">perl t/xWindow.t</pre><p>
		The parent directory is the only choice, since <code class="computeroutput">ExtUtils::testlib</code>
		can not set up the include paths properly from the other directories.
		</p></div><div class="sect1" title="3.6. Locale dependency"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_locale"></a>3.6. Locale dependency</h2></div></div></div><p>
		Some of the Perl tests depend on the locale. They expect the English
		text in some of the error strings received from the OS and Perl, so if
		you try to run them in a non-English locale, these tests fail.
		</p><p>
		To work around this issue, I've added <code class="computeroutput">LANG=C</code> in the top-level Makefile,
		and when the tests run from there, they use this English locale.
		</p><p>
		However if you run <code class="computeroutput">make test</code> directly in the <code class="computeroutput">perl/Triceps</code>
		subdirectory, it has no such override (because the Makefile there is built by Perl).
		If you run the test from there and use a non-English locale, you'd have
		to set the locale for the command expicitly:
		</p><pre class="programlisting">LANG=C make test</pre><p>
		Some of these expected messages might also change between different 
		OSes and between different versions of Perl. They seem pretty stable
		overall but you'd never known when something might change somewhere,
		and that would lead to the spurious failures that can be ignored.
		I'd be interested to learn of them, to support all known forms of
		messages in the future.
		</p></div><div class="sect1" title="3.7. Installation of the Perl library"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_install_perl"></a>3.7. Installation of the Perl library</h2></div></div></div><a class="indexterm" name="id500520"></a><p>
		If you have the root permissions on the machine and want to install
		Triceps in the central location, just run
		</p><pre class="programlisting">make -C perl/Triceps install</pre><p>
		If you don't, there are multiple options. One is to create your
		private Perl hierarchy in the home directory. If you decide to
		put it into <code class="computeroutput">$HOME/inst</code>, the installation there becomes
		</p><pre class="programlisting">mkdir -p $HOME/inst
cp -Rf perl/Triceps/blib/* $HOME/inst/</pre><p>
		You can then set the environment variable
		</p><pre class="programlisting">export PERL5LIB=$HOME/inst/lib:$HOME/inst/arch</pre><p>
		to have your private hierarchy prepended to the Perl's standard
		library path. You can then insert <span class="quote">&#8220;<span class="quote"><code class="computeroutput">use Triceps;</code></span>&#8221;</span>
		and the Triceps module will be found. If you want to have the man
		pages from that directory working too, set
		</p><pre class="programlisting">export MANPATH=$HOME/inst:$MANPATH</pre><p>
		Not that Triceps has any usable man pages at the moment.
		</p><p>
		However if you're building a package that uses Triceps and
		will be shipped to the customer and/or deployed to a production
		machine, placing the libraries into the
		home directory is still not the best idea. Not only you don't
		want to pollute the random home directories, you also want to
		make sure that your libraries get picked up, and not the ones
		that might happen to be installed on the machine from
		some other sources (because they may be of different versions,
		or completely different libraries that accidentaly have the
		same name).
		</p><p>
		The best idea then is to copy Triceps and all the other
		libraries into your distribution package, and have the binaries
		(including the scripts) find them by a relative path.
		</p><p>
		Suppose you build the package prototype in the <code class="computeroutput">$PKGDIR</code>,
		with the binaries and scripts located in the subdirectory <code class="computeroutput">bin</code>, and the
		Triceps library located in the subdirectory <code class="computeroutput">blib</code>.
		When you build your package, you install the Triceps library in that
		prototype by
		</p><pre class="programlisting">cp -Rf perl/Triceps/blib $PKGDIR/</pre><p>
		Then this package gets archived, sent to the destination machine and
		unarchived. Whatever the package type, <code class="computeroutput">tar</code>, <code class="computeroutput">cpio</code> 
		or <code class="computeroutput">rpm</code>, doesn't matter.
		The relative paths under it stay the same. For example,
		if it gets installed under <code class="computeroutput">/opt/my_package</code>, the directory
		hierarchy would look like this:
		</p><pre class="programlisting">/opt/my_package
     +- bin
     |  +- my_program.pl
     +- blib
        +- ... Triceps stuff ...</pre><p>
		The script <code class="computeroutput">my_program.pl</code> can then use the following code at the
		top to load the Triceps package:
		</p><pre class="programlisting">#!/usr/bin/perl

use File::Basename;

# This is the magic sequence that adds the relative include paths.
BEGIN {
  my $mypath = dirname($0);
  unshift @INC, "${mypath}/../blib/lib", "${mypath}/../blib/arch";
}

use Triceps;</pre><p>
		It finds its own path from <code class="computeroutput">$0</code>, by taking its directory name. Then it
		adds the relative directories for the Perl modules and XS shared libraries
		to the include path. And finally loads Triceps using the modified
		include path. Of course, more paths for more packages can be added
		as well. The script can also use that own directory (if saved into a global
		instead of <code class="computeroutput">my</code> variable) to run the other programs later,
		find the configuration files and so on.
		</p></div><div class="sect1" title="3.8. Installation of the C++ library"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_install_cpp"></a>3.8. Installation of the C++ library</h2></div></div></div><a class="indexterm" name="id500716"></a><p>
		There are no special install scripts for the C++ libraries and includes.
		To build your C++ code with Triceps, simply specify the location of Triceps
		sources and built libraries with options <code class="computeroutput">-I</code> and <code class="computeroutput">-L</code>. For example, if
		you have built Triceps in <code class="computeroutput">$HOME/srcs/triceps-1.0.0</code>, you can add
		the following to your Makefile:
		</p><pre class="programlisting">TRICEPSBASE=$(HOME)/srcs/triceps-1.0.0
CFLAGS += -I$(TRICEPSBASE)/cpp -DTRICEPS_NSPR4
LDFLAGS += -L$(TRICEPSBASE)/cpp/build -ltriceps -lnspr4 -pthread</pre><p>
		The Triceps include files expect that the Triceps C++ subdirectory
		is directly in the include path as shown.
		</p><p>
		The exact set of <code class="computeroutput">-D</code> flags and extra <code class="computeroutput">-l</code> libraries may vary with the Triceps
		configuration. To get the exact ones used in the configuration, run the special
		configuration <code class="computeroutput">make</code> targets:
		</p><pre class="programlisting">make --quiet -f cpp/Makefile.inc getconf
make --quiet -f cpp/Makefile.inc getxlib</pre><p>
		The additions to <code class="computeroutput">CFLAGS</code> are returned by <code class="computeroutput">getconf</code>. The additional external
		libraries for <code class="computeroutput">LDFLAGS</code> are returned by <code class="computeroutput">getxlib</code>. It's important
		to use the same settings in the build of Triceps itself and of the user programs.
		The differing settings may cause the program to crash.
		</p><p>
		If you build your code with the dynamic library, the best packaging practice is to
		copy the <code class="computeroutput">libtriceps.so</code> to the same directory where your binary is
		located and specify its location with the build flags (for GCC, the flags of other
		compilers may vary):
		</p><pre class="programlisting">LDFLAGS += "-Wl,-rpath='$$ORIGIN/.'"</pre><p>
		Or any relative path would do. For example, if your binary package contains
		the binaries in the subdirectory <code class="computeroutput">bin</code> and the libraries in the subdirectory
		<code class="computeroutput">lib</code>, the setting for the path of the libraries relative
		to the binaries will be:
		</p><pre class="programlisting">LDFLAGS += "-Wl,-rpath='$$ORIGIN/../lib'"</pre><p>
		But locating the binaries and the shared libraries won't work if Triceps and your
		program get ever ported to Windows. Windows searches for the DLLs only in the
		same directory.
		</p><p>
		Or it might be easier to build your code with the static library: just
		instead of <code class="computeroutput">-ltriceps</code>, link explicitly with
		<code class="computeroutput">$(TRICEPSBASE)/cpp/build/libtriceps.a</code> and the libraries it
		requires:
		</p><pre class="programlisting">LDFLAGS += $(TRICEPSBASE)/cpp/build/libtriceps.a -lpthread -lnspr4</pre></div><div class="sect1" title="3.9. Disambiguation of the C++ library"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_disambig_cpp"></a>3.9. Disambiguation of the C++ library</h2></div></div></div><p>
		A problem with the shared libraries is that you never know, which
		exact library will end up linked at run time. The system library
		path takes priority over the one specified in <code class="computeroutput">-rpath</code>.
		So if somene has installed a Triceps shared library system-wide,
		it would be found and used instead of your one. And it might be
		of a completely different version. Or some other package might
		have messed with <code class="computeroutput">LD_LIBRARY_PATH</code> in the user's <code class="computeroutput">.profile</code>, and
		inserted its path with its own version of Triceps.
		</p><p>
		Messing with <code class="computeroutput">LD_LIBRARY_PATH</code> is bad. The good solution
		is to give your libraries some unique name, so that it would
		not get confused. Instead of <code class="computeroutput">libtriceps.so</code>, name it
		something like <code class="computeroutput">libtriceps_my_corp_my_project_v_123.so</code>.
		</p><p>
		Triceps can build the libraries with such names directly.
		To change the name, edit <code class="computeroutput">cpp/Makefile.inc</code> and change
		</p><pre class="programlisting">LIBRARY := triceps</pre><p>
		to
		</p><pre class="programlisting">LIBRARY := triceps_my_corp_my_project_v_123</pre><p>
		and it will produce the custom-named library. The Perl part of the build
		detects this name change automatically and still works (though for the
		Perl build it doesn't change much, the static C++ Triceps library gets
		linked into the XS-produced shared library).
		</p><p>
		There is also a special <code class="computeroutput">make</code> target to get back the base name
		of the Triceps library:
		</p><pre class="programlisting">make --quiet -f cpp/Makefile.inc getlib</pre><p>
		The other potential naming conflict could happen with both shared and
		dynamic libraries. It appears when you want to link two different versions
		of the library into the same binary. This is needed rarely, but still needed.
		If nothing special is done, the symbol names in two libraries clash and nothing works.
		Triceps provides a way around it by having an opportunity to rename the
		C++ namespaces, instead of the default namespace <span class="quote">&#8220;<span class="quote"><code class="computeroutput">Triceps</code></span>&#8221;</span>. 
		It can be done again by editing <code class="computeroutput">cpp/Makefile.inc</code>
		and modifying the setting <code class="computeroutput">TRICEPS_CONF</code>:
		</p><pre class="programlisting">TRICEPS_CONF += -DTRICEPS_NS=TricepsMyVersion</pre><p>
		Suppose that you have two Triceps versions that you want both to
		use in the same binary. Suppose that you are building them in
		<code class="computeroutput">$(HOME)/srcs/triceps-1.0.0</code> and <code class="computeroutput">$(HOME)/srcs/triceps-2.0.0</code>.
		</p><p>
		Then you edit <code class="computeroutput">$(HOME)/srcs/triceps-1.0.0/cpp/Makefile.inc</code> and
		put in there
		</p><pre class="programlisting">TRICEPS_CONF += -DTRICEPS_NS=Triceps1</pre><p>
		And in <code class="computeroutput">$(HOME)/srcs/triceps-2.0.0/cpp/Makefile.inc</code> put
		</p><pre class="programlisting">TRICEPS_CONF += -DTRICEPS_NS=Triceps2</pre><p>
		If you use the shared libraries, you need to disambiguate their names too,
		as described above, but for the static libraries you don't have to.
		</p><p>
		Almost there, but you need to have your code use the different namespaces
		for different versions too. The good practice is to include in your files
		</p><pre class="programlisting">#include &lt;common/Conf.h&gt;</pre><p>
		and then use everywhere the Triceps namespace <code class="computeroutput">TRICEPS_NS</code> instead of <code class="computeroutput">Triceps</code>.
		Then as long as one source file deals with only one version of Triceps,
		it can be easily manipulated to which version to use by providing that
		version in the include path. And you get your program to work with two
		versions of Triceps by linking the object files produces from these
		source files together into one binary.
		Then you just build some of your files
		with <code class="computeroutput">-I$(HOME)/srcs/triceps-1.0.0/cpp</code> and some with 
		<code class="computeroutput">-I$(HOME)/srcs/triceps-2.0.0/cpp</code> and avoid any conflicts
		or code changes.
		</p><p>
		At the link time, you will need to link with the libraries from both versions.
		</p></div><div class="sect1" title="3.10. Build configuration settings"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_build_config"></a>3.10. Build configuration settings</h2></div></div></div><p>
		Since Triceps has only a very limited autoconfiguration yet, it may need to be configured
		manually for the target operating system. The same method is used for the
		build options.
		</p><p>
		The configuration options are set in the file <code class="computeroutput">cpp/Makefile.inc</code>.
		The extra defines are added in <code class="computeroutput">TRICEPS_CONF</code>, the extra library dependencies
		in <code class="computeroutput">TRICEPS_XLIB</code>.
		</p><p>
		So far the only such configurable library dependency is the NSPR4 library.
		It's used for its implementation of the atomic integers and pointers.
		Normally the build attempts to auto-detect the location and name of the
		library and includes, or otherwise builds without it.
		Without it the code still works but uses a less efficient implementation
		of an integer or pointer protected by a mutex. 
		If your system has a version of NSPR4 that doesn't get auto-detected,
		you can still enable it by changing the settings manually. For example,
		for Fedora Linux the auto-detected version amounts to the following
		settings:
		</p><pre class="programlisting">TRICEPS_CONF += -DTRICEPS_NSPR -I/usr/include/nspr4
TRICEPS_XLIB += -lnspr4</pre><p>
		<code class="computeroutput">-DTRICEPS_NSPR</code> tells the code to compile with NSPR support
		enabled, and the other settings give the location of the includes and
		of the library.
		</p><p>
		The other build options require only the <code class="computeroutput">-D</code> settings.
		</p><pre class="programlisting">TRICEPS_CONF += -DTRICEPS_NS=TricepsMyVersion</pre><p>
		Changes the namespace of Triceps.
		</p><pre class="programlisting">TRICEPS_CONF += -DTRICEPS_BACKTRACE=false</pre><p>
		Disables the use of the glibc stack backtrace library (it's a standard
		part of glibc nowadays but if you use a non-GNU libc, you might have
		to disable it). This library is used to make the messages on fatal
		errors more readable, and let you find the location of the error easier.
		</p></div></div><div class="chapter" title="Chapter 4. API Fundamentals"><div class="titlepage"><div><div><h2 class="title"><a name="ch_api_fund"></a>Chapter 4. API Fundamentals</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_api_lang">4.1. Languages and layers</a></span></dt><dt><span class="sect1"><a href="#sc_confessions">4.2. Errors, deaths and confessions</a></span></dt><dt><span class="sect1"><a href="#sc_memory_fund">4.3. Memory management fundamentals</a></span></dt><dt><span class="sect1"><a href="#sc_code">4.4. Code references and snippets</a></span></dt><dt><span class="sect1"><a href="#sc_constants">4.5. Triceps constants</a></span></dt><dt><span class="sect1"><a href="#sc_objprint">4.6. Printing the object contents</a></span></dt><dt><span class="sect1"><a href="#sc_hungarian">4.7. The Hungarian notation</a></span></dt><dt><span class="sect1"><a href="#sc_perl_libex">4.8. The Perl libraries and examples</a></span></dt></dl></div><div class="sect1" title="4.1. Languages and layers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_api_lang"></a>4.1. Languages and layers</h2></div></div></div><p>
		As mentioned before, at the moment Triceps provides the APIs in C++ and
		Perl. They are similar but not quite the same, because the nature of
		the compiled and scripted languages is different. The C++ API is more
		direct and expects discipline from the programmer: if some incorrect
		arguments are passed, everything might crash. The Perl API should never
		crash. It should detect any incorrect use and report an orderly error.
		Besides, the idioms of the scripted languages are different from the
		compiled languages, and different usages become convenient.
		</p><a class="indexterm" name="id478668"></a><p>
		So far only the Perl API is documented in this manual. Its is considered
		the primary one for the end users, and also richer and easier to use.
		The C++ API will be documented as well, just it didn't make the cut for
		the version 1.0. If you're interested in the C++ API, read the Perl
		documentation first, to understand the ideas of Triceps, and then
		look in the source code. The C++ classes have very extensive comments
		in the header files.
		</p><a class="indexterm" name="id498880"></a><a class="indexterm" name="id500124"></a><p>
		The Perl API is implemented in XS. Some people, may wonder, why not
		SWIG? SWIG would automatically export the API into many languages, not
		just Perl. The problem with SWIG is that it just maps the API
		one-to-one. And this doesn't work any good, it makes for some very ugly
		APIs with abilities to crash from the user code. Which then have to be
		wrapped into more scripting code before they become usable. So then why
		bother with SWIG, it's easier to just use the scripting language's
		native extension methods.  Another benefit of the native XS support is
		the access to the correct memory management.
		</p><p>
		In general, I've tried to avoid the premature optimization. The idea is
		to get it working at all first, and then bother about working fast.
		Except for the cases when the need for optimization looked obvious, and
		the logic intertwined with the general design strongly ehough, that if
		done one way, would be difficult to change in the future. We'll see, if
		these <span class="quote">&#8220;<span class="quote">obvious</span>&#8221;</span> cases really turn out to be the obvious
		wins, or will they become a premature-optimization mess.
		</p><p>
		There is usually more than one way to do something in Triceps. It has 
		been written in layers: There is the C++ API layer on the bottom, then
		the Perl layer that closely parallels it, then more of the niceties
		built in Perl. There is more than one way to organize the manual,
		structuring it by features or by layers. Eventually I went in the
		order of the major features, discussing each one of them at various
		layers. 
		</p><p>
		I've also tried to show, how these layers are built on top of each other
		and connected. Which might be too much detail for the first reading.
		If you feel that something is going over your head, just skim over it.
		It could be marked more clearly but I don't like this kind of marking.
		I hate the side-panels in the magazines. I like the text to flow smoothly
		and sequentially. I don't like the <span class="quote">&#8220;<span class="quote">simplifications</span>&#8221;</span> that
		distort the real meaning and add all kinds of confusion. I like
		having all the details I can get, and then I can skip over the ones
		that look too complicated (and read them again when they start making
		sense).
		</p><p>
		Also, a major goal of Triceps is the extensibility.  And the best way
		to learn how to extend it, is by looking up close at how it has already
		been extended.
		</p></div><div class="sect1" title="4.2. Errors, deaths and confessions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_confessions"></a>4.2. Errors, deaths and confessions</h2></div></div></div><a class="indexterm" name="id468488"></a><a class="indexterm" name="id497719"></a><a class="indexterm" name="id467743"></a><a class="indexterm" name="id485605"></a><p>
		When the Perl API of Triceps detects an error, it makes the interpreter
		die with an error message. Unless of course you catch it with <code class="computeroutput">eval</code>.
		The message includes the call stack as the method <code class="computeroutput">Carp::confess()</code>
		would. <code class="computeroutput">confess()</code> is a very useful method that helps a lot
		with finding the source of the problem, it's much better than the plain
		<code class="computeroutput">die()</code>. Triceps uses internally the methods from Carp to build
		the stack trace in the message. But it also does one better: it includes the
		stack of the Triceps label calls into the trace.
		</p><p>
		You are welcome to use <code class="computeroutput">confess</code> directly as well, it's
		typically done in the following pattern:
		</p><pre class="programlisting">&amp;someFunction() or confess "Error message";
&amp;someFunction() or confess "Error message: $!";</pre><p>
		This is what the Triceps methods implemented in Perl do. The variable
		<code class="computeroutput">$!</code> contains the error messages from the methods that
		deal with the system errors.
		To require the
		package with <code class="computeroutput">confess</code>, do:
		</p><pre class="programlisting">use Carp;</pre><p>
		The full description of Carp is available at 
		<a class="ulink" href="http://perldoc.perl.org/Carp.html" target="_top">http://perldoc.perl.org/Carp.html</a>.
		It has more functions, however I find the full
		stack trace the most helpful thing in any case.
		</p><p>
		There also are modules to make all the cases of <code class="computeroutput">die</code> work like <code class="computeroutput">confess</code>,
		<code class="computeroutput">Devel::SimpleTrace</code> and <code class="computeroutput">Carp::Always</code>. They work by intercepting
		the pseudo-signals <code class="computeroutput">__WARN__</code> and <code class="computeroutput">__DIE__</code>. The logic of
		<code class="computeroutput">Carp::Always</code> is pretty simple, see
		<a class="ulink" href="http://cpansearch.perl.org/src/FERREIRA/Carp-Always-0.11/lib/Carp/Always.pm" target="_top">http://cpansearch.perl.org/src/FERREIRA/Carp-Always-0.11/lib/Carp/Always.pm</a>,
		so if you're not feeling like installing the module, you can easily do the same directly
		in your code.
		</p><p>
		If you want to intercept
		the error to add more information to the message, use <code class="computeroutput">eval</code>:
		</p><pre class="programlisting">eval { $self-&gt;{unit}-&gt;call($rowop) }
  or confess "Bad rowop argument:\n$@";</pre><p>
		I have some better ideas about reporting the errors in the nested
		templated but they need to be implemented and tried out yet.
		</p><p>
		A known problem with <code class="computeroutput">confess</code> in a threaded program
		is that it leaks the scalars, apparently by leaving garbage on the Perl stack,
		even when intercepted with <code class="computeroutput">eval</code>. It's actually not a problem when the confession
		is not intercepted, then the program exits anyway. But if confessing
		frequently and catching these confessions, the leak can accumulate
		to something noticeable.
		</p><p>
		The problem seems to be in the line 
		</p><pre class="programlisting">package DB;</pre><p>
		in the middle of one
		of its internal functions. Perhaps changing the package in the middle
		of a function is not such a great idea, leaving some garbage on the
		stack. The most interesting part is that this line can be removed
		altogether, with no adverse effects, and then the leak stops.
		So be warned and don't be surprised. Maybe it will get fixed.
		</p><p>
		Now let's look at how the C++ parts of Triceps interact with confessions.
		When the Perl code inside a label or tracer or aggregator or index sorting handler dies, the C++
		infrastructure around it catches the error. 
		It unrolls the stack trace through the
		C++ code and passes the <code class="computeroutput">die</code> request to the Perl code that called it.
		If that Perl code was called through another Triceps C++ code, that C++ code
		will catch the error and continue unrolling the stack and reporting back to Perl.
		When one Perl label calls another
		Perl label that calls the third Perl label, the call sequence goes in layers of 
		Perl&#8212;C++&#8212;Perl&#8212;C++&#8212;Perl&#8212;C++&#8212;Perl. 
		If that last label has its Perl code die
		and there are no <code class="computeroutput">eval</code>s in between, the stack will be correctly unwound
		back through all these layers and reported in the error message.  The C++
		code will include the reports of all the chained label calls as well.
		If one of the intermediate Perl layers wraps the call in <code class="computeroutput">eval</code>,
		it will receive the error message with the stack trace up to that point.
		</p><p>
		More of the error handling details will be discussed later in
		<a class="xref" href="#sc_sched_unwind" title="7.5. Error handling during the execution">Section 7.5: &#8220;Error handling during the execution&#8221; </a>
		and 
		<a class="xref" href="#sc_template_wrapfess" title="10.8. Error reporting in the templates">Section 10.8: &#8220;Error reporting in the templates&#8221; </a>.
		</p></div><div class="sect1" title="4.3. Memory management fundamentals"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_memory_fund"></a>4.3. Memory management fundamentals</h2></div></div></div><a class="indexterm" name="id504474"></a><p>
		The memory is managed in Triceps using the reference counters. Each
		Triceps object has a reference counter in it. In C++ this is done
		explicitly, in Perl it gets mostly hidden behind the Perl memory
		management that also uses the reference counters. Mostly.
		</p><a class="indexterm" name="id504490"></a><p>
		In C++ the Autoref template is used to produce the reference objects.
		The memory management at the C++ level is  described in more detail in
		<a class="xref" href="#sc_cpp_mem" title="20.3. Memory management in the C++ API and the Autoref reference">Section 20.3: &#8220;Memory management in the C++ API and the Autoref reference&#8221; </a>.
		As the references are copied around between these objects, the
		reference counts in the target objects are automatically adjusted. When
		the reference count drops to 0, the target object gets destroyed. While
		there are live references, the object can't get destroyed from under
		them. All nice and well and simple, however still possible to get
		wrong.
		</p><a class="indexterm" name="id504515"></a><p>
		The major problem with the reference counters is the reference cycles.
		If object A has a reference to object B, and object B has a reference
		(possibly, indirect) to object A, then neither of them will ever be
		destroyed. Many of these cases can be resolved by keeping a reference
		in one direction and a plain pointer in the other. This of course
		introduces the problem of hanging pointers, so extra care has to be
		taken to not reference them. There also are the unpleasant situations
		when there is absolutely no way around the reference cycles. For
		example, the Triceps label's method may keep a reference to the next
		label, where to send its processed results. If the labels are connected
		into a loop (a perfectly normal occurrence), this would cause a
		reference cycle. Here the way around is to know when all the labels are
		no longer used (before the thread exit), and explicitly tell them to
		clear their references to the other labels. This breaks up the cycle,
		and then bits and pieces can be collected by the reference count logic.
		</p><p>
		The reference cycle problem can be seen all the way up into the Perl level.
		However Triceps provides the ready solutions for its typical occurences.
		To explain it, more about Triceps operation has to be explained first,
		so it's described in detail later in
		<a class="xref" href="#ch_memory" title="Chapter 8. Memory Management">Chapter 8: &#8220;<i>Memory Management</i>&#8221; </a>.
		</p><p>
		The reference counting may be single-threaded or multi-threaded. If an
		object may only be used inside one thread, the references to it use the
		faster single-threaded counting. In C++ it's real important to not
		access and not reference the single-threaded objects from multiple
		threads. In Perl, when a new thread is created, only the multithreaded
		objects from the parent thread become accessible for it, the rest become
		undefined, so the issue gets handled automatically (as of version 1.0
		even the potentially multithreaded objects are still exported to Perl
		as single-threaded, with no connection between threads yet).
		</p><a class="indexterm" name="id504559"></a><p>
		The C++ objects are exported into Perl through wrappers. The wrappers
		perform the adaptation between Perl reference counting and Triceps
		reference counting, and sometimes more of the helper functions. Perl
		sees them as blessed objects, from which you can inherit and otherwise
		treat like normal objects. 
		</p><p>
		When we say that a Perl variable <code class="computeroutput">$label</code> contains a Triceps
		label object, it really means that it contains a <span class="emphasis"><em>referece</em></span> to
		a label object. When it gets copied like <code class="computeroutput">$label2 = $label</code>,
		this copies the reference and now both variables refer to the same
		label object (more exactly, even to the same wrapper object). Any 
		changes to the object's state done through one
		reference will also be visible through the other reference.
		</p><p>
		When the Perl references are copied between the variables, this
		increases the Perl reference count to the same wrapper object. However
		if an object goes into the C++ land, and then is extracted back (such
		as, create a Rowop from a Row, and then extract the Row from that
		Rowop), a brand new wrapper gets created. It's the same underlying C++
		object but with multiple wrappers. You can't tell that it's the same
		object by comparing the Perl references, because they may be pointing
		to the different wrappers. However Triceps provides the method
		<code class="computeroutput">same()</code> that compares the data inside the wrappers. It can be
		used as
		</p><pre class="programlisting">$row1-&gt;same($row2)</pre><p>
		and if it returns true, then both <code class="computeroutput">$row1</code> and <code class="computeroutput">$row2</code> point to the same
		underlying row. 
		</p><p>
		Note also that if you inherit from the Triceps objects
		and add some extra data to them, none of that data nor even your
		derived class'es identity will be preserved when a new wrapper is created
		from the underlying C++ object.
		</p></div><div class="sect1" title="4.4. Code references and snippets"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_code"></a>4.4. Code references and snippets</h2></div></div></div><a class="indexterm" name="id513675"></a><a class="indexterm" name="id513685"></a><p>
		Many of the Triceps Perl API objects accept the Perl code arguments,
		to be executed as needed. This code can be specified as either a function
		reference or a string containing the source code snippet.
		The major reason to accept the arguments in the source code format
		is the ability to pass them through between the threads, which cannot
		be done with the compiled code. See more information on that in 
		<a class="xref" href="#sc_mt_objects" title="16.4. Object passing between threads">Section 16.4: &#8220;Object passing between threads&#8221; </a>. 
		</p><p>
		Only a few of the classes can be exported between the threads
		but for consistency all the classes support the code arguments in
		either format. This feature is built into the general way the
		Triceps XS methods handle the code references.
		</p><p>
		The following examples are equivalent, one using a function
		reference, another using a source code snippet.
		Of course, if you know that the created object will be
		exported to another thread, you must use the source code
		format. Otherwise you can take your pick.
		</p><pre class="programlisting">$it= Triceps::IndexType-&gt;newPerlSorted("b_c", undef,
sub {
  my $res = ($_[0]-&gt;get("b") &lt;=&gt; $_[1]-&gt;get("b")
    || $_[0]-&gt;get("c") &lt;=&gt; $_[1]-&gt;get("c"));
  return $res;
}
);

$it= Triceps::IndexType-&gt;newPerlSorted("b_c", undef,
'
  my $res = ($_[0]-&gt;get("b") &lt;=&gt; $_[1]-&gt;get("b")
    || $_[0]-&gt;get("c") &lt;=&gt; $_[1]-&gt;get("c"));
  return $res;
'
);</pre><p>
		As you can see, when specifying the handler as source code,
		you must specify only the function body, and the 
		<code class="computeroutput">sub { ... }</code> will be wrapped around it implicitly.
		Including the <code class="computeroutput">sub</code> would be an error.
		</p><p>
		There are other differences between the code references and the
		source code format:
		</p><p>
		When you compile a function, it carries with it the lexical context. So
		you can make the closures that refer to the <span class="quote">&#8220;<span class="quote">my</span>&#8221;</span> variables in their
		lexical scope. With the source code snippets you can't do this. 
		The source code gets compiled in the context of the main package,
		and that's all they can see. In some cases, it might not even be
		compiled immediately. If an object has an explicit initialization,
		the code snippets get compiled at the initialization time.
		And if the object is exported to another thread, the code snippets
		will be re-compiled when an object's copy is created and initialized in that
		another thread.  Remember also that the global
		variables are not shared between the threads, so if you refer to a
		global variable in the code snippet and rely on a value in that
		variable, it won't be present in the other threads (unless the other
		threads are direct descendants and the value was set before their
		creation).
		</p><p>
		The code written in Perl can make use of the source code snippets as well.
		If it just passes these code arguments to the XS methods, it
		will get this support automatically. But if it wants to call
		these snippets directly from the Perl code, Triceps provides
		a convenience method that would accept the code in either format
		and compile it if needed:
		</p><pre class="programlisting">$code = Triceps::Code::compile($code_ref_or_source);</pre><p>
		It takes either a code reference or a source code string as an argument
		and returns the reference to the compiled code. If the argument was a
		code reference, it just passes through unchanged. If it was a source
		code snippet, it gets compiled (and the rules are the same, the text
		gets the <code class="computeroutput">sub { ... }</code> wrapper added around it implicitly).
		</p><p>
		If the argument was an <code class="computeroutput">undef</code>, it also passes through unchanged. This is
		convenient in case if the code is optional. But if it isn't then the
		caller should check for <code class="computeroutput">undef</code>.
		</p><p>
		If the compilation fails, the method confesses, and includes the error
		and the source code into the message, in the same way as the XS methods
		do.
		</p><p>
		The optional second argument can be used to provide information
		about the meaning of the code for the error messages. If it's undefined
		then the default is <span class="quote">&#8220;<span class="quote">Code snippet</span>&#8221;</span>:
		</p><pre class="programlisting">$code = Triceps::Code::compile($code_ref_or_source, $description);</pre><p>
		For example, if the code represents an error handler,
		the call can be done as follows:
		</p><pre class="programlisting">$code = Triceps::Code::compile($code, "Error handler");</pre></div><div class="sect1" title="4.5. Triceps constants"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_constants"></a>4.5. Triceps constants</h2></div></div></div><a class="indexterm" name="id513845"></a><p>
		Triceps has a number of symbolic constants that are grouped into
		essentially enums. The constants themselves will be introduced with the
		classes that use them, but here is the general description common to
		them all.
		</p><p>
		In Perl they all are placed into the same namespace. Each group of
		constants (that can be thought of as an enum) gets its name prefix. For
		example, the operation codes are all prefixed with OP_, the enqueueing
		modes with EM_, and so on.
		</p><p>
		The underlying constants are all integer. The way to give symbolic
		names to constants in Perl is to define a function without arguments
		that would return the value. Each constant has such a function defined
		for it. For example, the opcode for the <span class="quote">&#8220;<span class="quote">insert</span>&#8221;</span> operation is the
		result of function <code class="computeroutput">Triceps::OP_INSERT</code>. 
		</p><p>
		Most methods that take constants as arguments are also smart enough to
		recognise the constant names as strings, and automatically convert them
		to integers. For example, the following calls are equivalent:
		</p><pre class="programlisting">$label-&gt;makeRowop(&amp;Triceps::OP_INSERT, ...);
$label-&gt;makeRowop("OP_INSERT", ...);</pre><p>
		For a while I've thought that the version with
		<code class="computeroutput">Triceps::OP_INSERT</code> would be more efficient and might check
		for correctness of the name at compile time.  But as it turns out, no,
		on both counts. The look-up of the function by name happens at run
		time, so there is no compile-time check.  And that look-up happens to
		be a little slower than the one done by the Triceps C++ code, so
		there is no win there either. The string version is not only shorter
		but also more efficient. The only win with the function is if you call it
		once, remember the result in a variable and then reuse. Unless you're 
		chasing the last few percent of performance in a tight loop, it's not
		worth the trouble. Perhaps in the future the functions will be replaced
		with the module-level variables: <span class="emphasis"><em>that</em></span> would be both faster and
		allow the compile-time checking with <code class="computeroutput">use strict</code>.
		</p><p>
		What if you need to print out a constant in a message? Triceps provides
		the conversion functions for each group of constants. They generally
		are named <code class="computeroutput">Triceps::<span class="emphasis"><em>something</em></span>String</code>. 
		For example,
		</p><pre class="programlisting">print &amp;Triceps::opcodeString(&amp;Triceps::OP_INSERT);</pre><a class="indexterm" name="id513938"></a><p>
		would print <span class="quote">&#8220;<span class="quote">OP_INSERT</span>&#8221;</span>.
		If the argument is out of range of the valid enums, it would confess.
		There is also a version of these functions ending with <code class="computeroutput">Safe</code>:
		</p><pre class="programlisting">print &amp;Triceps::opcodeStringSafe(&amp;Triceps::OP_INSERT);</pre><p>
		The difference is that it returns <code class="computeroutput">undef</code> if the input value
		is out of range, thus being safe from confessions.
		</p><p>
		There also are functions to convert from strings to constant values.
		They generally are named <code class="computeroutput">Triceps::string<span class="emphasis"><em>Something</em></span></code>. 
		For example,
		</p><pre class="programlisting">&amp;Triceps::stringOpcode("OP_INSERT")
&amp;Triceps::stringOpcodeSafe("OP_INSERT")</pre><p>
		would return the integer value of <code class="computeroutput">Triceps::OP_INSERT</code>. If the
		string name is not valid for this kind of constants, it would also
		either confess without <code class="computeroutput">Safe</code> in the name or return <code class="computeroutput">undef</code>
		with it.
		</p></div><div class="sect1" title="4.6. Printing the object contents"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_objprint"></a>4.6. Printing the object contents</h2></div></div></div><a class="indexterm" name="id514029"></a><p>
		When debugging the programs, it's important to find from the error
		messages, what is going on, what kinds of objects are getting involved.
		Because of this, many of the Triceps objects provide a way to print out
		their contents into a string. This is done with the method
		<code class="computeroutput">print()</code>. The simplest use is as follows:
		</p><pre class="programlisting">$message = "Error in object " . $object-&gt;print();</pre><p>
		Most of the objects tend to have a pretty complicated internal
		structure and are printed on multiple lines. They look better when the
		components are appropriately indented. The default call prints as if
		the basic message is un-indented, and indents every extra level by 2
		spaces.
		</p><p>
		This can be changed with extra arguments. The general format of
		<code class="computeroutput">print()</code> is:
		</p><pre class="programlisting">$object-&gt;print(<span class="emphasis"><em>[$indent, [$subindent] ]</em></span>)</pre><p>
		where <span class="emphasis"><em>$indent</em></span> is the initial indentation, and <span class="emphasis"><em>$subindent</em></span> is
		the additional indentation for every level. The default <code class="computeroutput">print()</code> is
		equivalent to <code class="computeroutput">print("", "  ")</code>.
		</p><p>
		A special case is
		</p><pre class="programlisting">$object-&gt;print(undef)</pre><p>
		It prints the object in a single line, without line breaks.
		</p><p>
		Here is an example of how a row type object would get printed. The details
		of the row types will be described later, for now just assume that a
		row type is defined as:
		</p><pre class="programlisting">$rt1 = Triceps::RowType-&gt;new(
  a =&gt; "uint8",
  b =&gt; "int32",
  c =&gt; "int64",
  d =&gt; "float64",
  e =&gt; "string",
);</pre><p>
		Then <code class="computeroutput">$rt1-&gt;print()</code> produces:
		</p><pre class="programlisting">row {
  uint8 a,
  int32 b,
  int64 c,
  float64 d,
  string e,
}</pre><p>
		With extra arguments <code class="computeroutput">$rt1-&gt;print("++", "--")</code>:
		</p><pre class="programlisting">row {
++--uint8 a,
++--int32 b,
++--int64 c,
++--float64 d,
++--string e,
++}</pre><p>
		The first line doesn't have a <span class="quote">&#8220;<span class="quote">++</span>&#8221;</span> because the
		assumption is that the text gets appended to some other text
		already on this line, so any prefixes are used only for the
		following lines.
		</p><p>
		And finally with an undef argument <code class="computeroutput">$rt1-&gt;print(undef)</code>:
		</p><pre class="programlisting">row { uint8 a, int32 b, int64 c, float64 d, string e, }</pre><a class="indexterm" name="id505124"></a><p>
		The Rows and Rowops do not have the <code class="computeroutput">print()</code> method.
		That's largely because the C++ code does not deal with printing
		the actual data, this is left to the Perl code. So instead
		they have the method <code class="computeroutput">printP()</code> that does a similar
		job. Only it's simpler and doesn't have any of the indenting
		niceties. It always prints the data in a single line. The <span class="quote">&#8220;<span class="quote">P</span>&#8221;</span> 
		in <span class="quote">&#8220;<span class="quote">printP</span>&#8221;</span> stands for <span class="quote">&#8220;<span class="quote">Perl</span>&#8221;</span>. The name
		is also different because of this lack of indenting niceties.
		See more about it in the 
		<a class="xref" href="#sc_Rows" title="5.4. Rows">Section 5.4: &#8220;Rows&#8221; </a>. 
		</p></div><div class="sect1" title="4.7. The Hungarian notation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_hungarian"></a>4.7. The Hungarian notation</h2></div></div></div><p>
		The Hungarian notation is the idea that the name of each variable
		should be prefixed with some abbreviation of its type. It has probably
		become most widely known from the Microsoft operating systems.
		</p><p>
		Overall it's a complete abomination and brain damage. But 
		I'm using it widely in the examples in this manual. Why? The problem is that there
		usually too many components for one logical purpose. For a table, there
		would be a row type, a table type, and the table itself. Rather than
		inventing separate names for them, it's easier to have a common name
		and an uniform prefix. Eventually something better would have to be
		done but for now I've fallen back on the Hungarian notation.
		One possibility is to just not give names to the intermediate
		entities. Say just have a named table, and then there would be
		the the type of the table and the row type of the table.
		</p><p>
		Among the CEP systems, Triceps is not unique in the Hungarian notation
		department. Coral8/Sybase CCL has this mess of lots of schemas, input
		streams, windows and output streams, with the same naming problems. The
		uniform naming prefixes or suffixes help making this mess more
		navigable. I haven't actually used StreamBase but from reading the
		documentation I get the feeling that the Hungarian notation is probably
		useful for its SQL as well.
		</p></div><div class="sect1" title="4.8. The Perl libraries and examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_perl_libex"></a>4.8. The Perl libraries and examples</h2></div></div></div><a class="indexterm" name="id505213"></a><a class="indexterm" name="id505223"></a><p>
		The official Triceps classes are collected in the Triceps package
		(and its subpackages). 
		</p><p>
		However when writing tests and examples I've found
		that there are also some repeating elements. Initially I've been handling
		the situation by either combining all examples using such an element into a
		single file or by copying it around. Then I've collected all such fragments
		under the package Triceps::X.
		X can be thought of as a mark of eXperimental, eXample,
		eXtraneous code. 
		</p><p>
		While the code in the official part of the library is extensively
		tested, the X-code is tested only in its most important functionality
		and not in the details.
		This code is not exactly of production quality but is
		good enough for the examples, and can be used as a starting point for
		development of the better code. Quite a few fragments of Triceps went
		this way: the joins have been done as an example first, and then
		solidified for the main code base, and so did the aggregation.
		</p><a class="indexterm" name="id505252"></a><p>
		One of these modules is Triceps::X::TestFeed. It's a small
		infrastructure to run the examples, pretending that it gets the input
		from stdin and sends output to stdout, while actually doing it all in
		memory. All of the more complicated examples have been written to use it. 
		When you look in the code of the actual running examples and compare
		it to the code snippets in the manual, you can see the differences.
		
		A <code class="computeroutput">&amp;readLine</code> shows instead of <code class="computeroutput">&lt;STDIN&gt;</code>, and a
		<code class="computeroutput">&amp;send</code> instead of <code class="computeroutput">print</code> (and for the manual, I have a script that does
		the reverse substitutions automatically when I insert the code examples into
		it). 
		</p></div></div><div class="chapter" title="Chapter 5. Rows"><div class="titlepage"><div><div><h2 class="title"><a name="ch_Rows"></a>Chapter 5. Rows</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_SimpleTypes">5.1. Simple types</a></span></dt><dt><span class="sect1"><a href="#sc_RowTypes">5.2. Row types</a></span></dt><dt><span class="sect1"><a href="#sc_RowTypesEquiv">5.3. Row types equivalence</a></span></dt><dt><span class="sect1"><a href="#sc_Rows">5.4. Rows</a></span></dt></dl></div><p>
	In Triceps the relational data is stored and passed around as rows
	(once in a while I call them records, which is the same thing
	here). Each row belongs to a certain type, that defines the types
	of the fields. Each field may belong to one of the simple types.
	</p><div class="sect1" title="5.1. Simple types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_SimpleTypes"></a>5.1. Simple types</h2></div></div></div><a class="indexterm" name="id473998"></a><p>
		The simple values in Triceps belong to one of the simple types:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		uint8
		</li><li class="listitem">
		int32
		</li><li class="listitem">
		int64
		</li><li class="listitem">
		float64
		</li><li class="listitem">
		string
		</li></ul></div><p>
		I like the explicit specification of the data size, so it's not some
		mysterious <span class="quote">&#8220;<span class="quote">double</span>&#8221;</span> but an explicit <span class="quote">&#8220;<span class="quote">float64</span>&#8221;</span>.
		</p><p>
		When the data is stored in the rows, it's stored in the strongly-typed
		binary format. When it's extracted from the rows for the Perl code to
		access, it gets converted into the Perl values. And the other way
		around, when stored into the rows, the conversion is done from the Perl
		values.
		</p><p>
		<code class="computeroutput">uint8</code> is the type intended to represent the raw bytes. So, for example,
		when they are compared, they should be compared as raw bytes, not
		according to the locale. Since Perl stores the raw bytes in strings,
		and its <code class="computeroutput">pack()</code> and <code class="computeroutput">unpack()</code> functions operate on strings, The Perl side
		of Triceps extracts the uint8 values from records into Perl strings,
		and the other way around. 
		</p><p>
		The string type is intended to represent a text string in whatever
		current locale (at some point it may become always UTF-8, this question
		is open for now).
		</p><p>
		Perl on the 32-bit machines has an issue with int64: it has no type to
		represent it directly. Because of that, when the int64 values are
		passed to Perl on the 32-bit machines, they are converted into the
		floating-point numbers. This gives only 54 bits (including sign) of
		precision, but that's close enough. Anyway, the 32-bit machines are
		obsolete by now, and Triceps it targeted towards the 64-bit machines.
		</p><p>
		On the 64-bit machines both int32 and int64 translate to the Perl
		64-bit integers.
		</p><a class="indexterm" name="id469547"></a><p>
		Note that there is no special type for timestamps. As of version 1.0
		there is no time-based processing inside Triceps, but that does not
		prevent you from passing around timestamps as data and use them in your
		logic. Just store the timestamps as integers (or, if you prefer,
		as floating point numbers). When the time-based processing will be
		added to Perl, the plan is to still use the int64 to store the number
		of microseconds since the Unix epoch. My experience with the time types
		in the other CEP systems is that they cause nothing but confusion.
		In the meantime, the time-based processing is still possible by driving
		the notion of time explicitly. It's described in the
		<a class="xref" href="#ch_time" title="Chapter 13. Time processing">Chapter 13: &#8220;<i>Time processing</i>&#8221; </a>.
		</p></div><div class="sect1" title="5.2. Row types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_RowTypes"></a>5.2. Row types</h2></div></div></div><a class="indexterm" name="id467990"></a><a class="indexterm" name="id495259"></a><p>
		A row type is created from a sequence of (field-name, field-type)
		string pairs, for example:
		</p><pre class="programlisting">$rt1 = Triceps::RowType-&gt;new(
  a =&gt; "uint8",
  b =&gt; "int32",
  c =&gt; "int64",
  d =&gt; "float64",
  e =&gt; "string",
);</pre><p>
		Even though the pairs look like a hash, don't use an actual hash to
		create row types! The order of pairs in a hash is unpredictable, while
		the order of fields in a row type usually matters.
		</p><p>
		In an actual row the field may have a value or be NULL. The NULLs are
		represented in Perl as <code class="computeroutput">undef</code>.
		</p><a class="indexterm" name="id495295"></a><a class="indexterm" name="id495308"></a><p>
		The real-world records tend to be pretty wide and contain
		repetitive data. Hundreds of fields are not unusual, and I know of a
		case when an Aleri customer wanted to have records of two thousand
		fields (and succeeded). This just begs for arrays. So the Triceps rows
		allow the array fields. They are specified by adding <span class="quote">&#8220;<span class="quote">[]</span>&#8221;</span> at the end of
		field type. The arrays may only be made up of fixed-width data, so no
		arrays of strings.
		</p><pre class="programlisting">$rt2 = Triceps::RowType-&gt;new(
  a =&gt; "uint8[]",
  b =&gt; "int32[]",
  c =&gt; "int64[]",
  d =&gt; "float64[]",
  e =&gt; "string", # no arrays of strings!
);</pre><a class="indexterm" name="id479119"></a><p>
		The arrays are of variable length, whatever array data passed when a
		row is created determines its length. The individual elements in the
		array may not be NULL (and if <code class="computeroutput">undef</code>s are passed in the array used to
		construct the row, they will be replaced with 0s). The whole array
		field may be NULL, and this situation is equivalent to an empty array.
		</p><p>
		The type uint8 is typically used in arrays, <span class="quote">&#8220;<span class="quote">uint8[]</span>&#8221;</span> is the Triceps
		way to define a blob field. In Perl the <span class="quote">&#8220;<span class="quote">uint8[]</span>&#8221;</span> is represented as a
		string value, same as a simple <span class="quote">&#8220;<span class="quote">unit8</span>&#8221;</span>.
		</p><p>
		The rest of array values are represented in Perl as references to Perl
		arrays, containing the actual values.
		</p><p>
		The row type objects provide a way for introspection:
		</p><pre class="programlisting">$rt-&gt;getdef()</pre><p>
		returns back the array of pairs used to create this type. It can be
		used among other things for the schema inheritance. For example, the
		multi-part messages with daily unique ids can be defined as:
		</p><pre class="programlisting">$rtMsgKey = Triceps::RowType-&gt;new(
  date =&gt; "string",
  id =&gt; "int32",
);

$rtMsg = Triceps::RowType-&gt;new(
  $rtMsgKey-&gt;getdef(),
  from =&gt; "string",
  to =&gt; "string",
  subject =&gt; "string",
);

$rtMsgPart = Triceps::RowType-&gt;new(
  $rtMsgKey-&gt;getdef(),
  type =&gt; "string",
  payload =&gt; "string",
);</pre><p>
		The meaning here is the same as in the CCL example:
		</p><pre class="programlisting">create schema rtMsgKey (
  string date,
  integer id
);
create schema rtMsg inherits from rtMsgKey (
  string from,
  string to,
  string subject
);
create schema rtMsgPart inherits from rtMsgKey (
  string type,
  string payload
);</pre><p>
		The grand plan is to provide some better ways of defining the
		commonality of fields between row types. It should include the ability
		to rename fields, to avoid conflicts, and to remember this equivalence
		to be reused in the further joins without the need to write it over and
		over again. But it has not come to the implementation stage yet.
		</p><p>
		The other methods are:
		</p><pre class="programlisting">$rt-&gt;getFieldNames()</pre><p>
		returns the array of field names only.
		</p><pre class="programlisting">$rt-&gt;getFieldTypes()</pre><p>
		returns the array of field types only.
		</p><pre class="programlisting">$rt-&gt;getFieldMapping()</pre><p>
		returns the array of pairs that map the field names to their indexes in
		the field definitions. It can be stored into a hash and used for
		name-to-index translation. It's used mostly in the templates, to
		generate code that accesses data in the rows by field index (which is
		more efficient than access by name). For example, for <code class="computeroutput">rtMsgKey</code>
		defined above it would return <code class="computeroutput">(date =&gt; 0, id =&gt; 1)</code>.
		</p></div><div class="sect1" title="5.3. Row types equivalence"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_RowTypesEquiv"></a>5.3. Row types equivalence</h2></div></div></div><a class="indexterm" name="id479333"></a><a class="indexterm" name="id479347"></a><a class="indexterm" name="id479360"></a><a class="indexterm" name="id479374"></a><p>
		The Triceps objects are usually strongly typed. A label handles rows of
		a certain type. A table stores rows of a certain type.
		</p><p>
		However there may be multiple ways to check whether a row fits for a
		certain type:
		</p><div class="itemizedlist"><a class="indexterm" name="id501705"></a><ul class="itemizedlist" type="disc"><li class="listitem">
		It may be a row of the exact same type, created with the same RowType object.
		</li><li class="listitem">
		It may be a row of another type but one with the exact same definition.
		</li><li class="listitem">
		It may be a row of another type that has the same number of fields and
		field types but different field names. The field names (and everything
		else in Triceps) are case-sensitive.
		</li></ul></div><p>
		The row types may be compared for these conditions using the methods:
		</p><pre class="programlisting">$rt1-&gt;same($rt2)
$rt1-&gt;equals($rt2)
$rt1-&gt;match($rt2)</pre><p>
		The comparisons are hierarchical: if two type references are the same,
		they would also be equal and matching; two equal types are also
		matching.
		</p><p>
		Most of the objects would accept the rows of any matching type (this
		may change or become adjustable in the future). However if the rows are
		not of the same type, this check involves a performance penalty. If the
		types are the same, the comparison is limited to comparing the
		pointers. But if not, then the whole type definition has to be
		compared. So every time a row of a different type is passed, it would
		involve the overhead of type comparison.
		</p><p>
		For example:
		</p><pre class="programlisting">my @schema = (
  a =&gt; "int32",
  b =&gt; "string"
);

my $rt1 = Triceps::RowType-&gt;new(@schema);
# $rt2 is equal to $rt1: same field names and field types
my $rt2 = Triceps::RowType-&gt;new(@schema);
# $rt3  matches $rt1 and $rt2: same field types but different names
my $rt3 = Triceps::RowType-&gt;new(
  A =&gt; "int32",
  B =&gt; "string"
);

my $lab = $unit-&gt;makeDummyLabel($rt1, "lab");
# same type, efficient
my $rop1 = $lab-&gt;makeRowop(&amp;Triceps::OP_INSERT,
  $rt1-&gt;makeRowArray(1, "x"));
# different row type, involves a comparison overhead
my $rop2 = $lab-&gt;makeRowop(&amp;Triceps::OP_INSERT,
  $rt2-&gt;makeRowArray(1, "x"));
# different row type, involves a comparison overhead
my $rop3 = $lab-&gt;makeRowop(&amp;Triceps::OP_INSERT,
  $rt3-&gt;makeRowArray(1, "x"));</pre><p>
		A dummy label used here is a label that does nothing (its usefulness
		will be explained later).
		</p><a class="indexterm" name="id501766"></a><a class="indexterm" name="id501779"></a><p>
		Once the Rowop is constructed, no further penalty is involved: the
		row in the Rowop is re-typed to the type of the label from now on.
		It's physically still the same row with another reference to it,
		but when you get it back from the Rowop, it will have the label's
		type. It's all a part of the interesting interaction between C++
		and Perl. All the type checking is done in the Perl XS layer.
		The C++ code just expects that the data is always right and doesn't
		carry the types around. When the Perl code wants to get the row
		back from the Rowop, it wants to know the type of the row.
		The only way to get it is to look, what is the label of this
		Rowop, and get the row type from the label. This is also the
		reason why the types have to be checked when the Rowop is
		constructed: if a wrong row is placed into the Rowop, there will
		be no later opportunity to check it for correctness, and bad
		data may cause a crash.
		</p></div><div class="sect1" title="5.4. Rows"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_Rows"></a>5.4. Rows</h2></div></div></div><a class="indexterm" name="id501810"></a><p>
		The rows in Triceps always belong to some row type, and are always
		immutable. Once a row is created, it can not be changed. This allows it
		to be referenced from multiple places, instead of copying the whole row
		value. Naturally, a row may be passed and shared between multiple
		threads.
		</p><p>
		The row type provides the constructor methods for the rows:
		</p><pre class="programlisting">$row = $rowType-&gt;makeRowArray(@fieldValues);
$row = $rowType-&gt;makeRowHash($fieldName =&gt; $fieldValue, ...);</pre><p>
		Here <code class="computeroutput">$row</code> is a reference to the resulting row. As usual, in case of
		error it will confess.
		</p><p>
		In the array form, the values for the fields go in the same order as
		they are specified in the row type (if there are too few values, the
		rest will be considered NULL, having too many values is an error).
		</p><p>
		The Perl value of <code class="computeroutput">undef</code> is treated as NULL. 
		</p><p>
		In the hash form, the fields are specified as name-value pairs. If the
		same field is specified multiple times, the last value will overwrite
		all the previous ones. The unspecified fields will be left as
		NULL. Again, the arguments of the function actually are an array, but
		if you pass a hash, its contents will be converted to an array on the
		call stack.
		</p><p>
		If the performance is important, the array form is more efficient,
		since the hash form has to translate internally the field names to
		indexes.
		</p><p>
		The row itself and its type don't have any concept of keys in general
		and of the primary key in particular. So any fields may be left as NULL.
		There is no <span class="quote">&#8220;<span class="quote">NOT NULL</span>&#8221;</span> constraint.
		</p><p>
		Some examples:
		</p><pre class="programlisting">$row  = $rowType-&gt;makeRowArray(@fields);
$row  = $rowType-&gt;makeRowArray($a, $b, $c);
$row  = $rowType-&gt;makeRowHash(%fields);
$row  = $rowType-&gt;makeRowHash(a =&gt; $a, b =&gt; $b);</pre><p>
		The usual Perl conversions are applied to the values. So for example,
		if you pass an integer 1 for a string field, it will be converted to
		the string <span class="quote">&#8220;<span class="quote">1</span>&#8221;</span>. Or if you pass a string <span class="quote">&#8220;<span class="quote"></span>&#8221;</span> for an integer field, it
		will be converted to 0. 
		</p><p>
		If a field is an array (as always, except for <code class="computeroutput">uint8[]</code> which is
		represented as a Perl string), its value is a Perl array reference (or
		<code class="computeroutput">undef</code>). For example:
		</p><pre class="programlisting">$rt1 = Triceps::RowType-&gt;new(
  a =&gt; "uint8[]",
  b =&gt; "int32[]",
);
$row = $rt1-&gt;makeRowArray("abcd", [1, 2, 3]);</pre><p>
		An empty array will become a NULL value. So the following two are equivalent:
		</p><pre class="programlisting">$row = $rt1-&gt;makeRowArray("abcd", []);
$row = $rt1-&gt;makeRowArray("abcd", undef);</pre><p>
		Remember that an array field may not contain NULL values. Any <code class="computeroutput">undef</code>s
		in the array fields will be silently converted to zeroes (since arrays
		are supported only for the numeric types, a zero value would always
		be available for all of them). The following two are equivalent:
		</p><pre class="programlisting">$row = $rt1-&gt;makeRowArray("abcd", [undef, undef]);
$row = $rt1-&gt;makeRowArray("abcd", [0, 0]);</pre><p>
		The row also provides a way to copy itself, modifying the values of
		selected fields:
		</p><pre class="programlisting">$row2 = $row1-&gt;copymod($fieldName =&gt; $fieldValue, ...);</pre><p>
		The fields that are not explicitly specified will be left unchanged.
		Since the rows are immutable, this is the closest thing to the field
		assignment. <code class="computeroutput">copymod()</code> is generally more efficient than
		extracting the row into an array or hash, replacing a few of them with
		new values and constructing a new row. It bypasses the
		binary-to-Perl-to-binary conversions for the unchanged fields.
		</p><p>
		The row knows its type, which can be obtained with
		</p><pre class="programlisting">$row-&gt;getType()</pre><p>
		Note that this will create a new Perl wrapper to the underlying type
		object. So if you do:
		</p><pre class="programlisting">$rt1 = ...;
$row = $rt1-&gt;makeRow...;
$rt2 = $row-&gt;getType();</pre><p>
		then <code class="computeroutput">$rt1</code> will not be equal to <code class="computeroutput">$rt2</code> by the direct
		Perl comparison (<code class="computeroutput">$rt1 != $rt2</code>). However both <code class="computeroutput">$rt1</code>
		and <code class="computeroutput">$rt2</code> will refer to the same row type object, so
		<code class="computeroutput">$rt1-&amp;gt;same($rt2)</code> will be true.
		</p><p>
		The row references can also be compared for sameness:
		</p><pre class="programlisting">$row1-&gt;same($row2)</pre><p>
		The row contents can be extracted back into Perl representation as
		</p><pre class="programlisting">@adata = $row-&gt;toArray();
%hdata = $row-&gt;toHash();</pre><p>
		Again, the NULL fields will become <code class="computeroutput">undef</code>s, and the array fields (unless
		they are NULL) will become Perl array references. Since the empty array
		fields are equivalent to NULL array fields, on extraction back they
		will be treated the same as NULL fields, and become <code class="computeroutput">undef</code>s.
		</p><p>
		There is also a convenience function to get one field from a row at a
		time by name:
		</p><pre class="programlisting">$value = $row-&gt;get("fieldName");</pre><p>
		If you need to access only a few fields from a big row, <code class="computeroutput">get()</code> is more
		efficient (and easier to write) that extracting the whole row with
		<code class="computeroutput">toHash()</code> or even with <code class="computeroutput">toArray()</code>. But don't forget that every time you
		call <code class="computeroutput">get()</code>, it creates a new Perl value, which may be pretty involved
		if the value is an array. So the most efficient way then for the
		values that get reused many times is to call <code class="computeroutput">get()</code>, remember the result in a Perl
		variable, and then reuse that variable.
		</p><p>
		There is also a way to conveniently print a rows contents, usually for
		the debugging purposes:
		</p><pre class="programlisting">$result = $row-&gt;printP();</pre><a class="indexterm" name="id502128"></a><p>
		The name <code class="computeroutput">printP</code> is an artifact of implementation: it shows that this
		method is implemented in Perl and uses the default Perl conversions of
		values to strings. The <code class="computeroutput">uint8[]</code> arrays are printed directly as strings.
		The result is a sequence of <code class="computeroutput">name="value"</code> or 
		<code class="computeroutput">name=["value", "value", "value"]</code> 
		for all the non-NULL fields. The backslashes and double quotes
		inside the values are escaped by backslashes in Perl style. For
		example, reusing the row type above,
		</p><pre class="programlisting">$row = $rt1-&gt;makeRowArray('ab\ "cd"', [0, 0]);
print $row-&gt;printP(), "\n";</pre><p>
		will produce
		</p><pre class="programlisting">a="ab\\ \"cd\"" b=["0", "0"]</pre><p>
		It's possible to check quickly if all the fields of a row are NULL:
		</p><pre class="programlisting">$result = $row-&gt;isEmpty();</pre><p>
		It returns 1 if all the fields are NULL and 0 otherwise.
		</p><p>
		Finally, there is a deep debugging method:
		</p><pre class="programlisting">$result = $row-&gt;hexdump()</pre><p>
		That dumps the raw bytes of the row's binary format, and is useful only
		to debug the more weird issues.
		</p></div></div><div class="chapter" title="Chapter 6. Labels and Row Operations"><div class="titlepage"><div><div><h2 class="title"><a name="ch_LabelsRowops"></a>Chapter 6. Labels and Row Operations</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_Labels">6.1. Labels basics</a></span></dt><dt><span class="sect1"><a href="#sc_Label_construction">6.2. Label construction</a></span></dt><dt><span class="sect1"><a href="#sc_LabelOther">6.3. Other label methods</a></span></dt><dt><span class="sect1"><a href="#sc_Rowop">6.4. Row operations</a></span></dt><dt><span class="sect1"><a href="#sc_opcodes">6.5. Opcodes</a></span></dt></dl></div><div class="sect1" title="6.1. Labels basics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_Labels"></a>6.1. Labels basics</h2></div></div></div><p>
		In each CEP engine there are two kinds of logic: One is to get some
		request, look up some state, maybe update some state, and return the
		result. The other has to do with the maintenance of the state: make
		sure that when one part of the state is changed, the change propagates
		consistently through the rest of it. If we take a common RDBMS for an
		analog, the first kind would be like the ad-hoc queries, the second
		kind will be like the triggers. The CEP engines are very much like
		database engines driven by triggers, so the second kind tends to
		account for a lot of code.
		</p><p>
		The first kind of logic is often very nicely accommodated by the
		procedural logic. The second kind often (but not always) can benefit
		from a more relational, SQLy definition. However the SQLy definitions
		don't stay SQLy for long.  When every every SQL
		statement executes, it gets compiled first into the procedural form,
		and only then executes as the procedural code.
		</p><p>
		The Triceps approach is tilted toward the procedural execution. That is,
		the procedural definitions come out of the box, and then the high-level
		relational logic can be defined on top of them with the templates and
		code generators.
		</p><a class="indexterm" name="id490530"></a><p>
		These bits of code, especially where the first and second kind connect,
		need some way to pass the data and operations between them. In Triceps
		these connection points are called Labels.
		</p><a class="indexterm" name="id483857"></a><a class="indexterm" name="id491465"></a><p>
		The streaming data rows enter the procedural logic through a label.
		Each row causes one call on the label. From the functional standpoint
		they are the same as Coral8 Streams, as has been shown in
		<a class="xref" href="#sc_1950s" title="1.4. We're not in 1950s any more, or are we?">Section 1.4: &#8220;We're not in 1950s any more, or are we?&#8221; </a>.
		Except that in Triceps the labels receive not just
		rows but operations on rows, as in Aleri: a combination of a row and an
		operation code. 
		</p><p>
		They are named <span class="quote">&#8220;<span class="quote">labels</span>&#8221;</span> because Triceps has been built
		around the more procedural ideas, and when looked at from that side,
		the labels are targets of calls and GOTOs.
		</p><a class="indexterm" name="id481786"></a><a class="indexterm" name="id503339"></a><p>
		If the streaming model is defined as a data flow graph, each arrow in
		the graph is essentially a GOTO operation, and each node is a label.
		</p><p>
		A Triceps label is not quite a GOTO label, since the actual procedural
		control always returns back after executing the label's code. It can be
		thought of as a label of a function or procedure. But if the caller
		does nothing but immedially return after getting the control back, it
		works very much like a GOTO label.
		</p><p>
		Each label accepts operations on rows of a certain type.
		</p><p>
		Each label belongs to a certain execution unit, so a label can be used
		only strictly inside one thread and can not be shared between threads.
		</p><p>
		Each label may have some code to execute when it receives a row
		operation. The labels without code can be useful too.
		</p><a class="indexterm" name="id465437"></a><a class="indexterm" name="id464659"></a><p>
		A Triceps model contains the straightforward code and the mode complex
		stateful elements, such as tables, aggregators, joiners (which may be
		implemented in C++ or in Perl, or created as user templates). These
		stateful elements would have some input labels, where the actions may
		be sent to them (and the actions may also be done as direct method
		calls), and output labels, where they would produce the indications of
		the changed state and/or responses to the queries. This is shown
		in the diagram in
		<a class="xref" href="#fig_label_chain" title="Figure 6.1. Stateful elements with chained labels.">Figure 6.1</a>.
		The output labels
		are typically the ones without code (<span class="quote">&#8220;<span class="quote">dummy labels</span>&#8221;</span>). They do nothing
		by themselves, but can pass the data to the other labels. This passing
		of data is achieved by <span class="emphasis"><em>chaining</em></span> the labels: when a label is
		called, it will first execute its own code (if it has any), and then
		call the same operation on whatever labels are chained from it. Which
		may have more labels chained from them in turn. So, to pass the data,
		chain the input label of the following element to the output label of
		the previous element.
		</p><div class="figure"><a name="fig_label_chain"></a><div class="figure-contents"><div><img src="label-000-chain.lowres.png" width="NaN" alt="Stateful elements with chained labels."></div></div><p class="title"><b>Figure 6.1. Stateful elements with chained labels.</b></p></div><br class="figure-break"><p>
		The make things clear, a label doesn't have to be a part of a stateful
		element. The labels absolutely can exist by themselves. It's just that
		the stateful elements can use the labels as their endpoints.
		</p></div><div class="sect1" title="6.2. Label construction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_Label_construction"></a>6.2. Label construction</h2></div></div></div><p>
		The execution unit provides methods to construct labels. A dummy label
		is constructed as:
		</p><a class="indexterm" name="id503815"></a><pre class="programlisting">$label = $unit-&gt;makeDummyLabel($rowType, "name");</pre><p>
		It takes as arguments the type of rows that the label will accept and
		the symbolic name of the label. As usual, the name can be any but for the ease of
		debugging it's better to give the same name as the label variable.
		</p><p>
		The label with Perl code is constructed as follows:
		</p><a class="indexterm" name="id503843"></a><pre class="programlisting">$label = $unit-&gt;makeLabel($rowType, "name", $clearSub,
  $execSub, @args);</pre><p>
		The row type and name arguments are the same as for the dummy label.
		The following two arguments provide the references to the Perl functions
		that perform the actions. 
		They can be specified as a function reference or a source code string, see
		<a class="xref" href="#sc_code" title="4.4. Code references and snippets">Section 4.4: &#8220;Code references and snippets&#8221; </a>. 
		<code class="computeroutput">$execSub</code> is the function that executes to
		handle the incoming rows. It gets the arguments:
		</p><pre class="programlisting">&amp;$execSub($label, $rowop, @args)</pre><p>
		Here <code class="computeroutput">$label</code> is this label, <code class="computeroutput">$rowop</code> is the row operation, and <code class="computeroutput">@args</code>
		are the same as extra arguments specified at the label creation.
		</p><a class="indexterm" name="id472349"></a><p>
		The row operation actually contains the label reference, so why pass it
		the second time? The reason lies in the chaining. The current label may
		be chained, possibly through multiple levels, to some original label,
		and the rowop will refer to that original label. The extra argument
		lets the code find the current label.
		</p><p>
		<code class="computeroutput">$clearSub</code> is the function that clears the label. It will be explained in the
		<a class="xref" href="#sc_memory_labels" title="8.2. Clearing of the labels">Section 8.2: &#8220;Clearing of the labels&#8221; </a>.
		Either of <code class="computeroutput">$execSub</code> and <code class="computeroutput">$clearSub</code> can be specified as <code class="computeroutput">undef</code>. Though
		a label with an undefined <code class="computeroutput">$execSub</code> makes the label useless for anything
		other than clearing. On an attempt to send data to it, it will complain that
		the label has been cleared.
		The undefined <code class="computeroutput">$clearSub</code> causes the function
		<code class="computeroutput">Triceps::clearArgs()</code> to be used as the default, which provides the
		correct reaction for most situations.
		</p><a class="indexterm" name="id472423"></a><p>
		There is a special convenience constructor for the labels that are used
		only for clearing an object (their usefulness is discussed in
		<a class="xref" href="#sc_memory_labels" title="8.2. Clearing of the labels">Section 8.2: &#8220;Clearing of the labels&#8221; </a>).
		</p><pre class="programlisting">$lb = $unit-&gt;makeClearingLabel("name", @args);</pre><p>
		The arguments would be the references to the objects that need clearing,
		usually the object's <code class="computeroutput">$self</code>. They will be cleared with
		<code class="computeroutput">Triceps::clearArgs()</code> when the label clearing gets called.
		</p></div><div class="sect1" title="6.3. Other label methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_LabelOther"></a>6.3. Other label methods</h2></div></div></div><p>
		The chaining of labels is done with the method:
		</p><pre class="programlisting">$label1-&gt;chain($label2);</pre><p>
		<code class="computeroutput">$label2</code> becomes chained to <code class="computeroutput">$label1</code>.
		A label can not be chained to itself, neither directly nor through
		other intermediate labels. The row types of the chained labels must be equal
		(this is more strict than for queueing up the row operations for labels,
		and might change one or the other way in the future).
		</p><p>
		When <code class="computeroutput">$label1</code> executes, its chained labels will normally
		be executed in the order they were chained. However sometines it's
		necessary to add a label to the chain later but have it called
		first. This is done with the method:
		</p><pre class="programlisting">$label1-&gt;chainFront($label2);</pre><p>
		It chains <code class="computeroutput">$label2</code> at the start of the chain. Of course,
		if more labels will be chained at the front afterwards, <code class="computeroutput">$label2</code>
		will be called only after them. But usually there is a need for only
		one such label, and it's usually connected to the FnReturn and Facet
		objects. For an example, see
		<a class="xref" href="#sc_mt_pipeline" title="16.3. Multithreaded pipeline">Section 16.3: &#8220;Multithreaded pipeline&#8221; </a>.
		</p><p>
		A label's chainings can be cleared with
		</p><pre class="programlisting">$label1-&gt;clearChained();</pre><p>
		It returns nothing, and clears the chainings from this label. There is
		no way to unchain only some selected labels.
		</p><p>
		To check if there are any labels chained from this one, use:
		</p><pre class="programlisting">$result = $label-&gt;hasChained();</pre><p>
		The same check can be done with
		</p><pre class="programlisting">@chain = $label-&gt;getChain();

if ($#chain &gt;= 0) { ... }</pre><p>
		but <code class="computeroutput">hasChained()</code> is more efficient since it doesn't have
		to construct that intermediate array.
		</p><p>
		There is also a convenience method that
		creates a new label by chaining it from an existing label:
		</p><pre class="programlisting">$label2 = $label1-&gt;makeChained($name, $subClear, $subExec, @args);</pre><p>
		The arguments are very much the same as in <code class="computeroutput">Unit::makeLabel()</code>, only there is
		no need to specify the row type for the new label (nor obviously the
		Unit), these are taken from the original label. It's really a wrapper
		that finds the unit and row type from <code class="computeroutput">label1</code>, makes a new
		label, and then chains it off <code class="computeroutput">label1</code>.
		</p><p>
		The whole label can be cleared with
		</p><pre class="programlisting">$label-&gt;clear();</pre><p>
		This is fully equivalent to what happens when an execution unit clears
		the labels: it calls the clear function (if any) and clears the
		chainings. Note that the labels that used to be chained from this one
		do not get cleared themselves, they're only unchained from this one.
		To check whether the label has been already cleared use:
		</p><pre class="programlisting">$result = $label-&gt;isCleared();</pre><p>
		Labels have the usual way of comparing the references:
		</p><pre class="programlisting">$label1-&gt;same($label2)</pre><p>
		returns true if both references point to the same label object.
		</p><p>
		The labels introspection can be done with the methods:
		</p><pre class="programlisting">$rowType = $label-&gt;getType();
$rowType = $label-&gt;getRowType();
$unit = $label-&gt;getUnit();
$name = $label-&gt;getName();
@chainedLabels = $label-&gt;getChain();
$execSubRef = $label-&gt;getCode();</pre><p>
		The methods <code class="computeroutput">getType()</code> and <code class="computeroutput">getRowType()</code> are the same, they both return
		the row type of the label. <code class="computeroutput">getType()</code> is shorter, which looked convenient
		for a while, but <code class="computeroutput">getRowType()</code> has the name consistent with the
		rest of the classes. This consistency comes useful when passing the objects
		of various types to the same methods, using the Perl's name-based
		polymorphism. For now both of them are present, but <code class="computeroutput">getType()</code> will
		likely be deprecated in the future.
		</p><p>
		If the label has been cleared, <code class="computeroutput">getUnit()</code> will return an
		<code class="computeroutput">undef</code>. <code class="computeroutput">getChain()</code> returns an array of references
		to the chained labels. <code class="computeroutput">getCode()</code> is actually half-done
		because it returns just the Perl function reference to the execution
		handler but not its arguments, nor reference to the clearing function.
		It will be changed in the future to fix these issues.
		<code class="computeroutput">getCode()</code> is not applicable to the dummy labels, and would
		return an <code class="computeroutput">undef</code> for them.
		</p><p>
		The labels actually exist in multiple varieties. The underlying common
		denominator is the C++ class Label. This class may be extended and the
		resulting labels embedded into the C++ objects. These labels can be
		accesses and controlled from Perl but their logic is hardcoded in their
		objects and is not directly visible from Perl. The dummy labels are
		a subclass of labels in general, and can be constructed directly
		from Perl. Another subclass is the labels with the Perl handlers.
		They can be constructed from Perl, and really only from Perl. The C++
		code can access and control them, in a symmetrical relation. The
		method <code class="computeroutput">getCode()</code> has meaning only on these Perl labels.
		Finally, the clearing labels also get created from Perl, and fundamentally
		are Perl labels with many settings hardcoded in the constructor.
		<code class="computeroutput">getCode()</code> can be used on them too but since they have
		no handler code, it would always return <code class="computeroutput">undef</code>.
		</p><p>
		There is also a way to change a label's name:
		</p><pre class="programlisting">$label-&gt;setName($name);</pre><p>
		It returns nothing, and there is probably no reason to call it. It will
		likely be removed in the future.
		</p><p>
		The label also provides the constructor methods for the row operations, 
		which are described below.
		</p><p>
		And for completeness I'll mention the methods used to mark the
		label as non-reentrant and to read this mark back. They will be described
		in detail in 
		<a class="xref" href="#sc_sched_recursion" title="7.13. Recursion control">Section 7.13: &#8220;Recursion control&#8221; </a>.
		</p><pre class="programlisting">$label-&gt;setNonReentrant();
$val = $label-&gt;isNonReentrant();</pre></div><div class="sect1" title="6.4. Row operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_Rowop"></a>6.4. Row operations</h2></div></div></div><a class="indexterm" name="id506418"></a><a class="indexterm" name="id506428"></a><p>
		A row operation (also known as rowop) in Triceps is an unit of work for
		a label. It's always destined for a particular label (which could also
		pass the rowop to its chained labels), and has a row to process and an opcode.
		The opcodes will be described momentarily in the
		<a class="xref" href="#sc_opcodes" title="6.5. Opcodes">Section 6.5: &#8220;Opcodes&#8221; </a>.
		</p><p>
		A row operation is constructed as:
		</p><pre class="programlisting">$rowop = $label-&gt;makeRowop($opcode, $row);</pre><p>
		The opcode may be specified an integer or as a string.
		Historically, there is also an optional extra argument for the enqueuing
		mode but it's already obsolete, so I don't show it here.
		</p><p>
		Since the labels are single-threaded, the rowops are single-threaded
		too. The rowops are immutable, just as the rows are. It's possible
		to keep a rowop around and call it over and over again.
		</p><p>
		A rowop can be created from a bunch of fields in an array or hash form 
		in two steps:
		</p><pre class="programlisting">$rowop = $label-&gt;makeRowop($opcode, $rt-&gt;makeRowHash(
  $fieldName =&gt; $fieldValue, ...));
$rowop = $label-&gt;makeRowop($opcode, $rt-&gt;makeRowArray(@fields));</pre><p>
		Since this kind of creation happens fairly often, writing out these
		calls every time becomes tedious. The Label provides the combined
		constructors to make life easier:
		</p><pre class="programlisting">$rowop = $label-&gt;makeRowopHash($opcode, $fieldName =&gt; $fieldValue, ...);
$rowop = $label-&gt;makeRowopArray($opcode, @fields);</pre><a class="indexterm" name="id506494"></a><p>
		Note that they don't need the row type argument any more,
		because the label knows the row type and provides it.
		Internally these methods are currently implemented in Perl, and just wrap
		the two calls into one.  In the future they will be rewritten
		in C++ for greater efficiency.
		</p><p>
		There also are the methods that create a rowop and immediately
		call it. They will be described with the execution unit.
		</p><p>
		A copy of rowop (not just another reference but an honest separate
		copied object) can be created with:
		</p><pre class="programlisting">$rowop2 = $rowop1-&gt;copy();</pre><p>
		However, since the rowops are immutable, a reference is just as good as
		a copy. This method is historic and will likely be removed or modified.
		</p><p>
		A more interesting operation is the rowop adoption:
		it is a way to pass the row and opcode from one rowop to another new
		one, with a different label.
		</p><a class="indexterm" name="id506534"></a><pre class="programlisting">$rowop2 = $label-&gt;adopt($rowop1);</pre><p>
		It is very convenient for building the label handlers that pass the
		rowops to the other labels unchanged. For example, a label
		that filters the data and passes it to the next label, can be implemented as
		follows:
		</p><pre class="programlisting">my $lab1 = $unit-&gt;makeLabel($rt1, "lab1", undef, sub {
  my ($label, $rowop) = @_;
  if ($rowop-&gt;getRow()-&gt;get("a") &gt; 10) {
    $unit-&gt;call($lab2-&gt;adopt($rowop));
  }
});</pre><p>
		This code doesn't even look at the opcode in the rowop, it just
		passes it through and lets the next label worry about it.
		The functionality of <code class="computeroutput">adopt()</code> also can be implemented with
		</p><pre class="programlisting">$rowop2 = $label-&gt;makeRowop($rowop1-&gt;getOpcode(), $rowop1-&gt;getRow());</pre><p>
		But <code class="computeroutput">adopt()</code> is easier to call and also more efficient,
		because less of the intermediate data surfaces from the C++ level to
		the Perl level.
		</p><p>
		The references to rowops can be compared as usual:
		</p><pre class="programlisting">$rowop1-&gt;same($rowop2)</pre><p>
		returns true if both point to the same rowop object.
		</p><p>
		The rowop data can be extracted back:
		</p><pre class="programlisting">$label = $rowop-&gt;getLabel();
$opcode = $rowop-&gt;getOpcode();
$row = $rowop-&gt;getRow();</pre><p>
		A Rowop can be printed (usually for debugging purposes) with
		</p><pre class="programlisting">$string = $rowop-&gt;printP();
$string = $rowop-&gt;printP($name);</pre><p>
		Just as with a row, the method <code class="computeroutput">printP()</code> is implemented in Perl. In
		the future a <code class="computeroutput">print()</code> done right in C++ may be added, but for now I try
		to keep all the interpretation of the data on the Perl side. Even though
		<code class="computeroutput">printP()</code> is implemented in Perl, it can print the rowops
		for any kinds of labels.  The
		following example gives an idea of the format in which the rowops get
		printed:
		</p><pre class="programlisting">$lb = $unit-&gt;makeDummyLabel($rt, "lb");
$rowop = $lb-&gt;makeRowop(&amp;Triceps::OP_INSERT, $row);
print $rowop-&gt;printP(), "\n";</pre><p>
		would produce
		</p><pre class="programlisting">lb OP_INSERT a="123" b="456" c="3000000000000000" d="3.14" e="text"</pre><p>
		The row contents is printed through <code class="computeroutput">Row::printP()</code>, so it has
		the same format.
		</p><p>
		The optional argument allows to override the name of the label
		printed. For example, if in the example above the last line were
		to be replaced with
		</p><pre class="programlisting">print $rowop-&gt;printP("OtherLabel"), "\n";</pre><p>
		the result will become:
		</p><pre class="programlisting">OtherLabel OP_INSERT a="123" b="456" c="3000000000000000" d="3.14" e="text"</pre><p>
		It makes the printing of rowops in the chained
		labels more convenient. A chained label's execution handler receives
		the original unchanged rowop that refers to the first label in the
		chain. So when it gets printed, it will print the name of the first
		label in the chain, which might be very surprising. The explicit
		argument allows to override it to the name of the chained label (or to
		any other value).
		</p></div><div class="sect1" title="6.5. Opcodes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_opcodes"></a>6.5. Opcodes</h2></div></div></div><p>
		The defined opcodes are:
		</p><a class="indexterm" name="id506721"></a><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">&amp;Triceps::OP_NOP</code> or <code class="computeroutput">"OP_NOP"</code></li><li class="listitem"><code class="computeroutput">&amp;Triceps::OP_INSERT</code> or <code class="computeroutput">"OP_INSERT"</code></li><li class="listitem"><code class="computeroutput">&amp;Triceps::OP_DELETE</code> or <code class="computeroutput">"OP_DELETE"</code></li></ul></div><p>
		The meaning is straightforward: NOP does nothing, INSERT inserts
		a row, DELETE deletes a row. There is no opcode to replace or
		update a row. The updates are done as two separate operations: first
		DELETE the old value then INSERT the new value. The order is
		important: the old value has to be deleted before inserting the new one.
		But there is no requirement that these operations must go one
		after another. If you want to update ten rows, you can first
		delete all ten and then insert the new ten. In the
		normal processing the end result will be the same, even though
		it might go through some different intermediate states.
		It's a good idea to write your models to follow the same principle.
		</p><p>
		Internally an opcode is always represented as an integer constant.
		The same constant value can be obtained by calling the functions
		<code class="computeroutput">&amp;Triceps::OP_*</code>. However when constructing the rowops,
		you can also use the string literals <code class="computeroutput">"OP_*"</code> with
		the same result, they will be automatically transtaled to the integers. 
		In fact, the string literal form is slightly
		faster (unless you save the result of the function in a variable
		and then use the integer value from that variable for the
		repeated construction).
		</p><p>
		But when you get the opcodes back from rowops, they are always
		returned as integers. Triceps provides functions that convert
		the opcodes between the integer and string constants:
		</p><a class="indexterm" name="id506815"></a><pre class="programlisting">$opcode = &amp;Triceps::stringOpcode($opcodeName);
$opcodeName = &amp;Triceps::opcodeString($opcode);</pre><p>
		They come handy for all kinds of print-outs. If you pass the invalid
		values, the conversion to integers will return an <code class="computeroutput">undef</code>.
		</p><p>
		The conversion of the invalid integers to strings is more interesting.
		And by the way, you can pass the invalid integer opcodes to the
		rowop construction too, and they won't be caught. The way they
		will be processed is a bit of a lottery. The proper integer values
		are actually bitmasks, and they are nicely formatted to make sense.
		The invalid values would make some random bitmasks, and they will
		get processed in some unpredictable way. When converting an invalid
		integer to a string, <code class="computeroutput">opcodeString</code> tries to predict and 
		show this way in a set of letters <code class="computeroutput">I</code> and <code class="computeroutput">D</code>
		in square brackets, for INSERT and DELETE flags. If both are present, 
		usually the INSERT flag wins over the DELETE in the processing. 
		If none are present, it's a NOP.
		</p><p>
		In the normal
		processing you don't normally read the opcode and then compare
		it with different values. Instead you check the meaning of the
		opcode (that is internally a bitmask) directly with the rowop methods:
		</p><pre class="programlisting">$rowop-&gt;isNop()
$rowop-&gt;isInsert()
$rowop-&gt;isDelete()</pre><p>
		The typical idiom for the label's handler function is:
		</p><pre class="programlisting">if ($rowop-&gt;isInsert()) {
  # handle the insert logic ...
} elsif($rowop-&gt;isDelete()) {
  # handle the delete logic...
}</pre><p>
		The NOPs get silently ignored in this idiom, as they should be.
		Generally there is no point in creating the rowops with the <code class="computeroutput">OP_NOP</code> opcode,
		unless you want to use them for some weird logic.
		</p><p>
		The main Triceps package also provides functions to check the integer
		opcode values directly:
		</p><pre class="programlisting">Triceps::isNop($opcode)
Triceps::isInsert($opcode)
Triceps::isDelete($opcode)</pre><p>
		The same-named methods of Rowop are just the more convenient and
		efficient way to say
		</p><pre class="programlisting">Triceps::isNop($rowop-&gt;getOpcode())
Triceps::isInsert($rowop-&gt;getOpcode())
Triceps::isDelete($rowop-&gt;getOpcode())</pre><p>
		They handle the whole logic directly in C++ without an extra
		Perl conversion of the values.
		</p></div></div><div class="chapter" title="Chapter 7. Scheduling"><div class="titlepage"><div><div><h2 class="title"><a name="ch_scheduling"></a>Chapter 7. Scheduling</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_sched_intro">7.1. Introduction to the scheduling</a></span></dt><dt><span class="sect1"><a href="#sc_sched_compar">7.2. Comparative scheduling in the various CEP systems</a></span></dt><dt><span class="sect1"><a href="#sc_sched_unit_basics">7.3. Execution unit basics</a></span></dt><dt><span class="sect1"><a href="#sc_sched_tray">7.4. Trays</a></span></dt><dt><span class="sect1"><a href="#sc_sched_unwind">7.5. Error handling during the execution</a></span></dt><dt><span class="sect1"><a href="#sc_sched_no_bundling">7.6. No bundling</a></span></dt><dt><span class="sect1"><a href="#sc_sched_topo_loops">7.7. Topological loops</a></span></dt><dt><span class="sect1"><a href="#sc_sched_mainloop">7.8. The main loop</a></span></dt><dt><span class="sect1"><a href="#sc_sched_mainloop_socket">7.9. Main loop with a socket</a></span></dt><dt><span class="sect1"><a href="#sc_sched_tracing">7.10. Tracing the execution</a></span></dt><dt><span class="sect1"><a href="#sc_sched_detail">7.11. The gritty details of Triceps scheduling</a></span></dt><dt><span class="sect1"><a href="#sc_sched_loop">7.12. The gritty details of Triceps loop scheduling</a></span></dt><dt><span class="sect1"><a href="#sc_sched_recursion">7.13. Recursion control</a></span></dt></dl></div><div class="sect1" title="7.1. Introduction to the scheduling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_intro"></a>7.1. Introduction to the scheduling</h2></div></div></div><a class="indexterm" name="id472113"></a><a class="indexterm" name="id466686"></a><p>
		The scheduling determines, in which order the row operations are
		processed. If there are multiple operations available, which one
		should be processed first?  The scheduler keeps a queue of the operations
		and selects, which one to execute next.  This has a major effect on the
		logic of a CEP model.  
		</p><p>
		The Triceps approach to scheduling varied over time. Initially it
		looked like the purely procedural execution will be enough, with the
		order determined by the order of the procedural execution, and no
		explicit scheduling would be needed.  This has proved to have its own
		limitations, and thus the labels and their scheduling were born. Then
		it had turned out that the most typical thing to do with a label is to
		call it, again in the purely procedural order.
		</p><p>
		So for the most part you don't need to think about scheduling in Triceps.
		It just works as expected: when you call a label with a rowop, the call 
		returns after the label's work is all done.
		You can pretty much skip over the section
		with the low-level details altogether, just read the high-level sections. 
		The only important exception is the topological loops,
		where the rowops go repeatedly through a closed loop of the labels.
		But even for them the Perl API provides the high-level methods that
		take care of the details under the hood. And there is another way to 
		deal with the loops by using the streaming functions and procedural loops.
		</p><p>
		If you want to understand the loop scheduling better, skim over
		the sections with the details. You'd also need to do this if you plan
		to write the Triceps models in C++, since as of version 2.0 the C++ API 
		does not provide the high-level methods for building the loops yet.
		</p><p>
		Only if you are a serious CEP
		affictionado and want to understand how everything really works,
		you need to seriously read all the details.
		</p></div><div class="sect1" title="7.2. Comparative scheduling in the various CEP systems"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_compar"></a>7.2. Comparative scheduling in the various CEP systems</h2></div></div></div><a class="indexterm" name="id469263"></a><a class="indexterm" name="id461580"></a><a class="indexterm" name="id493377"></a><a class="indexterm" name="id504228"></a><p>
		There are multiple approaches to scheduling employed by different
		CEP systems. The classic Aleri CEP essentially didn't
		have any, except for the flow control between threads, because each its
		element is a separate thread. Coral8 had an intricate scheduling
		algorithm. Sybase R5.1 has the same logic as Coral8 inside each thread.
		StreamBase presumably also has some.
		</p><p>
		The scheduling logic in Triceps is different from the other CEP
		systems. The Coral8 logic looks at first like the only reasonable way
		to go, but could not be used in Triceps for three reasons: First, it's a trade
		secret, so it can't be simply reused. If I'd never seen it, that would
		not be an issue but I've worked on it and implemented its version for
		R5.1. Second, it relies on the properties that the compiler computes from
		the model graph analysis. Triceps has no compiler, and could not do
		this. Third, in reality it simply doesn't work that well. There are
		quite a few cases when the Coral8 scheduler comes up with a strange and
		troublesome execution order.
		</p></div><div class="sect1" title="7.3. Execution unit basics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_unit_basics"></a>7.3. Execution unit basics</h2></div></div></div><a class="indexterm" name="id465449"></a><p>
		An execution unit (often called simply <span class="quote">&#8220;<span class="quote">unit</span>&#8221;</span>) 
		keeps the state of the Triceps execution for one
		thread. Each thread running Triceps must have its own execution unit.
		</p><p>
		It's perfectly possible to have multiple execution units in the
		same thread. This is typically done when there is some permanent
		model plus some small intermittent sub-models created on demand to handle
		the user requests. These small sub-models would be created in the
		separate units, to be destroyed when their work is done. But this is
		a somewhat advanced usage, more examples will be shown in
		<a class="xref" href="#sc_strf_units" title="15.11. Streaming functions and unit boundaries">Section 15.11: &#8220;Streaming functions and unit boundaries&#8221; </a>.
		The TQL implementation also does this, as described in
		<a class="xref" href="#ch_tql" title="Chapter 17. TQL, Triceps Trivial Query Language">Chapter 17: &#8220;<i>TQL, Triceps Trivial Query Language</i>&#8221; </a>.
		</p><p>
		This section describes the basic methods of the units, the most
		often used ones. The more advanced ones are described in the following
		sections, and the full reference is located in
		<a class="xref" href="#sc_ref_unit" title="19.3. Unit and FrameMark reference">Section 19.3: &#8220;Unit and FrameMark reference&#8221; </a>.
		</p><p>
		A unit is created with:
		</p><pre class="programlisting">$myUnit = Triceps::Unit-&gt;new("name");</pre><p>
		The name argument will be used in the error messages, making easier
		to find, which exact part of the model is having troubles.
		By convention the name should be the same as the name of the unit variable
		(<span class="quote">&#8220;<span class="quote">myUnit</span>&#8221;</span> in this case). 
		</p><p>
		The name can be read back:
		</p><pre class="programlisting">$name = $myUnit-&gt;getName();</pre><p>
		Also, as usual, the variable <code class="computeroutput">$myUnit</code> here contains a reference to the
		actual unit object, and two references can be compared for whether they
		refer to the same object:
		</p><pre class="programlisting">$result = $unit1-&gt;same($unit2);</pre><p>
		A unit also keeps an empty row type (one with no fields), primarily for the
		creation of the clearing labels (discussed in
		<a class="xref" href="#sc_memory_labels" title="8.2. Clearing of the labels">Section 8.2: &#8220;Clearing of the labels&#8221; </a>
		and
		<a class="xref" href="#sc_Label_construction" title="6.2. Label construction">Section 6.2: &#8220;Label construction&#8221; </a>),
		but you can use it for any other purposes
		too. You can get it with the method:
		</p><pre class="programlisting">$rt = $unit-&gt;getEmptyRowType();</pre><p>
		Each unit has its own instance of an empty row type. Its purely for
		the conveniece of memory management, they are all equivalent.
		</p><p>
		The labels are called with:
		</p><pre class="programlisting">$unit-&gt;call($rowop, ...);</pre><p>
		The identity of the label being called is embedded in the row operation.
		The <span class="quote">&#8220;<span class="quote">...</span>&#8221;</span> shows that multiple rowops may be passed as arguments.
		So the real signature of this method is:
		</p><pre class="programlisting">$unit-&gt;call(@rowops);</pre><a class="indexterm" name="id507040"></a><p>
		But this way it looks more confusing. A call with multiple
		arguments produces the same result as doing multiple calls with 
		one argument at a time. Not only
		rowops but also <span class="emphasis"><em>trays</em></span> (to be discussed later) of rowops can be
		used as arguments.
		</p><p>
		There also are the convenience methods that create the rowops
		from the field values and immediately call them:
		</p><pre class="programlisting">$unit-&gt;makeHashCall($label, $opcode,
  $fieldName =&gt; $fieldValue, ...);
$unit-&gt;makeArrayCall($label, $opcode, @fieldValues);</pre><p>
		The methods for creation of labels have been already discussed in
		<a class="xref" href="#sc_Label_construction" title="6.2. Label construction">Section 6.2: &#8220;Label construction&#8221; </a>.
		Here is their recap along with the similar methods for creation of
		tables and trays that will be discussed later:
		</p><pre class="programlisting">$label = $unit-&gt;makeDummyLabel($rowType, "name");

$label = $unit-&gt;makeLabel($rowType, "name",
  $clearSub, $execSub, @args);

$label = $unit-&gt;makeClearingLabel("name", @args);

$table = $unit-&gt;makeTable($tableType, "name");

$tray = $unit-&gt;makeTray(@rowops);</pre><a class="indexterm" name="id507089"></a><a class="indexterm" name="id473760"></a><p>
		A special thing about the labels is that when a unit creates
		a label, it keeps a reference to it, for clearing. A label keeps a pointer
		back to the unit but not a reference (if you call <code class="computeroutput">getUnit()</code>
		on a label, the returned value becomes a reference). For a table
		or a tray, the unit doesn't keep a reference to them. Instead,
		they keep a reference to the unit. 
		The references are at the C++ level, not Perl level.
		</p><p>
		With the tables, the references can get
		pretty involved: A table has labels associated with it.
		When a table is created, it also creates these labels.
		The unit keeps references of these labels. The table also
		keeps references of these labels. The table keeps a reference
		of the unit. The labels 
		have pointers to the unit and the
		table but not references, to avoid the reference cycles.
		</p><p>
		See more on the memory management and label clearing in the
		<a class="xref" href="#ch_memory" title="Chapter 8. Memory Management">Chapter 8: &#8220;<i>Memory Management</i>&#8221; </a>.
		</p></div><div class="sect1" title="7.4. Trays"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_tray"></a>7.4. Trays</h2></div></div></div><p>
		The easiest way to store a sequence of rowops is to put them into the Perl arrays,
		like:
		</p><pre class="programlisting">my @ops = ($rowop1, $rowop2);
push @ops, $rowop3;</pre><a class="indexterm" name="id473821"></a><p>
		However the C++ internals of Triceps do not know about the Perl
		arrays. And some of them can work directly with the sequences of rowops. So
		Triceps defines an internal sort-of-equivalent of Perl array for
		rowops, called a <span class="emphasis"><em>Tray</em></span>.
		</p><a class="indexterm" name="id473840"></a><p>
		The trays have first been used to <span class="quote">&#8220;<span class="quote">catch</span>&#8221;</span> the side effects of
		operations on the stateful elements, so the name <span class="quote">&#8220;<span class="quote">tray</span>&#8221;</span> came from the
		metaphor <span class="quote">&#8220;<span class="quote">put a tray under it to catch the drippings</span>&#8221;</span>.
		The new and better approach for catching the results in a tray
		catches the results of streaming functions.
		</p><p>
		The trays get created as:
		</p><pre class="programlisting">$tray = $unit-&gt;makeTray(@rowops);</pre><p>
		A tray always stores rowops for only one unit. It can be only used in
		one thread. A tray can be used in all the calling/enqueueing methods,
		just like the direct rowops (the details of the enqueueing methods will be
		described later in 
		<a class="xref" href="#sc_sched_detail" title="7.11. The gritty details of Triceps scheduling">Section 7.11: &#8220;The gritty details of Triceps scheduling&#8221; </a>
		and in
		<a class="xref" href="#sc_ref_unit" title="19.3. Unit and FrameMark reference">Section 19.3: &#8220;Unit and FrameMark reference&#8221; </a>).
		</p><pre class="programlisting">$unit-&gt;call($tray);
$unit-&gt;fork($tray);
$unit-&gt;schedule($tray);
$unit-&gt;enqueue($mode, $tray);
$unit-&gt;loopAt($mark, $tray);</pre><p>
		Moreover, multiple trays may be passed, and the loose rowops and trays
		can be mixed in the arguments of these functions, for example:
		</p><pre class="programlisting">$unit-&gt;call($rowopStartPkg, $tray, $rowopEndPkg);</pre><a class="indexterm" name="id507776"></a><p>
		A tray may contain the rowops of any types
		mixed in any order. This is by design, and it's an important feature
		that allows to build the protocol blocks out of rowops and perform an
		orderly data exchange. This feature is an absolute necessity for proper
		inter-process and inter-thread communication.
		</p><a class="indexterm" name="id507792"></a><a class="indexterm" name="id507802"></a><a class="indexterm" name="id507812"></a><p>
		The ability to send the rows of multiple types through the same channel
		in order is a must, and its lack makes the communication with some
		other CEP systems exceedingly difficult. Coral8 supports only one
		stream per connection. Aleri (and I believe Sybase R5) allows to send
		multiple streams through the same connection but has no guarantees of
		order between them. I don't know about the others, check yourself.
		</p><p>
		To iterate on a tray in the Perl code, it can be converted to a Perl array:
		</p><pre class="programlisting">@array = $tray-&gt;toArray();</pre><p>
		The size of the tray (the count of rowops in it) can be found directly
		without a conversion, and the unit can be read back too:
		</p><pre class="programlisting">$size = $tray-&gt;size();
$traysUnit = $tray-&gt;getUnit();</pre><p>
		Another way to create a tray is by copying an existing one:
		</p><pre class="programlisting">$tray2 = $tray1-&gt;copy();</pre><p>
		This copies the contents (which is the references to the rowops) and
		does not create any ties between the trays. The copying is really just
		a more efficient way to do an equivalent of:
		</p><pre class="programlisting">$tray2 = $tray1-&gt;getUnit()-&gt;makeTray($tray1-&gt;toArray());</pre><p>
		The tray references can be compared for whether they point to the same
		tray object:
		</p><pre class="programlisting">$result = $tray1-&gt;same($tray2);</pre><p>
		The contents of a tray may be cleared. Which is more convenient and
		more efficient than discarding a tray and creating another one:
		</p><pre class="programlisting">$tray-&gt;clear();</pre><p>
		The data may be added to the back of a tray:
		</p><pre class="programlisting">$tray-&gt;push(@rowops);</pre><p>
		Multiple rowops can be pushed in a single call. There are no other
		Perl-like operations on a tray: it's either create from a set of
		rowops, push, or convert to a Perl array.
		</p><p>
		Note that the trays are mutable, unlike the rows and rowops. Multiple
		references to a tray will see the same contents. If a tray is changed
		through one reference, the others will see the changes too.
		</p></div><div class="sect1" title="7.5. Error handling during the execution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_unwind"></a>7.5. Error handling during the execution</h2></div></div></div><a class="indexterm" name="id507921"></a><p>
		The basics of error handling have been described in
		<a class="xref" href="#sc_confessions" title="4.2. Errors, deaths and confessions">Section 4.2: &#8220;Errors, deaths and confessions&#8221; </a>.
		Now let's look more in-depth.
		When the labels execute, they may produce errors in one of two ways:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		The Perl code in the label might die.
		</li><li class="listitem">
		The call topology might violate the rules.
		</li></ul></div><p>
		The rules are basically that by default you can't make the recursive calls.
		A label may not make calls directly or through other labels to itself.
		The idea is to catch the call sequences that are likely to go into 
		the deep recursion and overflow the stack. It catches them early,
		on the first attempt of recursion. If you need to do the recursion,
		the best way is to use instead
		<code class="computeroutput">schedule()</code> or <code class="computeroutput">loopAt()</code> or the streaming
		functions with trays. That way you avoid overrunning the stack.
		</p><p>
		It's also possible to relax the recursion checks by specifying
		higher limits for the recursion count and stack depth. 
		How to do it is described in
		<a class="xref" href="#sc_sched_recursion" title="7.13. Recursion control">Section 7.13: &#8220;Recursion control&#8221; </a>.
		It comes useful in some special cases, as described in
		<a class="xref" href="#sc_strf_recursion" title="15.9. Streaming functions and recursion">Section 15.9: &#8220;Streaming functions and recursion&#8221; </a>.
		However such higher limits best be avoided unless really needed.
		</p><p>
		What particular stack is meant here? The execution of Triceps in Perl has
		three stacks:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		The system stack used by the underlying Triceps C++ code and
		by the internal functions of the Perl interpreter.
		</li><li class="listitem">
		The Perl call stack, keeping the call history of the Perl code.
		</li><li class="listitem">
		The Triceps call stack, keeping the call history of the Triceps
		labels in a Unit.
		</li></ul></div><p>
		The answer is <span class="quote">&#8220;<span class="quote">all three of these stacks</span>&#8221;</span>.
		As the calls are made, frames are pushed onto all these stacks,
		logically intermingling.
		</p><a class="indexterm" name="id508018"></a><a class="indexterm" name="id508028"></a><a class="indexterm" name="id508038"></a><p>
		Whichever way the error is detected, it causes the stacks to be unwound,
		undoing the intermingling in the opposite order. 
		The Perl error messages from <code class="computeroutput">die</code> or <code class="computeroutput">confess</code>
		and the Triceps tracing (in the C++ code) of the rowop calls and label chainings get
		combined into a common stack trace as the stacks are being unwound. When the code gets back to
		Perl, the XS code triggers a <code class="computeroutput">confess</code> with the message containing the
		unwound stack trace up to this point. If that happens to be in the
		handler of another label, it continues the hybrid stack
		unwinding. If not caught by <code class="computeroutput">eval</code>, it keeps going to the topmost Triceps Unit
		<code class="computeroutput">call()</code> or <code class="computeroutput">drainFrame()</code> and causes the whole program to die,
		printing the stack trace. In a multithreaded Triceps model there is also
		a step of interrupting all the threads in the model, but in the end
		it still ends up dying and printing the stack trace along with the
		information, what thread caused it.
		Which is a reasonable reaction most of the time.
		</p><p>
		Remember, the root cause is a serious error that is likely to leave the
		model in an inconsistent state, and it should usually be considered
		fatal.  
		</p><p>
		If you want to catch the errors, nip them in the bud
		by wrapping your Perl code in <code class="computeroutput">eval</code>. Then you can handle
		the errors before they have a chance to propagate.
		</p><p>
		In case if the program runs multiple models (multiple Units, or
		multiple multithreaded Apps) in it, it can
		also wrap the outermost call in <code class="computeroutput">eval</code>, and discard just this
		one erroneous model while leaving the other models running.
		If the erroneous units get properly cleared, they will free
		their memory and cause no leaks.
		</p><p>
		What happens to the rowops that were
		enqueued in the Triceps stack frames when the stack gets unwound? They
		get thrown away. The memory gets collected thanks to the reference
		counting, but the rowops and their sequence order get thrown out
		of the stack.
		The reason is basically that there may be no catching of the
		errors until unwinding to the outermost call. The choice is to either
		throw away everything after the first error or keep trying to
		execute the following rowops, collecting the errors. And that
		might become a lot of errors. I've taken the choice of stopping
		as early as possible, because the state of the model will probably
		be corrupted anyway and nothing but garbage would be coming out
		(if anything would be coming at all and not be stuck in an
		endless loop).
		</p></div><div class="sect1" title="7.6. No bundling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_no_bundling"></a>7.6. No bundling</h2></div></div></div><a class="indexterm" name="id508146"></a><p>
		The most important principle of Triceps scheduling is: No Bundling.
		Every rowop is for itself. 
		</p><p>
		I've seen the most damage done by bundling in the Coral8/Sybase R4
		scheduling, so I'll refer to it when explaining the dangers of
		bundling.
		</p><p>
		What is a bundle? It's a set of records that go through the execution
		together. If you have a model consisting of two functional elements F1
		and F2 connected in a sequential fashion 
		</p><pre class="programlisting">F1-&gt;F2</pre><p>
		and a few loose records R1, R2, R3, the
		normal execution order without bundling will be:
		</p><pre class="programlisting">F1(R1), F2(R1), F1(R2), F2(R2), F1(R3), F2(R3)</pre><p>
		Each row goes through the whole model (a real simple one in this case)
		before the next one is touched. This allows F2 to take into
		accont the state of F1 exactly as it was right after processing
		the same record, without any interventions in between.
		</p><a class="indexterm" name="id508192"></a><p>
		Even though the trays in Triceps store multiple rowops, they are not
		bundles.  When a tray is called, it works exactly as if every rowop
		from it were called separately in order. The first rowop fully
		propagates, then the second one, and so on.  The ordered storage in the
		trays only provides the order for that future execution or for a manual
		iteration over the rowops.
		</p><p>
		If the same records are placed in a bundle (R1, R2, R3), the execution
		order will be different:
		</p><pre class="programlisting">F1(R1), F1(R2), F1(R3), F2(R1), F2(R2), F2(R3)</pre><p>
		The whole bundle goes through F1 before the rows go to F2.
		</p><a class="indexterm" name="id508222"></a><a class="indexterm" name="id508231"></a><p>
		That would not always be a problem, and even could be occasionally useful, if
		the bundles were always created explicitly. In the reality of Coral8/Sybase R4 scheduling,
		every time a statement produces multiple rows from a single one
		(think of a join that picks multiple rows from another side), it
		creates a bundle and messes up all the logic after it. Some logic gets
		affected so badly that a few statements in CCL (the Sybase modeling language),
		such as <span class="quote">&#8220;<span class="quote">ON UPDATE</span>&#8221;</span>, had to
		be designated to always ignore the bundles, otherwise they would not
		work at all. At my past work I wrote a CCL pattern for breaking up the bundles.
		It's rather heavyweight and thus could not be used all over the place
		but provides a generic solution for the most unpleasant cases.
		</p><p>
		Worse yet, the bundles may get created in Coral8 absolutely
		accidentally: if two rows happen to have the same timestamp, for all
		practical purposes they would act as a bundle. In the models that were
		designed without the appropriate guards, this leads to the time-based
		bugs that are hard to catch and debug. Writing these guards correctly
		is hard, and testing them is even harder. 
		</p><p>
		Another issue with bundles is that they make the large queries slower.
		Suppose you do a query from a window that returns a million
		rows. All of them will be collected in a bundle, then the
		bundle will be sent to the interface gateway that would build one huge
		protocol packet, which will then be sent to the client, which will
		receive the whole packet and then finally iterate on the rows in it.
		Assuming that nothing runs out of memory along the way, it will be a
		long time until the client sees the first row. Very, very
		annoying.
		</p><a class="indexterm" name="id508270"></a><p>
		The Aleri CEP also had its own version of bundles, called transactions, but a
		more smart one. Aleri always relied on the primary keys. The condition
		for a transaction is that it must never contain multiple modification
		for the same primary key. Since there are no execution order guarantees
		between the functional elements, in this respect the transactions work
		in the same way as loose records, only with a more efficient
		communication between threads. Still, if the primary key changes in an
		element (say, an aggregator), the condition does not propagate through
		it. Such elements have to internally collapse the outgoing transactions
		along the new key, adding overhead.
		</p></div><div class="sect1" title="7.7. Topological loops"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_topo_loops"></a>7.7. Topological loops</h2></div></div></div><a class="indexterm" name="id508299"></a><a class="indexterm" name="id508313"></a><p>
		The easiest and most efficient way to schedule the loops is to do it
		procedurally, something like this:
		</p><pre class="programlisting">foreach my $row (@rowset) {
  $unit-&gt;call($lbA-&gt;makeRowop(&amp;Triceps::OP_INSERT, $row));
}</pre><a class="indexterm" name="id508337"></a><a class="indexterm" name="id508347"></a><p>
		However it requires that all the rowops to loop over are known in
		advance. In some situations this might not be true, but instead
		the rowop entering a loop iteration gets produced by the previous
		iteration. These situations are better served by the topological
		loops, formed by connecting the labels in a loop as shown in
		<a class="xref" href="#fig_sched_loop" title="Figure 7.1. Labels forming a topological loop.">Figure 7.1</a>.
		</p><div class="figure"><a name="fig_sched_loop"></a><div class="figure-contents"><div><img src="label-010-loop.lowres.png" width="NaN" alt="Labels forming a topological loop."></div></div><p class="title"><b>Figure 7.1. Labels forming a topological loop.</b></p></div><br class="figure-break"><p>
		However if the labels are simplemindedly doing the calls through
		a topology like this, the loop becomes a recursion: each label
		ends up indirectly calling itself for the next iteration of the
		loop, which repeats the same thing again ang again. This arrangement
		would quickly use up the stack and crash, so Triceps normally
		prohibits the recursive calls.
		</p><p>
		There are two ways to get around that problem. The first one is
		to use the trays and streaming functions as described in
		<a class="xref" href="#sc_strf_loops" title="15.5. Streaming functions and loops">Section 15.5: &#8220;Streaming functions and loops&#8221; </a>.
		It might be the more powerful alternative of the two,
		however the concept of streaming functions takes a fair amount of explaining
		and thus is placed later in the manual.
		The second way is to use the
		more advanced scheduling capabilities of the
		Triceps units, which is described here.
		</p><p>
		The detailed explanation of
		how it all works is somewhat complicated, split into a separate
		section
		<a class="xref" href="#sc_sched_loop" title="7.12. The gritty details of Triceps loop scheduling">Section 7.12: &#8220;The gritty details of Triceps loop scheduling&#8221; </a>
		for those interested. But there are the easy methods that cover
		up all the complexity.
		</p><p>
		The first part is done by creating the first label of the loop
		(such as the label A in
		<a class="xref" href="#fig_sched_loop" title="Figure 7.1. Labels forming a topological loop.">Figure 7.1</a>)
		through a special wrapper. This can be done in one of two ways:
		</p><pre class="programlisting">my ($lbFirst, $mark) = $unit-&gt;makeLoopHead($rowType, "name", $clearSub,
  $execSub, @args);
my ($lbFirst, $mark) = $unit-&gt;makeLoopAround("name", $lbToWrap);</pre><p>
		<code class="computeroutput">makeLoopHead()</code> is the way to use if you're creating a new Perl
		label to be the first one in the loop. It has the exact same arguments
		as <code class="computeroutput">makeLabel()</code>, which is described in
		<a class="xref" href="#sc_Label_construction" title="6.2. Label construction">Section 6.2: &#8220;Label construction&#8221; </a>.
		It will put an appropriate wrapper directly into the Perl code, that
		would do all the required magic before your code executes.
		</p><p>
		<code class="computeroutput">makeLoopAround()</code> is the way to use if you want to start the loop
		with some existing label (such as an input label of a table). It will
		create a new label that does the necessary magic, then chain its 
		argument label from the new one. Nothing really stops you from
		creating a Perl label manually and then wrapping it in 
		<code class="computeroutput">makeLoopAround()</code> but <code class="computeroutput">makeLoopHead()</code> produces
		a slightly more efficient code.
		</p><a class="indexterm" name="id508500"></a><p>
		Either way, two values are returned: the newly created label and
		a special FrameMark object.
		</p><p>
		When you send the rows into the loop, you absolutely must send them to
		this newly created label, <span class="bold"><strong>not</strong></span> directly to the underlying wrapped label!
		Otherwise the magic won't work.
		</p><p>
		The FrameMark is a special opaque object that is used to remember the state
		of the Triceps call stack at the start of the loop, to get back to it
		on the next iterations. It will be used when sending the rowops to the
		next iteration of the loop. Naturally, this object must be made accessible
		in the label handlers that do this sending.
		</p><p>
		The name argument will become the name of the created label. The FrameMark
		object also has a name, useful for diagnostics, that gets created by adding
		a suffix to the argument: <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>name</em></span>.mark</span>&#8221;</span>.
		</p><p>
		The second part, whenever you need to send a rowop back to the start of the loop,
		such as in the label C in 
		<a class="xref" href="#fig_sched_loop" title="Figure 7.1. Labels forming a topological loop.">Figure 7.1</a>,
		don't call it but use a special method:
		</p><pre class="programlisting">$unit-&gt;loopAt($mark, @rowops_or_trays);</pre><p>
		This will remember this rowop for the future. When the processing of the
		current iteration is all done, the scheduler in the unit will pick up
		the next remembered looped rowop and will feed it into the next iteration,
		until there are no more remembered rowops.  Only after that will the
		first call of the first label in the loop return to its caller.
		In 
		<a class="xref" href="#fig_sched_loop" title="Figure 7.1. Labels forming a topological loop.">Figure 7.1</a>
		the said caller will be the label X.
		</p><p>
		The rowops sent back must always be for the label <code class="computeroutput">$lbFirst</code>, returned
		by the <code class="computeroutput">makeLoop*()</code>.
		</p><p>
		It's perfectly fine to send multiple rowops back from a single iteration
		of the loop, each of these rowops will be processed in its own iteration
		in the order they were sent.
		</p><p>
		It's also perfectly fine to have the nested loops, as long as each loop
		uses its own frame mark object and starts from a separate label (add an
		empty label if needed).
		</p><p>
		There also are the convenience methods that create a rowop and
		loop it back in one go, just like <code class="computeroutput">makeHashCall()/makeArrayCall()</code>:
		</p><pre class="programlisting">$unit-&gt;makeHashLoopAt($mark, $lbFirst, $opcode,
  $fieldName =&gt; $fieldValue, ...);
$unit-&gt;makeArrayLoopAt($mark, $lbFirst, $opcode, @fieldValues);</pre><p>
		Now with all this knowledge let's write an example. It will compute
		the Fibonacci numbers.
		It's a real overcomplicated and perverse way of
		calculating the Fibonacci numbers. But it also is a great 
		fit to the type of problems that get solved with the
		topological loop, one of a simple kind.
		</p><a class="indexterm" name="id508623"></a><p>
		First, a quick reminder of what is a Fibonacci number.
		Historically it's a solution to the problem of breeding
		the spherical rabbits in a vacuum. But in the mathematical
		reality it's the sequence of numbers where each number
		is a sum of the two previous ones. Two initial elements
		are defined to be equal to 1, and it goes from there:
		</p><p>
		F<sub><span class="emphasis"><em>i</em></span></sub> = F<sub><span class="emphasis"><em>i</em></span>-1</sub> + F<sub><span class="emphasis"><em>i</em></span>-2</sub>
		</p><p>
		F<sub>1</sub> = 1; F<sub>2</sub> = 1
		</p><p>
		The Fibonacci numbers are often used as an example of recursive
		computations in the beginner's books on programming. The computation
		of the <span class="emphasis"><em>n</em></span>-th Fibonacci number is usually shown like this:
		</p><pre class="programlisting">sub fib1 # ($n)
{
  my $n = shift;
  if ($n &lt;= 2) {
    return 1;
  } else {
    return &amp;fib1($n-1) + &amp;fib1($n-2);
  }
}</pre><p>
		However that's not a good way to compute in the real world.
		When a function calls itself recursively once, its complexity
		is linear, O(<span class="emphasis"><em>n</em></span>). When a function calls itself twice or more,
		its complexity becomes exponential, O(e<sup><span class="emphasis"><em>n</em></span></sup>).
		At first you might think that it's only quadratic O(<span class="emphasis"><em>n</em></span><sup>2</sup>)
		because it forks two ways on each step. But these two ways keep forking
		and forking on each step, and it compounds to exponential. Which is
		a real bad thing.
		</p><p>
		To think of it, it's a huge waste, since the (<span class="emphasis"><em>n</em></span>-2)-th
		number is calculated anyway for the (<span class="emphasis"><em>n</em></span>-1)-th number.
		Why calculate it separately the second time? We could as well have saved
		and reused it. The Lisp people have figured this
		out a long time ago, and the Lisp books (if you can read Finnish or
		Russian, [<a href="#Hyvonen86" class="biblioref" title="[Hyvonen86]">Hyvonen86</a>] is a classical one)
		are full of examples that
		do exactly that. However I'm too lazy to explain how they work, so we're
		going to skip it together with the conversion of a tail recursion
		into a loop and get directly to the loop version. I find the loop
		version more natural and easier to write than a recursion anyway.
		</p><pre class="programlisting">sub fibStep2 # ($prev, $preprev)
{
  return ($_[0] + $_[1], $_[0]);
}

sub fib2 # ($n)
{
  my $n = shift;
  my @prev = (1, 0); # n and n-1

  while ($n &gt; 1) {
    @prev = &amp;fibStep2(@prev);
    $n--;
  }
  return $prev[0];
}</pre><p>
		The split into two functions is not mandatory for the loop
		version, it just does the clean separation of the loop counter
		logic and of the computation of the next step of the function.
		(But for the recursion version if would be mandatory).
		</p><p>
		I'm going to take this procedural loop version and transform
		it into a topological loop. It actually happens to be a real
		good match for the topological loop. In a topological loop
		a record keeps traveling through it and being transformed
		until it satisfies the loop exit condition. Here
		<code class="computeroutput">@prev</code> is the record contents, and the iteration count
		will be added to them to keep track of the exit condition.
		</p><pre class="programlisting">$uFib = Triceps::Unit-&gt;new("uFib");

my $rtFib = Triceps::RowType-&gt;new(
  iter =&gt; "int32", # iteration number
  cur =&gt; "int64", # current number
  prev =&gt; "int64", # previous number
);

my $lbPrint = $uFib-&gt;makeLabel($rtFib, "Print", undef, sub {
  print($_[1]-&gt;getRow()-&gt;get("cur"));
});

my $lbCompute; # will fill in later

my ($lbNext, $markFib) = $uFib-&gt;makeLoopHead(
  $rtFib, "Fib", undef, sub {
    my $iter = $_[1]-&gt;getRow()-&gt;get("iter");
    if ($iter &lt;= 1) {
      $uFib-&gt;call($lbPrint-&gt;adopt($_[1]));
    } else {
      $uFib-&gt;call($lbCompute-&gt;adopt($_[1]));
    }
  }
);

$lbCompute = $uFib-&gt;makeLabel($rtFib, "Compute", undef, sub {
  my $row = $_[1]-&gt;getRow();
  my $cur = $row-&gt;get("cur");
  $uFib-&gt;makeHashLoopAt($markFib, $lbNext, $_[1]-&gt;getOpcode(),
    iter =&gt; $row-&gt;get("iter") - 1,
    cur =&gt; $cur + $row-&gt;get("prev"),
    prev =&gt; $cur,
  );
});

my $lbMain = $uFib-&gt;makeLabel($rtFib, "Main", undef, sub {
  my $row = $_[1]-&gt;getRow();
  $uFib-&gt;makeHashCall($lbNext, $_[1]-&gt;getOpcode(),
    iter =&gt; $row-&gt;get("iter"),
    cur =&gt; 1,
    prev =&gt; 0,
  );
  print(" is Fibonacci number ", $row-&gt;get("iter"), "\n");
});

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/);
  $uFib-&gt;makeArrayCall($lbMain, @data);
  $uFib-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		You can see that it has grown quite a bit. That's why the procedural
		loops are generally a better idea. However if the computation involves
		a lot of the SQLy logic, the topological loops are still beneficial.
		</p><p>
		The main loop reads the CSV lines with opcodes (which aren't
		really used here, just passed through and then thrown away
		before printing) and calls <code class="computeroutput">$lbMain</code>. Here is an example
		of an input and output as they would intermix if the input
		was typed from the keyboard. As in the rest of this manual,
		the input lines are shown in bold.
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1</strong></span>
1 is a Fibonacci number 1
<span class="bold"><strong>OP_DELETE,2</strong></span>
1 is a Fibonacci number 2
<span class="bold"><strong>OP_INSERT,5</strong></span>
5 is a Fibonacci number 5
<span class="bold"><strong>OP_INSERT,6</strong></span>
8 is a Fibonacci number 6</pre><p>
		The input lines contain the values only for the field <code class="computeroutput">iter</code>, 
		which intentionally happens to be the first field in the row type. The
		other fields will be reset anyway in <code class="computeroutput">$lbMain</code>, so they are left as NULL.
		</p><p>
		The point of <code class="computeroutput">$lbMain</code> is to call the loop begin label <code class="computeroutput">$lbBegin</code> and then
		print the message about which Fibonacci number was requested. The value
		of the computed number is printed at the end of the loop, so when the
		words <span class="quote">&#8220;<span class="quote">is a Fibonacci number</span>&#8221;</span> are printed after it, that demonstrates that the
		execution of <code class="computeroutput">$lbMain</code> continues only after the loop is completed.
		</p><p>
		Just to rub it in a bit more, <code class="computeroutput">$lbMain</code> itself doesn't get
		back the result of the computation, because
		the Triceps <code class="computeroutput">call()</code> has no way to return any results.
		The intermediate states circle through the loop until the computation
		is completed, and the results are forwarded out of the loop to
		<code class="computeroutput">$lbPrint()</code>. All this time <code class="computeroutput">$lbMain</code> sits and waits
		for its call to complete. After the execution gets back to <code class="computeroutput">$lbMain</code>,
		it knows that <code class="computeroutput">$lbPrint()</code> already ran and printed the result,
		so it prints more detail after it. Another option would be for the loop
		result label to put the result value into some static variable, letting
		<code class="computeroutput">$lbMain</code> read it and print the whole message in one statement.
		</p><p>
		The loop logic is split into two labels <code class="computeroutput">$lbNext</code> and <code class="computeroutput">$lbCompute</code> purely
		to show that it can be split like this. <code class="computeroutput">$lbNext</code> handles the loop termination
		condition, and <code class="computeroutput">$lbCompute</code> does essentially the work of <code class="computeroutput">fibStep2()</code>. After
		the loop terminates, it passes the result row to <code class="computeroutput">$lbPrint</code> for the priniting
		of the value. 
		</p><p>
		When the code for <code class="computeroutput">$lbNext</code> is created, it contains the call of <code class="computeroutput">$lbCompute</code>.
		However the label <code class="computeroutput">$lbCompute</code> has not been created at this time yet! Not a problem,
		creating in advance an empty variable <code class="computeroutput">$lbCompute</code> is enough. The closure in <code class="computeroutput">$lbNext</code> will keep
		a reference to that variable, and the variable will be filled with the reference
		to the label later (but before the main loop executes).
		</p><p>
		And here is the version with <code class="computeroutput">makeLoopAround()</code>:
		</p><pre class="programlisting">my ($lbNext, $markFib); # will fill in later

$lbCompute = $uFib-&gt;makeLabel($rtFib, "Compute", undef, sub {
  my $row = $_[1]-&gt;getRow();
  my $cur = $row-&gt;get("cur");
  my $iter = $row-&gt;get("iter");
  if ($iter &lt;= 1) {
    $uFib-&gt;call($lbPrint-&gt;adopt($_[1]));
  } else {
    $uFib-&gt;makeHashLoopAt($markFib, $lbNext, $_[1]-&gt;getOpcode(),
      iter =&gt; $row-&gt;get("iter") - 1,
      cur =&gt; $cur + $row-&gt;get("prev"),
      prev =&gt; $cur,
    );
  }
});

($lbNext, $markFib) = $uFib-&gt;makeLoopAround(
  "Fib", $lbCompute
);</pre><p>
		The unit, row type, <code class="computeroutput">$lbPrint</code>, <code class="computeroutput">$lbMain</code> and 
		the main loop have stayed the same,
		so they are omitted from this example. The whole loop logic, both
		the termination condition and the computation step, have been 
		collected into one label <code class="computeroutput">$lbCompute</code>, to show that it can be done this
		way too. Then the loop head is created around <code class="computeroutput">$lbCompute</code>.
		</p><p>
		Since both <code class="computeroutput">$lbNext</code> and <code class="computeroutput">$markFib</code> need to be accessible
		inside <code class="computeroutput">$lbCompute</code>, they are created in advance and become
		visible in the closure scope. But the values are placed into these
		variables only after <code class="computeroutput">$lbCompute</code> is already defined (since
		<code class="computeroutput">$lbCompute</code> is an argument to build these values).
		</p><p>
		For the more curious, let's dig a little into what happens inside
		the <code class="computeroutput">makeLoop*()</code> methods. The same effect can be (and in C++ API
		has to be) achieved by calling the slightly lower-level methods.
		</p><p>
		The frame mark is created as follows:
		</p><pre class="programlisting">my $mark = Triceps::FrameMark-&gt;new("markName");</pre><p>
		It has to be remembered and then used in the first label of the
		loop to remember the state of the Triceps call stack:
		</p><pre class="programlisting">$unit-&gt;setMark($mark);</pre><p>
		This is normally the first thing done in the first label's handler.
		Yes, it will be remembered on every iteration of the loop. However
		the trick of the arrangement is that the call stack will be returned
		to the same state before each iteration, so on the second and following
		iterations this call will become a no-op.
		</p><p>
		The <code class="computeroutput">makeLoop*()</code> methods just do this for you, their
		implementation is fairly simple:
		</p><pre class="programlisting">sub makeLoopHead # ($self, $rt, $name, $clearSub, $execSub, @args)
{
  my ($self, $rt, $name, $clear, $exec, @args) = @_;

  my $mark = Triceps::FrameMark-&gt;new($name . ".mark");

  my $label = $self-&gt;makeLabel($rt, $name, $clear, sub {
    $self-&gt;setMark($mark);
    &amp;$exec(@_);
  }, @args);

  return ($label, $mark);
}

sub makeLoopAround # ($self, $name, $lbFirst)
{
  my ($self, $name, $lbFirst) = @_;
  my $rt = $lbFirst-&gt;getRowType();

  my $mark = Triceps::FrameMark-&gt;new($name . ".mark");

  my $lbWrap = $self-&gt;makeLabel($rt, $name, undef, sub {
    $self-&gt;setMark($mark);
  });
  $lbWrap-&gt;chain($lbFirst);

  return ($lbWrap, $mark);
}</pre><p>
		</p></div><div class="sect1" title="7.8. The main loop"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_mainloop"></a>7.8. The main loop</h2></div></div></div><a class="indexterm" name="id509157"></a><a class="indexterm" name="id509166"></a><p>
		The examples above had already shown the <span class="quote">&#8220;<span class="quote">main loop</span>&#8221;</span>, now
		let's look at it up close and discuss, what and why is it doing.
		The point of the main loop is to get the execution of the model going:
		accept some rowops from the outside world, shovel them into the
		Triceps model and process them, sending some result rowops back into
		the outside world. The sending back is done from inside the label handlers,
		so as long as the model runs, nothing else is needed for them.
		</p><p>
		By the time the program enters the main loop, the model should be all
		constructed and ready to run.
		The simplest main loop may look like this:
		</p><pre class="programlisting">while ($rowop = &amp;readRowop()) { # reads with some user-defined function
  $unit-&gt;call($rowop);
}</pre><p>
		This loop will read the incoming rowops as long as they're available,
		and call them. When <code class="computeroutput">$unit-&gt;call()</code> returns, the processing
		of the rowop in the model is done, including all the nested calls
		it caused.
		</p><p>
		However there is also a way to request the post-processing.
		It's somewhat similar to the Tcl concept of <span class="quote">&#8220;<span class="quote">idletasks</span>&#8221;</span>.
		An example of post-processing might be the flushing of the output
		buffer: the normal processing may collect a number of the output
		rowops in the buffer, and after everything is done, the buffer
		would be serialized and sent out.
		This post-processing needs to happen after the initial call returns.
		</p><p>
		The rowops are scheduled for post-processing with the method:
		</p><pre class="programlisting">$unit-&gt;schedule(@rowops_or_trays);</pre><a class="indexterm" name="id509234"></a><p>
		The model keeps a queue of the post-processing requests, and
		<code class="computeroutput">schedule()</code> adds to this queue.
		</p><p>
		However the simplest main loop shown above won't run the
		postprocessing. The queue would just keep growing.
		The postprocessing is done by the method
		</p><pre class="programlisting">$unit-&gt;drainFrame();</pre><p>
		It calls all the collected post-processing rowops in order.
		Their handling may keep scheduling more rowops, and the draining
		won't stop until all of them are processed. So they should not
		keep schduling more rowops forever, or the draining will never end.
		To handle the postprocessing properly, the main loop
		should be:
		</p><pre class="programlisting">while ($rowop = &amp;readRowop()) { # reads with some user-defined function
  $unit-&gt;call($rowop);
  $unit-&gt;drainFrame();
}</pre><p>
		You can even write it in a slightly different form:
		</p><pre class="programlisting">while ($rowop = &amp;readRowop()) { # reads with some user-defined function
  $unit-&gt;schedule($rowop);
  $unit-&gt;drainFrame();
}</pre><p>
		In this version the incoming rowop gets added to the queue, and then
		<code class="computeroutput">drainFrame()</code> calls it and any of its after-effects.
		Historically, this has been the intended way but then it had turned
		out that there is no point in first placing the incoming rowop
		onto the queue and then reading it from the queue, so calling
		it directly is slightly more efficient.
		</p><p>
		What if you decide in some label handler deep in the call tree
		that now is the good time to run the schduled rowops, similar
		to Tcl's <span class="quote">&#8220;<span class="quote">update idletasks</span>&#8221;</span> and call <code class="computeroutput">drainFrame()</code>?
		First of all, this is a very bad idea. The CEP models are usually
		very sensitive to the particular execution order, and inserting
		some random rowops in the middle tends to break things.
		Second, it won't work. It might execute <span class="emphasis"><em>some</em></span> rowops
		(which ones exactly is a long story, described in 
		<a class="xref" href="#sc_sched_detail" title="7.11. The gritty details of Triceps scheduling">Section 7.11: &#8220;The gritty details of Triceps scheduling&#8221; </a>)
		but none of the scheduled ones. In short, there is a reason to
		why the method is called <code class="computeroutput">drainFrame()</code>: the queue
		is organized in frames that are pushed stack-wise as the
		labels are called, and popped after the calls complete.
		<code class="computeroutput">DrainFrame()</code> drains the current frame. 
		<code class="computeroutput">Schedule()</code> puts the rowops onto the outermost frame
		that becomes accessible for draining only when the model is idle.
		</p><p>
		It is possible to find out whether there are the post-processing
		rowops scheduled and to run them one by one:
		</p><pre class="programlisting">while ($rowop = &amp;readRowop()) { # reads with some user-defined function
  $unit-&gt;call($rowop);
  while (!$unit-&gt;empty()) {
    $unit-&gt;callNext();
  }
}</pre><p>
		But of course a Perl loop is less efficient than the C++ loop
		in <code class="computeroutput">drainFrame()</code>.
		</p><p>
		Another straightforward idea is to read and execute the input
		as it comes in but delay the post-processing until the input
		becomes idle, exacly like the Tcl <span class="quote">&#8220;<span class="quote">idletasks</span>&#8221;</span> do.
		Somewhat like this:
		</p><pre class="programlisting">while (1) {
  if (!$unit-&gt;empty()) {
    $rowop = &amp;readRowopNoWait();
    if ($rowop) {
      $unit-&gt;call($rowop);
    } else {
      $unit-&gt;callNext();
    }
  } else {
    $rowop = &amp;readRowop();
    last if (!$rowop); # no more input
    $unit-&gt;call($rowop);
  }
}</pre><a class="indexterm" name="id509388"></a><p>
		It might even be useful sometimes but most of the time this turns
		out to be nothing but pain. The problem is that the exact order
		of execution becomes dependent on the timing of the data arrival,
		and the repeatable testing becomes next to impossible. It's
		another case of the bundling problem.
		</p><p>
		If the data arrives bundled with multiple rowops per packet,
		you have a choice whether to drain the frame after each rowop
		or after each packet. Which approach is better depends on the
		needs of the application and on whether the bundling of the
		rowops into packets is predictable and repeatable. If there are
		no defined boundaries between packets but the grouping is
		done simply by timeout or buffer size, such bundles are
		much better off being broken up into the individual rowops.
		</p><p>
		Now let's look at yet another aspect: the main loop may need
		to exit not only when there is no more input available
		but also after processing some requests. This can be done
		by adding a global stop flag, with label handlers setting it
		when they need to request the exit:
		</p><pre class="programlisting">$stop = 0;
while (!$stop &amp;&amp; ($rowop = &amp;readRowop())) {
  $unit-&gt;call($rowop);
  $unit-&gt;drainFrame();
}</pre><p>
		The examples in this manual tend to read the input data
		as plain text lines, convert them to rowops and execute.
		They are simple-minded, so they don't do any error checking,
		they would just fail randomly on the incorrect input.
		Their main loop usually goes along the
		following lines (with variations, to fit the examples, and as the
		main loop was refined over time):
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "lbCur") {
    $unit-&gt;makeArrayCall($lbCur, @data);
  } elsif ($type eq "lbPos") {
    $unit-&gt;makeArrayCall($lbPos, @data);
  }
  $unit-&gt;drainFrame();
}</pre><p>
		It reads the CSV (Comma-Separated Values) data from stdin,
		with the label name in the first column, the opcode in the
		second, and the data fields in the rest. Then dispatches
		according to the label.
		</p><p>
		Many variations are possible. It can be generalized to look up
		the labels from the hash:
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  $unit-&gt;makeArrayCall($labels{$type}, @data);
  $unit-&gt;drainFrame();
}</pre><p>
		Or call the procedural functions for some types:
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "lbCur") {
    $unit-&gt;makeArrayCall($lbCur, @data);
  } elsif ($type eq "lbPos") {
    $unit-&gt;makeArrayCall($lbPos, @data);
  } elsif ($type eq "clear") { # clear the previous day
    &amp;clearByDate($tPosition, @data);
  }
  $unit-&gt;drainFrame();
}</pre><p>
		Once again, none of these small examples are production-ready. 
		They have no error handling, and
		their parsing of the CSV data is primitive. It
		can't handle the quoting properly and can't parse the data
		with commas in it.
		A better ready way to parse the data will be provided in the future.
		For now, make your own.
		</p><p>
		The multithreaded models have their own special needs for the
		main loops. These will be discussed in 
		<a class="xref" href="#sc_mt_dynamic_server" title="16.6. Dynamic threads and fragments in a socket server">Section 16.6: &#8220;Dynamic threads and fragments in a socket server&#8221; </a>.
		</p></div><div class="sect1" title="7.9. Main loop with a socket"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_mainloop_socket"></a>7.9. Main loop with a socket</h2></div></div></div><a class="indexterm" name="id509498"></a><a class="indexterm" name="id509507"></a><a class="indexterm" name="id509521"></a><a class="indexterm" name="id509531"></a><p>
		A fairly typical situation is when a CEP model has to run in a daemon
		process, receiving and sending data through the network sockets.
		Here goes an example that does this. It's not production-ready, it's
		only of an example quality, and thus is located in an X-package.
		It still has the issue with the parsing of the CSV data, its
		handling of the errors is not well-tested, and it makes a few
		simplifying assumptions about the buffering (more on this below). 
		Other than that, it's a decent starting point.
		You can import this package as Triceps::X::SimpleServer,
		its source code found in 
		<code class="computeroutput">lib/Triceps/X/SimpleServer.pm</code>.
		</p><pre class="programlisting">package Triceps::X::SimpleServer;

sub CLONE_SKIP { 1; }

our $VERSION = 'v2.0.0';

use Carp;
use Errno qw(EINTR EAGAIN);
use IO::Poll qw(POLLIN POLLOUT POLLHUP);
use IO::Socket;
use IO::Socket::INET;

our @ISA = qw(Exporter);

our %EXPORT_TAGS = ( 'all' =&gt; [ qw(
  outBuf outCurBuf mainLoop startServer makeExitLabel makeServerOutLabel
) ] );

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

# For whatever reason, Linux signals SIGPIPE when writing on a closed
# socket (and it's not a pipe). So intercept it.
sub interceptSigPipe
{
  if (!$SIG{PIPE}) {
    $SIG{PIPE} = sub {};
  }
}

# and intercept SIGPIPE by default on import
&amp;interceptSigPipe();</pre><p>
		The package starts with the usual imports and exports. The CLONE_SKIP
		is required to make sure that the package interacts properly with
		the multithreading (any objects of this package won't be cloned
		into the new threads, and since the cloning tends to not work right
		anyway, I'm not sure why it's not the default).
		</p><p>
		Then it intercepts and ignores the SIGPIPE signal for the reasons
		described in the comment. It's very inconvenient to have your
		server die on a signal when the other side decides to drop the connection.
		Any server dealing with sockets on Linux must intercept SIGPIPE.
		Intercepting it with an empty handler looks like a better idea than
		ignoring it altogether, to make extra-sure that the writer won't
		be stuck in that write forever, but perhaps ignoring it would be just as good.
		The interception is placed into a function which gets called on the
		package import and can be called again later in case if something
		else resets the handler to default.
		</p><pre class="programlisting"># the socket and buffering control for the main loop;
# they are all indexed by a unique id
our %clients; # client sockets
our %inbufs; # input buffers, collecting the whole lines
our %outbufs; # output buffers
our $poll; # the poll object
our $cur_cli; # the id of the current client being processed
our $srv_exit; # exit when all the client connections are closed

# Writing to the output buffers. Will also trigger the polling to
# actually send the output data to the client's socket.
#
# @param id - the client id, as generated on the client connection
#        (if the client already disconnected, this call will
#        have no effect)
# @param string - the string to write
sub outBuf # ($id, $string)
{
  my $id = shift;
  my $line = shift;
  if (exists $clients{$id}) {
    $outbufs{$id} .= $line;
    # If there is anything to write on a buffer, stop reading from it.
    $poll-&gt;mask($clients{$id} =&gt; POLLOUT);
  }
}

# Write to the output buffer of the current client (as set in $cur_cli
# by the main loop).
#
# @param string - the string to write
sub outCurBuf # ($string)
{
  outBuf($cur_cli, @_);
}

# Close the client connection. This doesn't flush the ouput buffer,
# so it must be called only after the flush is done, or if the flush
# can not be done (such as, if the client has dropped the connection).
# It does delete all the client-related data.
#
# @param id - the client id, as generated on the client connection
# @param h - the socket handle of the client
sub _closeClient # ($id, $h)
{
  my $id = shift;
  my $h = shift;
  $poll-&gt;mask($h, 0);
  $h-&gt;close();
  delete $clients{$id}; # OK per Perl manual even when iterating
  delete $inbufs{$id};
  delete $outbufs{$id};
}

# The server main loop. Runs with the specified server socket.
# Accepts the connections from it, then polls the connections for
# input, reads the data in CSV and dispatches it using the labels hash.
#
# XXX Caveats:
# The way this works, if there is no '\n' before EOF,
# the last line won't be processed.
# Also, the whole output for all the input will be buffered
# before it can be sent.
#
# @param srvsock - the server socket handle
# @param labels - Reference to the label hash, that contains the
#        mappings used to dispatch the input, in either of formats:
#          name =&gt; label_object
#          name =&gt; code_reference
#        The input from the clients is parsed as CSV with the 1st field
#        containing the label name.  Then if the looked up dispatch is an
#        actual label, the rest of CSV fields are: the 2nd the opcode, and the rest
#        the data fields in the order of the label's row type. If the
#        looked up dispatch is a Perl sub reference, just the whole input
#        line is passed to it as an argument.
sub mainLoop # ($srvsock, $%labels)
{
  my $srvsock = shift;
  my $labels = shift;

  my $client_id = 0; # unique strings
  our $poll = IO::Poll-&gt;new();

  $srvsock-&gt;blocking(0);
  $poll-&gt;mask($srvsock =&gt; POLLIN);
  $srv_exit = 0;

  while(!$srv_exit || keys %clients != 0) {
    my $r = $poll-&gt;poll();
    confess "poll failed: $!" if ($r &lt; 0 &amp;&amp; ! $!{EAGAIN} &amp;&amp; ! $!{EINTR});

    if ($poll-&gt;events($srvsock)) {
      while(1) {
        my $client = $srvsock-&gt;accept();
        if (defined $client) {
          $client-&gt;blocking(0);
          $clients{++$client_id} = $client;
          # print("Accepted client $client_id\n");
          $poll-&gt;mask($client =&gt; (POLLIN|POLLHUP));
        } elsif($!{EAGAIN} || $!{EINTR}) {
          last;
        } else {
          confess "accept failed: $!";
        }
      }
    }

    my ($id, $h, $mask, $n, $s);
    while (($id, $h) = each %clients) {
      no warnings; # or in tests prints a lot of warnings about undefs

      $cur_cli = $id;
      $mask = $poll-&gt;events($h);
      if (($mask &amp; POLLHUP) &amp;&amp; !defined $outbufs{$id}) {
        # print("Lost client $client_id\n");
        _closeClient($id, $h);
        next;
      }
      if ($mask &amp; POLLOUT) {
        $s = $outbufs{$id};
        $n = $h-&gt;syswrite($s);
        if (defined $n) {
          if ($n &gt;= length($s)) {
            delete $outbufs{$id};
            # now can accept more input
            $poll-&gt;mask($h =&gt; (POLLIN|POLLHUP));
          } else {
            substr($outbufs{$id}, 0, $n) = '';
          }
        } elsif(! $!{EAGAIN} &amp;&amp; ! $!{EINTR}) {
          warn "write to client $id failed: $!";
          _closeClient($id, $h);
          next;
        }
      }
      if ($mask &amp; POLLIN) {
        $n = $h-&gt;sysread($s, 10000);
        if ($n == 0) {
          # print("Lost client $client_id\n");
          _closeClient($id, $h);
          next;
        } elsif ($n &gt; 0) {
          $inbufs{$id} .= $s;
        } elsif(! $!{EAGAIN} &amp;&amp; ! $!{EINTR}) {
          warn "read from client $id failed: $!";
          _closeClient($id, $h);
          next;
        }
      }
      # The way this works, if there is no '\n' before EOF,
      # the last line won't be processed.
      # Also, the whole output for all the input will be buffered
      # before it can be sent.
      while($inbufs{$id} =~ s/^(.*)\n//) {
        my $line = $1;
        chomp $line;
        {
          local $/ = "\r"; # take care of a possible CR-LF in this block
          chomp $line;
        }
        my @data = split(/,/, $line);
        my $lname = shift @data;
        my $label = $labels-&gt;{$lname};
        if (defined $label) {
          if (ref($label) eq 'CODE') {
            &amp;$label($line);
          } else {
            my $unit = $label-&gt;getUnit();
            confess "label '$lname' received from client $id has been cleared"
              unless defined $unit;
            eval {
              $unit-&gt;makeArrayCall($label, @data);
              $unit-&gt;drainFrame();
            };
            warn "input data error: $@\nfrom data: $line\n" if $@;
          }
        } else {
          warn "unknown label '$lname' received from client $id: $line "
        }
      }
    }
  }
}</pre><a class="indexterm" name="id509643"></a><p>
		The general outline follows the single-threaded multiplexing server described in
		[<a href="#Babkin10" class="biblioref" title="[Babkin10]">Babkin10</a>]. <code class="computeroutput">mainLoop()</code> gets the server socket
		and a dispatch table of labels or functions as its arguments. It then proceeds 
		with waiting for connections. 
		</p><p>
		Once a connection is received, it gets added to the set of
		active connections, to get included in the waiting for the input data.
		The input data is read as simplified CSV (no commas in the middle of values,
		and no way to reprsent the NULL values othar than for those omitted at the end
		of the line).
		It's expected to have the format:
		</p><pre class="programlisting"><span class="bold"><strong>name,opcode,data...</strong></span></pre><p>
		Such as:
		</p><pre class="programlisting"><span class="bold"><strong>window,OP_INSERT,5,AAA,30,30</strong></span>
<span class="bold"><strong>window.query,OP_INSERT</strong></span>
<span class="bold"><strong>exit,OP_NOP</strong></span></pre><p>
		The name part is then used to find a label in the dispatch table. The
		rest of the data is used to create a rowop for that label and execute it.
		As you can see, a row must contain at least the label name and opcode,
		or the execution will print an error message on the server's standard error
		and return no response to the client in the socket.
		</p><p>
		If the dispatch table contains not a label but a simple function reference
		for some name, the rest of the row is not even parsed, the function gets
		called without any arguments. If the exit is implemented as a function
		in the dispatch table, the following would also work:
		</p><pre class="programlisting"><span class="bold"><strong>exit</strong></span></pre><p>
		The data is sent back to the client through buffering. To send some data
		to a client, use 
		</p><pre class="programlisting">&amp;outBuf($id, $text);</pre><p>
		The <code class="computeroutput">$id</code> is the unique id of the client. How do you find, what is the id
		of the client you want to send the data to? When an input line is processed,
		the main loop knows, from what client it was received. It puts the id of that
		client in the global variable <code class="computeroutput">$Triceps::X::SimpleServer::cur_cli</code>. 
		You can take it from there and remember.
		If you want to reply to the current client, you don't need to bother yourself
		with the id at all, just call
		</p><pre class="programlisting">&amp;outCurBuf($text);</pre><p>
		If you remember an id for the future use, and the client disconnects before
		you call <code class="computeroutput">outBuf()</code>, the call will have no effect.
		In any case, if a client has disconnected, the further processing of its requests
		should usually be stopped, and thus checking if the client is still connected
		is a good idea anyway:
		</p><pre class="programlisting">if (exists $clients{$id}) {
  # ... prepare the data for it ...
  &amp;outBuf($id, $text);
} else {
  # ... stop sending the data to this client ...
}</pre><p>
		The client ids are not reused, so this check is
		always safe.
		</p><a class="indexterm" name="id509789"></a><a class="indexterm" name="id509799"></a><a class="indexterm" name="id523014"></a><a class="indexterm" name="id523022"></a><p>
		Once some output is buffered to send to a client, the further input from that
		client stops being accepted until the output buffer drains. But the processing
		in the Triceps unit scheduler keeps running until it runs out of things to do
		before it returns to the main loop. All this time the output buffer keeps
		collecting data without sending it to the client.  Also, the input
		buffer might happen to already contain multiple lines. Then all these lines
		will be processed before the data from the output buffer starts being sent
		to the client. If a request produces a large amount of data, all this data
		will be buffered first. It's a simplification but really the commercial
		CEP systems aren't doing a whole lot better: when asked for the contents of
		a table/window/materliaized view, Coral8 and Aleri and Sybase (don't know
		about StreamBase but it might be not different either) would make a copy
		of it first before sending the data. In some cases the copy is more efficient
		because it references the rows rather than copying the whole byte data, but
		in the grand scheme of things it's all the same.
		</p><p>
		Internally the information about the client sockets and their buffers is
		kept in the global hashes <code class="computeroutput">%clients</code>, <code class="computeroutput">%inbufs</code>, <code class="computeroutput">%outbufs</code>.
		It could be done a a single hash of objects but this was simpler.
		</p><p>
		The loop exits when the global variable <code class="computeroutput">$Triceps::X::SimpleServer::srv_exit</code> gets set 
		(synchronously, i.e. by one of the label handlers) to 1 and all the 
		clients disconnect. The requirement for disconnection of all the clients
		makes sure that all the output buffers get flushed before exit, and
		that was the easiest way to achieve this goal.
		</p><p>
		<code class="computeroutput">mainLoop()</code> relies on the listening socket being already created,
		bound and given to it as a parameter.  The creation of the socket and
		forking of a separate server process is wrapped in another function:
		</p><pre class="programlisting"># The server start function that creates the server socket,
# remembers its port number, then forks and
# starts the main loop in the child process. The parent
# process then returns the pair (port number, child PID).
#
# @param port - the port number to use; 0 will cause a unique free
#        port number to be auto-assigned
# @param labels - reference to the label hash, to be passed to mainLoop()
# @return - pair (port number, child PID) that can then be used to connect
#        to and control the server in the child process
sub startServer # ($port, $%labels)
{
  my $port = shift;
  my $labels = shift;

  my $srvsock = IO::Socket::INET-&gt;new(
    Proto =&gt; "tcp",
    LocalPort =&gt; $port,
    Listen =&gt; 10,
  ) or confess "socket failed: $!";
  # Read back the port, since the port 0 will cause a free port
  # to be auto-assigned.
  $port = $srvsock-&gt;sockport() or confess "sockport failed: $!";
  my $pid = fork();
  confess "fork failed: $!" unless defined $pid;
  if ($pid) {
    # parent
    $srvsock-&gt;close();
  } else {
    # child
    &amp;mainLoop($srvsock, $labels);
    exit(0);
  }
  return ($port, $pid);
}</pre><p>
		You can specify the server port 0 to request that the OS bind it to
		a randum unused port. The port number is then read back with <code class="computeroutput">sockport()</code>.
		The pair of the port numer and the server's child process id is then returned
		as the result. The process where the server runs is in this case
		just a child process, it's not properly daemonized.
		</p><p>
		For a simple complete example, let's make an echo server that would print
		back the rows it receives, as found in <code class="computeroutput">t/xQuery.t</code>:
		</p><a class="indexterm" name="id523122"></a><pre class="programlisting">our $rtTrade = Triceps::RowType-&gt;new(
  id =&gt; "int32", # trade unique id
  symbol =&gt; "string", # symbol traded
  price =&gt; "float64",
  size =&gt; "float64", # number of shares traded
);

use Triceps::X::SimpleServer qw(:all);

my $uEcho = Triceps::Unit-&gt;new("uEcho");
my $lbEcho = $uEcho-&gt;makeLabel($rtTrade, "echo", undef, sub {
  &amp;outCurBuf($_[1]-&gt;printP() . "\n");
});
my $lbEcho2 = $uEcho-&gt;makeLabel($rtTrade, "echo2", undef, sub {
  &amp;outCurBuf(join(",", "echo", &amp;Triceps::opcodeString($_[1]-&gt;getOpcode()),
    $_[1]-&gt;getRow()-&gt;toArray()) . "\n");
});
my $lbExit = $uEcho-&gt;makeLabel($rtTrade, "exit", undef, sub {
  $Triceps::X::SimpleServer::srv_exit = 1;
});

my %dispatch;
$dispatch{"echo"} = $lbEcho;
$dispatch{"echo2"} = $lbEcho2;
$dispatch{"exit"} = $lbExit;

my ($port, $pid) = &amp;Triceps::X::SimpleServer::startServer(0, \%dispatch);
print STDERR "port=$port pid=$pid\n";
waitpid($pid, 0);
exit(0);</pre><p>
		It starts the server and waits for it to exit. <code class="computeroutput">waitpid()</code> is used here
		in a simplified way too, it should properly be done in a loop until
		it succeeds or an error other than <code class="computeroutput">EINTR</code> is returned.
		</p><p>
		<code class="computeroutput">$rtTrade</code> is the row type for the expected data. 
		Two labels, <span class="quote">&#8220;<span class="quote">echo</span>&#8221;</span>
		and <span class="quote">&#8220;<span class="quote">echo2</span>&#8221;</span> differ in the way they print the data back:
		<span class="quote">&#8220;<span class="quote">echo</span>&#8221;</span> prints it in the symbolic form while <span class="quote">&#8220;<span class="quote">echo2</span>&#8221;</span>
		prints in CSV. The label <span class="quote">&#8220;<span class="quote">exit</span>&#8221;</span> sets the exit flag.
		Here is a small session log from the client side (46651 is the port
		that got picked at random and printed by the server on the start):
		</p><pre class="programlisting"><span class="bold"><strong>$ telnet localhost 46651</strong></span>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<span class="bold"><strong>echo,OP_INSERT,1,a,2,3.4</strong></span>
echo OP_INSERT id="1" symbol="a" price="2" size="3.4"
<span class="bold"><strong>echo2,OP_INSERT,1,a,2,3.4</strong></span>
echo,OP_INSERT,1,a,2,3.4
<span class="bold"><strong>exit,OP_NOP</strong></span>
<span class="bold"><strong>^]</strong></span>
<span class="bold"><strong>telnet&gt; q</strong></span>
Connection closed.</pre><p>
		The names in the dispatch table don't have to be the same as the names of
		the labels. It's often convenient to have them the same but not mandatory.
		</p><p>
		The exit label was created manually in this example but SimpleServer
		also provides the functions that create an exit label or an exit
		function, either of which can be placed into a dispatch table:
		</p><pre class="programlisting"># A dispatch function, sending anything to which will exit the server.
# The server will not flush the outputs before exit.
#
# Use like:
#   $dispatch{"exit"} = \&amp;Triceps::X::SimpleServer::exitFunc;
#
# In this way the input line doesn't have to contain the opcode.
# The alternative way is through makeExitLabel().
sub exitFunc # ($line)
{
    $srv_exit = 1;
}

# Create a label, sending anything to which will exit the server.
# The server will not flush the outputs before exit.
#
# Use like:
#   $dispatch{"exit"} = &amp;Triceps::X::SimpleServer::makeExitLabel($uTrades, "exit");
#
# In this way the input line has to contain at least the opcode.
# The alternative way is through exitFunc().
#
# @param unit - the unit in which to create the label
# @param name - the label name
# @return - the newly created label object
sub makeExitLabel # ($unit, $name)
{
  my $unit = shift;
  my $name = shift;
  return $unit-&gt;makeLabel($unit-&gt;getEmptyRowType(), $name, undef, sub {
    $srv_exit = 1;
  });
}</pre><p>
		<code class="computeroutput">makeExitLabel()</code> is quite simple, it creates a label with hardcoded
		function of setting the flag <code class="computeroutput">$srv_exit</code>. Even its row type
		is hardcoded to the empty rows. <code class="computeroutput">exitFunc()</code> sets the same flag
		directly.
		</p><p>
		There is also a function for making the labels that output
		their rows to the client in CSV format (as usual, no commas in the
		values, the same as is expected by the socket server):
		</p><pre class="programlisting"># Create a label that will print the data in CSV format to the server output
# (to the current client).
#
# @param fromLabel - the new label will be chained to this one and get the
#        data from it
# @param printName - if present, overrides the label name printed
# @return - the newly created label object
sub makeServerOutLabel # ($fromLabel [, $printName])
{
  no warnings; # or in tests prints a lot of warnings about undefs
  my $fromLabel = shift;
  my $printName = shift;
  my $unit = $fromLabel-&gt;getUnit();
  my $fromName = $fromLabel-&gt;getName();
  if (!$printName) {
    $printName = $fromName;
  }
  my $lbOut = $unit-&gt;makeLabel($fromLabel-&gt;getType(),
    $fromName . ".serverOut", undef, sub {
      &amp;outCurBuf(join(",", $printName,
        &amp;Triceps::opcodeString($_[1]-&gt;getOpcode()),
        $_[1]-&gt;getRow()-&gt;toArray()) . "\n");
    });
  $fromLabel-&gt;chain($lbOut);
  return $lbOut;
}</pre><p>
		<code class="computeroutput">makeServerOutLabel()</code> finds the
		unit and row type from the parent label, creates the printing label
		and chains it off the parent label. The newly created label is returned.
		The return value can be kept in a variable or immediately discarded;
		since the created label is already chained, it won't disappear.
		Tha name of the new label is produced from the name of the parent
		label by appending <span class="quote">&#8220;<span class="quote">.serverOut</span>&#8221;</span> to it.
		</p><a class="indexterm" name="id523300"></a><p>
		Running the automated tests of the servers requires the clients
		to be started automatically too, feed the input, receive the
		results, and then compare them to the expected results.
		The package Triceps::X::DumbClient from <code class="computeroutput">lib/Triceps/X/DumbClient.pm</code>
		does exactly that. The server code gets created as usual,
		only instead of starting the server, the dispatch table is
		given to the DumbClient method that takes care of starting
		the server, feeding the input, collecting the results,
		and waiting for the server to stop.
		</p><p>
		For example, the same echo example is run like this with
		DumbClient:
		</p><pre class="programlisting">use Triceps::X::SimpleServer qw(:all);

my $uEcho = Triceps::Unit-&gt;new("uEcho");
my $lbEcho = $uEcho-&gt;makeLabel($rtTrade, "echo", undef, sub {
  &amp;outCurBuf($_[1]-&gt;printP() . "\n");
});
my $lbEcho2 = $uEcho-&gt;makeLabel($rtTrade, "echo2", undef, sub {
  &amp;outCurBuf(join(",", "echo", &amp;Triceps::opcodeString($_[1]-&gt;getOpcode()),
    $_[1]-&gt;getRow()-&gt;toArray()) . "\n");
});
my $lbExit = $uEcho-&gt;makeLabel($rtTrade, "exit", undef, sub {
  $Triceps::X::SimpleServer::srv_exit = 1;
});

my %dispatch;
$dispatch{"echo"} = $lbEcho;
$dispatch{"echo2"} = $lbEcho2;
$dispatch{"exit"} = $lbExit;

my @inputQuery = (
"echo,OP_INSERT,1,a,2,3.4\n",
"echo2,OP_INSERT,1,a,2,3.4\n",
);
my $expectQuery =
'&gt; echo,OP_INSERT,1,a,2,3.4
&gt; echo2,OP_INSERT,1,a,2,3.4
echo OP_INSERT id="1" symbol="a" price="2" size="3.4"
echo,OP_INSERT,1,a,2,3.4
';

Triceps::X::TestFeed::setInputLines(@inputQuery);
Triceps::X::DumbClient::run(\%dispatch);

ok(&amp;Triceps::X::TestFeed::getResultLines(), $expectQuery);</pre><a class="indexterm" name="id523341"></a><p>
		DumbClient works in symbiosis with the TestFeed module that
		handles the recorded inputs and outputs. Note that the
		<span class="quote">&#8220;<span class="quote">exit</span>&#8221;</span> line is not there, DumbClient
		adds it implicitly at the end of the input.
		</p><p>
		The input lines are also included by TestFeed in the output
		with the <span class="quote">&#8220;<span class="quote">&gt; </span>&#8221;</span> prepended to them. DumbClient
		feeds all the inputs first and then reads all the results,
		relying on the TCP buffering to avoid deadlocking on the
		flow control. This works only for the small amounts of
		input but is good enough for the small tests.
		</p><p>
		And the implementation of DumbClient is fairly small, there
		is only one method:
		</p><pre class="programlisting">sub run # ($labels)
{
  my $labels = shift;

  my ($port, $pid) = Triceps::X::SimpleServer::startServer(0, $labels);
  my $sock = IO::Socket::INET-&gt;new(
    Proto =&gt; "tcp",
    PeerAddr =&gt; "localhost",
    PeerPort =&gt; $port,
  ) or confess "socket failed: $!";
  while(&amp; readLine) {
    $sock-&gt;print($_);
    $sock-&gt;flush();
  }
  $sock-&gt;print("exit,OP_INSERT\n");
  $sock-&gt;flush();
  $sock-&gt;shutdown(1); # SHUT_WR
  while(&lt;$sock&gt;) {
    &amp; send($_);
  }
  waitpid($pid, 0);
}</pre><p>
		As mentioned before in 
		<a class="xref" href="#sc_perl_libex" title="4.8. The Perl libraries and examples">Section 4.8: &#8220;The Perl libraries and examples&#8221; </a>,
		the methods <code class="computeroutput">readLine</code> and <code class="computeroutput">send</code> are imported from the
		TestFeed module.
		</p></div><div class="sect1" title="7.10. Tracing the execution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_tracing"></a>7.10. Tracing the execution</h2></div></div></div><a class="indexterm" name="id523407"></a><p>
		When developing the CEP models, there always comes the question: WTF
		had just happened? How did it manage get this result? Followed by
		subscribing to many intermediate results and trying to piece together
		the execution order.
		</p><p>
		Triceps provides two solutions for this situation: First, the
		procedural approach should make the logic much easier to follow.
		Second, it has a ready way to trace the execution and then read the
		trace in one piece. It can also be used to analyze any variables on the
		fly, and possibly stop the execution and enter some manual mode.
		</p><p>
		The idea here is simple: provide the Unit with a method that will be
		called:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		before a label executes,
		</li><li class="listitem">
		before the chained labels execute,
		</li><li class="listitem">
		after the chained labels execute,
		</li><li class="listitem">
		after the label executes,
		</li><li class="listitem">
		before the label's frame is drained (and thus the forked rowops
		execute, see the details of that in
		<a class="xref" href="#sc_sched_detail" title="7.11. The gritty details of Triceps scheduling">Section 7.11: &#8220;The gritty details of Triceps scheduling&#8221; </a>
		),
		</li><li class="listitem">
		after the frame is drained.
		</li></ul></div><p>
		The calls around the chaining and around the draining are done only if there
		are the chained labels to call or forked rowops to drain accordingly. Otherwise these
		pairs are skipped. 
		</p><p>
		The tracing calls happen in the order shown above.
		The call after the label executes goes after the chained calls (if any),
		enveloping them. However the draining calls happen after that (and no matter
		how many rowops were forked onto that frame, there will be only one
		after-draining call per frame, still referring to the original label).
		</p><p>
		For the simple tracing, a small simple tracer is provided. It
		actually executes directly as compiled in C++ so it's quite
		efficient:
		</p><pre class="programlisting">$tracer = Triceps::UnitTracerStringName(option =&gt; $value, ...);</pre><p>
		The arguments are specified as the option name-value pairs.
		</p><p>
		The only option supported is <span class="quote">&#8220;<span class="quote">verbose</span>&#8221;</span>, which may be 0 (default) or
		non-0. If it's 0 (false), the tracer will record a message only before
		executing each label. If true, it will record a message on each
		stage. The class is named UnitTracerStringName because it records the
		execution trace in the string format, including the names of the
		labels. The tracer is set into the unit:
		</p><a class="indexterm" name="id523495"></a><a class="indexterm" name="id523504"></a><pre class="programlisting">$unit-&gt;setTracer($tracer);</pre><p>
		The unit's current tracer can also be read back:
		</p><pre class="programlisting">$oldTracer = $unit-&gt;getTracer();</pre><p>
		If no tracer was previously set, <code class="computeroutput">getTracer()</code> will return <code class="computeroutput">undef</code>.
		And <code class="computeroutput">undef</code> can also be used as an argument of <code class="computeroutput">setTracer()</code>, to
		cancel any previously set tracing. 
		</p><p>
		The tracer references can be compared for whether they refer to the
		same underlying object:
		</p><pre class="programlisting">$result = $tracer1-&gt;same($tracer2);</pre><p>
		There are multiple kinds of tracer objects, and <code class="computeroutput">same()</code> can
		be called safely for either kind of tracer, including mixing them
		together. Of course, the tracers of different kinds definitely would
		not be the same tracer object.
		</p><p>
		As the unit runs, the tracing information gets collected in the tracer
		object. It can be extracted back with:
		</p><pre class="programlisting">$data = $tracer-&gt;print();</pre><p>
		This does not reset the trace. To reset it, use:
		</p><pre class="programlisting">$tracer-&gt;clearBuffer();</pre><p>
		Here is a code sequence designed to produce a fairly involved trace:
		</p><pre class="programlisting">$sntr = Triceps::UnitTracerStringName-&gt;new(verbose =&gt; 1);
$u1-&gt;setTracer($sntr);

$c_lab1 = $u1-&gt;makeDummyLabel($rt1, "lab1");
$c_lab2 = $u1-&gt;makeDummyLabel($rt1, "lab2");
$c_lab3 = $u1-&gt;makeDummyLabel($rt1, "lab3");

$c_op1 = $c_lab1-&gt;makeRowop(&amp;Triceps::OP_INSERT, $row1);
$c_op2 = $c_lab1-&gt;makeRowop(&amp;Triceps::OP_DELETE, $row1);

$c_lab1-&gt;chain($c_lab2);
$c_lab1-&gt;chain($c_lab3);
$c_lab2-&gt;chain($c_lab3);

$u1-&gt;schedule($c_op1);
$u1-&gt;schedule($c_op2);

$u1-&gt;drainFrame();</pre><p>
		The trace is:
		</p><pre class="programlisting">unit 'u1' before label 'lab1' op OP_INSERT {
unit 'u1' before-chained label 'lab1' op OP_INSERT {
unit 'u1' before label 'lab2' (chain 'lab1') op OP_INSERT {
unit 'u1' before-chained label 'lab2' (chain 'lab1') op OP_INSERT {
unit 'u1' before label 'lab3' (chain 'lab2') op OP_INSERT {
unit 'u1' after label 'lab3' (chain 'lab2') op OP_INSERT }
unit 'u1' after-chained label 'lab2' (chain 'lab1') op OP_INSERT }
unit 'u1' after label 'lab2' (chain 'lab1') op OP_INSERT }
unit 'u1' before label 'lab3' (chain 'lab1') op OP_INSERT {
unit 'u1' after label 'lab3' (chain 'lab1') op OP_INSERT }
unit 'u1' after-chained label 'lab1' op OP_INSERT }
unit 'u1' after label 'lab1' op OP_INSERT }
unit 'u1' before label 'lab1' op OP_DELETE {
unit 'u1' before-chained label 'lab1' op OP_DELETE {
unit 'u1' before label 'lab2' (chain 'lab1') op OP_DELETE {
unit 'u1' before-chained label 'lab2' (chain 'lab1') op OP_DELETE {
unit 'u1' before label 'lab3' (chain 'lab2') op OP_DELETE {
unit 'u1' after label 'lab3' (chain 'lab2') op OP_DELETE }
unit 'u1' after-chained label 'lab2' (chain 'lab1') op OP_DELETE }
unit 'u1' after label 'lab2' (chain 'lab1') op OP_DELETE }
unit 'u1' before label 'lab3' (chain 'lab1') op OP_DELETE {
unit 'u1' after label 'lab3' (chain 'lab1') op OP_DELETE }
unit 'u1' after-chained label 'lab1' op OP_DELETE }
unit 'u1' after label 'lab1' op OP_DELETE }</pre><p>
		The print-out is not indented because the execution of real models
		tends to involve some quite long call chains, which would result
		in some extremely wide indenting. Instead the curly braces at the
		end of each line help to find the matching pair. You can always
		use the <code class="computeroutput">vi</code> command <code class="computeroutput">%</code> to jump to the matching
		brace, or a similar feature in the other editors.
		</p><p>
		In non-verbose mode the same trace would be:
		</p><pre class="programlisting">unit 'u1' before label 'lab1' op OP_INSERT
unit 'u1' before label 'lab2' (chain 'lab1') op OP_INSERT
unit 'u1' before label 'lab3' (chain 'lab2') op OP_INSERT
unit 'u1' before label 'lab3' (chain 'lab1') op OP_INSERT
unit 'u1' before label 'lab1' op OP_DELETE
unit 'u1' before label 'lab2' (chain 'lab1') op OP_DELETE
unit 'u1' before label 'lab3' (chain 'lab2') op OP_DELETE
unit 'u1' before label 'lab3' (chain 'lab1') op OP_DELETE</pre><p>
		The non-verbose trace doesn't have the curly braces because
		there are no matching pairs of lines.
		</p><p>
		The actual contents of the rows is not printed in either case. This
		is basically because the tracer is implemented in C++, and I've been
		trying to keep the knowledge of the meaning of the simple data types
		out of the C++ code as much as possible for now. But it can be
		implemented with a Perl tracer.
		</p><p>
		A Perl tracer is created with:
		</p><pre class="programlisting">$tracer = Triceps::UnitTracerPerl-&gt;new($sub, @args);</pre><p>
		The arguments are a reference to a function, and optionally arguments
		for it. The resulting tracer can be used in the unit's <code class="computeroutput">setTracer()</code> as
		usual.
		A source code string may be used instead of the function reference, see
		<a class="xref" href="#sc_code" title="4.4. Code references and snippets">Section 4.4: &#8220;Code references and snippets&#8221; </a>. 
		</p><p>
		The function of the Perl tracer gets called as:
		</p><pre class="programlisting">&amp;$sub($unit, $label, $fromLabel, $rowop, $when, @args)</pre><p>
		The arguments are:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">$unit</code> is the usual unit reference.
		</li><li class="listitem"><code class="computeroutput">$label</code> is the current label being traced.
		</li><li class="listitem"><code class="computeroutput">$fromLabel</code> is the parent label in the chaining (would be
		<code class="computeroutput">undef</code> if the current label is called directly, without
		chaining from anything).
		</li><li class="listitem"><code class="computeroutput">$rowop</code> is the current row operation.
		</li><li class="listitem"><code class="computeroutput">$when</code> is an integer constant showing the point when the
		tracer is being called. It's value may be one of
		<code class="computeroutput">&amp;Triceps::TW_BEFORE</code>, 
		<code class="computeroutput">&amp;Triceps::TW_AFTER</code>, 
		<code class="computeroutput">&amp;Triceps::TW_BEFORE_DRAIN</code>,
		<code class="computeroutput">&amp;Triceps::TW_AFTER_DRAIN</code>,
		<code class="computeroutput">&amp;Triceps::TW_BEFORE_CHAINED</code>, 
		<code class="computeroutput">&amp;Triceps::TW_AFTER_CHAINED</code>; 
		the prefix <code class="computeroutput">TW</code> stands for <span class="quote">&#8220;<span class="quote">tracer when</span>&#8221;</span>.
		</li><li class="listitem"><code class="computeroutput">@args</code> are the extra arguments passed from the tracer creation.
		</li></ul></div><a class="indexterm" name="id523801"></a><p>
		The <code class="computeroutput">TW_*</code> constants can as usual be converted to and from
		strings with the calls
		</p><pre class="programlisting">$string = &amp;Triceps::tracerWhenString($value);
$value = &amp;Triceps::stringTracerWhen($string);
$string = &amp;Triceps::tracerWhenStringSafe($value);
$value = &amp;Triceps::stringTracerWhenSafe($string);</pre><p>
		There also are the conversion functions with strings more suitable for
		the human-readable messages: 
		<span class="quote">&#8220;<span class="quote">before</span>&#8221;</span>, 
		<span class="quote">&#8220;<span class="quote">after</span>&#8221;</span>, 
		<span class="quote">&#8220;<span class="quote">before-chained</span>&#8221;</span>,
		<span class="quote">&#8220;<span class="quote">after-chained</span>&#8221;</span>,
		<span class="quote">&#8220;<span class="quote">before-drain</span>&#8221;</span>, 
		<span class="quote">&#8220;<span class="quote">after-drain</span>&#8221;</span>. 
		These are actually the conversions used in the
		UnitTracerStringName. The functions for them are:
		</p><pre class="programlisting">$string = &amp;Triceps::tracerWhenHumanString($value);
$value = &amp;Triceps::humanStringTracerWhen($string);
$string = &amp;Triceps::tracerWhenHumanStringSafe($value);
$value = &amp;Triceps::humanStringTracerWhenSafe($string);</pre><p>
		Now that the constants have been mentioned, the order of tracing calls
		for a single executing rowop on a single label is:
		</p><pre class="programlisting">TW_BEFORE
TW_BEFORE_CHAINED
TW_AFTER_CHAINED
TW_AFTER
TW_BEFORE_DRAIN
TW_AFTER_DRAIN</pre><p>
		There is also a general way to find, if the <code class="computeroutput">$when</code>
		refers to a <span class="quote">&#8220;<span class="quote">before</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">after</span>&#8221;</span>
		situation:
		</p><pre class="programlisting">$result = &amp;Triceps::tracerWhenIsBefore($when);
$result = &amp;Triceps::tracerWhenIsAfter($when);</pre><p>
		Their typical usage in a trace function, to append an opening or closing brace, looks like:
		</p><pre class="programlisting">if (Triceps::tracerWhenIsBefore($when)) {
  $msg .= " {";
} elsif (Triceps::tracerWhenIsAfter($when)) {
  $msg .= " }";
}</pre><p>
		More trace points that are neither <span class="quote">&#8220;<span class="quote">before</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">after</span>&#8221;</span> could get added
		in the future, so a good practice is to use an elsif with both
		conditions rather than a simple if/else with one condition.
		</p><p>
		The Perl tracers allow to execute any arbitrary actions when tracing.
		They can act as breakpoints by looking for certain conditions and
		opening a debugging session when those are met.
		</p><p>
		For an example of a Perl tracer, let's start with a
		tracer function that works like UnitTracerStringName:
		</p><pre class="programlisting">sub tracerCb() # unit, label, fromLabel, rop, when, extra
{
  my ($unit, $label, $from, $rop, $when, @extra) = @_;
  our $history;

  my $msg = "unit '" . $unit-&gt;getName() . "' "
    . Triceps::tracerWhenHumanString($when) . " label '"
    . $label-&gt;getName() . "' ";
  if (defined $fromLabel) {
    $msg .= "(chain '" . $fromLabel-&gt;getName() . "') ";
  }
  $msg .= "op " . Triceps::opcodeString($rop-&gt;getOpcode());
  if (Triceps::tracerWhenIsBefore($when)) {
    $msg .= " {";
  } elsif (Triceps::tracerWhenIsAfter($when)) {
    $msg .= " }";
  }
  $msg .= "\n";
  $history .= $msg;
}

undef $history;
$ptr = Triceps::UnitTracerPerl-&gt;new(\&amp;tracerCb);
$u1-&gt;setTracer($ptr);</pre><p>
		It's slightly different, in the way that it always produces the
		verbose trace, and that it collects the trace in the global
		variable <code class="computeroutput">$history</code>. But the resulting text is the same as
		with UnitTracerStringName.
		</p><p>
		Now let's improve on it by printing the
		whole rowop contents too. In a <span class="quote">&#8220;<span class="quote">proper</span>&#8221;</span> way this advanced
		tracer would be defined as a class constructing the tracer objects.
		But to reduce the amount of code let's just make it a standalone
		function to be used with the Perl tracer constructor. 
		</p><p>
		And for something different let's make the result indented, with two spaces
		per indenting level. As mentioned before, the indenting
		is actually not such a great idea.
		But for the small short examples it works well.
		The function would take 3 extra arguments:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		Verbosity, a boolean value.
		</li><li class="listitem">
		Reference to an array variable where to append the text of the trace.
		This is more flexible than the fixed <code class="computeroutput">$history</code>. The array will contain
		the lines of the trace as its elements. And appending to an array
		should be more efficient than appending to the end of a potentially
		very long string.
		</li><li class="listitem">
		Reference to a scalar variable that would be used to keep the indenting level.
		The value of that variable will be updated as the tracing happens. Its
		initial value will determine the initial indenting level. 
		</li></ul></div><pre class="programlisting">sub traceStringRowop
{
  my ($unit, $label, $fromLabel, $rowop, $when,
    $verbose, $rlog, $rnest) = @_;

  if ($verbose) {
    ${$rnest}-- if (Triceps::tracerWhenIsAfter($when));
  } else {
    return if ($when != &amp;Triceps::TW_BEFORE);
  }

  my $msg =  "unit '" . $unit-&gt;getName() . "' "
    . Triceps::tracerWhenHumanString($when) . " label '"
    . $label-&gt;getName() . "' ";
  if (defined $fromLabel) {
    $msg .= "(chain '" . $fromLabel-&gt;getName() . "') ";
  }
  my $tail = "";
  if (Triceps::tracerWhenIsBefore($when)) {
    $tail = " {";
  } elsif (Triceps::tracerWhenIsAfter($when)) {
    $tail = " }";
  }
  push (@{$rlog}, ("  " x ${$rnest}) . $msg . "op "
    . $rowop-&gt;printP() . $tail);

  if ($verbose) {
    ${$rnest}++ if (Triceps::tracerWhenIsBefore($when));
  }
}

undef @history;
my $tnest =  0; # keeps track of the tracing nesting level
$ptr = Triceps::UnitTracerPerl-&gt;new(\&amp;traceStringRowop, 1, \@history, \$tnest);
$u1-&gt;setTracer($ptr);</pre><p>
		For the same call sequence as before, the output will be as follows
		(I've tried to wrap the long lines in a logically consistent way
		but it still spoils the effect of indenting a bit):
		</p><pre class="programlisting">unit 'u1' before label 'lab1' op lab1 OP_INSERT a="123" b="456"
    c="789" d="3.14" e="text"  {
  unit 'u1' before-chained label 'lab1' op lab1 OP_INSERT a="123"
      b="456" c="789" d="3.14" e="text"  {
    unit 'u1' before label 'lab2' (chain 'lab1') op lab1 OP_INSERT
        a="123" b="456" c="789" d="3.14" e="text"  {
      unit 'u1' before-chained label 'lab2' (chain 'lab1') op lab1
          OP_INSERT a="123" b="456" c="789" d="3.14" e="text"  {
        unit 'u1' before label 'lab3' (chain 'lab2') op lab1 OP_INSERT
            a="123" b="456" c="789" d="3.14" e="text"  {
        unit 'u1' after label 'lab3' (chain 'lab2') op lab1 OP_INSERT
            a="123" b="456" c="789" d="3.14" e="text"  }
      unit 'u1' after-chained label 'lab2' (chain 'lab1') op lab1
          OP_INSERT a="123" b="456" c="789" d="3.14" e="text"  }
    unit 'u1' after label 'lab2' (chain 'lab1') op lab1 OP_INSERT
        a="123" b="456" c="789" d="3.14" e="text"  }
    unit 'u1' before label 'lab3' (chain 'lab1') op lab1 OP_INSERT
        a="123" b="456" c="789" d="3.14" e="text"  {
    unit 'u1' after label 'lab3' (chain 'lab1') op lab1 OP_INSERT
        a="123" b="456" c="789" d="3.14" e="text"  }
  unit 'u1' after-chained label 'lab1' op lab1 OP_INSERT a="123"
      b="456" c="789" d="3.14" e="text"  }
unit 'u1' after label 'lab1' op lab1 OP_INSERT a="123" b="456" c="789"
    d="3.14" e="text"  }
unit 'u1' before label 'lab1' op lab1 OP_DELETE a="123" b="456"
    c="789" d="3.14" e="text"  {
  unit 'u1' before-chained label 'lab1' op lab1 OP_DELETE a="123"
      b="456" c="789" d="3.14" e="text"  {
    unit 'u1' before label 'lab2' (chain 'lab1') op lab1 OP_DELETE
        a="123" b="456" c="789" d="3.14" e="text"  {
      unit 'u1' before-chained label 'lab2' (chain 'lab1') op lab1
          OP_DELETE a="123" b="456" c="789" d="3.14" e="text"  {
        unit 'u1' before label 'lab3' (chain 'lab2') op lab1 OP_DELETE
            a="123" b="456" c="789" d="3.14" e="text"  {
        unit 'u1' after label 'lab3' (chain 'lab2') op lab1 OP_DELETE
            a="123" b="456" c="789" d="3.14" e="text"  }
      unit 'u1' after-chained label 'lab2' (chain 'lab1') op lab1
          OP_DELETE a="123" b="456" c="789" d="3.14" e="text"  }
    unit 'u1' after label 'lab2' (chain 'lab1') op lab1 OP_DELETE
        a="123" b="456" c="789" d="3.14" e="text"  }
    unit 'u1' before label 'lab3' (chain 'lab1') op lab1 OP_DELETE
        a="123" b="456" c="789" d="3.14" e="text"  {
    unit 'u1' after label 'lab3' (chain 'lab1') op lab1 OP_DELETE
        a="123" b="456" c="789" d="3.14" e="text"  }
  unit 'u1' after-chained label 'lab1' op lab1 OP_DELETE a="123"
      b="456" c="789" d="3.14" e="text"  }
unit 'u1' after label 'lab1' op lab1 OP_DELETE a="123" b="456" c="789"
    d="3.14" e="text"  }</pre><p>
		As mentioned before, each label produces two levels of indenting: one
		for everything after <span class="quote">&#8220;<span class="quote">before</span>&#8221;</span>, another one for the nested
		labels.
		</p><p>
		Eventually this tracing should become another standard class in Triceps.
		</p></div><div class="sect1" title="7.11. The gritty details of Triceps scheduling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_detail"></a>7.11. The gritty details of Triceps scheduling</h2></div></div></div><p>
		There are four ways of executing a rowop in Triceps:
		</p><a class="indexterm" name="id524053"></a><a class="indexterm" name="id524062"></a><div class="variablelist"><dl><dt><span class="term">Call:</span></dt><dd><a class="indexterm" name="id524080"></a><p>
				Execute the label right now, including all the nested calls.
				When the call returns, the execution is completed. This is
				the most typical way, and the only one described in detail so far.
				</p></dd><dt><span class="term">Schedule:</span></dt><dd><a class="indexterm" name="id524103"></a><p>
				Execute the label after everything else is done.
				</p></dd><dt><span class="term">Fork:</span></dt><dd><a class="indexterm" name="id524125"></a><p>
				Execute the label after the current label returns but
				before its caller gets the control back or
				anything else is done. Obviously, if multiple labels are
				forked, they will execute in the order they were forked.
				The forked labels can be seen as <span class="quote">&#8220;<span class="quote">little siblings</span>&#8221;</span> of the
				current label. Forking is currently not used much, other
				than for the special case of looping.
				</p></dd><dt><span class="term">Loop:</span></dt><dd><a class="indexterm" name="id524152"></a><a class="indexterm" name="id524161"></a><p>
				Execute the label as the start of the next iteration of the
				topological loop, after the current iteration is fully
				completed. This is a special case of fork, essentially
				forking at the level of the loop's first label.
				</p></dd></dl></div><a class="indexterm" name="id524181"></a><p>
		The common term encompassing all of them is <span class="quote">&#8220;<span class="quote">enqueue</span>&#8221;</span>.
		<span class="quote">&#8220;<span class="quote">Enqueue</span>&#8221;</span> is an ugly word but since I've already used the
		word <span class="quote">&#8220;<span class="quote">schedule</span>&#8221;</span> for a specific purpose, I needed another word to name
		all these operations together. Hence <span class="quote">&#8220;<span class="quote">enqueue</span>&#8221;</span>.
		</p><p>
		The meaning is kind of intuitively straightforward but the details might sometimes
		be a bit surprising. So let us look in detail at how it works inside
		on an example of a fairly convoluted scheduling sequence.
		</p><a class="indexterm" name="id524212"></a><a class="indexterm" name="id524221"></a><a class="indexterm" name="id524229"></a><a class="indexterm" name="id524237"></a><p>
		A scheduler in the execution unit keeps not just a single queue but 
		a stack of queues that contain
		the rowops to be executed. The rowops get into the queues when they are
		forked or looped or scheduled.  Each queue
		is essentially a stack frame, so I'll be using the terms <span class="emphasis"><em>queue</em></span> and
		<span class="emphasis"><em>frame</em></span> interchangeably. The stack always contains at least one
		queue, which is called the <span class="bold"><strong>outermost</strong></span> stack frame.
		</p><p>
		When the new rowops arrive from the outside world, they can be added with the method
		<code class="computeroutput">schedule()</code> to that stack frame. That's what <code class="computeroutput">schedule()</code> does: always
		adds rowops to the outermost stack frame, no matter how many frames
		might be pushed on top of it. If rowops 1, 2 and 3 are
		added, the stack looks like this (the brackets denote a stack frame):
		</p><pre class="programlisting">[1, 2, 3]</pre><p>
		The unit method <code class="computeroutput">drainFrame()</code> is then used to run the
		scheduler and process the rowops. It makes the unit call each rowop on
		the innermost frame (which is initially the same as outermost
		frame, since there is only one frame) in order.
		</p><p>
		First it calls the rowop 1. It's removed from the queue, then a new
		frame is pushed onto the stack:
		</p><pre class="programlisting">[ ] ~1
[2, 3]</pre><p>
		This new frame is the rowop 1's frame, which is marked on the diagram
		by <span class="quote">&#8220;<span class="quote">~1</span>&#8221;</span>. The diagram shows the most recently pushed, innermost,
		frame on top, and the oldest, outermost frame on the bottom. The
		concepts of <span class="quote">&#8220;<span class="quote">innermost</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">outermost</span>&#8221;</span>
		come from the nested calls: the most recent call is nested the deepest
		in the middle and is the innermost one.
		</p><p>
		Then the rowop 1 executes. If it
		calls rowop 4, another frame is pushed onto the stack for it:
		</p><pre class="programlisting">[ ] ~4
[ ] ~1
[2, 3]</pre><p>
		Then the rowop 4 executes. The rowop 4 never gets onto any of the queues.
		The call just pushes a new frame and executes the rowop right away.
		The identity of rowop being processed is kept in the call context. A
		call also involves a direct C++ call on the thread stack, and if any
		Perl code is involved, a Perl call too. Because of this, if you nest
		the calls too deeply, you may run out of the thread stack space and
		get it to crash.
		</p><p>
		After the rowop 4 is finished (not calling any other
		rowops), the innermost empty frame is popped before the execution of
		rowop 1 continues. The queue stack reverts to the previous state.
		</p><pre class="programlisting">[ ] ~1
[2, 3]</pre><p>
		Suppose then rowop 1 forks rowops 5 and 6 by calling the Unit method
		<code class="computeroutput">fork()</code>. They are appended to the
		innermost frame in the order they are forked.
		</p><pre class="programlisting">[5, 6] ~1
[2, 3]</pre><p>
		If rowop 1 then calls rowop 7, again a frame is pushed onto the stack
		before it executes:
		</p><pre class="programlisting">[ ] ~7
[5, 6] ~1
[2, 3]</pre><p>
		The rowops 5 and 6 still don't execute, they keep sitting on the queue
		until the rowop 1 would return.
		After the call of rowop 7 completes, the scheduler stack returns to
		the previous state.
		</p><a class="indexterm" name="id524377"></a><p>
		Suppose now the execution of rowop 1 completes. But its stack frame can
		not be popped yet, because it is not empty. Now is the time to execute
		the rowops from it. It's also called <span class="quote">&#8220;<span class="quote">frame draining</span>&#8221;</span>
		but if works somewhat differently in the case of the forked rowops.
		The first rowop gets picked from the frame and called, but in a special way.
		It doesn't get its own frame. Instead, it takes over the frame of its
		parent rowop. The frame that was marked <span class="quote">&#8220;<span class="quote">~1</span>&#8221;</span> now changes
		its marking to <span class="quote">&#8220;<span class="quote">~5</span>&#8221;</span> because of that take-over:
		</p><pre class="programlisting">[6] ~5
[2, 3]</pre><p>
		If the rowop 5 forks rowop 8, the stack becomes:
		</p><pre class="programlisting">[6, 8] ~5
[2, 3]</pre><p>
		Since the frame was inherited from the parent rowop 1, the rowop 8
		just gets appended to the end of it after rowop 6. The rowops forked
		in the same frame are executed in the order they were forked.
		Unlike the calls, there is no nesting involved in forking.
		</p><p>
		When the execution of rowop 5 returns, the execution of the forked
		rowops from the innermost frame continues. The rowop 6 gets picked
		from the front of the frame and takes over the frame ownership:
		</p><pre class="programlisting">[8] ~6
[2, 3]</pre><p>
		Suppose the rowop 6 doesn't call or fork anything else and returns.
		Then the rowop 8 starts executing and takes over the frame:
		</p><pre class="programlisting">[ ] ~8
[2, 3]</pre><p>
		Suppose rowop 8 calls <code class="computeroutput">schedule()</code> of rowop 9. Rowop 9 is then
		added to the outermost queue:
		</p><pre class="programlisting">[ ] ~8
[2, 3, 9]</pre><p>
		Rowop 8 then returns, its queue is empty, so it's popped and its call completes.
		</p><pre class="programlisting">[2, 3, 9]</pre><p>
		The method <code class="computeroutput">drainFrame()</code> keeps running on the outermost
		frame, now taking the rowop 2 and executing it, and so on, until the
		outermost queue becomes empty, and <code class="computeroutput">drainFrame()</code> returns.
		</p><a class="indexterm" name="id524480"></a><p>
		An interesting question is, what happens with the chained labels?
		Where do they fit in the order of execution? They turn out to be
		similar to a <code class="computeroutput">fork()</code>.
		The presence of chaining gets checked after the original label completes its execution 
		but before executing any of the forked labels from its frame.
		If any chained labels are found, they are called one by one.
		They take over the frame of the parent, just like the forked labels.
		Any of the chained labels may also call <code class="computeroutput">fork()</code>, adding
		more labels to the frame. The next forked label (if any) gets
		executed only after all the labels chained from the current
		one are done.
		</p><p>
		What would happen if <code class="computeroutput">drainFrame()</code> is called not from outside
		the model but from inside some label handler? It will drain the
		innermost frame. Suppose that the queue stack was in the following
		state, with rowop 5 executing:
		</p><pre class="programlisting">[6, 8] ~5
[2, 3]</pre><p>
		If the label handler of the rowop 5 calls <code class="computeroutput">drainFrame()</code>
		now, <code class="computeroutput">drainFrame()</code> will do its usual job: pick the
		rowops one by one from the innermost frame, create the nested
		frames for them and execute. So first it will pick up the rowop 6:
		</p><pre class="programlisting">[ ] ~6
[8] ~5
[2, 3]</pre><p>
		After the rowop 6 completes, its frame gets popped:
		</p><pre class="programlisting">[8] ~5
[2, 3]</pre><p>
		But <code class="computeroutput">drainFrame()</code> continues running, and now picks the rowop 8:
		</p><pre class="programlisting">[ ] ~8
[ ] ~5
[2, 3]</pre><p>
		After the rowop 8 completes, its frame gets also popped:
		</p><pre class="programlisting">[ ] ~5
[2, 3]</pre><p>
		At this point the innermost frame becomes empty and <code class="computeroutput">drainFrame()</code>
		returns. The label handler of rowop 5 continues its execution.
		</p><p>
		If you haven't forked anything, the innermost frame will be empty, and
		<code class="computeroutput">drainFrame()</code> will do nothing. If you did fork some rowops,
		<code class="computeroutput">drainFrame()</code> looks like a convenient way to call them now
		and then continue. However note that in this case the semantics is
		different from the normal forking. The rowops from the frame will
		be called in the nested frames, not taking over the original frame.
		So if say rowop 6 refers to the same label as rowop 5, this nested
		execution will be considered a recursive call of the same label.
		Thus <code class="computeroutput">drainFrame()</code> is best used only with the outermost
		frame.
		</p><p>
		What if the rowop 1 weren't scheduled and then drained but was just
		directly called? The outermost frame will remain empty, while a new
		frame will be pushed for the rowop 1 as usual:
		</p><pre class="programlisting">[ ] ~1
[ ]</pre><p>
		If the rowop 1 executed the same code as before, after the call it
		will leave the rowop 9 scheduled on the outermost frame:
		</p><pre class="programlisting">[9]</pre><p>
		To execute the rowop 9, call <code class="computeroutput">drainFrame()</code>, or it will be
		stuck there forever.
		</p><p>
		Note that the execution order differs depending on whether the
		incoming rowops were scheduled or directly called, and on when
		the <code class="computeroutput">drainFrame()</code> is called. If the three rowops were
		scheduled and then drained, the execution order will be
		1, 2, 3, 9. If they were called directly with draining the
		frame after each one, the order will be 1, 9, 2, 3. And if they
		were called directly but with draining only after the last
		one, it would be again 1, 2, 3, 9. 
		</p><p>
		The loop scheduling is a whole big separate subject that will
		be discussed in the next section.
		</p></div><div class="sect1" title="7.12. The gritty details of Triceps loop scheduling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_loop"></a>7.12. The gritty details of Triceps loop scheduling</h2></div></div></div><a class="indexterm" name="id524664"></a><a class="indexterm" name="id524676"></a><a class="indexterm" name="id524687"></a><a class="indexterm" name="id524696"></a><p>
		Now it's time to look at what is really going on when a
		topological loop gets executed. Let's continue looking at
		the loop example that was already shown in
		<a class="xref" href="#fig_sched_loop" title="Figure 7.1. Labels forming a topological loop.">Figure 7.1 (page )</a>.
		
		</p><p>
		If the loop were handled simple-mindedly, with all the execution
		done by calls, it could use a lot of stack space.
		Suppose some rowop X1 is scheduled for label X, and causes the loop
		to be executed twice, with rowops X1, A2, B3, C4, A5, B6, C7, Y8. If each
		operation is done as a <code class="computeroutput">call()</code>, the stack grows like this: It starts with
		X1 called, creating its own execution frame (marked as such for clarity):
		</p><pre class="programlisting">[ ] ~X1
[ ]</pre><p>
		Which then calls A2:
		</p><pre class="programlisting">[ ] ~A2
[ ] ~X1
[ ]</pre><p>
		Which then continues the calls in sequence.
		By the time the execution comes to Y8, the stack looks like this:
		</p><pre class="programlisting">[ ] ~Y8
[ ] ~C7
[ ] ~B6
[ ] ~A5
[ ] ~C4
[ ] ~B3
[ ] ~A2
[ ] ~X1
[ ]</pre><p>
		The loop has been converted into recursion, and the whole length of
		execution is the depth of the recursion. If the loop executes a million
		times, the stack will be three million levels deep. Worse yet, it's not
		just the Triceps scheduler stack that grows, it's also the process
		(C++ and Perl) stack.
		</p><a class="indexterm" name="id524762"></a><a class="indexterm" name="id524774"></a><p>
		Which is why this kind of recursive calls is forbidden by default
		in Triceps. If you try to do it, on the first recursive call the
		execution will die with an error. You can enable the recursion
		but this only lets the stack grow and doesn't prevent the growth.
		</p><p>
		Would things be better with <code class="computeroutput">fork()</code> instead of
		<code class="computeroutput">call()</code> used throughout the loop? It starts the same way:
		</p><pre class="programlisting">[X1]</pre><p>
		Then X1 executes, gets its own frame and forks A2:
		</p><pre class="programlisting">[A2] ~X1
[ ]</pre><p>
		Then A2 inherits the stack frame and executes, forks B3:
		</p><pre class="programlisting">[B3] ~A2
[ ]</pre><p>
		On each step the frame will be inherited by the next label,
		and if Y8 is also eventually forked, at the end the stack will
		be:
		</p><pre class="programlisting">[ ] ~Y8
[ ]</pre><p>
		Problem solved, no matter how many iterations were done by the loop,
		the stack will stay limited. 
		</p><p>
		The catch though is that <span class="emphasis"><em>every</em></span>
		operation inside the loop must be done with a <code class="computeroutput">fork()</code>.
		If there is even one <code class="computeroutput">call()</code> occuring in the loop, the
		stack will grow by a frame for each <code class="computeroutput">call()</code> and may
		become quite deep again. The problem is that <code class="computeroutput">call()</code> is
		hardcoded in many primitives, such as Tables, and is fairly typically
		used in the templates as well. The historic solution for that
		was to specify for each table, how it should handle its results,
		call them or fork them or even schedule them. And the templates
		could use a similar approach.
		</p><p>
		The practice had quickly showed that not only all this explicit
		choice is quite cumbersome and easy to miss, but also the
		semantics of <code class="computeroutput">fork()</code> is different from <code class="computeroutput">call()</code>
		in a very annoying way. If some label wants to do something,
		call some other label, then do something more using the result of the call, doing it with
		<code class="computeroutput">call()</code> is simple: just execute all this procedurally
		in sequence. After <code class="computeroutput">call()</code> returns, its work is
		guaranteed to be done and any global state to be updated.
		Not so with <code class="computeroutput">fork()</code> that just puts the rowop onto
		a queue, there just isn't any way to get the second half
		of the original label's code to execute only after all the
		effects from the forked rowop had propagated.
		(Historically <code class="computeroutput">fork()</code> worked differently in
		Triceps 1.0 and did allow to reproduce the call semantics
		through some minor contortions but then it kept growing
		the stack on every fork, just as the calls do).
		</p><p>
		The solution, even back in the version 1.0 days, was to add a special
		method for the loop scheduling.
		</p><a class="indexterm" name="id524916"></a><p>
		It starts with the concept of the frame mark. A <span class="emphasis"><em>frame mark</em></span> is a token
		object, completely opaque to the program. It can be used only in two
		operations:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">setMark()</code> remembers the  position in the frame stack, just
		outside the current frame.
		</li><li class="listitem"><code class="computeroutput">loopAt()</code> enqueues a rowop at the marked frame.
		</li></ul></div><p>
		Then the loop wold have its mark object M. The label A will execute
		<code class="computeroutput">setMark(M)</code>, and the label C will execute <code class="computeroutput">loopAt(M, rowop(A))</code>. The rest
		of the execution can as well use <code class="computeroutput">call()</code>, as shown in
		<a class="xref" href="#fig_sched_loop" title="Figure 7.1. Labels forming a topological loop.">Figure 7.1</a>.
		</p><div class="figure"><a name="fig_sched_mark"></a><div class="figure-contents"><div><img src="label-011-mark.lowres.png" width="NaN" alt="Proper calls in a loop."></div></div><p class="title"><b>Figure 7.2. Proper calls in a loop.</b></p></div><br class="figure-break"><p>
		When the label A executes the rowop A2, first things it does is
		calling setMark(M). After that the stack will look like this:
		</p><pre class="programlisting">[ ] ~A2, mark M
[ ] ~X1
[ ]</pre><p>
		The mark M remembers the current frame. The stack
		at the end of C4, after it has called <code class="computeroutput">loopAt(M, A5)</code>, is:
		</p><pre class="programlisting">[ ] ~C4
[ ] ~B3
[A5] ~A2, mark M
[ ] ~X1
[ ]</pre><p>
		The stack then unwinds until A5 starts its execution:
		</p><pre class="programlisting">[ ] ~A5, mark M
[ ] ~X1
[ ]</pre><p>
		When A5 inherits the stack frame from A2, the mark M stays put.
		The label A would normally call <code class="computeroutput">setMark(M)</code> again anyway,
		but it will just put the mark onto the same frame, so effectively
		it's a no-operation.
		</p><p>
		Thus each iteration starts with a fresh stack, and the stack depth is
		limited to one iteration. The nested loops can also be properly
		executed.
		</p><p>
		After Y8 completes, the stack will unroll back, and X1
		can continue its execution:
		</p><pre class="programlisting">[ ] ~X1
[ ]</pre><p>
		To reiterate, when the control returns back to X1, the whole loop
		is done.
		</p><p>
		What happens after the stack unwinds past the mark? The mark gets
		unset. When someone calls <code class="computeroutput">loopAt()</code> with an unset mark, the rowop is
		enqueued in the outermost frame, having the same effect as <code class="computeroutput">schedule()</code>.
		</p><p>
		It's possible to use this handling of an unset mark to some creative
		effects. It allows the loops to take a pause in the middle.
		Suppose the label B finds that it can't process
		the rowop B3 until some other data has arrived. What it can do then is remember
		B3 somewhere in the thread state and return. The loop has not completed but
		it can't progress either, so the call unrolls until it becomes empty.
		In this case the code of label X must be prepared to find that the
		loop hadn't completed yet after the call of A2 returns.
		Since the frame of X1 is popped off the stack, the mark M gets unset. 
		The knowledge that the loop needs to be continued stays remembered
		in the state.
		</p><p>
		After some time that awaited data arrives, as some other rowop. When that
		rowop gets processed, it will find that remembered state with B3 and will make
		it continue, maybe by calling <code class="computeroutput">call(B3)</code> again. So now the
		logic in B finds all the data it needs and continues with the loop,
		calling C4. C4 will do its job and call <code class="computeroutput">loopAt(M, A5)</code>.
		But the mark M has been unset a while ago!  Scheduling A5 at the outermost
		frame seems to be a logical thing to do at this point. Then whatever
		current processing will complete and unwind, and the loop will continue
		after it. When the rowop A5 gets executed, the label A will call
		<code class="computeroutput">setMark(M)</code> again, thus setting the mark on its new frame,
		and making the loop run as far as it can before executing any other
		scheduled rowops.
		</p><p>
		Overall, pausing and then restarting a loop like this is not such
		a good idea. The caller of the loop normally expects that it can wait
		for the loop to complete, and that when the loop returns, it's all done.
		If a loop may decide to bail out now and continue later, the
		effects may be quite unexpected.
		</p></div><div class="sect1" title="7.13. Recursion control"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_sched_recursion"></a>7.13. Recursion control</h2></div></div></div><a class="indexterm" name="id525128"></a><p>
		Historically, the recursive calls (when a
		label calls itself, directly or indirectly) have been forbidden in
		Triceps. Mind you, the recursive calling could still be done even
		then with the help of trays and forking.
		And it's probably the best way too from the
		standpoint of correctness. However it's not the most straightforward
		way, and the real recursion still comes handy once in a while.
		</p><p>
		Now the recursion is allowed in its direct way. Especially
		that it doesn't have to be all-or-nothing, it can be done in a
		piecemeal and controlled fashion.
		</p><p>
		It's controlled per-unit. Each unit has two adjustable limits:
		</p><a class="indexterm" name="id525151"></a><a class="indexterm" name="id525160"></a><a class="indexterm" name="id525171"></a><div class="variablelist"><dl><dt><span class="term">Maximal stack depth:</span></dt><dd><p>
				Limits the total depth of the unit's call stack. That's the
				maximal length of the call chain, whether it goes straight or
				in loops.
				</p></dd><dt><span class="term">Maximal recursion depth:</span></dt><dd><p>
				Limits the number of times each particular label may appear on
				the call stack. So if you have a recursive code fragment
				(a simple-minded loop or a recursive streaming function), this
				is the limit on its recursive reentrances.
				</p></dd></dl></div><p>
		Both these limits accept the 0 and negative values to mean <span class="quote">&#8220;<span class="quote">unlimited</span>&#8221;</span>.
		</p><p>
		The default is as it has been before: unlimited stack depth, recursion
		depth of 1 (which means that each label may be called once but it may
		not call itself). But now you can change them with the calls:
		</p><pre class="programlisting">$unit-&gt;setMaxStackDepth($n);
$unit-&gt;setMaxRecursionDepth($n);</pre><p>
		You can change them at any time, even when the unit is running (but
		they will be enforced only on the next attempt to execute a rowop).
		</p><p>
		You can also read the current values:
		</p><pre class="programlisting">$n = $unit-&gt;maxStackDepth();
$n = $unit-&gt;maxRecursionDepth();</pre><p>
		Another thing about the limits is that even if you set them to
		<span class="quote">&#8220;<span class="quote">unlimited</span>&#8221;</span> or to some very large values, there still are the system
		limits. The calls use the C++ process (or thread) stack and the Perl stack, and if you
		make too many of them, the stack will overflow and the whole process
		will crash and possibly dump core. Keeping the call depths within
		reason is still a good idea.
		</p><a class="indexterm" name="id525253"></a><p>
		Now you can do the direct recursion. However as with the procedural
		code, not all the labels are reentrant. Some of them may work with the
		static data structures that can't be modified in a nested fashion.
		Think for example of a table: when you modify a table, it sends rowops
		to its <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span> labels. You can connect the other labels there,
		and react to the table modifications. However these labels can't
		attempt to modify the same table, because the table is already in the
		middle of a modification, and it's not reentrant.
		</p><p>
		The table still has a separate logic to check for non-reentrance, and
		no matter what is the unit's general recursion depth limit, for the
		table it always stays at 1. Moreover, the table enforces it across both
		the input label interface and the procedural interface.
		</p><a class="indexterm" name="id525282"></a><p>
		If you make your own non-reentrant labels, Triceps can make this check
		for you. Just mark the first label of the non-reentrant sequence with
		</p><pre class="programlisting">$label-&gt;setNonReentrant();</pre><p>
		It will have its own private recursion limit of 1. Any time it's
		attempted to execute recursively, it will confess. There is no way to
		unset this flag: when a label is known to be non-reentrant, it can not
		suddenly become reentrant until its code is rewritten.
		</p><p>
		You can read this flag with
		</p><pre class="programlisting">$val = $label-&gt;isNonReentrant();</pre></div></div><div class="chapter" title="Chapter 8. Memory Management"><div class="titlepage"><div><div><h2 class="title"><a name="ch_memory"></a>Chapter 8. Memory Management</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_ref_cycles">8.1. Reference cycles</a></span></dt><dt><span class="sect1"><a href="#sc_memory_labels">8.2. Clearing of the labels</a></span></dt><dt><span class="sect1"><a href="#sc_clearing_labels">8.3. The clearing labels</a></span></dt></dl></div><div class="sect1" title="8.1. Reference cycles"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_cycles"></a>8.1. Reference cycles</h2></div></div></div><a class="indexterm" name="id467062"></a><p>
		Remember that the
		Triceps memory management uses the reference counting, which does not like
		the reference cycles, as has been mentioned in
		<a class="xref" href="#sc_memory_fund" title="4.3. Memory management fundamentals">Section 4.3: &#8220;Memory management fundamentals&#8221; </a>. 
		The reference cycles cause the objects to be never
		freed. It's no big deal if the data structures exist until the program
		exit anyway but it becomes a memory leak if they keep being created and deleted
		dynamically.
		</p><a class="indexterm" name="id472306"></a><p>
		The problems come not with the data that goes through the models but
		with the models themselves. The data gets reference-counted without any
		issues. The reference cycles can get formed only between the elements of
		the models: labels, tables etc. If you don't need them destroyed until
		the program exits (or more exactly, until the Perl interpreter instance
		exits), there is no problem. The leaks could happen only if the model
		elements get created and destroyed as the program runs, such as if you
		use them to parse and process the short-lived ad-hoc queries.
		</p><p>
		These leaks are pretty hard to diagnose. There are some
		packages, like Devel::Cycle, but they won't detect the loops that
		involve a reference at C++ level. And when the Perl interpreter exits,
		it clears up all the variables used, even the ones involved in the
		loops, so if you run it under valgrind, valgrind doesn't show any
		leaks. There is a package Devel::LeakTrace that should be able
		to detect all these left-over variables. However I can't tell for sure
		yet, so far I haven't had enough patience to build all the
		dependencies for it.
		</p><p>
		One possibility is to use the weak references (using the module Scalar::Util).
		But the problem is that you need to not forget weakening the references
		manually. Too much work, too much attention, too easy to forget. 
		</p><p>
		The mechanism used in Triceps works by breaking up the reference cycles
		when the data needs to be cleared. The execution unit
		keeps track of all its labels, and when it gets destoryed, clears them
		up, breaking up the cycles. It's also possible to clear the labels
		individually, by a manual call.
		</p><p>
		The clearing of a label clears all the chainings.
		The chained labels get cleared too in their turn, and eventually the whole chain
		clears up. This removes the links in the forward direction, and if any
		cycles were present, they become open.
		More on the details of label clearing in the 
		<a class="xref" href="#sc_memory_labels" title="8.2. Clearing of the labels">Section 8.2: &#8220;Clearing of the labels&#8221; </a>. 
		</p><p>
		Another potential for reference cycles is between the execution
		unit and the labels. A unit keeps a reference to all its labels. So the
		labels can not keep a reference to the unit. And they don't. Internally
		they have a plain C++ pointer to the unit. However the Perl level
		may present a problem.
		</p><p>
		In many cases 
		the labels have a Perl reference to the template object where they belong. 
		And that object is likely to have a Perl reference to the unit. It's one more
		opportunity for the reference cycle. This code usually looks like this:
		</p><pre class="programlisting">package MyTemplate;

sub new # ($class, $unit, $name, $rowType, ...)
{
  my $class = shift;
  my $unit = shift;
  my $name = shift;
  my $rowType = shift;
  my $self = {};

  ...

  $self-&gt;{unit} = $unit;
  $self-&gt;{inputLabel} = $unit-&gt;makeLabel($rowType, $name . ".in",
    sub { ... }, sub { ... }, $self);

  ...

  bless $self, $class;
  return $self;
}</pre><p>
		So the unit refers to the label at the C++ level, the label has a
		<code class="computeroutput">$self</code> reference to the Perl object that owns it, and 
		the object's <code class="computeroutput">$self-&gt;{unit}</code> refers back to the unit.
		Once the label clearing happens, the link from the unit will
		disappear and the cycle would unroll. But the clearing would not
		happen by itself because the unit can't get automatically
		defererenced and destroyed.
		</p><p>
		Because of this, the unit provides an explicit way to trigger the clearing:
		</p><pre class="programlisting">$unit-&gt;clearLabels();</pre><a class="indexterm" name="id466609"></a><a class="indexterm" name="id464135"></a><p>
		If you want to get rid of an execution unit with all its components
		without exiting the whole program, use this call. It will start the
		chain reaction of destruction. Of course, don't forget to undefine all the other
		references in your program to these objects being destroyed.
		</p><p>
		There is also a way to trigger this chain reaction automatically.
		It's done with a helper object that is created as follows:
		</p><pre class="programlisting">my $clearUnit = $unit-&gt;makeClearingTrigger();</pre><a class="indexterm" name="id503936"></a><p>
		When the reference to <code class="computeroutput">$clearUnit</code> gets destroyed, it
		will call <code class="computeroutput">$unit-&gt;clearLabels()</code> and trigger the destruction
		of the whole unit. Obviously, don't copy the <code class="computeroutput">$clearUnit</code>
		variable, keep it on one place.
		</p><p>
		If you put it into a block variable, the unit will get destroyed on
		exiting the block. If you put it into a global variable in a thread,
		the unit will get destroyed when the thread exits (though I'm a bit
		hazy on the Perl memoery management with threads yet, it might get
		all cleared by itself without any special tricks too).
		</p></div><div class="sect1" title="8.2. Clearing of the labels"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_memory_labels"></a>8.2. Clearing of the labels</h2></div></div></div><p>
		To remind, a label that executes the Perl code is created with:
		</p><a class="indexterm" name="id496823"></a><pre class="programlisting">$label = $unit-&gt;makeLabel($rowType, "name", \&amp;clearSub,
  \&amp;execSub, @args);</pre><p>
		The function <code class="computeroutput">clearSub</code> deals with the destruction. 
		</p><a class="indexterm" name="id496851"></a><a class="indexterm" name="id496865"></a><p>
		The clearing of a label drops all the references to <code class="computeroutput">execSub</code>, <code class="computeroutput">clearSub</code>
		and arguments, and clears all the chainings. And of course the chained
		labels get cleared too.  But before anything else
		is done, <code class="computeroutput">clearSub</code> gets a chance to execute and clear any
		application-level data. It gets as its arguments all the
		arguments from the label constructor, same as <code class="computeroutput">execSub</code>:
		</p><pre class="programlisting">clearSub($label, @args)</pre><p>
		A typical case is to keep the state of a stateful element in a hash:
		</p><pre class="programlisting">package MyTemplate;

sub new # ($class, $unit, $name, $rowType, ...)
{
  my $class = shift;
  my $unit = shift;
  my $name = shift;
  my $rowType = shift;
  my $self = {};

  ...

  $self-&gt;{unit} = $unit;
  $self-&gt;{inputLabel} = $unit-&gt;makeLabel($rowType, $name . ".in",
    \&amp;clear, \&amp;handle, $self);

  ...

  bless $self, $class;
  return $self;
}</pre><p>
		These elements may end up pointing to the other elements. It's fairly common to keep
		the pointers to the other elements (especially tables) that provide inputs to this one.
		In general, these references <span class="quote">&#8220;<span class="quote">up</span>&#8221;</span> should be safe because the clearing of the
		labels would destroy the references <span class="quote">&#8220;<span class="quote">down</span>&#8221;</span> and open the cycles.
		But the way things get connected in the heat of the moment, you never know.
		It's better to be safe than sorry.
		To be on the safe side, the clearing function can wipe out the whole state of the element
		by undefining its hash:
		</p><pre class="programlisting">sub clear # ($label, $self)
{
  my ($label, $self) = @_;
  undef %$self;
}</pre><p>
		The whole contents of the hash becomes lost, all the refrences from it disappear.
		And if you use this approach in every object, the complete destruction reigns
		and everything is nicely laid to waste.
		</p><p>
		Writing these clear methods for each class quickly becomes tedious and easy to
		forget. Triceps is a step ahead: it provides a ready function
		<code class="computeroutput">Triceps::clearArgs()</code> that does all this destruction. It can undefine
		the contents of various things passed as its arguments, and then also undefines
		these arguments themselves. Just reuse it:
		</p><pre class="programlisting">$self-&gt;{inputLabel} = $unit-&gt;makeLabel($rowType, $name . ".in",
  \&amp;Triceps::clearArgs, \&amp;handle, $self);</pre><p>
		But that's not all. Triceps is actually <span class="emphasis"><em>two</em></span> steps ahead. If the
		<code class="computeroutput">clearSub</code> is specified as <code class="computeroutput">undef</code>, Triceps automatically
		treats it to be <code class="computeroutput">Triceps::clearArgs()</code>. The last snippet and
		the following one are equivalent:
		</p><pre class="programlisting">$self-&gt;{inputLabel} = $unit-&gt;makeLabel($rowType, $name . ".in",
  undef, \&amp;handle, $self);</pre><p>
		No need to think, the default will do the right thing for you. Of course,
		if by some reason you don't want this destruction to happen, you'd have to
		override it with an empty function <span class="quote">&#8220;<span class="quote"><code class="computeroutput">sub {}</code></span>&#8221;</span>.
		</p></div><div class="sect1" title="8.3. The clearing labels"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_clearing_labels"></a>8.3. The clearing labels</h2></div></div></div><a class="indexterm" name="id501546"></a><p>
		Some templates don't have their own input labels, instead they just
		combine and tie together a few internal objects, and use the input
		labels of some of these internal objects as their inputs. Among
		the templates included with Triceps, JoinTwo is
		one of them, it just combines two LookupJoins. Without an input label,
		there would be no clearing, and the template object would never
		get undefined. 
		</p><p>
		This can be solved by creating an artificial label that is not connected
		anywhere and has no code to execute. Its only purpose in life would be
		to clear the object when told so.
		To make life easier, rather than abusing <code class="computeroutput">makeLabel()</code>,
		there is a way to create the special clearing-only labels:
		</p><pre class="programlisting">$lb = $unit-&gt;makeClearingLabel("name", @args);</pre><a class="indexterm" name="id498270"></a><p>
		The arguments would be the references to the objects that need clearing,
		usually <code class="computeroutput">$self</code>.  For a concrete usage example, here is how
		JoinTwo uses it:
		</p><pre class="programlisting">$self-&gt;{clearingLabel} = $self-&gt;{unit}-&gt;makeClearingLabel(
  $self-&gt;{name} . ".clear", $self);</pre><p>
		Since this call <span class="quote">&#8220;<span class="quote">should never fail</span>&#8221;</span>, on
		any errors it will confess. There is no need to check the result. The
		result can be saved in a variable or can be simply ignored. If you
		throw away the result, you won't be able to access that label from the
		Perl code but it won't be lost: it will be still referenced from the
		unit, until the unit gets cleared.
		</p><p>
		Note how the clearing label doesn't have a row type. In reality every
		label does how a row type, just it would be silly to abuse the random
		row types to create the clearing-only labels. Because of this, the
		clearing labels are created with a special empty row type that has no
		fields in it. If you ever want to use this row type for any other
		purposes, you can get it with the method
		</p><pre class="programlisting">$rt = $unit-&gt;getEmptyRowType();</pre><p>
		Under the hood, the clearing label is the same as a normal label
		with Perl code, only with the special default values used
		for its construction. The normal Perl label methods would work on
		it like on a normal label.
		</p><p>
		</p></div></div><div class="chapter" title="Chapter 9. Tables"><div class="titlepage"><div><div><h2 class="title"><a name="ch_tables"></a>Chapter 9. Tables</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_table_hello">9.1. Hello, tables!</a></span></dt><dt><span class="sect1"><a href="#sc_table_label">9.2. Tables and labels</a></span></dt><dt><span class="sect1"><a href="#sc_table_iteration">9.3. Basic iteration through the table</a></span></dt><dt><span class="sect1"><a href="#sc_table_delete">9.4. Deleting a row</a></span></dt><dt><span class="sect1"><a href="#sc_table_RowHandle">9.5. A closer look at the RowHandles</a></span></dt><dt><span class="sect1"><a href="#sc_table_fifo">9.6. A window is a FIFO</a></span></dt><dt><span class="sect1"><a href="#sc_table_secondary">9.7. Secondary indexes</a></span></dt><dt><span class="sect1"><a href="#sc_table_sorted">9.8. Sorted index</a></span></dt><dt><span class="sect1"><a href="#sc_table_ordered">9.9. Ordered index</a></span></dt><dt><span class="sect1"><a href="#sc_table_indextree">9.10. The index tree</a></span></dt><dt><span class="sect1"><a href="#sc_table_idx_intro">9.11. Table and index type introspection</a></span></dt><dt><span class="sect1"><a href="#sc_table_copy_tray">9.12. The copy tray</a></span></dt><dt><span class="sect1"><a href="#sc_table_wrapup">9.13. Table wrap-up</a></span></dt></dl></div><div class="sect1" title="9.1. Hello, tables!"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_hello"></a>9.1. Hello, tables!</h2></div></div></div><a class="indexterm" name="id474802"></a><p>
		The tables are the fundamental elements of state-keeping in Triceps. 
		Let's start with a basic example:
		</p><a class="indexterm" name="id489392"></a><pre class="programlisting">my $hwunit = Triceps::Unit-&gt;new("hwunit");
my $rtCount = Triceps::RowType-&gt;new(
  address =&gt; "string",
  count =&gt; "int32",
);

my $ttCount = Triceps::TableType-&gt;new($rtCount)
  -&gt;addSubIndex("byAddress",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "address" ])
  )
;
$ttCount-&gt;initialize();

my $tCount = $hwunit-&gt;makeTable($ttCount, "tCount");

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/\W+/);

  # the common part: find if there already is a count for this address
  my $rhFound = $tCount-&gt;findBy(
    address =&gt; $data[1]
  );
  my $cnt = 0;
  if (!$rhFound-&gt;isNull()) {
    $cnt = $rhFound-&gt;getRow()-&gt;get("count");
  }

  if ($data[0] =~ /^hello$/i) {
    my $new = $rtCount-&gt;makeRowHash(
      address =&gt; $data[1],
      count =&gt; $cnt+1,
    );
    $tCount-&gt;insert($new);
  } elsif ($data[0] =~ /^count$/i) {
    print("Received '", $data[1], "' ", $cnt + 0, " times\n");
  } else {
    print("Unknown command '$data[0]'\n");
  }
}</pre><p>
		What happens here? The main loop reads the lines from standard input, splits
		into words and uses
		the first word as a command and the second word as a key. Note that
		it's not CSV format, it's words with the non-alphanumeric characters separating
		the words. <span class="quote">&#8220;<span class="quote">Hello, table!</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">hello world</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">count world</span>&#8221;</span> are examples
		of the valid inputs. For someting different, the commands are compared
		with their case ignored (but the case matters for the key).
		</p><p>
		The example counts,
		how many times each key has been <code class="computeroutput">hello</code>-ed, and prints this count back
		on the command <code class="computeroutput">count</code>. Here is a sample, with the input
		lines printed in bold:
		</p><pre class="programlisting"><span class="bold"><strong>Hello, table!</strong></span>
<span class="bold"><strong>Hello, world!</strong></span>
<span class="bold"><strong>Hello, table!</strong></span>
<span class="bold"><strong>count world</strong></span>
Received 'world' 1 times
<span class="bold"><strong>Count table</strong></span>
Received 'table' 2 times</pre><a class="indexterm" name="id486332"></a><p>
		In this example the table is read and modified using the direct procedural calls.
		As you can see, there isn't even any need for unit scheduling and
		such. There is a scheduler-based interface to the tables too, it will be shown
		soon. But in many cases the direct access is easier. Indeed,
		this particular example could have been implemented with the plain Perl
		hashes. Nothing wrong with that either. Well, the Perl tables provide
		many more intersting ways of indexing the data. But if you don't need them,
		they don't matter. And at some future point the
		tables will be supporting the on-disk persistence, but no reason to
		bother much about that now: things are likely to change a dozen times
		yet before that happens. Feel free to just use the Perl data structures
		if they make the code easier.
		</p><p>
		A table is created through a table type. This allows to stamp out
		duplicate tables of the same type, which can get handy when the
		multithreading will be added. A table is local to a thread. A table
		type can be shared between threads. To look up
		something in another thread's table, you'd either have to ask it
		through a request-reply protocol or to keep a local copy of the table.
		Such a copy can be easily done by creating a copy table from the same type.
		</p><p>
		In reality, right now all the business with table types separated from
		the tables is more pain than gain. It not only adds extra steps but
		also makes difficult to define a template that acts on a table by
		defining extra features on it. Something will be done about it, I have
		a few ideas.
		</p><p>
		The table type gets first created and configured, then initialized.
		After a table type is initialized, it can not be changed any more.
		That's the point of the initialization call: tell the type that all
		the configuration has been done, and it can go immutable now. 
		Fundamentally, configuting a table type just makes it collect
		bits and pieces. Nothing but the most gross errors can be detected
		at that point. At initialization time everything comes together
		and everything gets checked for consistency.  A table
		type must be fully initialized in one thread before it can be shared
		with other threads. The historic reason for this API is that it mirrors
		the C++ API, which has turned out not to look that good in Perl. It's
		another candidate for a change. 
		</p><a class="indexterm" name="id510989"></a><p>
		A table type gets the row type and at least one index. Here it's a
		hashed index by the key field <code class="computeroutput">address</code>. "Hashed" means that
		you can look up the rows by the key value but there are no promises
		about any specific row order. And the hashing is used to make the
		key comparisons more efficient. The key of a hashed index may
		consist of multiple fields.
		</p><p>
		The table is then created from the table type, and given a name.
		</p><a class="indexterm" name="id511018"></a><p>
		The rows can then be inserted into the table (and removed too, not
		shown in this example yet). The default behavior of the hashed index is to
		replace the old row if a new row with the same key is inserted.
		</p><a class="indexterm" name="id511037"></a><a class="indexterm" name="id511050"></a><p>
		The search in the table is done by the method <code class="computeroutput">findBy()</code> with 
		the key fields of the index.  Which returns a RowHandle
		object. A RowHandle is essentially an iterator in the table. Even if
		the row is not found, a RowHandle will be still returned but it will be
		NULL, which is checked for by <code class="computeroutput">$rh-&gt;isNull()</code>.
		</p><p>
		No matter which command will be used, it's always useful to look up
		the previous row for the key: its contents would be either printed
		or provide the previous value for the increase. So the model does
		it first and gets the count from it. If it's not found, then the 
		count is set to 0. 
		</p><p>
		Then it looks at the command and does what it's been told.
		Updating the count amounts to creating a new row with the new
		values and inserting it into the table. It replaces the previous one.
		</p><p>
		This is just the tip of the iceberg. The tables in Triceps have a lot
		more features.
		</p></div><div class="sect1" title="9.2. Tables and labels"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_label"></a>9.2. Tables and labels</h2></div></div></div><a class="indexterm" name="id513347"></a><p>
		A table does not have to be operated in a procedural way. It can be
		plugged into the the scheduler machinery. Whenever a table is created,
		three labels are created with it.
		</p><a class="indexterm" name="id513361"></a><a class="indexterm" name="id513374"></a><div class="itemizedlist"><a class="indexterm" name="id513401"></a><ul class="itemizedlist" type="disc"><li class="listitem">
		The input label is for sending the modification rowops to the
		table. The table provides the handler for it that applies the
		incoming rowops to the table. 
		</li><li class="listitem">
		The output label propagates the
		modifications done to the table. It is a dummy label, and does
		nothing by itself. It's there for chaining the other labels to it. The
		output rowop comes quite handy to propagate the table's modifications
		to the rest of the state.
		</li><li class="listitem">
		The pre-modification label is also a dummy label, for chaining other
		labels to it. It sends the rowops right before they are applied
		to the table. This comes very handy for the elements that need to
		act depending on the previous state of the table, such as joins.
		The pre-modification label doesn't simply mirror the input label.
		The rows received on the input label may trigger the automatic changes
		to the table, such as an old row being deleted when a new row with
		the same key is inserted. All these modifications, be they automatic
		or explicit, will be reported to the pre-modification label.
		Since the pre-modification label is used relatively rarely, it contains
		a special optimization: if there is no label chained to it, no rowop
		will be sent to it in the first place. Don't be surprised if you
		enable the tracing and don't see it in the trace.
		</li></ul></div><a class="indexterm" name="id513423"></a><p>
		Again, the rowops coming through these labels aren't necessarily
		the same. If a DELETE rowop comes to the input label, referring to a
		row that is not in the table, it will not propagate anywhere. If an INSERT rowop
		comes in and causes another row to be replaced, the replaced row will
		be sent to the pre-modification and output labels as a DELETE rowop first.
		</p><p>
		Anf of course the table may be modified through the procedural
		interface. These modifications also produce rowops on the
		pre-modification and output labels.
		</p><p>
		The labels of the table have names. They are produced by adding
		suffixes to the table name. They are "tablename.in", "tablename.pre"
		and "tablename.out".
		</p><a class="indexterm" name="id513453"></a><a class="indexterm" name="id513467"></a><a class="indexterm" name="id513480"></a><a class="indexterm" name="id514145"></a><a class="indexterm" name="id514154"></a><p>
		In the <span class="quote">&#8220;<span class="quote">no bundling</span>&#8221;</span> spirit, a rowop is sent to the pre-modification
		label right before it's applied to the table, and to the output label
		right after it's applied. If the labels executed from there need to read the table,
		they can, and will find the table in the exact state with no intervening
		modifications. However, they can't modify the table neither directly nor
		by calling its input label. When these labels are called, the table is in
		the middle of a modification and it can't accept another one. Such attempts
		are treated as recursive modifications, forbidden, and the program 
		will die on them. If you need to modify
		the table, use <code class="computeroutput">schedule()</code> or <code class="computeroutput">loopAt()</code> to have the next modification done
		later. However there are no guarantees about other modifications getting
		done in between. When the looped rowop executes, it might need to check the state
		of the table again and decide if its operation still makes sense.
		</p><p>
		So, let's make a version of <span class="quote">&#8220;<span class="quote">Hello, table</span>&#8221;</span> example that passes the
		modification requests as rowops through the labels. It will print the information about
		the updates to the table as they happen, so there is no more use having a
		separate command for that. But for another demonstration let's add a
		command that would clear the counter of hellos.  Here is its code:
		</p><pre class="programlisting">my $hwunit = Triceps::Unit-&gt;new("hwunit");
my $rtCount = Triceps::RowType-&gt;new(
  address =&gt; "string",
  count =&gt; "int32",
);

my $ttCount = Triceps::TableType-&gt;new($rtCount)
  -&gt;addSubIndex("byAddress",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "address" ])
  )
;
$ttCount-&gt;initialize();

my $tCount = $hwunit-&gt;makeTable($ttCount, "tCount");

my $lbPrintCount = $hwunit-&gt;makeLabel($tCount-&gt;getRowType(),
  "lbPrintCount", undef, sub { # (label, rowop)
    my ($label, $rowop) = @_;
    my $row = $rowop-&gt;getRow();
    print(&amp;Triceps::opcodeString($rowop-&gt;getOpcode), " '",
      $row-&gt;get("address"), "', count ", $row-&gt;get("count"), "\n");
  } );
$tCount-&gt;getOutputLabel()-&gt;chain($lbPrintCount);

# the updates will be sent here, for the tables to process
my $lbTableInput = $tCount-&gt;getInputLabel();

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/\W+/);

  # the common part: find if there already is a count for this address
  my $rhFound = $tCount-&gt;findBy(
    address =&gt; $data[1]
  );
  my $cnt = 0;
  if (!$rhFound-&gt;isNull()) {
    $cnt = $rhFound-&gt;getRow()-&gt;get("count");
  }

  if ($data[0] =~ /^hello$/i) {
    $hwunit-&gt;makeHashSchedule($lbTableInput, "OP_INSERT",
      address =&gt; $data[1],
      count =&gt; $cnt+1,
    );
  } elsif ($data[0] =~ /^clear$/i) {
    $hwunit-&gt;makeHashSchedule($lbTableInput, "OP_DELETE",
      address =&gt; $data[1]
    );
  } else {
    print("Unknown command '$data[0]'\n");
  }
  $hwunit-&gt;drainFrame();
}</pre><p>
		The table creation is the same as last time. 
		The row finding in the table is also the same.
		</p><p>
		The printing of the modifications to the table is done with <code class="computeroutput">$lbPrintCount</code>,
		which is connected to the table's output label. It prints the opcode,
		the address of the greeting, and the count of greetings. It will
		show us what is happening to the table as soon as it happens.
		An unit trace could be used instead but a custom printout contains
		less noise.
		The pre-modification label is of no interest here, so it's not used.
		</p><p>
		The references to the labels of a table are gotten with:
		</p><pre class="programlisting">$label = $table-&gt;getInputLabel();
$label = $table-&gt;getPreLabel();
$label = $table-&gt;getOutputLabel();</pre><p>
		The deletion does not require an exact row to be sent in. All it needs
		is a row with the keys for deletion, the rest of the fields in it
		are ignored. So the <span class="quote">&#8220;<span class="quote">clear</span>&#8221;</span> command puts only the key field in it.
		</p><p>
		Here is an example of input (in bold) and output:
		</p><pre class="programlisting"><span class="bold"><strong>Hello, table!</strong></span>
OP_INSERT 'table', count 1
<span class="bold"><strong>Hello, world!</strong></span>
OP_INSERT 'world', count 1
<span class="bold"><strong>Hello, table!</strong></span>
OP_DELETE 'table', count 1
OP_INSERT 'table', count 2
<span class="bold"><strong>clear, table</strong></span>
OP_DELETE 'table', count 2
<span class="bold"><strong>Hello, table!</strong></span>
OP_INSERT 'table', count 1</pre><p>
		An interesting thing happens after the second <span class="quote">&#8220;<span class="quote">Hello, table!</span>&#8221;</span>: the code
		send only an <code class="computeroutput">OP_INSERT</code> but the output shows an <code class="computeroutput">OP_DELETE</code> and <code class="computeroutput">OP_INSERT</code>.
		The <code class="computeroutput">OP_DELETE</code> for the old row gets automatically generated when a
		row with repeated key is inserted. 
		Now, depending on what you want, just sending in the first place the consequent inserts of
		rows with the same keys, and relying on the table's internal
		consistency to turn them into updates, might be a good thing or not.
		Overall it's a dirty way to write but sometimes it comes convenient.
		The clean way is to send the explicit deletes first. When the data
		goes through the table, it gets automatically cleaned.
		The subscribers to the table's output and pre-modification labels
		get the clean and consistent picture: a row never gets simply replaced, they
		always see an <code class="computeroutput">OP_DELETE</code> first and only then an <code class="computeroutput">OP_INSERT</code>.
		</p></div><div class="sect1" title="9.3. Basic iteration through the table"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_iteration"></a>9.3. Basic iteration through the table</h2></div></div></div><p>
		Let's add a dump of the table contents to the "Hello, table" example,
		either version of it. For that, the code needs to go through every record
		in the table:
		</p><pre class="programlisting">  elsif ($data[0] =~ /^dump$/i) {
    for (my $rhi = $tCount-&gt;begin(); !$rhi-&gt;isNull(); $rhi = $rhi-&gt;next()) {
      print($rhi-&gt;getRow-&gt;printP(), "\n");
    }
  }</pre><a class="indexterm" name="id514365"></a><p>
		As you can see, the row handle works kind of like an STL iterator.
		Only the end of iteration is detected by receiving a NULL row handle.
		Calling <code class="computeroutput">next()</code> on a NULL row handle is OK but it would just return
		another NULL handle.
		And there is no decrementing the iterator, you can only go forward
		with <code class="computeroutput">next()</code>. The backwards iteration is in the plans but
		not implemented yet.
		</p><p>
		An example of this fragment's output would be:
		</p><pre class="programlisting"><span class="bold"><strong>Hello, table!</strong></span>
<span class="bold"><strong>Hello, world!</strong></span>
<span class="bold"><strong>Hello, table!</strong></span>
<span class="bold"><strong>count world</strong></span>
Received 'world' 1 times
<span class="bold"><strong>Count table</strong></span>
Received 'table' 2 times
<span class="bold"><strong>dump</strong></span>
address="world" count="1"
address="table" count="2"</pre><p>
		The order of the rows in the printout is the same as the order of rows
		in the table's index. Which is no particular order, since it's a hashed
		index. As long as you stay with the same 64-bit AMD64 architecture
		(with LSB-first byte order), it will stay the same on consecutive runs.
		But switching to a 32-bit machine or to an MSB-first byte order (such
		as a SPARC, if you can still find one) will change the hash
		calculation, and with it the resulting row order. There are the
		ordered indexes as well, they will be described later.
		</p></div><div class="sect1" title="9.4. Deleting a row"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_delete"></a>9.4. Deleting a row</h2></div></div></div><p>
		Deleting a row from a table through the input label is simple: send a
		rowop with <code class="computeroutput">OP_DELETE</code>, it will find the row with the matching key 
		and delete it, as was shown above.
		In the procedural way the same can be done with the method
		<code class="computeroutput">deleteRow()</code>. The added row deletion code for the main loop of 
		<span class="quote">&#8220;<span class="quote">Hello, table</span>&#8221;</span> (either version, but particularly relevant
		for the one from
		<a class="xref" href="#sc_table_hello" title="9.1. Hello, tables!">Section 9.1: &#8220;Hello, tables!&#8221; </a>)
		is:
		</p><pre class="programlisting">  elsif ($data[0] =~ /^delete$/i) {
    my $res = $tCount-&gt;deleteRow($rtCount-&gt;makeRowHash(
      address =&gt; $data[1],
    ));
    print("Address '", $data[1], "' is not found\n") unless $res;
  }</pre><a class="indexterm" name="id514498"></a><a class="indexterm" name="id514508"></a><a class="indexterm" name="id514521"></a><p>
		The result allows to differentiate between the situations when the 
		row was found and deleted and the row was not found.
		On any error the call confesses.
		</p><p>
		However we already find the row handle in advance in <code class="computeroutput">$rhFound</code>. For this case a more
		efficient form is available, and it can be added to the example as:
		</p><pre class="programlisting">    elsif ($data[0] =~ /^remove$/i) {
      if (!$rhFound-&gt;isNull()) {
        $tCount-&gt;remove($rhFound);
      } else {
        print("Address '", $data[1], "' is not found\n");
      }
    }</pre><p>
		It removes a specific row handle from the table. In whichever way you
		find it, you can remove it. An attempt to remove a NULL handle would be
		an error and cause a confession.
		</p><p>
		The reason why <code class="computeroutput">remove()</code> is more efficient than <code class="computeroutput">deleteRow()</code> is
		that <code class="computeroutput">deleteRow()</code> amounts to finding the row handle by key and then
		removing it. And the <code class="computeroutput">OP_DELETE</code> rowop sent to the input label
		calls <code class="computeroutput">deleteRow()</code>.
		</p><p>
		<code class="computeroutput">deleteRow()</code> never deletes more than one row, even if multiple
		rows match (yes, the indexes don't have to be unique).
		There isn't any method to delete multiple rows at once. Every row has
		to be deleted by itself.
		As an example, here is the implementation of the command <span class="quote">&#8220;<span class="quote">clear</span>&#8221;</span> for
		<span class="quote">&#8220;<span class="quote">Hello, table</span>&#8221;</span> that clears all the table contents by
		iterating through it:
		</p><pre class="programlisting">  elsif ($data[0] =~ /^clear$/i) {
    my $rhi = $tCount-&gt;begin();
    while (!$rhi-&gt;isNull()) {
      my $rhnext = $rhi-&gt;next();
      $tCount-&gt;remove($rhi);
      $rhi = $rhnext;
    }
  }</pre><a class="indexterm" name="id514627"></a><p>
		After a handle is removed from the table, it continues to exist, as
		long as there are references to it. It could even be inserted back into
		the table. However until (and unless) it's inserted back, it can not be
		used for iteration any more. Calling <code class="computeroutput">next()</code> on a handle that
		is not in the table would just return a NULL handle. So the next row has
		to be found before removing the current one.
		</p></div><div class="sect1" title="9.5. A closer look at the RowHandles"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_RowHandle"></a>9.5. A closer look at the RowHandles</h2></div></div></div><a class="indexterm" name="id514664"></a><p>
		A few uses of the RowHandles have been shown by now. So, what is a
		RowHandle? As Captain Obvious would say, RowHandle is a class (or
		package, in Perl terms) implementing a row handle.
		</p><p>
		A row handle keeps a table's service information (including the index
		data) for a single data row, including of course a reference to the row
		itself. Each row is stored in the table through its handle. 
		The row handle is also an iterator in the table, and a special one:
		it's an iterator for <span class="emphasis"><em>all</em></span> the table's indexes at once.
		For you SQLy people, an iterator is essentially a cursor on an index.
		For you Java people, an iterator can be used to do more than step
		sequentially through rows.
		So far only the table types with one index have been shown, but
		in reality multiple indexes are supported, potentially with quite
		complicated arrangements. More on the indexes later, for now just keep
		it in mind.  A row handle can be found through one index and then used
		to iterate through another one. Or you can iterate through one index,
		find a certain row handle and continue iterating through another index
		starting from that handle. If you remember a reference on a particular
		row handle, you can always continue iteration from that point later.
		(unless the row handle gets removed from the table).
		</p><p>
		A RowHandle
		always belongs to a particular table, the RowHandles can not be shared
		nor moved between two tables, even if the tables are of the same type.
		Since the tables are single-threaded, obviously the RowHandles may not
		be shared between the threads either.
		</p><p>
		However a RowHandle may exist without being inserted into a table. In
		this case it still has a spiritual connection to that table but is not
		included in the index (the iteration attempts with it would just return 
		<span class="quote">&#8220;<span class="quote">end of the index</span>&#8221;</span>), and will be destroyed as soon as all the
		references to it disappear.
		</p><p>
		The insertion of a row into a table actually happens in two steps:
		</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
		A RowHandle is created for a row.
		</li><li class="listitem">
		This new handle is inserted into the table.
		</li></ol></div><p>
		This is done with the following code:
		</p><pre class="programlisting">$rh = $table-&gt;makeRowHandle($row);
$table-&gt;insert($rh);</pre><a class="indexterm" name="id514738"></a><p>
		Only it just so happens that to make life easier, the method
		<code class="computeroutput">insert()</code> has been made to accept either a row handle or
		directly a row. If it finds a row, it makes a handle for it behind the
		curtains and then proceeds with the insertion of that handle. Passing a
		row directly is also more efficient (if you don't have a handle already
		created for it for some other reason) because the row handle creation
		then happens entirely in the C++ code, without surfacing into Perl.
		</p><p>
		A handle can be created for any row of a type matching the table's
		row type. For a while it was accepting only equal types but that
		was not consistent with what the labels are doing, so I've changed it.
		</p><a class="indexterm" name="id514770"></a><a class="indexterm" name="id514780"></a><p>
		The method <code class="computeroutput">insert()</code> has a return value. It's often ignored but occasionally
		comes handy.  1 means that the row has been inserted successfully, and
		0 means that the row has been rejected. On errors it confesses.
		An attempt to insert a NULL handle or a handle that is already in the
		table will cause a rejection, not an error.
		Also the table's index may reject a row with duplicate key (though
		right now this option is not implemented, and the hash index silently
		replaces the old row with the new one).
		</p><p>
		There is a method to find out if a row handle is in the table or not:
		</p><pre class="programlisting">$result = $rh-&gt;isInTable();</pre><p>
		Though it's used mostly for debugging, when some strange things start going on.
		</p><a class="indexterm" name="id514820"></a><p>
		The searching for rows in the table by key has been previously shown with the
		method <code class="computeroutput">findBy()</code>. Which happens to be a wrapper over a more general method
		<code class="computeroutput">find()</code>: it constructs a row from its argument fields and then calls
		<code class="computeroutput">find()</code> with that row as a sample of data to find.
		The method <code class="computeroutput">find()</code> is similar to <code class="computeroutput">insert()</code> in the
		handling of its arguments: the <span class="quote">&#8220;<span class="quote">proper</span>&#8221;</span> way is to give
		it a row handle argument, but the more efficient way is to give it a 
		row argument, and it will create the handle for it as needed before
		performing a search.
		</p><p>
		Now you might wonder: huh, <code class="computeroutput">find()</code> takes a row handle and returns a row
		handle? What's the point? Why not just use the first row handle? Well,
		those are different handles:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		The argument handle is normally not in the table. It's created brand
		new from a row that contains the keys that you want to find, just for
		the purpose of searching.
		</li><li class="listitem">
		The returned handle is always in the table (of course, unless it's
		NULL). It can be further used to extract back the row data, and/or for
		iteration.
		</li></ul></div><p>
		Though nothing really prevents you from searching for a handle that is
		already in the table. You'll just get back the same handle, after
		gratuitously spending some CPU time. (There are exceptions to this,
		with the more complex indexes that will be described later).
		</p><p>
		Why do you need to create new a row handle just for the search? Due to
		the internal mechanics of the implementation. A handle stores the
		helper information for the index. For example, the hash index
		calculates the hash value of all the row's key fields once and
		stores it in the row handle. Despite it being called a hash index, it
		really stores the data in a tree, with the hash value used to speed up
		the comparisons for the tree order. It's much easier to make both the
		<code class="computeroutput">insert()</code> and <code class="computeroutput">find()</code> work with the hash value and row reference
		stored in the same way in a handle than to implement them differently. Because of
		this, <code class="computeroutput">find()</code> uses the exactly same row handle argument format as
		<code class="computeroutput">insert()</code>.
		</p><p>
		Can you create multiple row handles referring to the same row? Sure,
		knock yourself out. From the table's perspective it's the same thing as
		multiple row handles for multiple copies of the row with the same values
		in them, only using less memory.
		</p><p>
		There is more to the row handles than has been touched upon yet. It
		will all be revealed when more of the table features are described.
		The internal structure of the row handles will be described in the
		<a class="xref" href="#sc_table_indextree" title="9.10. The index tree">Section 9.10: &#8220;The index tree&#8221; </a>.
		</p></div><div class="sect1" title="9.6. A window is a FIFO"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_fifo"></a>9.6. A window is a FIFO</h2></div></div></div><a class="indexterm" name="id514965"></a><a class="indexterm" name="id514975"></a><p>
		A fairly typical situation in the CEP world is when a model needs to
		keep a limited history of events. For a simple example, let's discuss,
		how to remember the last two trades per stock symbol. The size of two
		has been chosen to keep the sample input and outputs small.
		</p><p>
		This is normally called a window logic, with a sliding window. You can
		think of it in a mechanical analogy: as the trades become available,
		they get printed on a long tape. However the tape is covered with a
		masking plate. The plate has a window cut in it that lets you see only
		the last two trades.
		</p><a class="indexterm" name="id514997"></a><p>
		Some CEP systems have the special data structures that implement this
		logic, that are called windows. Triceps has a feature on a table
		instead that makes a table work as a window. It's not unique in this
		department: for example Coral8 does the opposite, calls everything a
		window, even if some windows are really tables in every regard but
		name.
		</p><p>
		Here is a Triceps example of keeping the window for the last two trades
		and iteration over it:
		</p><pre class="programlisting">our $uTrades = Triceps::Unit-&gt;new("uTrades");
our $rtTrade = Triceps::RowType-&gt;new(
  id =&gt; "int32", # trade unique id
  symbol =&gt; "string", # symbol traded
  price =&gt; "float64",
  size =&gt; "float64", # number of shares traded
);

our $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
      -&gt;addSubIndex("last2",
        Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
      )
  )
;
$ttWindow-&gt;initialize();
our $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");

# remember the index type by symbol, for searching on it
our $itSymbol = $ttWindow-&gt;findSubIndex("bySymbol");
# remember the FIFO index, for finding the start of the group
our $itLast2 = $itSymbol-&gt;findSubIndex("last2");

# print out the changes to the table as they happen
our $lbWindowPrint = $uTrades-&gt;makeLabel($rtTrade, "lbWindowPrint",
  undef, sub { # (label, rowop)
    print($_[1]-&gt;printP(), "\n"); # print the change
  });
$tWindow-&gt;getOutputLabel()-&gt;chain($lbWindowPrint);

while(&lt;STDIN&gt;) {
  chomp;
  my $rTrade = $rtTrade-&gt;makeRowArray(split(/,/));
  my $rhTrade = $tWindow-&gt;makeRowHandle($rTrade);
  $tWindow-&gt;insert($rhTrade);
  # There are two ways to find the first record for this
  # symbol. Use one way for the symbol AAA and the other for the rest.
  my $rhFirst;
  if ($rTrade-&gt;get("symbol") eq "AAA") {
    $rhFirst = $tWindow-&gt;findIdx($itSymbol, $rTrade);
  } else  {
    # $rhTrade is now in the table but it's the last record
    $rhFirst = $rhTrade-&gt;firstOfGroupIdx($itLast2);
  }
  my $rhEnd = $rhFirst-&gt;nextGroupIdx($itLast2);
  print("New contents:\n");
  for (my $rhi = $rhFirst;
      !$rhi-&gt;same($rhEnd); $rhi = $rhi-&gt;nextIdx($itLast2)) {
    print("  ", $rhi-&gt;getRow()-&gt;printP(), "\n");
  }
}</pre><p>
		This example reads the trade records in CSV format, inserts them into
		the table, and then prints the actual modifications reported by the
		table and the new state of the window for this symbol. And here is a sample
		log, with the input lines in bold:
		</p><pre class="programlisting"><span class="bold"><strong>1,AAA,10,10</strong></span>
tWindow.out OP_INSERT id="1" symbol="AAA" price="10" size="10"
New contents:
  id="1" symbol="AAA" price="10" size="10"
<span class="bold"><strong>2,BBB,100,100</strong></span>
tWindow.out OP_INSERT id="2" symbol="BBB" price="100" size="100"
New contents:
  id="2" symbol="BBB" price="100" size="100"
<span class="bold"><strong>3,AAA,20,20</strong></span>
tWindow.out OP_INSERT id="3" symbol="AAA" price="20" size="20"
New contents:
  id="1" symbol="AAA" price="10" size="10"
  id="3" symbol="AAA" price="20" size="20"
<span class="bold"><strong>4,BBB,200,200</strong></span>
tWindow.out OP_INSERT id="4" symbol="BBB" price="200" size="200"
New contents:
  id="2" symbol="BBB" price="100" size="100"
  id="4" symbol="BBB" price="200" size="200"
<span class="bold"><strong>5,AAA,30,30</strong></span>
tWindow.out OP_DELETE id="1" symbol="AAA" price="10" size="10"
tWindow.out OP_INSERT id="5" symbol="AAA" price="30" size="30"
New contents:
  id="3" symbol="AAA" price="20" size="20"
  id="5" symbol="AAA" price="30" size="30"
<span class="bold"><strong>6,BBB,300,300</strong></span>
tWindow.out OP_DELETE id="2" symbol="BBB" price="100" size="100"
tWindow.out OP_INSERT id="6" symbol="BBB" price="300" size="300"
New contents:
  id="4" symbol="BBB" price="200" size="200"
  id="6" symbol="BBB" price="300" size="300"</pre><a class="indexterm" name="id515095"></a><a class="indexterm" name="id515109"></a><p>
		You can see that the window logic works: at no time is there
		more than two rows in each group. As more rows are inserted,
		the oldest rows get deleted.
		</p><a class="indexterm" name="id515127"></a><a class="indexterm" name="id515140"></a><p>
		Now let's dig into the code.
		The first thing to notice is that the table type has two
		indexes (strictly speaking, index types, but most of the time
		they can be called indexes without creating a confusion) in it. Unlike
		your typical database, the indexes in this example are nested.
		</p><pre class="programlisting">TableType
+-IndexType Hash "bySymbol"
  +-IndexType Fifo "last2"</pre><p>
		If you follow the nesting, you can see, that the first call <code class="computeroutput">addSubIndex()</code>
		adds an index type to the table type, while the textually second
		<code class="computeroutput">addSubIndex()</code> adds an index to the previous index.
		</p><p>
		The same can also be written out in multiple separate calls,
		with the intermediate results stored in the variables:
		</p><pre class="programlisting">$itLast2 = Triceps::IndexType-&gt;newFifo(limit =&gt; 2);
$itSymbol = Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ]);
$itSymbol-&gt;addSubIndex("last2", $itLast2);
$ttWindow = Triceps::TableType-&gt;new($rtTrade);
$ttWindow-&gt;addSubIndex("bySymbol", $itSymbol);</pre><p>
		I'm not perfectly happy with the way the table types are constructed
		with the index types right now, since the parenthesis levels have
		turned out a bit hard to track. This is another example of following
		the C++ API in Perl that didn't work out too well, and it will change
		in the future. But for now please bear with it.
		</p><p>
		The index nesting is kind of intuitively clear, but the details may
		take some time to get your head wrapped around them. You can think of
		it as the inner index type creating the miniature tables that hold the
		rows, and then the outer index holding not individual rows but those
		miniature tables. So, to find the rows in the table you go through two
		levels of indexes: first through the outer index, and then through the
		inner one. The table takes care of these details and makes them
		transparent, unless you want to stop your search at an intermediate
		level: such as, to find <span class="emphasis"><em>all</em></span> the transactions with a given
		symbol, you need to do a search in the outer index, but then from that
		point iterate through all rows in the found inner index. For this you
		obviously have to tell the table, where do you want to stop in
		the search.
		</p><a class="indexterm" name="id515216"></a><p>
		The outer index is the hash index that we've seen before, the inner
		index is a FIFO index. A FIFO index doesn't have any key, it just keeps
		the rows in the order they were inserted. You can search in a FIFO
		index but most of the time it's not the best idea: since it has no
		keys, it searches linearly through all its rows until it finds an exact
		match (or runs out of rows). It's a reasonable last-resort way but it's
		not fast and in many cases not what you want. This also sends
		a few ripples through the row deletion. Remember that the method
		<code class="computeroutput">deleteRow()</code> and sending the <code class="computeroutput">OP_DELETE</code> to the table's input label invoke
		<code class="computeroutput">find()</code>, which would cause the linear search on the FIFO indexes. So
		when you use a FIFO index, it's usually better to find the row handle
		you want to delete in some other way and then call <code class="computeroutput">remove()</code> on it, or
		use another approach that will be shown later. Or just keep inserting
		the rows and never delete them, like this example does.
		</p><p>
		A FIFO index may contain multiple copies of an exact same
		row. It doesn't care, it just keeps whatever rows were given to it in
		whatever order they were given. 
		</p><p>
		By default a FIFO index just keeps whatever rows come to it. However it
		may have a few options. Setting the option <code class="computeroutput">limit</code> limits the number of
		rows stored in the index (not per the whole table but per one of those
		<span class="quote">&#8220;<span class="quote">miniature tables</span>&#8221;</span>). When you try to insert one row too many, the oldest
		row gets thrown out, and the limit stays unbroken. That's what creates
		the window behavior: keep the most recent N rows.
		</p><p>
		If you look at the sample output, you can see that inserting the rows
		with ids 1-4 generates only the insert events on the table. But the
		rows 5 and 6 start overflowing their FIFO indexes, and cause the oldest
		row to be automatically deleted before completing the insert of the new
		one.
		</p><p>
		A FIFO index doesn't have to be nested inside a hash index. If you put
		a FIFO index at the top level, it will control the whole table. So it
		would be not two last record per key but two last records inserted in the
		whole table.
		</p><a class="indexterm" name="id515298"></a><a class="indexterm" name="id515311"></a><p>
		Continuing with the example, the table gets created, and then the index
		types get extracted back from the table type. Now, why not just write
		out the table type creation with intermediate variables 
		as shown above and remember the index
		references? At some point in the past this actually would have worked
		but not any more. It has to do with the way the table type and its
		index types are connected. It's occasionally convenient to create one
		index type and then reuse it in multiple table types. However for the
		whole thing to work, the index type must be tied to its particular
		table type. This tying together happens when the table type is
		initialized. If you put the same index type into two table types, then when
		the first table type is initialized, the index type will get tied to
		it. The second table type would then fail to initialize because an
		index in it is already tied elsewhere. To get around this
		dilemma, now when you call <code class="computeroutput">addSubIndex()</code>, it doesn't connect the
		original index type, instead it makes a copy of it. That copy then gets
		tied with the table type and later gets returned back with <code class="computeroutput">findSubIndex()</code>.
		</p><p>
		The table methods that take an index type argument
		absolutely require that the index type must be tied to that table's type. If
		you try to pass a seemingly the same index type that has not been tied,
		or has been tied to a different table type, that is an error. 
		</p><p>
		One last note on this subject: there is
		no interdependency between the methods <code class="computeroutput">makeTable()</code> and <code class="computeroutput">findSubIndex()</code>,
		they can be done in either order.
		</p><p>
		The example output comes from two sources. The running updates on the table's
		modifications (the lines with <code class="computeroutput">OP_INSERT</code> and <code class="computeroutput">OP_DELETE</code>) are printed from the label
		<code class="computeroutput">$lbWindowPrint</code>. The new window contents is printed from the main loop.
		</p><p>
		The main loop reads the trade records in the simple
		CSV format without the opcode, and for simplicity inserts directly 
		into the table with the procedural API, bypassing
		the scheduler. After the row is inserted, the contents of its index
		group (that <span class="quote">&#8220;<span class="quote">miniature table</span>&#8221;</span>) gets printed. The insertion could as
		well have been done with passing directly the row reference, without
		explicitly creating a handle. But that handle will be used to
		demonstrate an interesting point.
		</p><a class="indexterm" name="id515405"></a><a class="indexterm" name="id515418"></a><p>
		To print the contents of an index group, we need to find its
		boundaries. In Triceps these boundaries are expressed as the first row
		handle of the group, and as the row handle right after the group. There
		is an internal logic to that, and it will be explained later, but for
		now just take it on faith.
		</p><p>
		With the information we have, there are two ways to find the first row of the group:
		</p><a class="indexterm" name="id515442"></a><a class="indexterm" name="id515456"></a><div class="itemizedlist"><a class="indexterm" name="id515520"></a><ul class="itemizedlist" type="disc"><li class="listitem">
		With the table's method <code class="computeroutput">findIdx()</code>. It's very much like <code class="computeroutput">find()</code>, only it
		has an extra argument of a specific index type. If the index type given
		has no further nesting in it, <code class="computeroutput">findIdx()</code> works exactly like <code class="computeroutput">find()</code>. In
		fact, <code class="computeroutput">find()</code> is exactly such a special case of <code class="computeroutput">findIdx()</code> with an
		automatically chosen index type. If you use an index type with further nesting
		under it, <code class="computeroutput">findIdx()</code> will return the handle of the first row in the
		group under it (or the usual NULL row handle if not found).
		</li><li class="listitem">
		If we create the row handle explicitly before inserting it into the
		table, as was done in the example, that will be the exact row handle
		inserted into the table. Not a copy or anything but this particular row
		handle. After a row handle gets inserted into the table, it knows its
		position in the indexes. It knows, in which group it is.
		And we still have a reference to it. So then
		we can use this knowledge to navigate within the group, 
		jump to the first row handle in the group
		with <code class="computeroutput">firstOfGroupIdx()</code>. It also takes an index type but in this case
		it's the type that controls the group, the FIFO index in out case.
		</li></ul></div><p>
		The example shows both ways. As a demonstration, it uses the first way
		if the symbol is <span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span> and the second way for all the other symbols.
		</p><a class="indexterm" name="id515553"></a><p>
		The end boundary is found by calling <code class="computeroutput">nextGroupIdx()</code> on the first row's
		handle. The handle of the newly inserted row could have also been used for
		<code class="computeroutput">nextGroupIdx()</code>, or any other handle in the group. For any
		handle belonging to the same group, the result is exactly the same.
		</p><p>
		And finally, after the iteration boundaries have been found,
		the iteration on the group can run. The end
		condition comparison is done with <code class="computeroutput">same()</code>, to compare the row
		handle references and not just their Perl-level wrappers. The stepping
		is done with <code class="computeroutput">nextIdx()</code>, with is exactly like <code class="computeroutput">next()</code> but according to a
		particular index, the FIFO one. This has actually been done purely to
		show off this method. In this particular case the result produced by
		<code class="computeroutput">next()</code>, <code class="computeroutput">nextIdx()</code> on the FIFO index type and <code class="computeroutput">nextIdx()</code> on 
		the outer hash index type is exactly the same. We'll come to the reasons of
		that yet.
		</p><a class="indexterm" name="id515627"></a><p>
		Looking forward, as you iterate through the group, you could do some manual aggregation
		along the way. For example, find the average price of the last two
		trades, and then do something useful with it.
		</p><p>
		There is also a piece of information that you can find without iteration:
		the size of the group.
		</p><a class="indexterm" name="id515647"></a><pre class="programlisting">$size = $table-&gt;groupSizeIdx($idxType, $row_or_rh);</pre><p>
		This information is important for the joins, and iterating every time through the
		group is inefficient if all you want to get is the group size. Since when you need
		this data you usually have the row and not the row handle, this operation
		accepts either and implicitly performs a <code class="computeroutput">findIdx()</code> on the row to find the
		row handle. Moreover, even if it receives the argument of a row handle that
		is not in the table, it will also automatically perform a <code class="computeroutput">findIdx()</code> on it
		(though calling it for a row handle in
		the table is more efficient because the group would not need to be
		looked up first). 
		</p><p>
		If there is no such group in the table, the result will be 0. 
		</p><p>
		The <code class="computeroutput">$idxType</code> argument is the non-leaf parent index of the group. (Using a
		leaf index type is not an error but it always returns 0, because there
		are no groups under it). It's basically the same index type as you
		would use in <code class="computeroutput">findIdx()</code> to find the first row of the group
		or in <code class="computeroutput">firstOfGroupIdx()</code> or <code class="computeroutput">nextGroupIdx()</code> to find the boundaries
		of thr group.
		Remember, a non-leaf
		index type defines the groups, and the nested index types under it
		define the order in those groups (and possibly further break them down
		into sub-groups).
		</p><p>
		It's a bit confusing, so let's recap with another example.
		If you have a table type defined as:
		</p><pre class="programlisting">our $ttPosition = Triceps::TableType-&gt;new($rtPosition)
  -&gt;addSubIndex("primary",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date", "customer", "symbol" ])
  )
  -&gt;addSubIndex("currencyLookup", # for joining with currency conversion
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date", "currency" ])
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
  -&gt;addSubIndex("byDate", # for cleaning by date
    Triceps::SimpleOrderedIndex-&gt;new(date =&gt; "ASC")
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
;</pre><p>
		then it would make sense to call <code class="computeroutput">groupSizeIdx()</code>, 
		<code class="computeroutput">firstOfGroupIdx()</code> and <code class="computeroutput">nextGroupIdx()</code>
		with the indexes
		<span class="quote">&#8220;<span class="quote">currencyLookup</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">byDate</span>&#8221;</span> 
		but not with <span class="quote">&#8220;<span class="quote">primary</span>&#8221;</span>,
		<span class="quote">&#8220;<span class="quote">currencyLookup/grouping</span>&#8221;</span> nor <span class="quote">&#8220;<span class="quote">byDate/grouping</span>&#8221;</span>.  You can call
		<code class="computeroutput">findIdx()</code> with any index, but for
		<span class="quote">&#8220;<span class="quote">currencyLookup</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">byDate</span>&#8221;</span> it would return the first row of the group
		while for
		<span class="quote">&#8220;<span class="quote">primary</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">currencyLookup/grouping</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">byDate/grouping</span>&#8221;</span>
		it would return the only matching row. On the other hand, for iteration in a group, it makes
		sense to call <code class="computeroutput">nextIdx()</code> only on 
		<span class="quote">&#8220;<span class="quote">primary</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">currencyLookup/grouping</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">byDate/grouping</span>&#8221;</span>.
		Calling <code class="computeroutput">nextIdx()</code> on the non-leaf index types is not an error
		but it would in effect resolve to the same thing as using their
		first leaf sub-indexes.
		</p></div><div class="sect1" title="9.7. Secondary indexes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_secondary"></a>9.7. Secondary indexes</h2></div></div></div><p>
		The last example dealt only with the row inserts, because it could not
		handle the deletions that well. What if the trades may get cancelled
		and have to be removed from the table? There is a solution to this
		problem: add one more index. Only this time not nested but in parallel.
		The indexes in the table type become tree-formed:
		</p><a class="indexterm" name="id515846"></a><a class="indexterm" name="id515860"></a><a class="indexterm" name="id515873"></a><pre class="programlisting">TableType
+-IndexType Hash "byId" (id)
+-IndexType Hash "bySymbol" (symbol)
  +-IndexType Fifo "last2"</pre><p>
		It's very much like the common relational databases where you can
		define multiple indexes on the same table. Both indexes <code class="computeroutput">byId</code> and
		<code class="computeroutput">bySymbol</code> (together with its nested sub-index) refer to the same
		set of rows stored in the table. Only <code class="computeroutput">byId</code> allows to easily find
		the records by the unique id, while <code class="computeroutput">bySymbol</code> is responsible for
		keeping then grouped by the symbol, in FIFO order. It could be said
		that <code class="computeroutput">byId</code> is the primary index (since it has a unique key) and
		<code class="computeroutput">bySymbol</code> is a secondary one (since it does the grouping) but
		from the Triceps'es standpoint they are pretty much equal and parallel
		to each other.
		</p><a class="indexterm" name="id515937"></a><p>
		To illustrate the point, here is a modified version of the previous
		example. Not only does it manage the deletes but also computes the
		average price of the collected transactions as it iterates through
		the group, thus performing a manual aggregation.
		</p><pre class="programlisting">our $uTrades = Triceps::Unit-&gt;new("uTrades");
our $rtTrade = Triceps::RowType-&gt;new(
  id =&gt; "int32", # trade unique id
  symbol =&gt; "string", # symbol traded
  price =&gt; "float64",
  size =&gt; "float64", # number of shares traded
);

our $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
      -&gt;addSubIndex("last2",
        Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
      )
  )
;
$ttWindow-&gt;initialize();
our $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");

# remember the index type by symbol, for searching on it
our $itSymbol = $ttWindow-&gt;findSubIndex("bySymbol");
# remember the FIFO index, for finding the start of the group
our $itLast2 = $itSymbol-&gt;findSubIndex("last2");

# remember, which was the last row modified
our $rLastMod;
our $lbRememberLastMod = $uTrades-&gt;makeLabel($rtTrade, "lbRememberLastMod",
  undef, sub { # (label, rowop)
    $rLastMod = $_[1]-&gt;getRow();
  });
$tWindow-&gt;getOutputLabel()-&gt;chain($lbRememberLastMod);

# Print the average price of the symbol in the last modified row
sub printAverage # (row)
{
  return unless defined $rLastMod;
  my $rhFirst = $tWindow-&gt;findIdx($itSymbol, $rLastMod);
  my $rhEnd = $rhFirst-&gt;nextGroupIdx($itLast2);
  print("Contents:\n");
  my $avg;
  my ($sum, $count);
  for (my $rhi = $rhFirst;
      !$rhi-&gt;same($rhEnd); $rhi = $rhi-&gt;nextIdx($itLast2)) {
    print("  ", $rhi-&gt;getRow()-&gt;printP(), "\n");
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  if ($count) {
    $avg = $sum/$count;
  }
  print("Average price: ", (defined $avg? $avg: "Undefined"), "\n");
}

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/);
  $uTrades-&gt;makeArrayCall($tWindow-&gt;getInputLabel(), @data);
  &amp;printAverage();
  undef $rLastMod; # clear for the next iteration
  $uTrades-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		And an example of its work, with the input lines shown in bold:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
Average price: 10
<span class="bold"><strong>OP_INSERT,2,BBB,100,100</strong></span>
Contents:
  id="2" symbol="BBB" price="100" size="100"
Average price: 100
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
  id="3" symbol="AAA" price="20" size="20"
Average price: 15
<span class="bold"><strong>OP_INSERT,4,BBB,200,200</strong></span>
Contents:
  id="2" symbol="BBB" price="100" size="100"
  id="4" symbol="BBB" price="200" size="200"
Average price: 150
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
Contents:
  id="3" symbol="AAA" price="20" size="20"
  id="5" symbol="AAA" price="30" size="30"
Average price: 25
<span class="bold"><strong>OP_INSERT,6,BBB,300,300</strong></span>
Contents:
  id="4" symbol="BBB" price="200" size="200"
  id="6" symbol="BBB" price="300" size="300"
Average price: 250
<span class="bold"><strong>OP_DELETE,3</strong></span>
Contents:
  id="5" symbol="AAA" price="30" size="30"
Average price: 30
<span class="bold"><strong>OP_DELETE,5</strong></span>
Contents:
Average price: Undefined</pre><p>
		The input has changed: now an extra column is prepended to it,
		containing the opcode for the row. The updates to the table are not
		printed any more, but the calculated average price is printed after the
		new contents of the group.
		</p><p>
		In the code, the first obvious addition is the extra index in the table
		type. The label that used to print the updates is gone, and replaced
		with another one, that remembers the last modified row in a global
		variable.
		</p><p>
		That last modified row is then used in the function <code class="computeroutput">printAverage()</code>
		to find the group for iteration.
		Why? Could not we just remember the symbol from the input data? Not always.
		As you can see from the last two input rows with <code class="computeroutput">OP_DELETE</code>, the
		trade id is the only field required to find and delete a row using the
		index <code class="computeroutput">byId</code>. So these trade cancellation rows take a shortcut and
		only provide the trade id, not the rest of the fields. If we try to
		remember the symbol fields from them, we'd remember an <code class="computeroutput">undef</code>.
		Can we just look up the row by id after the incoming rowop has been processed?
		Not after the deletion.
		If we try to find the symbol by looking up the row
		after the deletion, we will find nothing, because the row will already
		be deleted. We could look up the row in the table before the deletion,
		and remember it, and afterwards do the look-up of the group by
		it. But since on deletion the row with will come to the table's
		output label anyway, we can just ride the wave and remember it instead
		of doing the manual look-up. And this also spares the need of creating
		a row with the last symbol for searching: we get a ready pre-made row
		with the right symbol in it.
		</p><p>
		Note that in this example, unlike the previous one, there are no two
		ways of finding the group any more: after deletion the row handle will
		not be in the table any more, and could not be used to jump directly to
		the beginning of its group. <code class="computeroutput">findIdx()</code> has to be used to find the group.
		</p><p>
		By the time <code class="computeroutput">printAverage()</code> executes, it could happen that all the rows with that symbol
		will be gone, and the group will disappear. This situation is handled
		nicely in an automatic way: <code class="computeroutput">findIdx()</code> will return a NULL row handle, for which then
		<code class="computeroutput">nextGroupIdx()</code> will also return a NULL row handle. The for-loop will
		immediately satisfy the condition of <code class="computeroutput">$rhi-&gt;same($rhEnd)</code>, it will
		make no iterations, the <code class="computeroutput">$count</code> and <code class="computeroutput">$avg</code> will be left undefined.
		In result no rows will be printed and the average value will be printed
		as <span class="quote">&#8220;<span class="quote">Undefined</span>&#8221;</span>, as you can see in the reaction to the last input row
		in the sample output.
		</p><p>
		The main loop becomes reduced to reading the input, splitting the line,
		separating the opcode, calling the table's input label, and printing
		the average. The auto-conversion from the opcode name is used when
		constructing the rowop. Normally it's not a good practice, since the
		program will die if it finds a bad rowop in the input, but good enough
		for a small example. The direct use of <code class="computeroutput">$uTrades-&gt;call()</code> 
		guarantees that by the time it returns, the last modified row
		will be remembered in <code class="computeroutput">$rLastMod</code>, available for <code class="computeroutput">printAverage()</code>
		to use.
		</p><p>
		After the average is calculated, <code class="computeroutput">$rLastMod</code> is reset to prevent it from
		accidentally affecting the next row. If the next row is an attempt to
		delete a trade id that is not in the table any more, the DELTE operation
		will have no effect on the table, and nothing will be sent from the
		table's output label. <code class="computeroutput">$rLastMod</code> will stay undefined, and
		<code class="computeroutput">printAverage()</code> will check it and immediately return.
		An attempt to pass an <code class="computeroutput">undef</code> argument to <code class="computeroutput">findIdx()</code> would be an error.
		</p><p>
		The final <code class="computeroutput">$uTrades-&gt;drainFrame()</code> is there purely for
		completeness. In this case we know that nothing will be scheduled by
		the labels downstream from the table, and there will be nothing to
		drain.
		</p><a class="indexterm" name="id519962"></a><a class="indexterm" name="id519975"></a><a class="indexterm" name="id519989"></a><a class="indexterm" name="id520002"></a><p>
		Now, an interesting question is: how does the table know, that to
		delete a row, it has to find it using the field <code class="computeroutput">id</code>? Or, since
		the deletion internally uses <code class="computeroutput">find()</code>, the more precise question is: how
		does <code class="computeroutput">find()</code> know that it has to use the index <code class="computeroutput">byId</code>? It doesn't
		use any magic. It simply goes by the first index defined in the table.
		That's why the index <code class="computeroutput">byId</code> has been very carefully placed before
		<code class="computeroutput">bySymbol</code>. The same principle applies to all the other functions
		like <code class="computeroutput">next()</code>, that use an index but don't receive one as an argument:
		the first index is always the default index. There is a bit more detail to
		it, but that's the rough principle.
		</p></div><div class="sect1" title="9.8. Sorted index"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_sorted"></a>9.8. Sorted index</h2></div></div></div><p>
		The hashed index provides a way to store rows indexed by a key. It is fast
		but it has a price to pay for that speed: when iterating through it,
		the records come in an unpredictable (though repeatable, within a
		particular machine architecture) order determined by the hash function.
		If the order doesn't matter, that's fine. But often the order does
		matter, and is desirable even at the tradeoff of the reduced performance.
		</p><a class="indexterm" name="id520081"></a><p>
		The sorted index provides a solution for this problem. It is created
		with:
		</p><pre class="programlisting">$it = Triceps::IndexType-&gt;newPerlSorted($sortName,
  $initFunc, $compareFunc, @args);</pre><p>
		The <span class="quote">&#8220;<span class="quote">Perl</span>&#8221;</span> in <span class="quote">&#8220;<span class="quote">newPerlSorted</span>&#8221;</span> refers to the
		fact that the sorting order is specified as a Perl comparison function.
		</p><p>
		<code class="computeroutput">$sortName</code> is just a symbolic name for printouts. It's used when you
		call <code class="computeroutput">$it-&gt;print()</code> (directly or as a recursive call from the table
		type print) to let you know what kind of index type it is, since it
		can't print the compiled comparison function. It is also used in the
		error messages if something dies inside the comparison function: the
		comparison is executed from deep inside the C++ code, and by that time
		the <code class="computeroutput">$sortName</code> is the only way to identify the source of the problems.
		It's not the same name as used to connect the index type into the table
		type hierarchy with <code class="computeroutput">addSubIndex()</code>. As usual, an index type may be
		reused in multiple hierarchies, with different names, but in all cases
		it will also keep the same <code class="computeroutput">$sortName</code>. This may be easier to show with an
		example:
		</p><pre class="programlisting">$rt1 = Triceps::RowType-&gt;new(
  a =&gt; "int32",
  b =&gt; "string",
);

$it1 = Triceps::IndexType-&gt;newPerlSorted("basic", undef, \&amp;compBasic);

$tt1 = Triceps::TableType-&gt;new($rt1)
  -&gt;addSubIndex("primary", $it1)
;

$tt2 = Triceps::TableType-&gt;new($rt1)
  -&gt;addSubIndex("first", $it1)
;

print $tt1-&gt;print(), "\n";
print $tt2-&gt;print(), "\n";</pre><p>
		The print calls in it will produce:
		</p><pre class="programlisting">table (
  row {
    int32 a,
    string b,
  }
) {
  index PerlSortedIndex(basic) primary,
}
table (
  row {
    int32 a,
    string b,
  }
) {
  index PerlSortedIndex(basic) first,
}</pre><p>
		Both the name of the index type in the table type and the name of
		the sorted index type are printed, but in different spots.
		</p><p>
		The <code class="computeroutput">$initFunc</code> and/or <code class="computeroutput">$compareFunc</code> function references 
		(or, as usual, they may be specified as source code strings) specify the sorting order.
		One of them may be left undefined but not both. <code class="computeroutput">@args</code> are the optional
		arguments that will be passed to both functions.
		</p><p>
		The easiest but least flexible way is to just use the
		<code class="computeroutput">$compareFunc</code>. It gets two Rows (not RowHandles!) as arguments, plus
		whatever is specified in <code class="computeroutput">@args</code>. It returns the usual Perl-style
		<span class="quote">&#8220;<span class="quote">&lt;=&gt;</span>&#8221;</span> result. For example:
		</p><pre class="programlisting">sub compBasic # ($row1, $row2)
{
  return $_[0]-&gt;get("a") &lt;=&gt; $_[1]-&gt;get("a");
}</pre><p>
		Don't forget to use <span class="quote">&#8220;<span class="quote">&lt;=&gt;</span>&#8221;</span> for the numbers and <span class="quote">&#8220;<span class="quote">cmp</span>&#8221;</span> for the
		strings. The typical Perl idiom for sorting by more than one field is
		to connect them by <span class="quote">&#8220;<span class="quote">||</span>&#8221;</span>.
		</p><p>
		Or, if we want to specify the field names as arguments, we could define
		a sort function that sorts first by a numeric field in ascending order,
		then by a string field in descending order:
		</p><pre class="programlisting">sub compAscDesc # ($row1, $row2, $numFldAsc, $strFldDesc)
{
  my ($row1, $row2, $numf, $strf) = @_;
  return $row1-&gt;get($numf) &lt;=&gt; $row2-&gt;get($numf)
    || $row2-&gt;get($strf) cmp $row1-&gt;get($strf); # backwards for descending
}

my $sit = Triceps::IndexType-&gt;newPerlSorted("by_a_b", undef,
  \&amp;compAscDesc, "a", "b");</pre><a class="indexterm" name="id520260"></a><p>
		This assumes that the row type will have a numeric field <span class="quote">&#8220;<span class="quote">a</span>&#8221;</span> and a
		string field <span class="quote">&#8220;<span class="quote">b</span>&#8221;</span>. If it doesn't then this will not
		be discovered until you create a table and try to insert some rows into
		it, which will finally call the comparison function. At which point
		the attempt to get a non-existing field will confess, this error
		will be caught by the table and set the sticky error in it. The insert
		operation will confess with this error, and any future operations
		on the table will also confess with this error (this is the meaning of
		<span class="quote">&#8220;<span class="quote">sticky</span>&#8221;</span>), the table will become
		unusable.
		</p><p>
		The <code class="computeroutput">$initFunc</code> provides a way to do that check and more up front.
		It is called at the table type initialization time. By this time all
		this extra information is known, and it gets the references to the
		table type, index type (itself, but with the class stripped back to
		Triceps::IndexType), row type, and whatever extra arguments that were
		passed. It can do all the checks once.
		</p><p>
		The init function's return value is kind of backwards to everything
		else: on success it returns <code class="computeroutput">undef</code>, on error it returns the error
		message. It could die too, but simply returning an error message is
		somewhat nicer. The returned error messages may contain multiple 
		lines separated by <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span>, so it should try to collect all the error
		information it can.
		</p><p>
		The init function that would check the arguments for the
		last example can be defined as:
		</p><pre class="programlisting">sub initNumStr # ($tabt, $idxt, $rowt, @args)
{
  my ($tabt, $idxt, $rowt, @args) = @_;
  my %def = $rowt-&gt;getdef(); # the field definition
  my $errors; # collect as many errors as possible
  my $t;

  if ($#args != 1) {
    $errors .= "Received " . ($#args + 1) . " arguments, must be 2.\n"
  } else {
    $t = $def{$args[0]};
    if ($t !~ /int32$|int64$|float64$/) {
      $errors .= "Field '" . $args[0] . "' is not of numeric type.\n"
    }
    $t = $def{$args[1]};
    if ($t !~ /string$|uint8/) {
      $errors .= "Field '" . $args[1] . "' is not of string type.\n"
    }
  }

  if (defined $errors) {
    # help with diagnostics, append the row type to the error listing
    $errors .= "the row type is:\n";
    $errors .= $rowt-&gt;print();
  }
  return $errors;
}

my $sit = Triceps::IndexType-&gt;newPerlSorted("by_a_b", \&amp;initNumStr,
  \&amp;compAscDesc, "a", "b");</pre><p>
		The init function can do even better: it can create and set
		the comparison function. It's done with:
		</p><pre class="programlisting">$idxt-&gt;setComparator($compareFunc);</pre><p>
		When the init function sets the comparator,
		the compare function argument in <code class="computeroutput">newPerlSorted()</code>
		can be left undefined, because <code class="computeroutput">setComparator()</code> would override
		it anyway. But one way or the other, the compare function
		must be set, or the index type initialization and with it
		the table type initialization will fail.
		</p><a class="indexterm" name="id520367"></a><p>
		By the way, the sorted index type init function is <span class="bold"><strong>not</strong></span> of the
		same kind as the aggregator type init function. The aggregator type
		could use an init function of this kind too, but at the time it looked
		like too much extra complexity. It probably will be added in the
		future. But more about aggregators later.
		</p><p>
		A fancier example of the init function will be shown in the next
		section.
		</p><a class="indexterm" name="id520392"></a><p>
		Internally the implementation of the sorted index shares much
		with the hashed index. They both are implemented as trees but they
		compare the rows in different ways. The hashed index is aimed
		for speed, the sorted index for flexibility. The common implementation
		means that they share certain traits. Both kinds have the unique keys,
		there can not be two rows with the same key in an index of either kind.
		Both kinds allow to nest other indexes in them.
		</p><a class="indexterm" name="id520413"></a><p>
		The handling of the fatal errors (as in <code class="computeroutput">die()</code>) in the initialization 
		and especially comparison functions is an interesting subject.
		The errors propagate properly through the table,
		and the table operations confess with the Perl handler's error message.
		But since an error in the comparison function means that things are going
		very, very wrong, after that the table becomes inoperative and will die
		on all the subsequent operations as well. You need to be very careful
		in writing these functions.
		</p></div><div class="sect1" title="9.9. Ordered index"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_ordered"></a>9.9. Ordered index</h2></div></div></div><a class="indexterm" name="id520446"></a><a class="indexterm" name="id520460"></a><a class="indexterm" name="id520469"></a><p>
		To specify the sorting order in a more SQL-like fashion, Triceps
		has the class SimpleOrderedIndex. It's implemented entirely in Perl, on
		top of the sorted index. Besides being useful by itself, it shows off
		two concepts: the initialization function of the sorted index, and the
		template with code generation on the fly.
		</p><p>
		First, how to create an ordered index:
		</p><pre class="programlisting">$it = Triceps::SimpleOrderedIndex-&gt;new($fieldName =&gt; $order, ...);</pre><p>
		The arguments are the key fields. <code class="computeroutput">$order</code> is one of
		<code class="computeroutput">"ASC"</code> for ascending and <code class="computeroutput">"DESC"</code> for descending.
		Here is an example of a table with this index:
		</p><pre class="programlisting">my $tabType = Triceps::TableType-&gt;new($rowType)
  -&gt;addSubIndex("sorted",
    Triceps::SimpleOrderedIndex-&gt;new(
      a =&gt; "ASC",
      b =&gt; "DESC",
    )
  );</pre><p>
		When it gets translated into a sorted index, the comparison function
		gets generated automatically. It's smart enough to generate the string
		comparisons for the <code class="computeroutput">string</code> and <code class="computeroutput">uint8</code> fields, and the numeric
		comparisons for the numeric fields. It's not smart enough to do the
		locale-specific comparisons for the strings and locale-agnostic for the
		<code class="computeroutput">uint8</code>, it just uses whatever you have set up in <code class="computeroutput">cmp</code> for both. It
		treats the NULL field values as numeric 0 or empty strings. It doesn't
		handle the array fields at all but can at least detect such attempts
		and flag them as errors.
		</p><p>
		A weird artifact of the boundary between C++ and Perl is that when you
		get the index type back from the table type like
		</p><pre class="programlisting">$sortIdx = $tabType-&gt;findSubIndex("sorted");</pre><p>
		the reference stored in <code class="computeroutput">$sortIdx</code> will be of the base type
		Triceps::IndexType. That's because the C++ internals of the TableType
		object know nothing about any derived Perl types. But it's no big deal,
		since there are no other useful methods for SimpleOrderedIndex anyway.
		For the future, I have an idea of a workaround, but it has to wait
		for the future.
		</p><p>
		If you call <code class="computeroutput">$sortIdx-&gt;print()</code>, it will give you an idea of how it
		was constructed:
		</p><pre class="programlisting">PerlSortedIndex(SimpleOrder a ASC, b DESC, )</pre><p>
		The contents of the parenthesis is a sort name from the sorted index'es
		standpoint. It's an arbitrary string. But when the ordered index
		prepares this string to pass to the sorted index, it puts its
		arguments into it.
		</p><p>
		Now the interesting part, I want to show the implementation of the
		ordered index. It's not too big and it shows the flexibility and the
		extensibility of Triceps:
		</p><pre class="programlisting">package Triceps::SimpleOrderedIndex;

our @ISA = qw(Triceps::IndexType);

# Create a new ordered index. The order is specified
# as pairs of (fieldName, direction) where direction is a string
# "ASC" or "DESC".
sub new # ($class, $fieldName =&gt; $direction...)
{
  my $class = shift;
  my @args = @_; # save a copy

  # build a descriptive sortName
  my $sortName = 'SimpleOrder ';
  while ($#_ &gt;= 0) {
    my $fld = shift;
    my $dir = shift;
    $sortName .= quotemeta($fld) . ' ' . quotemeta($dir) . ', ';
  }

  $self = Triceps::IndexType-&gt;newPerlSorted(
    $sortName, '&amp;Triceps::SimpleOrderedIndex::init(@_)', undef, @args
  );
  bless $self, $class;
  return $self;
}

# The initialization function that actually parses the args.
sub init # ($tabt, $idxt, $rowt, @args)
{
  my ($tabt, $idxt, $rowt, @args) = @_;
  my %def = $rowt-&gt;getdef(); # the field definition
  my $errors; # collect as many errors as possible
  my $compare = ""; # the generated comparison function
  my $connector = "return"; # what goes between the comparison operators

  while ($#args &gt;= 0) {
    my $f = shift @args;
    my $dir = uc(shift @args);

    my ($left, $right); # order the operands depending on sorting direction
    if ($dir eq "ASC") {
      $left = 0; $right = 1;
    } elsif ($dir eq "DESC") {
      $left = 1; $right = 0;
    } else {
      $errors .= "unknown direction '$dir' for field '$f', use 'ASC' or 'DESC'\n";
      # keep going, may find more errors
    }

    my $type = $def{$f};
    if (!defined $type) {
      $errors .= "no field '$f' in the row type\n";
      next;
    }

    my $cmp = "&lt;=&gt;"; # the comparison operator
    if ($type eq "string"
    || $type =~ /^uint8.*/) {
      $cmp = "cmp"; # string version
    } elsif($type =~ /\]$/) {
      $errors .= "can not order by the field '$f', it has an array type '$type', not supported yet\n";
      next;
    }

    my $getter = "-&gt;get(\"" . quotemeta($f) . "\")";

    $compare .= "  $connector \$_[$left]$getter $cmp \$_[$right]$getter\n";

    $connector = "||";
  }

  $compare .= "  ;\n";

  if (defined $errors) {
    # help with diagnostics, append the row type to the error listing
    $errors .= "the row type is:\n";
    $errors .= $rowt-&gt;print();
  } else {
    # set the comparison as source code
    #print STDERR "DEBUG Triceps::SimpleOrderedIndex::init: comparison function:\n$compare\n";
    $idxt-&gt;setComparator($compare);
  }
  return $errors;
}</pre><p>
		The class constructor simply builds the sort name from the arguments
		and offloads the rest of logic to the init function. It can't really do
		much more: when the index type object is constructed, it doesn't know
		yet, where it will be used and what row type it will get. It tries to
		enquote nicely the weird characters in the arguments when they go into
		the sort name. Not that much use is coming from it at the moment: the
		C++ code that prints the table type information doesn't do the same, so
		there still is a chance of misbalanced quotes in the result. But
		perhaps the C++ code will be fixed at some point too.
		</p><p>
		The init function is called at the table type initialization time
		with all the needed information.
		It goes through all the arguments, looks up the fields in the row type,
		and checks them for correctness. It tries to collect as much of the
		error information as possible. The returned error messages may contain
		multiple lines separated by <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span>, and the ordered index makes use of
		it. The error messages get propagated back to the table type level,
		nicely indented and returned from the table initialization. If the init
		function finds any errors, it appends the printout of the row type too,
		to make finding what went wrong easier. A result of a particularly bad
		call to a table type initialization may look like this:
		</p><pre class="programlisting">index error:
  nested index 1 'sorted':
    unknown direction 'XASC' for field 'z', use 'ASC' or 'DESC'
    no field 'z' in the row type
    can not order by the field 'd', it has an array type 'float64[]', not supported yet
    the row type is:
    row {
      uint8 a,
      uint8[] b,
      int64 c,
      float64[] d,
      string e,
    }</pre><p>
		Also as the init goes through the arguments, it constructs the text of
		the compare function in the variable <code class="computeroutput">$compare</code>. Here the use of
		<code class="computeroutput">quotemeta()</code> for the user-supplied strings is important to avoid the
		syntax errors in the generated code. If no errors are found in the
		arguments, the compare function gets compiled with <code class="computeroutput">eval</code>. There
		should not be any errors, but it's always better to check. Finally the
		compiled compare function is set in the sorted index with
		</p><pre class="programlisting">$idxt-&gt;setComparator($cmpfunc)</pre><p>
		If you uncomment the debugging printout line (and run <span class="quote">&#8220;<span class="quote"><code class="computeroutput">make</code></span>&#8221;</span>, and maybe
		<span class="quote">&#8220;<span class="quote"><code class="computeroutput">make install</code></span>&#8221;</span> afterwards), you can see the auto-generated code printed
		on stderr when you use the simple ordered index. It will look somewhat
		like this:
		</p><pre class="programlisting">sub {
  return $_[0]-&amp;gt;get("a") cmp $_[1]-&amp;gt;get("a")
  || $_[1]-&amp;gt;get("c") &amp;lt;=&amp;gt; $_[0]-&amp;gt;get("c")
  || $_[0]-&amp;gt;get("b") cmp $_[1]-&amp;gt;get("b")
  ;
}</pre><p>
		That's it! An entirely new piece of functionality added in a smallish Perl
		snippet. This is your typical Triceps template: collect the arguments,
		use them to build Perl code, and compile it. Of course, if you don't
		want to deal with the code generation and compilation, you can just
		call your class methods and whatnot to interpret the arguments. But if
		the code will be reused, the compilation is more efficient.
		</p></div><div class="sect1" title="9.10. The index tree"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_indextree"></a>9.10. The index tree</h2></div></div></div><a class="indexterm" name="id520742"></a><a class="indexterm" name="id520755"></a><p>
		The index types in a table type can form a pretty much arbitrary tree.
		Following the common tree terminology, the index types that have no
		other index types nested in them, are called the <span class="emphasis"><em>leaf</em></span> index
		types. Since there seems to be no good one-word naming for the index
		types that have more index types nested in them ("inner"? "nested" is
		too confusing), I simply call them <span class="emphasis"><em>non-leaf</em></span>.
		</p><p>
		At the moment the Hashed, Sorted and Ordered index types can be used
		only in both leaf and non-leaf positions. The FIFO index types must
		always be in the leaf position, they don't allow the further nesting.
		</p><p>
		Now is the time to look deeper into what is going on inside a table.
		Note that I've been very carefully talking about <span class="quote">&#8220;<span class="quote">index types</span>&#8221;</span> and not
		<span class="quote">&#8220;<span class="quote">indexes</span>&#8221;</span>. In this section the difference matters. The index types are in
		the table type, the indexes are in the table. One index type may
		generate multiple indexes.
		</p><p>
		This will become clearer after you see the illustrations. 
		First, the legend in the
		<a class="xref" href="#fig_idx_legend" title="Figure 9.1. Drawings legend.">Figure 9.1</a>.
		</p><div class="figure"><a name="fig_idx_legend"></a><div class="figure-contents"><div><img src="idx-000-legend.lowres.png" width="NaN" alt="Drawings legend."></div></div><p class="title"><b>Figure 9.1. Drawings legend.</b></p></div><br class="figure-break"><a class="indexterm" name="id520839"></a><p>
		The nodes belonging to the table type are shown in red, the nodes
		belonging to the table are shown in blue, and the contents of the
		RowHandle is shown separately in yellow. The lines on the drawings
		represent not exactly pointers as such but more of the logical
		connections that may be more complicated than the simple pointers.
		</p><p>
		The lines in the RowHandle don't mean anything at all, they just show
		that the parts go together. In reality a RowHandle is a chunk of
		memory, with various elements placed in that memory. As far as indexes
		are concerned, the RowHandle contains an iterator for every index where
		it belongs. This lets it know its position in the table, to iterate
		along every index, and, most importantly, to be removed quickly from
		every index. A RowHandle belongs to one index of each index type, and
		contains the matching number of iterators in it.
		</p><p>
		The table type is shown as a normal flat tree. But the table itself is
		more complex and becomes 3-dimensional. Its <span class="quote">&#8220;<span class="quote">view from above</span>&#8221;</span> matches
		the table type's tree but the data grows <span class="quote">&#8220;<span class="quote">up</span>&#8221;</span> in the third dimension.
		</p><p>
		Let's start with the simplest case: a table type with only one index
		type. Whether the index type is hash or FIFO, doesn't matter here.
		</p><pre class="programlisting">TableType
+-IndexType "A"</pre><p>
		<a class="xref" href="#fig_idx_one" title="Figure 9.2. One index type.">Figure 9.2</a>
		shows the table structure.
		</p><div class="figure"><a name="fig_idx_one"></a><div class="figure-contents"><div><img src="idx-010-one.lowres.png" width="NaN" alt="One index type."></div></div><p class="title"><b>Figure 9.2. One index type.</b></p></div><br class="figure-break"><a class="indexterm" name="id520924"></a><p>
		The table here always contains exactly one index, matching the one
		defined index type, and the root index. The root index is very dumb,
		its only purpose is to tie together the multiple top-level indexes into
		a tree.
		</p><p>
		The only index of type A provides an ordering of the records, and this
		ordering is used for the iteration on the table.
		</p><p>
		For the next example let's look at the straight nesting in
		<a class="xref" href="#fig_idx_nested" title="Figure 9.3. Straight nesting.">Figure 9.3</a>.
		</p><pre class="programlisting">TableType
+-IndexType "A"
  +-IndexType "B"</pre><div class="figure"><a name="fig_idx_nested"></a><div class="figure-contents"><div><img src="idx-020-nested.lowres.png" width="NaN" alt="Straight nesting."></div></div><p class="title"><b>Figure 9.3. Straight nesting.</b></p></div><br class="figure-break"><p>
		The stack of row references is shown visually divided to match the
		indexing, but in reality there is no special division. This was done
		purely to make the picture easier to read.
		</p><a class="indexterm" name="id520996"></a><p>
		There is still only one index of type A. And this is always the case
		with the top-level indexes, there is only one of them. This index
		divides the rows into 3 <span class="emphasis"><em>groups</em></span>. Just like the rows in a leaf
		index, the groups in a non-leaf index are ordered in some 
		index-specific way.
		</p><p>
		Each group then has its own second-level index of type B. Which then
		defines an order for the rows in it. To reiterate: the index of type A
		splits the rows by groups, then the group's index of type B defines the
		order of the rows in the group.
		</p><a class="indexterm" name="id521024"></a><p>
		So what happens when we iterate through the table and ask for the next
		row handle? The current row handle contains the iterators in the
		indexes of types A and B. The easy thing is to advance the iterator of
		type B. Yeah, but in <span class="emphasis"><em>which</em></span> index? The 
		<a class="xref" href="#fig_idx_nested" title="Figure 9.3. Straight nesting.">Figure 9.3</a>
		shows three indexes of
		type B, let's call them B1, B2 and B3. The iterator of type B in the
		row handle tells the relative position in the index, but it doesn't
		tell, which index it is. We need to step back and look at the index
		type A. It's the top-level index type, so there is always only one
		index for it. Then we take the iterator of type A and find this row's
		group in the index A. The group contains the index of type B, say B1.
		We can then take this index B1, take the iterator of type B from the
		row handle, and advance this iterator in this index. If the advance
		succeeded, then great, we've got the next row handle. But if the
		current row was the last row in B1, we need to step back to the index A
		again, advance the current row handle's iterator of type A there, find
		its index B2, and pick the first row handle of B2.
		</p><a class="indexterm" name="id521061"></a><p>
		This process is what happens when we use <code class="computeroutput">$rh-&gt;nextIdx($itB)</code>. 
		The iteration goes by the leaf
		index type B, however it relies on all the index types in the path from
		the table type to B. If we do <code class="computeroutput">$rh-&gt;next()</code>, the result is the same
		because the <span class="emphasis"><em>first leaf</em></span> index type is used as the default index type for
		the iteration.
		</p><p>
		If we do <code class="computeroutput">$rh-&gt;next($itA)</code>, the semantics is still the same:
		return the next row handle (not the next group). There is no way to get
		to the row handle without going all the way through a leaf index. So
		when a non-leaf index type is used for the iteration, it gets
		implicitly extended to its first nested leaf index type. 
		</p><a class="indexterm" name="id521107"></a><p>
		What would happen if a new row gets inserted, and the index type A
		determines that it does not belong to any of the existing groups? A new
		group will be created and inserted in the appropriate position in A's
		order. This group will have a new index of type B created, and the new
		row inserted in that index.
		</p><p>
		What would happen if both rows in B1 are removed? B1 will become empty
		and will be collapsed. The index A will delete the B1's group and B1
		itself, and will remain with only two groups. The effect propagates
		upwards: if all the rows are removed, the last index of type B will
		collapse, then the index A will become empty and also collapse and be
		deleted. The only thing left will be the root index that stays in the
		existence no matter what.
		</p><p>
		When a table is first created, it has only the root index. The rest of
		the indexes pop into the existence as the rows get inserted. If you
		wonder, yes, this does apply to a table type with only one index type
		as well. Just this point has not been brought up until now.
		</p><p>
		Among all this froth of creation and collapse the iterators stay
		stable. Once a row is inserted, the indexes leading to it are not going
		anywhere (at least until that row gets removed). But since other rows
		and groups may be inserted around it, the notion of what row is next,
		will change over time.
		</p><p>
		Let's go through how the other index-related operations work.
		</p><a class="indexterm" name="id521151"></a><p>
		The iteration through the whole table starts with <code class="computeroutput">begin()</code> or
		<code class="computeroutput">beginIdx()</code>, the first being a form of the second that always uses the
		first leaf index type. <code class="computeroutput">beginIdx()</code> is fairly straightforward: it just
		follows the path from the root to the leaf, picking the first position
		in each index along the way, until it hits the RowHandle, as is shown in
		<a class="xref" href="#fig_idx_nested_begin" title="Figure 9.4. begin(), beginIdx($itA) and beginIdx($itB) work the same for this table.">Figure 9.4</a>.
		That found RowHandle becomes its result. If the table is
		empty, it returns the NULL row handle.
		</p><div class="figure"><a name="fig_idx_nested_begin"></a><div class="figure-contents"><div><img src="idx-021-nested-begin.lowres.png" width="NaN" alt="begin(), beginIdx($itA) and beginIdx($itB) work the same for this table."></div></div><p class="title"><b>Figure 9.4. <code class="computeroutput">begin()</code>, <code class="computeroutput">beginIdx($itA)</code> and <code class="computeroutput">beginIdx($itB)</code> work the same for this table.</b></p></div><br class="figure-break"><a class="indexterm" name="id521239"></a><p>
		The next pair is <code class="computeroutput">find()</code> and <code class="computeroutput">findIdx()</code> (and
		<code class="computeroutput">findBy()</code> and <code class="computeroutput">findIdxBy()</code> are wrappers around those). 
		As usual, <code class="computeroutput">find()</code> is the same
		thing as <code class="computeroutput">findIdx()</code> on the table's first leaf index type. It also
		follows the path from the root to the target index type. On each step
		it tries to find a matching position in the current index. If the
		position could not be found, the search fails and a NULL row handle is
		returned. If found, it is used to progress to the next index.
		</p><p>
		As has been mentioned in
		<a class="xref" href="#sc_table_RowHandle" title="9.5. A closer look at the RowHandles">Section 9.5: &#8220;A closer look at the RowHandles&#8221; </a>, 
		the search always works internally on a
		RowHandle argument. If a plain Row is used as an argument, a new
		temporary RowHandle will be created for it, searched, and then freed
		after the search. This works well for two reasons. First, the indexes
		already have the functions for comparing two row handles to build their
		ordering. The same functions are reused for the search. Second, the row
		handles contain not only the index iterators but also the cached
		information from the rows, to make the comparisons faster. The exact
		kind of cached information varies by the index type. The FIFO,
		Sorted and Ordered indexes
		use none. The Hashed indexes calculate a hash of the key field values,
		that will be used as a quick differentiator for the search. This
		information gets created when the row handle gets created. Whether the
		row handle is then used to insert into the table or to search in it,
		the hash is then used in the same way, to speed up the comparisons.
		</p><p>
		In <code class="computeroutput">findIdx()</code>, the non-leaf index type arguments behave differently
		than the leaf ones: up to and including the index of the target type,
		the search works as usual. But then at the next level the logic
		switches to the same as in <code class="computeroutput">beginIdx()</code>, going for the first row handle
		of the first leaf sub-index. This lets you find the first row handle of
		the matching group under the target index type.
		</p><p>
		If you use <code class="computeroutput">$table-&gt;findIdx($itA, $rh)</code>, on 
		<a class="xref" href="#fig_idx_nested_findidx" title="Figure 9.5. findIdx($itA, $rh) goes through A and then switches to the beginIdx() logic.">Figure 9.5</a>
		it will go through
		the root index to the index A. There it will try to find the matching
		position. If none is found, the search ends and returns a NULL row
		handle. If the position is found, the search progresses towards the
		first leaf sub-index type. Which is the index type B, and which
		conveniently sits in this case right under A. The position in the index
		A determines, which index of type B will be used for the next step.
		Suppose it's the second position, so the second index of type B is
		used. Since we're now past the target index A, the logic used is the
		same as for <code class="computeroutput">beginIdx()</code>, and the first position in B2 is picked. Which
		then leads to the first row handle of the second sub-stack of handles.
		</p><div class="figure"><a name="fig_idx_nested_findidx"></a><div class="figure-contents"><div><img src="idx-022-nested-findidx.lowres.png" width="NaN" alt="findIdx($itA, $rh) goes through A and then switches to the beginIdx() logic."></div></div><p class="title"><b>Figure 9.5. <code class="computeroutput">findIdx($itA, $rh)</code> goes through A and then switches to the <code class="computeroutput">beginIdx()</code> logic.</b></p></div><br class="figure-break"><p>
		The method <code class="computeroutput">firstOfGroupIdx()</code> allows to navigate within a group, to jump
		from some row somewhere in the group to the first one, and then from
		there iterate through the group. The example in
		<a class="xref" href="#sc_table_fifo" title="9.6. A window is a FIFO">Section 9.6: &#8220;A window is a FIFO&#8221; </a>
		made use of it.
		</p><p>
		The 
		<a class="xref" href="#fig_idx_nested_firstOfGroupIdx" title="Figure 9.6. firstOfGroupIdx($itB, $rh).">Figure 9.6</a>
		shows an example of <code class="computeroutput">$table-&gt;firstOfGroupIdx($itB, $rh)</code>,
		where <code class="computeroutput">$rh</code> is pointing to the third record in B2. What it needs to do is
		go back to B2, and then execute the <code class="computeroutput">begin()</code> logic from there on.
		However, remember, the row handle does not have a pointer to the
		indexes in the path, it only has the iterators. So, to find B2, the
		method does not really back up from the original row. It has to start
		all the way back from the root and follow the path to B2 using the iterators in
		<code class="computeroutput">$rh</code>. Since it uses the ready iterators, this works fast and requires no
		row comparisons. But logically it's equivalent to backing up by one level,
		and I'll continue calling it that for simpicity.
		Once B2 (an index of type B) is reached, the <code class="computeroutput">begin()</code> logic goes for
		the first row in there.
		</p><p>
		<code class="computeroutput">firstOfGroupIdx()</code> works on both leaf and non-leaf index type arguments
		in the same way: it backs up from the reference row to the index of
		that type and executes the <code class="computeroutput">begin()</code> logic from there. Obviously, if you
		use it on a non-leaf index type, the <code class="computeroutput">begin()</code>-like part will follow its
		first leaf index type.
		</p><div class="figure"><a name="fig_idx_nested_firstOfGroupIdx"></a><div class="figure-contents"><div><img src="idx-023-nested-firstOfGroupIdx.lowres.png" width="NaN" alt="firstOfGroupIdx($itB, $rh)."></div></div><p class="title"><b>Figure 9.6. <code class="computeroutput">firstOfGroupIdx($itB, $rh)</code>.</b></p></div><br class="figure-break"><p>
		The method <code class="computeroutput">nextGroupIdx()</code> jumps to the first row of the next group,
		according to the argument index type. To do that, it has to retrace one
		level higher than <code class="computeroutput">firstOfGroupIdx()</code>. 
		<a class="xref" href="#fig_idx_nested_nextGroupIdx" title="Figure 9.7. nextGroupIdx($itB, $rh).">Figure 9.7</a>
		shows that
		<code class="computeroutput">$table-&gt;nextGroupIdx($itB, $rh)</code> that starts from the same row handle
		as in
		<a class="xref" href="#fig_idx_nested_firstOfGroupIdx" title="Figure 9.6. firstOfGroupIdx($itB, $rh).">Figure 9.6</a>,
		has to logically back up to the index A, go to the next
		iterator there, and then follow to the first row of B3.
		</p><div class="figure"><a name="fig_idx_nested_nextGroupIdx"></a><div class="figure-contents"><div><img src="idx-024-nested-nextGroupIdx.lowres.png" width="NaN" alt="nextGroupIdx($itB, $rh)."></div></div><p class="title"><b>Figure 9.7. <code class="computeroutput">nextGroupIdx($itB, $rh)</code>.</b></p></div><br class="figure-break"><p>
		As before, in reality there is no backing up, just the path is retraced
		from the root using the iterators in the row handle. Once the parent of
		index type B is reached (which is the index of type A), the path
		follows not the iterator from the row handle but the next one (yes,
		copied from the row handle, increased, followed). This gives the index
		of type B that contains the next group. And from there the same
		<code class="computeroutput">begin()</code>-like logic finds its first row.
		</p><p>
		Same as <code class="computeroutput">firstOfGroupIdx()</code>, <code class="computeroutput">nextGroupIdx()</code> may be used on both the leaf
		and non-leaf indexes, with the same logic.
		</p><p>
		It's kind of annoying that <code class="computeroutput">firstOfGroupIdx()</code> and <code class="computeroutput">nextGroupIdx()</code> take
		the index type inside the group while <code class="computeroutput">findIdx()</code> uses takes the parent
		index type to act on the same group. But as you can see, each of them
		follows its own internal logic, and I'm not sure if they can be
		reconciled to be more consistent.
		</p><p>
		At the moment the only navigation is forward. There is no matching
		<code class="computeroutput">last()</code>, <code class="computeroutput">prev()</code> or <code class="computeroutput">lastGroupIdx()</code> or <code class="computeroutput">prevGroupIdx()</code>. They are in the
		plan, but so far they are the victims of corner-cutting. Though there is a version of
		<code class="computeroutput">last()</code> in the AggregatorContext, since it happens to be particularly important
		for the aggregation.
		</p><p>
		Continuing our excursion into the index nesting topologies, the next
		example is of two parallel leaf index types:
		</p><pre class="programlisting">TableType
+-IndexType A
+-IndexType B</pre><p>
		The resulting internal arrangement is shown in
		<a class="xref" href="#fig_idx_2pri" title="Figure 9.8. Two top-level index types.">Figure 9.8</a>.
		</p><div class="figure"><a name="fig_idx_2pri"></a><div class="figure-contents"><div><img src="idx-030-2pri.lowres.png" width="NaN" alt="Two top-level index types."></div></div><p class="title"><b>Figure 9.8. Two top-level index types.</b></p></div><br class="figure-break"><p>
		Each index type produces exactly one index under the root (since the
		top-level index types always produce one index). Both indexes contain
		the same number of rows, and exactly the same rows. When a row is added
		to the table, it's added to all the leaf index types (one actual index
		of each type). When a row is deleted from the table, it's deleted from
		all the leaf index types. So the total is always the same. However the
		order of rows in the indexes may differ. The drawing shows the row
		references stacked in the same order as the index A because the index A
		is of the first leaf index type, and as such is the default one for the
		iteration.
		</p><p>
		The row handle contains the iterators for both paths, A and B. It's
		pretty normal to find a row through one index type and then iterate
		from there using the other index type.
		</p><p>
		The next example in
		<a class="xref" href="#fig_idx_prisec" title="Figure 9.9. A &#8220;primary&#8221; and &#8220;secondary&#8221; index type.">Figure 9.9</a>
		has a <span class="quote">&#8220;<span class="quote">primary</span>&#8221;</span> index with a unique key and a 
		<span class="quote">&#8220;<span class="quote">secondary</span>&#8221;</span> index that groups the records:
		</p><pre class="programlisting">TableType
+-IndexType A
+-IndexType B
  +-IndexType C</pre><div class="figure"><a name="fig_idx_prisec"></a><div class="figure-contents"><div><img src="idx-040-prisec.lowres.png" width="NaN" alt="A primary and secondary index type."></div></div><p class="title"><b>Figure 9.9. A <span class="quote">&#8220;<span class="quote">primary</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">secondary</span>&#8221;</span> index type.</b></p></div><br class="figure-break"><p>
		The index type A still produces one index and references all the rows
		directly. The index of type B produces the groups, with each group
		getting an index of type C. The total set of rows referrable through A
		and through B is still the same but through B they are split into
		multiple groups.
		</p><p>
		And 
		<a class="xref" href="#fig_idx_nestfork" title="Figure 9.10. Two index types nested under one.">Figure 9.10</a>
		shows two leaf index types nested under one non-leaf.
		</p><pre class="programlisting">TableType
+-IndexType A
  +-IndexType B
  +-IndexType C</pre><div class="figure"><a name="fig_idx_nestfork"></a><div class="figure-contents"><div><img src="idx-050-nestfork.lowres.png" width="NaN" alt="Two index types nested under one."></div></div><p class="title"><b>Figure 9.10. Two index types nested under one.</b></p></div><br class="figure-break"><p>
		As usual, there is only one index of type A, and it splits the rows
		into groups. The new item in this picture is that each group has two
		indexes in it: one of type B and one of type C. Both indexes in the
		group contain the same rows. They don't decide, which rows they get.
		The index A decides, which rows go into which group. Then if the group
		1 contains two rows, indexes B1 and C1, would both contain two rows
		each, the exact same set. The stack of row references has been visually
		split by groups to make this point more clear.
		</p><p>
		This happens to be a pretty useful arrangement: for example, B might be
		a hash index type, or a sorted index type, allowing to
		find the records by the key (and for the sorted index, to iterate in
		the order of keys), while C might be a FIFO index, keeping the
		insertion order, and maybe keeping the window size limited.
		</p><p>
		That's pretty much it for the basic index topologies. Some much more
		complex index trees can be created, but they would be the combinations
		of the examples shown. Also, don't forget that every extra index type
		adds overhead in both memory and CPU time, so avoid adding indexes that
		are not needed.
		</p><a class="indexterm" name="id521861"></a><p>
		One more fine point has to do with the replacement policies. Consider
		that we have a table that contains the rows with a single field:
		</p><pre class="programlisting">id int32</pre><p>
		And the table type has two indexes:
		</p><pre class="programlisting">TableType
+-IndexType "A" HashIndex key=(id)
+-IndexType "B" FifoIndex limit=3</pre><p>
		And we send there the rowops:
		</p><pre class="programlisting">INSERT id=1
INSERT id=2
INSERT id=3
INSERT id=2</pre><p>
		The last rowop that inserts the row with id=2 for the second time
		triggers the replacement policy in both index
		types. In the index A it is a duplicate key and will cause the removal
		of the previous row with id=2. In the index B it overflows the limit
		and pushes out the oldest row, the one with id=1. If both records get
		deleted, the resulting table contents will be 2 rows (shown in FIFO
		order):
		</p><pre class="programlisting">id=3
id=2</pre><p>
		Which is probably not the best outcome. It might be tolerable with a
		FIFO index and a hashed index but gets even more annoying if there are
		two FIFO index types in the table: one top-level limiting the total
		number of rows, another one nested under a hashed index, limiting the
		number of rows per group, and they start conflicting this way with each
		other.
		</p><p>
		The Triceps FIFO index is actually smart enough to avoid such problems: it
		looks at what the preceding indexes have decided to remove, checks if
		any of these rows belong to its group, and adjusts its calculation
		accordingly. In this example the index B will find out that the row
		with id=2 is already displaced by the index A. That leaves only 2 rows
		in the index B, so adding a new one will need no displacement. The
		resulting table contents will be
		</p><pre class="programlisting">id=1
id=3
id=2</pre><p>
		However here the order of index types is important. If the table were
		to be defined as
		</p><pre class="programlisting">TableType
+-IndexType "B" FifoIndex limit=3
+-IndexType "A" HashIndex key=(id)</pre><p>
		then the replacement policy of the index type B would run first, find
		that nothing has been displaced yet, and displace the row id=1. After
		that the replacement policy of the index type A will run, and being a
		hashed index, it doesn't have a choice, it has to replace the row id=2.
		And both rows end up displaced.
		</p><p>
		If the situations with automatic replacement of rows by the keyed
		indexes may arise, always make sure to put the keyed leaf index types
		before the FIFO leaf index types. However if you always diligently send
		a DELETE before the INSERT of the new version of the recond, then this
		problem won't occur and the order of index types will not matter.
		</p></div><div class="sect1" title="9.11. Table and index type introspection"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_idx_intro"></a>9.11. Table and index type introspection</h2></div></div></div><p>
		A lot of information about a table type and the index types in it 
		can be read back from them.
		</p><pre class="programlisting">$result = $tabType-&gt;isInitialized();
$result = $idxType-&gt;isInitialized();</pre><p>
		return whether a table or index type has been initialized.
		The index type gets initialized when the table type where it belongs
		gets initialized.  After a table or index type has been initialized, it can not
		be changed any more, and any methods that change it will return an
		error.
		When an index type becomes initialized, it becomes tied to a particular
		table type. This table type can be read with:
		</p><pre class="programlisting">$tabType = $idxType-&gt;getTabtype();
$tabType = $idxType-&gt;getTabtypeSafe();</pre><p>
		The difference between these methods is what happens if the index type
		was not set into a table type yet. <code class="computeroutput">getTabtype()</code> would
		confess while <code class="computeroutput">getTabtypeSafe()</code> would return an <code class="computeroutput">undef</code>.
		Which method to use, depends on the circumstances: if this situation
		is valid and you're ready to check for it and handle it, use
		<code class="computeroutput">getTabtypeSafe()</code>, otherwise use <code class="computeroutput">getTabtype()</code>.
		</p><a class="indexterm" name="id522032"></a><p>
		Even though an initialized index type can't be tied to another table,
		when you add it to another table or index type, a deep copy with
		all its sub-indexes will be made automatically, and that copy will 
		be uninitialized. So it will be able to get initialized and tied to 
		the new table. However if you want to add more sub-indexes to it,
		do a manual copy first:
		</p><pre class="programlisting">$idxTypeCopy = $idxType-&gt;copy();</pre><p>
		The information about the nested indexes can be found with:
		</p><pre class="programlisting">$itSub = $tabType-&gt;findSubIndex("indexName");
$itSub = $tabType-&gt;findSubIndexSafe("indexName");
@itSubs = $tabType-&gt;getSubIndexes();

$itSub = $idxType-&gt;findSubIndex("indexName");
$itSub = $idxType-&gt;findSubIndexSafe("indexName");
@itSubs = $idxType-&gt;getSubIndexes();</pre><p>
		The <code class="computeroutput">findSubIndex()</code> has been already shown in
		<a class="xref" href="#sc_table_secondary" title="9.7. Secondary indexes">Section 9.7: &#8220;Secondary indexes&#8221; </a>.
		It allows to find the index types on the next level of nesting, starting
		down from the table, and going recursively into the sub-indexes.
		The <code class="computeroutput">Safe</code> versions return <code class="computeroutput">undef</code> if the index is not
		found, instead of confessing.
		<code class="computeroutput">getSubIndexes()</code> returns the information about the index types of the
		next level at once, as the name =&gt; value pairs. The result array
		can be placed into a hash but that would lose the order
		of the sub-indexes, and the order is important for the logic.
		</p><p>
		This finds the index types step by step. An easier way to find an index
		type in a table type by the <span class="quote">&#8220;<span class="quote">path of the index</span>&#8221;</span> is with
		</p><pre class="programlisting">$idxType = $tabType-&gt;findIndexPath(\@idxNames);</pre><a class="indexterm" name="id522122"></a><a class="indexterm" name="id522136"></a><p>
		The arguments in the array form a path of names in the index type tree. If the path
		is not found, the function would confess.
		An empty path is also illegal and would cause the same result.
		Yes, the argument is not an array but a reference to array. This
		array is used essentially as a path object. For example the
		index from the
		<a class="xref" href="#sc_table_secondary" title="9.7. Secondary indexes">Section 9.7: &#8220;Secondary indexes&#8221; </a>
		could be found as:
		</p><pre class="programlisting">$itLast2 = $ttWindow-&gt;findIndexPath([ "bySymbol", "last2" ]);</pre><a class="indexterm" name="id522165"></a><p>
		The key (the set of fields that uniquely identify the rows) of the index type 
		can be found with
		</p><pre class="programlisting">@keys = $it-&gt;getKey();</pre><p>
		It can be used on any kind of index types but actually returns the data
		only for the Hashed index types.  On the other index types it returns an 
		empty array, though a better support will be available for the 
		Sorted and Ordered indexes in the future.
		</p><p>
		A fairly common need is to find an index by its name path, and also all the
		key fields that are used by all the indexes in this path. It's used
		for such purposes as joins, and it allows to treat a nested index
		pretty much as a composition of all the indexes in its path.
		The method
		</p><pre class="programlisting">($idxType, @keys) = $tabType-&gt;findIndexKeyPath(\@path);</pre><p>
		solves this problem and
		finds by path an index type that allows the direct look-up by key
		fields. It requires that every index type in the path returns a
		non-empty array of fields in <code class="computeroutput">getKey()</code>. In practice it means that every
		index in the path must be a Hashed index. Otherwise the method
		confesses. When the Sorted and maybe other index types will support
		<code class="computeroutput">getKey()</code>, they will be usable with this method too.
		</p><p>
		Besides checking that each index type in the path works by keys, this
		method builds and returns the list of all the key fields required for a
		look-up in this index. Note that <code class="computeroutput">@keys</code> is an actual array and not a
		reference to array. The return protocol of this method is a little
		weird: it returns an array of values, with the first value being the
		reference to the index type, and the rest of them the names of the key
		fields. If the table type were defined as
		</p><pre class="programlisting">$tt = Triceps::TableType-&gt;new($rt)
  -&gt;addSubIndex("byCcy1",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy1" ])
    -&gt;addSubIndex("byCcy12",
      Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy2" ])
    )
  )
  -&gt;addSubIndex("byCcy2",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy2" ])
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
;</pre><p>
		then <code class="computeroutput">$tt-&gt;findIndexKeyPath([ "byCcy1", "byCcy12" ])</code> would return 
		<code class="computeroutput">($ixtref, "ccy1", "ccy2")</code>, 
		where <code class="computeroutput">$ixtref</code> is the reference to the index type. When
		assigned to <code class="computeroutput">($ixt, @keys)</code>, <code class="computeroutput">$ixtref</code> would go into <code class="computeroutput">$ixt</code>, and 
		<code class="computeroutput">("ccy1", "ccy2")</code> would go into <code class="computeroutput">@keys</code>.
		</p><p>
		The key field names in the result go in the order they occurred in the
		definition, from the outermost to the innermost index. The key fields
		must not duplicate.  It's possible to define the index types where the
		key fields duplicate in the path, say:
		</p><pre class="programlisting">$tt = Triceps::TableType-&gt;new($rt)
  -&gt;addSubIndex("byCcy1",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy1" ])
    -&gt;addSubIndex("byCcy12",
      Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy2", "ccy1" ])
    )
  )
;</pre><p>
		And they would even work fine, with just a little extra overhead from
		duplication. But <code class="computeroutput">findIndexKeyPath()</code> will refuse such indexes and
		confess.
		</p><p>
		Yet another way to find an index is by the keys. Think of an SQL
		query: having a WHERE condition, you would want to find if there
		is an index on the fields in the condition, allowing to find the
		records quickly. Triceps is not quite up to this level of automatic
		query planning yet but it does some for the joins.
		If you know, by which fields you want to join,
		it's nice to find the correct index automatically. 
		The finding of an index by key is done with the method:
		</p><pre class="programlisting">@idxPath = $tableType-&gt;findIndexPathForKeys(@keyFields);</pre><p>
		It returns the array that represents the path to an index type that
		matches these key fields. And then having the path you can find the
		index type as such. The index type and all the types in the path
		still have to be of the Hashed variety. If the correct index cannot
		be found, an empty array is returned. If you specify the fields that
		aren't present in the row type in the first place, this is simply
		treated the same as being unable to find an index for these fields.
		If more that one index would match, the first one found in the direct
		order of the index tree walk is returned.
		</p><a class="indexterm" name="id522346"></a><p>
		The kind of the index type is also known as the type id. It can be found
		for an index type with
		</p><pre class="programlisting">$id = $idxType-&gt;getIndexId();</pre><p>
		It's an integer constant, matching one of the values:
		</p><a class="indexterm" name="id522374"></a><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">&amp;Triceps::IT_HASHED</code></li><li class="listitem"><code class="computeroutput">&amp;Triceps::IT_FIFO</code></li><li class="listitem"><code class="computeroutput">&amp;Triceps::IT_SORTED</code></li></ul></div><p>
		There is no different id for the ordered index, because it's
		built on top of the sorted index, and would return <code class="computeroutput">&amp;Triceps::IT_SORTED</code>.
		</p><p>
		The conversion between the strings and constants for index type ids is done with
		</p><pre class="programlisting">$intId = &amp;Triceps::stringIndexId($stringId);
$stringId = &amp;Triceps::indexIdString($intId);</pre><p>
		If an invalid value is supplied, the conversion functions will return <code class="computeroutput">undef</code>.
		</p><p>
		There is also a way to find the first index type of a particular kind.
		It's called somewhat confusingly
		</p><pre class="programlisting">$itSub = $idxType-&gt;findSubIndexById($indexTypeId);</pre><p>
		where <code class="computeroutput">$indexTypeId</code> is one of either of Triceps constants or the
		matching strings <code class="computeroutput">"IT_HASHED"</code>, <code class="computeroutput">"IT_FIFO"</code>, <code class="computeroutput">"IT_SORTED"</code>.
		</p><p>
		Technically, there is also IT_ROOT but it's of little use for this
		situation since it's the root of the index type tree hidden inside the
		table type, and would never be a sub-index type. It's possible to
		iterate through all the possible index type ids as
		</p><pre class="programlisting">for ($i = 0; $i &lt; &amp;Triceps::IT_LAST; $i++) { ... }</pre><a class="indexterm" name="id522498"></a><p>
		The first leaf sub-index type, that is the default for iteration,
		can be found explicitly as
		</p><pre class="programlisting">$itSub = $tabType-&gt;getFirstLeaf();
$itSub = $idxType-&gt;getFirstLeaf();</pre><p>
		If an index is already a leaf, <code class="computeroutput">getFirstLeaf()</code> on it
		will return itself.
		The <span class="quote">&#8220;<span class="quote">leaf-ness</span>&#8221;</span> of an index type can be found with:
		</p><pre class="programlisting">$result = $idxType-&gt;isLeaf();</pre><p>
		The usual reference comparison methods are:
		</p><pre class="programlisting">$result = $tabType1-&gt;same($tabType2);
$result = $tabType1-&gt;equals($tabType2);
$result = $tabType1-&gt;match($tabType2);

$result = $idxType1-&gt;same($idxType2);
$result = $idxType1-&gt;equals($idxType2);
$result = $idxType1-&gt;match($idxType2);</pre><a class="indexterm" name="id522554"></a><p>
		Two table types are considered equal when they have the equal row types,
		and exactly the same set of index types, with the same names.
		</p><a class="indexterm" name="id522572"></a><p>
		Two table types are considered matching when they have the matching row types,
		and matching set of index types, although the names of the index types
		may be different.
		</p><a class="indexterm" name="id522591"></a><p>
		Two index types are considered equal when they are of the same kind
		(type id), their type-specific parameters are equal, they have the
		same number of sub-indexes, with the same names, and equal pair-wise.
		They must also have the equal aggregators, which will be described in
		detail in the 
		<a class="xref" href="#ch_aggregation" title="Chapter 11. Aggregation">Chapter 11: &#8220;<i>Aggregation</i>&#8221; </a>.
		</p><a class="indexterm" name="id522617"></a><p>
		Two index types are considered matching when they are of the same kind,
		have matching type-specific parameters, they have the same number of
		sub-indexes, which are matching pair-wise, and the matching aggregators.
		The names of the sub-indexes may differ.
		As far as the type-specific parameters are concerned, it depends on the
		kind of the index type. The FIFO type considers any parameters matching.
		For a Hashed index the key fields must be the same. For a Sorted index
		the sorted condition must also be the same, and by extension this
		means the same condition for the Ordered index.
		</p></div><div class="sect1" title="9.12. The copy tray"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_copy_tray"></a>9.12. The copy tray</h2></div></div></div><p>
		The table methods <code class="computeroutput">insert()</code>, <code class="computeroutput">remove()</code> and <code class="computeroutput">deleteRow()</code> have an extra
		optional argument: the copy tray.
		</p><a class="indexterm" name="id522671"></a><a class="indexterm" name="id522681"></a><p>
		If used, it will put a copy of all the rowops produced during the
		operation (including the output of the aggregators, which will be
		described in 
		<a class="xref" href="#ch_aggregation" title="Chapter 11. Aggregation">Chapter 11: &#8220;<i>Aggregation</i>&#8221; </a>
		) into that tray. The
		idea here is to use it in cases if you don't want to connect the output
		labels of the table directly, but instead collect and process the rows
		from the tray manually afterwards. Like this:
		</p><pre class="programlisting">$ctr = $unit-&gt;makeTray();
$table-&gt;insert($row, $ctr);
foreach my $rop ($ctr-&gt;toArray()) {
  ...
}</pre><p>
		However in reality it didn't work out so well. The processing loop
		would have to have all the lengthy if-else sequences to branch first by
		the label (if there are any aggregators) and then by opcode. It looks
		too difficult. Well, it could work in the simple situations but not
		more than that.
		</p><p>
		In the future this feature will likely be deprecated unless it proves
		itself useful, and I already have a better idea. Because of this, I see
		no point in going into the more extended examples.
		</p></div><div class="sect1" title="9.13. Table wrap-up"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_table_wrapup"></a>9.13. Table wrap-up</h2></div></div></div><p>
		Not all of the table's features have been shown yet. The table
		class is the cornerstone of Triceps, and everything is connected
		to it.  The aggregators
		work with the tables and are a whole separate big subject with their
		own 
		<a class="xref" href="#ch_aggregation" title="Chapter 11. Aggregation">Chapter 11: &#8220;<i>Aggregation</i>&#8221; </a>.
		The features that take advantage of the streaming functions are
		described in 
		<a class="xref" href="#sc_strf_tables" title="15.7. Streaming functions and tables">Section 15.7: &#8220;Streaming functions and tables&#8221; </a>.
		There also are many more options and small methods that
		haven't been touched upon yet. They are enumerated in the reference
		chapter, please refer there.
		</p></div></div><div class="chapter" title="Chapter 10. Templates"><div class="titlepage"><div><div><h2 class="title"><a name="ch_templates"></a>Chapter 10. Templates</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_template_intro">10.1. Comparative modularity</a></span></dt><dt><span class="sect1"><a href="#sc_template_variety">10.2. Template variety</a></span></dt><dt><span class="sect1"><a href="#sc_template_wrapper">10.3. Simple wrapper templates</a></span></dt><dt><span class="sect1"><a href="#sc_template_intercon">10.4. Templates of interconnected components</a></span></dt><dt><span class="sect1"><a href="#sc_template_options">10.5. Template options</a></span></dt><dt><span class="sect1"><a href="#sc_template_codegen">10.6. Code generation in the templates</a></span></dt><dt><span class="sect1"><a href="#sc_template_result">10.7. Result projection in the templates</a></span></dt><dt><span class="sect1"><a href="#sc_template_wrapfess">10.8. Error reporting in the templates</a></span></dt></dl></div><div class="sect1" title="10.1. Comparative modularity"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_template_intro"></a>10.1. Comparative modularity</h2></div></div></div><a class="indexterm" name="id489457"></a><p>
		The templates are the Triceps term for the reusable program modules.
		I've adopted the term from C++ because that was my inspiration
		for flexibility. But the Triceps templates are much more flexible yet.
		The problem with the C++ templates is that you have to write in them
		like in a functional language, substituting loops with recursion,
		with perverse nested calls for branching, and the result is quite
		hard to diagnose. Triceps uses the Perl's compilation on the fly
		to make things easier and more powerful.
		</p><p>
		Triceps is not unique in the desire for modularity. The other CEP
		systems have it too, but they tend to have it even more rigid than
		the C++ templates.  Let me show on a simple example.
		</p><a class="indexterm" name="id490203"></a><p>
		Coral8 doesn't provide a way to query the windows directly, especially
		when the CCL is compiled without debugging. So you're expected to make
		your own. People at a company where I've worked have developed a nice
		pattern that goes approximately like this:
		</p><a class="indexterm" name="id510930"></a><pre class="programlisting">// some window that we want to make queryable
create window w_my schema s_my
keep last per key_a per key_b
keep 1 week;

// the stream to send the query requests
// (the schema can be shared by all simple queries)
create schema s_query (
  qqq_id string // unique id of the query
);
create input stream query_my schema s_query;

// the stream to return the results
// (all result streams will inherit a partial schema)
create schema s_result (
  qqq_id string, // returns back the id received in the query
  qqq_end boolean, // will be TRUE in the special end indicator record
);
create output stream result_my schema inherits from s_result, s_my;

// now process the query
insert into result_my
select q.qqq_id, NULL, w.*
from s_query as q, w_my as w;

// the end marker
insert into result_my (qqq_id, qqq_end)
select qqq_id, TRUE
from s_query;</pre><p>
		To query the window, a program would select a unique query id,
		subscribe to result_my with a filter <code class="computeroutput">(qqq_id = unique_id)</code> and send a
		record of <code class="computeroutput">(unique_id)</code> into <code class="computeroutput">query_my</code>. Then it would sit and
		collect the result rows. Finally it would get a row with <code class="computeroutput">qqq_end = TRUE</code>
		and disconnect.
		</p><p>
		This is a fairly large amount of code to be repeated for every window.
		What I would like to to instead is to just write:
		</p><pre class="programlisting">create window w_my schema s_my
keep last per key_a per key_b
keep 1 week;

make_queryable(w_my);</pre><p>
		and have the template <code class="computeroutput">make_queryable</code> expand into the rest of the code
		(obviously, the schema definitions would not need to be expanded
		repeatedly, they would go into an include file).
		</p><p>
		To make things more interesting, it would be nice to have the query
		filter the results by some field values. Nothing as fancy as SQL, just
		by equality to some fields. Suppose, s_my includes the fields field_c
		and field_d, and we want to be able to filter by them. Then the query
		can be done as:
		</p><pre class="programlisting">create input stream query_my schema inherits from s_query (
  field_c integer,
  field_d string
);

// result_my is the same as before...

// query with filtering (in a rather inefficient way)
insert into result_my
select q.qqq_id, NULL, w.*
from s_query as q, w_my as w
where
  (q.field_c is null or q.field_c = w.field_c)
  and (q.field_d is null or q.field_d = w.field_d);

// the end marker is as before
insert into result_my (qqq_id, qqq_end)
select qqq_id, TRUE
from s_query;</pre><p>
		It would be nice then to create this kind of query as a template
		instantiation
		</p><pre class="programlisting">make_query(w_my, (field_c, field_d));</pre><p>
		Or even better, have the template determine the non-NULL
		fields in the query record and compile the right query on the
		fly.
		</p><a class="indexterm" name="id487189"></a><a class="indexterm" name="id483646"></a><p>
		But the Coral8 modules (nor the later Sybase CEP R5) aren't flexible
		enough to do any of it. A CCL module requires a fixed schema for all its
		interfaces.
		The StreamBase language is more flexible and
		allows to achieve some of the flexibility through the capture
		fields, where the <span class="quote">&#8220;<span class="quote">logically unimportant</span>&#8221;</span> fields
		are carried through the module as one combined payload field. 
		But they don't allow the variable lists of fields as parameters either,
		nor generation of different model topologies depending on the parameters.
		</p></div><div class="sect1" title="10.2. Template variety"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_template_variety"></a>10.2. Template variety</h2></div></div></div><p>
		A template in Triceps is generally a function or class that
		creates a fragment of the model based on its arguments.
		It provides the access points used to connect this fragment to the rest
		of the model.
		</p><p>
		There are different ways do do this. They can be broadly classified 
		in the order of increasing complexity as:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		A function that creates a single Triceps object and returns it.
		The benefit is that the function would automatically choose some complex
		object parameters based on the function parameters, thus turning
		a complex creation into a simple one.
		</li><li class="listitem">
		A class that similarly creates multiple fixed objects and interconnects
		them properly. It would also provide the accessor methods to export
		the access points of this sub-model. Since the Perl functions may
		return multiple values, this functionality sometimes can be
		conveniently done with a function as well, returning the access
		points in the return array.
		</li><li class="listitem">
		A class or function that creates multiple objects, with their number and
		connections dependent on the parameters. For a simple example, a template
		might receive multiple functions/closures as arguments and then create
		a pipeline of computational labels, each of them computing one
		function (of course, this really makes sense only when each label
		runs in a separate thread).
		</li><li class="listitem">
		A class or function that automatically generates the Perl code that
		will be used in the created objects. For a simple example, given the
		pairs of field names and values, a template can generate the code for a filter
		label that would pass only the rows where these fields have these values.
		The same effect can often be achieved by the interpretation as well:
		keep the arguments until the evaluation needs to be done, and then
		interpret them. But the early code generation with compilation 
		improves the efficiency of the computation. It's the same idea
		as in the C++ templates: do more of the hard work at the compile time
		and then run faster.
		</li></ul></div><p>
		The more complex and flexible is the template, the more difficult
		it's generally to write and debug, but then it just works, encapsulating
		a complex problem with a simpler interface. There is also the problem
		of user errors: when the user gives an incorrect argument to a complex
		template, understanding what exactly went wrong when the error manifests
		itself, may be quite difficult. The C++ templates are a good
		example of this. However the use of Perl, a general programming
		language, as a template language in Triceps provides a good solution
		for this problem: just check the arguments early in the template and
		produce the meaningful error messages. It may be a bit cumbersome
		to write but then easy to use. I also have plans for improving the
		automatic error reports, to make tracking through the layers
		of templates easier with minimal code additions in the templates.
		</p><p>
		I will show the examples of all the template types by implementing the table
		querying, the same I have shown in CCL in
		<a class="xref" href="#sc_template_intro" title="10.1. Comparative modularity">Section 10.1: &#8220;Comparative modularity&#8221; </a>,
		only now in Triceps.
		</p></div><div class="sect1" title="10.3. Simple wrapper templates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_template_wrapper"></a>10.3. Simple wrapper templates</h2></div></div></div><p>
		The SimpleServer package described in
		<a class="xref" href="#sc_sched_mainloop_socket" title="7.9. Main loop with a socket">Section 7.9: &#8220;Main loop with a socket&#8221; </a>
		contains templates for the repeating tasks. 
		<code class="computeroutput">makeExitLabel()</code> creates a label that will
		request the server to exit, <code class="computeroutput">makeServerOutLabel()</code> creates
		a label that will send the rows from some label back into the socket.
		</p><p>
		Rather than copying the code here again, please refer to the description in
		<a class="xref" href="#sc_sched_mainloop_socket" title="7.9. Main loop with a socket">Section 7.9: &#8220;Main loop with a socket&#8221; </a>.
		</p><p>
		Another similar template that is used throughout the following
		chapters creates a label that prints the rowop contents.
		It's located in the package that wraps the input (e.g. feeding)
		and output of the tests:
		</p><pre class="programlisting">package Triceps::X::TestFeed;

# a template to make a label that prints the data passing through another label
sub makePrintLabel($$) # ($print_label_name, $parent_label)
{
  my $name = shift;
  my $lbParent = shift;
  my $lb = $lbParent-&gt;getUnit()-&gt;makeLabel($lbParent-&gt;getType(), $name,
    undef, sub { # (label, rowop)
      print($_[1]-&gt;printP(), "\n");
    });
  $lbParent-&gt;chain($lb);
  return $lb;
}</pre><p>
		It works very much the same as <code class="computeroutput">makeServerOutLabel()</code>, only
		prints to a different destination.
		</p></div><div class="sect1" title="10.4. Templates of interconnected components"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_template_intercon"></a>10.4. Templates of interconnected components</h2></div></div></div><p>
		Let's move on to the query template. It will work a little
		differently than the CCL version. First, the socket main loop
		allows to send the response directly to the same client who
		issued the request. So there is no need for adding the request
		id field in the response and for the client filtering by it.
		Second, Triceps rows have the opcode field, which can be used
		to signal the end of the response. For example, the data
		rows can be sent with the opcode INSERT and the indication of
		the end of response can be sent with the opcode NOP and
		all fields NULL.  The query template can then be made as follows:
		</p><pre class="programlisting">package Query1;

sub new # ($class, $table, $name)
{
  my $class = shift;
  my $table = shift;
  my $name = shift;

  my $unit = $table-&gt;getUnit();
  my $rt = $table-&gt;getRowType();

  my $self = {};
  $self-&gt;{unit} = $unit;
  $self-&gt;{name} = $name;
  $self-&gt;{table} = $table;
  $self-&gt;{inLabel} = $unit-&gt;makeLabel($rt, $name . ".in", undef, sub {
    # This version ignores the row contents, just dumps the table.
    my ($label, $rop, $self) = @_;
    my $rh = $self-&gt;{table}-&gt;begin();
    for (; !$rh-&gt;isNull(); $rh = $rh-&gt;next()) {
      $self-&gt;{unit}-&gt;call(
        $self-&gt;{outLabel}-&gt;makeRowop("OP_INSERT", $rh-&gt;getRow()));
    }
    # The end is signaled by OP_NOP with empty fields.
    $self-&gt;{unit}-&gt;makeArrayCall($self-&gt;{outLabel}, "OP_NOP");
  }, $self);
  $self-&gt;{outLabel} = $unit-&gt;makeDummyLabel($rt, $name . ".out");

  bless $self, $class;
  return $self;
}

sub getInputLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{inLabel};
}

sub getOutputLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{outLabel};
}

sub getName # ($self)
{
  my $self = shift;
  return $self-&gt;{name};
}</pre><p>
		It creates the input label that does the work and the dummy output
		label that is used to send the result. The logic is easy: whenever
		a rowop is received on the input label, iterate through the table
		and send the contents to the output label. The contents of that
		received rowop doesn't even matter. The getter methods allow to
		get the endpoints.
		</p><p>
		Now this example can be used in a program. Most of it is the example
		infrastructure: the function to start the server in background and connect
		a client to it, the creation of the row type and table type to
		query, and then finally near the end the interesting part: the
		usage of the query template. The general running is enclosed
		in the package Triceps::X::DumbClient:
		</p><pre class="programlisting">package Triceps::X::DumbClient;

sub run # ($labels)
{
  my $labels = shift;

  my ($port, $pid) = Triceps::X::SimpleServer::startServer(0, $labels);
  my $sock = IO::Socket::INET-&gt;new(
    Proto =&gt; "tcp",
    PeerAddr =&gt; "localhost",
    PeerPort =&gt; $port,
  ) or confess "socket failed: $!";
  while(&amp; readLine) {
    $sock-&gt;print($_);
    $sock-&gt;flush();
  }
  $sock-&gt;print("exit,OP_INSERT\n");
  $sock-&gt;flush();
  $sock-&gt;shutdown(1); # SHUT_WR
  while(&lt;$sock&gt;) {
    &amp; send($_);
  }
  waitpid($pid, 0);
}</pre><p>
		The function <code class="computeroutput">run()</code> takes care of making the example easier to run:
		it starts the server in the background, reads the input data and
		sends it to the server, then reads the responses and prints them
		back, and finally waits for the server process to exit. It also takes
		care of sending the exit request to the server when the input
		reaches EOF.  The approach
		with first sending all the data there and then reading all the responses
		back is not very good. It works only if either the data gets sent
		without any responses, or a small amount of data (not to overflow the
		TCP buffers along the way) gets sent and then it's all the responses
		coming back.  But it's simple, and it works good enough for the
		small examples. And actually many of the commercial CEP interfaces
		work exacly like this: they either publish the data to the model
		or send a small subscription request and print the data received
		from the subscription.
		</p><p>
		Then the actual example makes use of this function:
		</p><pre class="programlisting"># The basic table type to be used as template argument.
our $rtTrade = Triceps::RowType-&gt;new(
  id =&gt; "int32", # trade unique id
  symbol =&gt; "string", # symbol traded
  price =&gt; "float64",
  size =&gt; "float64", # number of shares traded
);

our $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("bySymbol",
    Triceps::SimpleOrderedIndex-&gt;new(symbol =&gt; "ASC")
      -&gt;addSubIndex("last2",
        Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
      )
  )
;
$ttWindow-&gt;initialize();

my $uTrades = Triceps::Unit-&gt;new("uTrades");
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");
my $query = Query1-&gt;new($tWindow, "qWindow");
my $srvout = &amp;Triceps::X::SimpleServer::makeServerOutLabel($query-&gt;getOutputLabel());

my %dispatch;
$dispatch{$tWindow-&gt;getName()} = $tWindow-&gt;getInputLabel();
$dispatch{$query-&gt;getName()} = $query-&gt;getInputLabel();
$dispatch{"exit"} = &amp;Triceps::X::SimpleServer::makeExitLabel($uTrades, "exit");

Triceps::X::DumbClient::run(\%dispatch);</pre><p>
		The row type and table type have been just copied from some
		other example. There is no particular meaning to why such
		fields were selected or why the table has such indexes.
		They have been selected semi-randomly. The only triucky thing
		that affects the result is that this table implements a window
		with a limit of 2 rows per symbol.
		</p><p>
		After the table is created, the template instantiation is a single
		call, <code class="computeroutput">Query1-&gt;new()</code>. Then the output label of the query
		template gets connected to a label that sends the output back to the
		client, and that's it.
		</p><p>
		Here is an example of a run, with the input rows printed 
		as always in bold.
		</p><pre class="programlisting"><span class="bold"><strong>tWindow,OP_INSERT,1,AAA,10,10</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,3,AAA,20,20</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
qWindow.out,OP_INSERT,1,AAA,10,10
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_NOP,,,,
<span class="bold"><strong>tWindow,OP_INSERT,5,AAA,30,30</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,5,AAA,30,30
qWindow.out,OP_NOP,,,,</pre><p>
		Because of the way <code class="computeroutput">run()</code> works, all the input rows are
		printed before the output ones. If it were smarter and knew, when
		to expect the responses before sending more inputs, 
		the output would have been:
		</p><pre class="programlisting"><span class="bold"><strong>tWindow,OP_INSERT,1,AAA,10,10</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,3,AAA,20,20</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
qWindow.out,OP_INSERT,1,AAA,10,10
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_NOP,,,,
<span class="bold"><strong>tWindow,OP_INSERT,5,AAA,30,30</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,5,AAA,30,30
qWindow.out,OP_NOP,,,,</pre><p>
		Two rows get inserted into the table,
		then a query is done, then one more row is inserted, then another
		query sent. When the third row is inserted, the first row gets
		thrown away by the window limit, so the second query also
		returns two rows albeit different than the first query does.
		</p><p>
		It is possible to fold the table and the client send label creation 
		into the template as well.  It will then be used as follows:
		</p><pre class="programlisting">my $window = $uTrades-&gt;makeTableQuery2($ttWindow, "window");

my %dispatch;
$dispatch{$window-&gt;getName()} = $window-&gt;getInputLabel();
$dispatch{$window-&gt;getQueryLabel()-&gt;getName()} = $window-&gt;getQueryLabel();
$dispatch{"exit"} = &amp;ServerHelpers::makeExitLabel($uTrades, "exit");</pre><p>
		The rest of the infrastructure would stay unchanged. Just to show
		how it can be done, I've even added a factory method
		<code class="computeroutput">Unit::makeTableQuery2()</code>. The implementation of this
		template is:
		</p><pre class="programlisting">package TableQuery2;
use Carp;

sub CLONE_SKIP { 1; }

sub new # ($class, $unit, $tabType, $name)
{
  my $class = shift;
  my $unit = shift;
  my $tabType = shift;
  my $name = shift;

  my $table = $unit-&gt;makeTable($tabType, $name);
  my $rt = $table-&gt;getRowType();

  my $self = {};
  $self-&gt;{unit} = $unit;
  $self-&gt;{name} = $name;
  $self-&gt;{table} = $table;
  $self-&gt;{qLabel} = $unit-&gt;makeLabel($rt, $name . ".query", undef, sub {
    # This version ignores the row contents, just dumps the table.
    my ($label, $rop, $self) = @_;
    my $rh = $self-&gt;{table}-&gt;begin();
    for (; !$rh-&gt;isNull(); $rh = $rh-&gt;next()) {
      $self-&gt;{unit}-&gt;call(
        $self-&gt;{resLabel}-&gt;makeRowop("OP_INSERT", $rh-&gt;getRow()));
    }
    # The end is signaled by OP_NOP with empty fields.
    $self-&gt;{unit}-&gt;makeArrayCall($self-&gt;{resLabel}, "OP_NOP");
  }, $self);
  $self-&gt;{resLabel} = $unit-&gt;makeDummyLabel($rt, $name . ".response");

  $self-&gt;{sendLabel} = &amp;Triceps::X::SimpleServer::makeServerOutLabel($self-&gt;{resLabel});

  bless $self, $class;
  return $self;
}

sub getName # ($self)
{
  my $self = shift;
  return $self-&gt;{name};
}

sub getQueryLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{qLabel};
}

sub getResponseLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{resLabel};
}

sub getSendLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{sendLabel};
}

sub getTable # ($self)
{
  my $self = shift;
  return $self-&gt;{table};
}

sub getInputLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{table}-&gt;getInputLabel();
}

sub getOutputLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{table}-&gt;getOutputLabel();
}

sub getPreLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{table}-&gt;getPreLabel();
}

# add a factory to the Unit type
package Triceps::Unit;

sub makeTableQuery2 # ($self, $tabType, $name)
{
  return TableQuery2-&gt;new(@_);
}</pre><p>
		The meat of the logic stays the same. The creation of the table
		and of the client sending label are added around it, as well as
		a bunch of getter methods to get access to the components.
		</p><p>
		The output of this example is the same, with the only difference
		that it expects and sends different label names:
		</p><pre class="programlisting"><span class="bold"><strong>window,OP_INSERT,1,AAA,10,10</strong></span>
<span class="bold"><strong>window,OP_INSERT,3,AAA,20,20</strong></span>
<span class="bold"><strong>window.query,OP_INSERT</strong></span>
<span class="bold"><strong>window,OP_INSERT,5,AAA,30,30</strong></span>
<span class="bold"><strong>window.query,OP_INSERT</strong></span>
window.response,OP_INSERT,1,AAA,10,10
window.response,OP_INSERT,3,AAA,20,20
window.response,OP_NOP,,,,
window.response,OP_INSERT,3,AAA,20,20
window.response,OP_INSERT,5,AAA,30,30
window.response,OP_NOP,,,,</pre></div><div class="sect1" title="10.5. Template options"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_template_options"></a>10.5. Template options</h2></div></div></div><p>
		Often the arguments of the template constructor become more convenient
		to organize in the option name-value pairs. It becomes particularly
		useful when there are many arguments and/or when some of them really
		are optional. For our little query template this is not the case
		but it can be written with options nevertheless (a modification of the
		original version, without the table in it):
		</p><pre class="programlisting">package Query3;

sub new # ($class, $optionName =&gt; $optionValue ...)
{
  my $class = shift;
  my $self = {};

  &amp;Triceps::Opt::parse($class, $self, {
    name =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    table =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "Triceps::Table") } ],
  }, @_);

  my $name = $self-&gt;{name};

  my $table = $self-&gt;{table};
  my $unit = $table-&gt;getUnit();
  my $rt = $table-&gt;getRowType();

  $self-&gt;{unit} = $unit;
  $self-&gt;{name} = $name;
  $self-&gt;{inLabel} = $unit-&gt;makeLabel($rt, $name . ".in", undef, sub {
    # This version ignores the row contents, just dumps the table.
    my ($label, $rop, $self) = @_;
    my $rh = $self-&gt;{table}-&gt;begin();
    for (; !$rh-&gt;isNull(); $rh = $rh-&gt;next()) {
      $self-&gt;{unit}-&gt;call(
        $self-&gt;{outLabel}-&gt;makeRowop("OP_INSERT", $rh-&gt;getRow()));
    }
    # The end is signaled by OP_NOP with empty fields.
    $self-&gt;{unit}-&gt;makeArrayCall($self-&gt;{outLabel}, "OP_NOP");
  }, $self);
  $self-&gt;{outLabel} = $unit-&gt;makeDummyLabel($rt, $name . ".out");

  bless $self, $class;
  return $self;
}</pre><p>
		The getter methods stayed the same, so I've skipped them here.
		The call has changed:
		</p><pre class="programlisting">my $query = Query3-&gt;new(table =&gt; $tWindow, name =&gt; "qWindow");</pre><p>
		The output stayed the same.
		</p><p>
		The class Triceps::Opt is used to parse the arguments formatted as
		options. There is actually a similar option parser in CPAN but it
		didn't do everything I wanted, and considering how tiny it is, it's
		easier to write a new one from scratch than to extend that one. I also
		like to avoid the extra dependencies.
		</p><p>
		The heart of it is the method <code class="computeroutput">Triceps::Opt::parse()</code>. 
		It's normally called from a class constructor to parse the constructor's options,
		but can be called from the other functions as well.
		It does the following: 
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		Checks that all the options are known.
		</li><li class="listitem">
		Checks that the values are acceptable.
		</li><li class="listitem">
		Copies the values into the instance hash of the calling class.
		</li><li class="listitem">
		Provides the default values for the unspecified options.
		</li></ul></div><p>
		If anything goes wrong, it confesses with a reasonable message. The
		arguments tell the class name for the messages (since, remember, it
		is normally called from the class constructor), the
		reference to the object instance hash where to copy the options, the
		descriptions of the supported options, and the actual key-value pairs.
		</p><p>
		At the end of it, if all went well, the query's <code class="computeroutput">$self</code> will have the 
		values at keys <span class="quote">&#8220;<span class="quote">name</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">table</span>&#8221;</span>.
		</p><p>
		The options descriptions go in pairs of option name and an array
		reference with description. The array contains the default value and
		the checking function, either of which may be <code class="computeroutput">undef</code>. The checking
		function returns if everything went fine or confesses on any errors. To die
		happily with a proper message, it gets not only the value to
		check but more, altogether:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		The value to check.
		</li><li class="listitem">
		The name of the option.
		</li><li class="listitem">
		The name of the class, for error messages.
		</li><li class="listitem">
		The object instance (<code class="computeroutput">$self</code>), just in case.
		</li></ul></div><p>
		If you want to do multiple checks, you just make a closure and call all
		the checks in sequence, passing <code class="computeroutput">@_</code> to them all, like shown here for
		the option <span class="quote">&#8220;<span class="quote">table</span>&#8221;</span>. If more arguments need to be passed to
		the checking function, just add them after <code class="computeroutput">@_</code> (or, if you
		prefer, before it, if you write your checking function that way). 
		</p><p>
		You can create any checking functions, but a few ready ones are provided:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">Triceps::Opt::ck_mandatory</code> checks that the value is defined.
		</li><li class="listitem"><code class="computeroutput">Triceps::Opt::ck_ref</code> checks that the value is a reference to a
		particular class, or a class derived from it. Just give the class name as the extra argument. Or,
		to check that the reference is to array or hash, make the argument
		<code class="computeroutput">"ARRAY"</code> or <code class="computeroutput">"HASH"</code>. Or an empty string <code class="computeroutput">""</code> to check that it's not a
		reference at all. For the arrays and hashes it can also check the
		values contained in them for being references to the correct types: give that
		type as the second extra argument. But it doesn't go deeper than that,
		just one nesting level. It might be extended later, but for now one nesting
		level has been enough.
		</li><li class="listitem"><code class="computeroutput">Triceps::Opt::ck_refscalar</code> checks that the value is a reference to a
		scalar. This is designed to check the arguments which are used to
		return data back to the caller, and it would accept any previous value
		in that scalar: an actual scalar value, an <code class="computeroutput">undef</code> or a reference,
		since it's about to be overwritten anyway.
		</li></ul></div><p>
		The <code class="computeroutput">ck_ref()</code> and <code class="computeroutput">ck_refscalar()</code> allow the value to be undefined, so they
		can safely be used on the truly optional options. When I come up with more of
		the useful check functions, I'll add them.
		</p><p>
		Triceps::Opt provides more helper functions to deal with options after
		they have been parsed. One of them is <code class="computeroutput">handleUnitTypeLabel()</code> that handles
		a very specific but frequently occuring case: Depending on the usage, sometimes
		it's more convenient to give the template the input row type and unit, and later chain
		its input to another label; and sometimes it's more convenient to give it
		another ready label and have the template find out the row type and unit from it,
		and chain its input to that label automatically, like <code class="computeroutput">ServerHelpers::makeServerOutLabel()</code> 
		was shown doing in
		<a class="xref" href="#sc_template_wrapper" title="10.3. Simple wrapper templates">Section 10.3: &#8220;Simple wrapper templates&#8221; </a>.
		It's possible if the unit, row type and source label are made the optional options.
		</p><p>
		<code class="computeroutput">Triceps::Opt::handleUnitTypeLabel()</code> takes care of sorting out what information
		is available, that enough of it is available, that exactly one of row type or
		source label options is specified, and fills in the unit and row type
		values from the source label (specifying the unit option along with
		the source label is OK as long as the unit is the same). To show it
		off, I re-wrote the <code class="computeroutput">ServerHelpers::makeServerOutLabel()</code> as 
		a class with options:
		</p><pre class="programlisting">package ServerOutput;
use Carp;

sub CLONE_SKIP { 1; }

# Sending of rows to the server output.
sub new # ($class, $option =&gt; $value, ...)
{
  no warnings;

  my $class = shift;
  my $self = {};

  &amp;Triceps::Opt::parse($class, $self, {
    name =&gt; [ undef, undef ],
    unit =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::Unit") } ],
    rowType =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::RowType") } ],
    fromLabel =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::Label") } ],
  }, @_);

  &amp;Triceps::Opt::handleUnitTypeLabel("$class::new",
    unit =&gt; \$self-&gt;{unit},
    rowType =&gt; \$self-&gt;{rowType},
    fromLabel =&gt; \$self-&gt;{fromLabel}
  );
  my $fromLabel = $self-&gt;{fromLabel};

  if (!defined $self-&gt;{name}) {
    confess "$class::new: must specify at least one of the options name and fromLabel"
      unless (defined $self-&gt;{fromLabel});
    $self-&gt;{name} = $fromLabel-&gt;getName() . ".serverOut";
  }

  my $lb = $self-&gt;{unit}-&gt;makeLabel($self-&gt;{rowType},
    $self-&gt;{name}, undef, sub {
      &amp;Triceps::X::SimpleServer::outCurBuf(join(",",
        $fromLabel? $fromLabel-&gt;getName() : $self-&gt;{name},
        &amp;Triceps::opcodeString($_[1]-&gt;getOpcode()),
        $_[1]-&gt;getRow()-&gt;toArray()) . "\n");
    }, $self # $self is not used in the function but used for cleaning
  );
  $self-&gt;{inLabel} = $lb;
  if (defined $fromLabel) {
    $fromLabel-&gt;chain($lb);
  }

  bless $self, $class;
  return $self;
}

sub getInputLabel() # ($self)
{
  my $self = shift;
  return $self-&gt;{inLabel};
}</pre><p>
		The arguments to <code class="computeroutput">Triceps::Opt::handleUnitTypeLabel()</code> are the
		caller function name for the error messages, and the pairs of option name
		and reference to the option value for the unit, row type and the source
		label.
		</p><p>
		The new class also has the optional option <span class="quote">&#8220;<span class="quote">name</span>&#8221;</span>. If it's
		not specified and <span class="quote">&#8220;<span class="quote">fromLabel</span>&#8221;</span> is specified, the name
		is generated by appending a suffix to the name of the source label.
		The new class can be used in one of two ways, either
		</p><pre class="programlisting">my $srvout = ServerOutput-&gt;new(fromLabel =&gt; $query-&gt;getOutputLabel());</pre><p>
		or
		</p><pre class="programlisting">my $srvout = ServerOutput-&gt;new(
  name =&gt; "out",
  unit =&gt; $uTrades,
  rowType =&gt; $tWindow-&gt;getRowType(),
);
$query-&gt;getOutputLabel()-&gt;chain($srvout-&gt;getInputLabel());</pre><p>
		The second form comes handy if you want to create it before creating
		the query.
		</p><p>
		The other helper function is <code class="computeroutput">Triceps::Opt::checkMutuallyExclusive()</code>.
		It checks that no more than one option from the list is specified.
		The joins use it to allow multiple ways to specify the join condition.
		For now I'll show a bit contrived example, rewriting the last example
		of ServerOutput with it:
		</p><pre class="programlisting">package ServerOutput2;
use Carp;

sub CLONE_SKIP { 1; }

# Sending of rows to the server output.
sub new # ($class, $option =&gt; $value, ...)
{
  no warnings;

  my $class = shift;
  my $self = {};

  &amp;Triceps::Opt::parse($class, $self, {
    name =&gt; [ undef, undef ],
    unit =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory; &amp;Triceps::Opt::ck_ref(@_, "Triceps::Unit") } ],
    rowType =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::RowType") } ],
    fromLabel =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::Label") } ],
  }, @_);

  my $fromLabel = $self-&gt;{fromLabel};
  if (&amp;Triceps::Opt::checkMutuallyExclusive("$class::new", 1,
      rowType =&gt; $self-&gt;{rowType},
      fromLabel =&gt; $self-&gt;{fromLabel}
    ) eq "fromLabel"
  ) {
    $self-&gt;{rowType} = $fromLabel-&gt;getRowType();
  }

  if (!defined $self-&gt;{name}) {
    confess "$class::new: must specify at least one of the options name and fromLabel"
      unless (defined $self-&gt;{fromLabel});
    $self-&gt;{name} = $fromLabel-&gt;getName() . ".serverOut";
  }

  my $lb = $self-&gt;{unit}-&gt;makeLabel($self-&gt;{rowType},
    $self-&gt;{name}, undef, sub {
      &amp;Triceps::X::SimpleServer::outCurBuf(join(",",
        $fromLabel? $fromLabel-&gt;getName() : $self-&gt;{name},
        &amp;Triceps::opcodeString($_[1]-&gt;getOpcode()),
        $_[1]-&gt;getRow()-&gt;toArray()) . "\n");
    }, $self # $self is not used in the function but used for cleaning
  );
  $self-&gt;{inLabel} = $lb;
  if (defined $fromLabel) {
    $fromLabel-&gt;chain($lb);
  }

  bless $self, $class;
  return $self;
}

sub getInputLabel() # ($self)
{
  my $self = shift;
  return $self-&gt;{inLabel};
}</pre><p>
		The arguments of the <code class="computeroutput">Triceps::Opt::checkMutuallyExclusive()</code>
		are the caller name for error messages, flag whether one of the mutually
		exclusive options must be specified, and the pairs of option names and
		values (this time not references, just values). It returns the name of
		the only option specified by the user, or <code class="computeroutput">undef</code> if none were.
		If more than one option was used, or if none were used and the mandatory
		flag is set, the function will confess.
		</p><p>
		The way this version of the code works, the option <span class="quote">&#8220;<span class="quote">unit</span>&#8221;</span>
		must be specified in any case, so the use case with the source label becomes:
		</p><pre class="programlisting">my $srvout = ServerOutput2-&gt;new(
  unit =&gt; $uTrades,
  fromLabel =&gt; $query-&gt;getOutputLabel()
);</pre><p>
		The use case with the independent creation is the same as with 
		the previous version of the <code class="computeroutput">ServerOutput</code>.
		</p></div><div class="sect1" title="10.6. Code generation in the templates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_template_codegen"></a>10.6. Code generation in the templates</h2></div></div></div><p>
		Suppose we want to filter the result of the query by the
		equality to the fields in the query request row. The list
		of the fields would be given to the query template. 
		The query code would check if these fields are not NULL
		(and since the simplistic CSV parsing is not good enough
		to tell between NULL and empty values, not an empty
		value either), and pass only the rows that match it.
		Here we go (skipping the methods that are the same as before):
		</p><pre class="programlisting">package Query4;
use Carp;

sub CLONE_SKIP { 1; }

sub new # ($class, $optionName =&gt; $optionValue ...)
{
  my $class = shift;
  my $self = {};

  &amp;Triceps::Opt::parse($class, $self, {
    name =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    table =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "Triceps::Table") } ],
    fields =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "ARRAY") } ],
  }, @_);

  my $name = $self-&gt;{name};

  my $table = $self-&gt;{table};
  my $unit = $table-&gt;getUnit();
  my $rt = $table-&gt;getRowType();

  my $fields = $self-&gt;{fields};
  if (defined $fields) {
    my %rtdef = $rt-&gt;getdef();
    foreach my $f (@$fields) {
      my $t = $rtdef{$f};
      confess "$class::new: unknown field '$f', the row type is:\n"
          . $rt-&gt;print() . " "
        unless defined $t;
    }
  }

  $self-&gt;{unit} = $unit;
  $self-&gt;{name} = $name;
  $self-&gt;{inLabel} = $unit-&gt;makeLabel($rt, $name . ".in", undef, sub {
    my ($label, $rop, $self) = @_;
    my $query = $rop-&gt;getRow();
    my $cmp = $self-&gt;{compare};
    my $rh = $self-&gt;{table}-&gt;begin();
    ITER: for (; !$rh-&gt;isNull(); $rh = $rh-&gt;next()) {
      if (defined $self-&gt;{fields}) {
        my $data = $rh-&gt;getRow();
        my %rtdef = $self-&gt;{table}-&gt;getRowType()-&gt;getdef();
        foreach my $f (@{$self-&gt;{fields}}) {
          my $v = $query-&gt;get($f);
          # Since the simplified CSV parsing in the mainLoop() provides
          # no easy way to send NULLs, consider any empty or 0 value
          # in the query row equivalent to NULLs.
          if ($v
          &amp;&amp; (&amp;Triceps::Fields::isStringType($rtdef{$f})
            ? $query-&gt;get($f) ne $data-&gt;get($f)
            : $query-&gt;get($f) != $data-&gt;get($f)
            )
          ) {
            next ITER;
          }
        }
      }
      $self-&gt;{unit}-&gt;call(
        $self-&gt;{outLabel}-&gt;makeRowop("OP_INSERT", $rh-&gt;getRow()));
    }
    # The end is signaled by OP_NOP with empty fields.
    $self-&gt;{unit}-&gt;makeArrayCall($self-&gt;{outLabel}, "OP_NOP");
  }, $self);
  $self-&gt;{outLabel} = $unit-&gt;makeDummyLabel($rt, $name . ".out");

  bless $self, $class;
  return $self;
}</pre><p>
		Used as:
		</p><pre class="programlisting">my $query = Query4-&gt;new(table =&gt; $tWindow, name =&gt; "qWindow",
  fields =&gt; ["symbol", "price"]);</pre><p>
		The field names get checked up front for correctness.
		And then at run time the code iterates through them and
		does the checking. Since the comparisons have to be done
		differently for the string and numeric values,
		<code class="computeroutput">Triceps::Fields::isStringType()</code> is used to check
		the type of the fields. Triceps::Fields is a collection
		of functions that help dealing with fields in the templates.
		Another similar function is <code class="computeroutput">Triceps::Fields::isArrayType()</code>
		</p><p>
		If the option <span class="quote">&#8220;<span class="quote">fields</span>&#8221;</span> is not specified, it would
		work the same as before and produce the same result.
		For the filtering by symbol and price, a sample output is:
		</p><pre class="programlisting"><span class="bold"><strong>tWindow,OP_INSERT,1,AAA,10,10</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,3,AAA,20,20</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,4,BBB,20,20</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
qWindow.out,OP_INSERT,1,AAA,10,10
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,4,BBB,20,20
qWindow.out,OP_NOP,,,,
<span class="bold"><strong>tWindow,OP_INSERT,5,AAA,30,30</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT,5,AAA,0,0</strong></span>
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,5,AAA,30,30
qWindow.out,OP_NOP,,,,
<span class="bold"><strong>qWindow,OP_INSERT,0,,20,0</strong></span>
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,4,BBB,20,20
qWindow.out,OP_NOP,,,,</pre><p>
		The table data now has one more row of data added to it, with the
		symbol <span class="quote">&#8220;<span class="quote">BBB</span>&#8221;</span>.
		The first query has no values to filter in it, so it just dumps
		the whole table as before. The second query filters by the symbol
		<span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span>. The field for price is 0, so it gets treated
		as empty and excluded from the comparison. The fields for id and
		size are not in the fields option, so they get ignored even if
		the value of id is 5. The third query filters by the price 
		equal to 20. The symbol field is empty in the query, so it does
		not participate in the filtering.
		</p><a class="indexterm" name="id517788"></a><p>
		Looking at the query execution code, now there is a lot more
		going on in it. And quite a bit of it is static, that could be
		computed at the time the query object is created.
		The next version does that, building and compiling the
		comparator function in advance:
		</p><pre class="programlisting">package Query5;
use Carp;

sub CLONE_SKIP { 1; }

sub new # ($class, $optionName =&gt; $optionValue ...)
{
  my $class = shift;
  my $self = {};

  &amp;Triceps::Opt::parse($class, $self, {
    name =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    table =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "Triceps::Table") } ],
    fields =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "ARRAY") } ],
    saveCodeTo =&gt; [ undef, \&amp;Triceps::Opt::ck_refscalar ],
  }, @_);

  my $name = $self-&gt;{name};

  my $table = $self-&gt;{table};
  my $unit = $table-&gt;getUnit();
  my $rt = $table-&gt;getRowType();

  my $fields = $self-&gt;{fields};
  if (defined $fields) {
    my %rtdef = $rt-&gt;getdef();

    # Generate the code of the comparison function by the fields.
    # Since the simplified CSV parsing in the mainLoop() provides
    # no easy way to send NULLs, consider any empty or 0 value
    # in the query row equivalent to NULLs.
    my $gencmp = '
      sub # ($query, $data)
      {
        use strict;
        my ($query, $data) = @_;
        my $v;';
    foreach my $f (@$fields) {
      my $t = $rtdef{$f};
      confess "$class::new: unknown field '$f', the row type is:\n"
          . $rt-&gt;print() . " "
        unless defined $t;
      $gencmp .= '
        $v = $query-&gt;get("' . quotemeta($f) . '");
        if ($v) {';
      if (&amp;Triceps::Fields::isStringType($t)) {
        $gencmp .= '
          return 0 if ($v ne $data-&gt;get("' . quotemeta($f) . '"));';
      } else {
        $gencmp .= '
          return 0 if ($v != $data-&gt;get("' . quotemeta($f) . '"));';
      }
      $gencmp .= '
        }';
    }
    $gencmp .= '
        return 1; # all succeeded
      }';

    ${$self-&gt;{saveCodeTo}} = $gencmp if (defined($self-&gt;{saveCodeTo}));
    $self-&gt;{compare} = eval $gencmp;
    # $@ already contains an \n at the end
    confess("Internal error: $class failed to compile the comparator:\n$@function text:\n"
        . Triceps::Code::numalign($gencmp, "  ") . "\n")
      if $@;
  }

  $self-&gt;{unit} = $unit;
  $self-&gt;{name} = $name;
  $self-&gt;{inLabel} = $unit-&gt;makeLabel($rt, $name . ".in", undef, sub {
    my ($label, $rop, $self) = @_;
    my $query = $rop-&gt;getRow();
    my $cmp = $self-&gt;{compare};
    my $rh = $self-&gt;{table}-&gt;begin();
    for (; !$rh-&gt;isNull(); $rh = $rh-&gt;next()) {
      if (!defined $cmp || &amp;$cmp($query, $rh-&gt;getRow())) {
        $self-&gt;{unit}-&gt;call(
          $self-&gt;{outLabel}-&gt;makeRowop("OP_INSERT", $rh-&gt;getRow()));
      }
    }
    # The end is signaled by OP_NOP with empty fields.
    $self-&gt;{unit}-&gt;makeArrayCall($self-&gt;{outLabel}, "OP_NOP");
  }, $self);
  $self-&gt;{outLabel} = $unit-&gt;makeDummyLabel($rt, $name . ".out");

  bless $self, $class;
  return $self;
}</pre><p>
		The code of the anonymous comparison function gets generated in <code class="computeroutput">$gencmp</code> 
		and then compiled by using <code class="computeroutput">eval</code>. 
		</p><a class="indexterm" name="id517850"></a><p>
		If the compilation fails (which should never happen, since the generated code
		should be always correct), it's printed out as a part of the error message,
		making the diagnostic easier. The function <code class="computeroutput">numalign()</code> makes the error messages
		easier to match to the code by printing out the line numbers with the code.
		It's described in detail in
		<a class="xref" href="#sc_ref_code" title="19.2. Code helpers reference">Section 19.2: &#8220;Code helpers reference&#8221; </a>.
		</p><p>
		<code class="computeroutput">eval</code> returns the pointer to the
		compiled function which is then used at run time. The generation
		uses all the same logic to decide on the string or numeric
		comparisons, and also effectively unrolls the loop. When generating
		the string constants in functions from the user-supplied values, 
		it's important to enquote them with <code class="computeroutput">quotemeta()</code>. Even when we're
		talking about the field names, they still could have some funny
		characters in them. The option <span class="quote">&#8220;<span class="quote">saveCodeTo</span>&#8221;</span> can be used
		to get the source code of the comparator, it gets saved at the
		reference after it gets generated.
		</p><p>
		If the filter field option is not used, the comparator remains undefined.
		</p><p>
		The use of this version is the same as of the previous one, but
		to show the source code of the comparator, I've added its printout:
		</p><pre class="programlisting">my $cmpcode;
my $query = Query5-&gt;new(table =&gt; $tWindow, name =&gt; "qWindow",
  fields =&gt; ["symbol", "price"], saveCodeTo =&gt; \$cmpcode );
# as a demonstration
print("Code:\n$cmpcode\n");</pre><p>
		This produces the result:
		</p><pre class="programlisting">Code:

      sub # ($query, $data)
      {
        use strict;
        my ($query, $data) = @_;
        my $v = $query-&gt;get("symbol");
        if ($v) {
          return 0 if ($v ne $data-&gt;get("symbol"));
        }
        my $v = $query-&gt;get("price");
        if ($v) {
          return 0 if ($v != $data-&gt;get("price"));
        }
        return 1; # all succeeded
      }
<span class="bold"><strong>tWindow,OP_INSERT,1,AAA,10,10</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,3,AAA,20,20</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,4,BBB,20,20</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
qWindow.out,OP_INSERT,1,AAA,10,10
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,4,BBB,20,20
qWindow.out,OP_NOP,,,,
<span class="bold"><strong>tWindow,OP_INSERT,5,AAA,30,30</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT,5,AAA,0,0</strong></span>
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,5,AAA,30,30
qWindow.out,OP_NOP,,,,
<span class="bold"><strong>qWindow,OP_INSERT,0,,20,0</strong></span>
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,4,BBB,20,20
qWindow.out,OP_NOP,,,,</pre><p>
		Besides the code printout, the result is the same as last time.
		</p><p>
		Now, why list the fields in an option? Why not just take them all?
		After all, if the user doesn't want filtering on some field, he
		can always simply not set it in the query row. If the efficiency
		is a concern, with possibly hundreds of fields in the row with
		only few of them used for filtering, we can do better: we can
		generate and compile the comparison function after we see the
		query row. Here goes the next version that does all this:
		</p><pre class="programlisting">package Query6;
use Carp;

sub CLONE_SKIP { 1; }

sub new # ($class, $optionName =&gt; $optionValue ...)
{
  my $class = shift;
  my $self = {};

  &amp;Triceps::Opt::parse($class, $self, {
    name =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    table =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "Triceps::Table") } ],
  }, @_);

  my $name = $self-&gt;{name};

  my $table = $self-&gt;{table};
  my $unit = $table-&gt;getUnit();
  my $rt = $table-&gt;getRowType();

  $self-&gt;{unit} = $unit;
  $self-&gt;{name} = $name;
  $self-&gt;{inLabel} = $unit-&gt;makeLabel($rt, $name . ".in", undef, sub {
    my ($label, $rop, $self) = @_;
    my $query = $rop-&gt;getRow();
    my $cmp = $self-&gt;genComparison($query);
    my $rh = $self-&gt;{table}-&gt;begin();
    for (; !$rh-&gt;isNull(); $rh = $rh-&gt;next()) {
      if (&amp;$cmp($query, $rh-&gt;getRow())) {
        $self-&gt;{unit}-&gt;call(
          $self-&gt;{outLabel}-&gt;makeRowop("OP_INSERT", $rh-&gt;getRow()));
      }
    }
    # The end is signaled by OP_NOP with empty fields.
    $self-&gt;{unit}-&gt;makeArrayCall($self-&gt;{outLabel}, "OP_NOP");
  }, $self);
  $self-&gt;{outLabel} = $unit-&gt;makeDummyLabel($rt, $name . ".out");

  bless $self, $class;
  return $self;
}

# Generate the comparison function on the fly from the fields in the
# query row.
# Since the simplified CSV parsing in the mainLoop() provides
# no easy way to send NULLs, consider any empty or 0 value
# in the query row equivalent to NULLs.
sub genComparison # ($self, $query)
{
  my $self = shift;
  my $query = shift;

  my %qhash = $query-&gt;toHash();
  my %rtdef = $self-&gt;{table}-&gt;getRowType()-&gt;getdef();
  my ($f, $v);

  my $gencmp = '
      sub # ($query, $data)
      {
        use strict;';

  # the sorting keeps the key order predictable for the tests;
  # the can also be done with Hash::Util::hash_traversal_mask()
  # but would not be backwards-compatible
  foreach $f (sort keys %qhash) {
    $v = $qhash{$f};
    next unless($v);
    my $t = $rtdef{$f};

    if (&amp;Triceps::Fields::isStringType($t)) {
      $gencmp .= '
        return 0 if ($_[0]-&gt;get("' . quotemeta($f) . '")
          ne $_[1]-&gt;get("' . quotemeta($f) . '"));';
    } else {
      $gencmp .= '
        return 0 if ($_[0]-&gt;get("' . quotemeta($f) . '")
          != $_[1]-&gt;get("' . quotemeta($f) . '"));';
    }
  }
  $gencmp .= '
        return 1; # all succeeded
      }';

  my $compare = eval $gencmp;
  # $@ already contains an \n at the end
  confess("Internal error: Query '" . $self-&gt;{name}
      . "' failed to compile the comparator:\n$@function text:\n"
      . Triceps::Code::numalign($gencmp, "  ") . "\n")
    if $@;

  # for debugging
  &amp;Triceps::X::SimpleServer::outCurBuf("Compiled comparator:\n$gencmp\n");

  return $compare;
}</pre><p>
		Thie option <span class="quote">&#8220;<span class="quote">fields</span>&#8221;</span> is gone, and the code generation
		has moved into the method <code class="computeroutput">genComparison()</code>, that gets called for
		each query. I've inserted the sending back of the comparison source code
		at the end of it, to make it easier to understand. Obviously, if this
		code were used in production, this would have to be commented out,
		and maybe some better option added for debugging.
		An example of the output is:
		</p><pre class="programlisting"><span class="bold"><strong>tWindow,OP_INSERT,1,AAA,10,10</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,3,AAA,20,20</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,4,BBB,20,20</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
Compiled comparator:

      sub # ($query, $data)
      {
        use strict;
        return 1; # all succeeded
      }
qWindow.out,OP_INSERT,1,AAA,10,10
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,4,BBB,20,20
qWindow.out,OP_NOP,,,,
<span class="bold"><strong>tWindow,OP_INSERT,5,AAA,30,30</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT,5,AAA,0,0</strong></span>
Compiled comparator:

      sub # ($query, $data)
      {
        use strict;
        return 0 if ($_[0]-&gt;get("symbol")
          ne $_[1]-&gt;get("symbol"));
        return 0 if ($_[0]-&gt;get("id")
          != $_[1]-&gt;get("id"));
        return 1; # all succeeded
      }
qWindow.out,OP_INSERT,5,AAA,30,30
qWindow.out,OP_NOP,,,,
<span class="bold"><strong>qWindow,OP_INSERT,0,,20,0</strong></span>
Compiled comparator:

      sub # ($query, $data)
      {
        use strict;
        return 0 if ($_[0]-&gt;get("price")
          != $_[1]-&gt;get("price"));
        return 1; # all succeeded
      }
qWindow.out,OP_INSERT,3,AAA,20,20
qWindow.out,OP_INSERT,4,BBB,20,20
qWindow.out,OP_NOP,,,,</pre><p>
		The first query contains no filter fields, so the function compiles
		to the constant 1. The second query has the fields id and symbol
		not empty, so the filtering goes by them. The third query has only
		the price field, and it is used for filtering.
		</p><p>
		The code generation on the fly is a powerful tool and is used
		throughout Triceps.
		</p></div><div class="sect1" title="10.7. Result projection in the templates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_template_result"></a>10.7. Result projection in the templates</h2></div></div></div><a class="indexterm" name="id518117"></a><a class="indexterm" name="id518127"></a><p>
		The other functionality provided by the Triceps::Fields is the
		filtering of the fields in the result row type, also known as 
		<span class="quote">&#8220;<span class="quote">projection</span>&#8221;</span>. You can select which fields you want
		and which you don't want, and rename the fields.
		</p><p>
		To show how it's done, I took the Query3 example from
		<a class="xref" href="#sc_template_options" title="10.5. Template options">Section 10.5: &#8220;Template options&#8221; </a>
		and added the result field filtering to it. I've also changed the
		format in which it returns the results to <code class="computeroutput">printP()</code>, to show the
		field names and make the effects of the field renaming visible.
		</p><pre class="programlisting">package Query7;

sub CLONE_SKIP { 1; }

sub new # ($class, $optionName =&gt; $optionValue ...)
{
  my $class = shift;
  my $self = {};

  &amp;Triceps::Opt::parse($class, $self, {
    name =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    table =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "Triceps::Table") } ],
    resultFields =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "ARRAY", ""); } ],
  }, @_);

  my $name = $self-&gt;{name};

  my $table = $self-&gt;{table};
  my $unit = $table-&gt;getUnit();
  my $rtIn = $table-&gt;getRowType();
  my $rtOut = $rtIn;

  if (defined $self-&gt;{resultFields}) {
    my @inFields = $rtIn-&gt;getFieldNames();
    my @pairs =  &amp;Triceps::Fields::filterToPairs($class, \@inFields, $self-&gt;{resultFields});
    ($rtOut, $self-&gt;{projectFunc}) = &amp;Triceps::Fields::makeTranslation(
      rowTypes =&gt; [ $rtIn ],
      filterPairs =&gt; [ \@pairs ],
    );
  } else {
    $self-&gt;{projectFunc} = sub {
      return $_[0];
    }
  }

  $self-&gt;{unit} = $unit;
  $self-&gt;{name} = $name;
  $self-&gt;{inLabel} = $unit-&gt;makeLabel($rtIn, $name . ".in", undef, sub {
    # This version ignores the row contents, just dumps the table.
    my ($label, $rop, $self) = @_;
    my $rh = $self-&gt;{table}-&gt;begin();
    for (; !$rh-&gt;isNull(); $rh = $rh-&gt;next()) {
      $self-&gt;{unit}-&gt;call(
        $self-&gt;{outLabel}-&gt;makeRowop("OP_INSERT",
          &amp;{$self-&gt;{projectFunc}}($rh-&gt;getRow())));
    }
    # The end is signaled by OP_NOP with empty fields.
    $self-&gt;{unit}-&gt;makeArrayCall($self-&gt;{outLabel}, "OP_NOP");
  }, $self);
  $self-&gt;{outLabel} = $unit-&gt;makeDummyLabel($rtOut, $name . ".out");

  bless $self, $class;
  return $self;
}

sub getInputLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{inLabel};
}

sub getOutputLabel # ($self)
{
  my $self = shift;
  return $self-&gt;{outLabel};
}

sub getName # ($self)
{
  my $self = shift;
  return $self-&gt;{name};
}

package main;

my $uTrades = Triceps::Unit-&gt;new("uTrades");
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");
my $query = Query7-&gt;new(table =&gt; $tWindow, name =&gt; "qWindow",
  resultFields =&gt; [ '!id', 'size/lot_$&amp;', '.*' ],
);
# print in the tokenized format
my $srvout = $uTrades-&gt;makeLabel($query-&gt;getOutputLabel()-&gt;getType(),
  $query-&gt;getOutputLabel()-&gt;getName() . ".serverOut", undef, sub {
    &amp;Triceps::X::SimpleServer::outCurBuf($_[1]-&gt;printP() . "\n");
  });
$query-&gt;getOutputLabel()-&gt;chain($srvout);

my %dispatch;
$dispatch{$tWindow-&gt;getName()} = $tWindow-&gt;getInputLabel();
$dispatch{$query-&gt;getName()} = $query-&gt;getInputLabel();
$dispatch{"exit"} = &amp;Triceps::X::SimpleServer::makeExitLabel($uTrades, "exit");

Triceps::X::DumbClient::run(\%dispatch);</pre><a class="indexterm" name="id509906"></a><p>
		The query now has the new option <span class="quote">&#8220;<span class="quote">resultFields</span>&#8221;</span> that
		defines the projection. That option accepts a reference to an
		array of pattern strings.
		If present, it gives the patterns of the fields to let through.
		The patterns may be either the explicit field names or regular
		expressions implicitly anchored at both front and back. There is also a
		bit of extra modification possible:
		</p><div class="variablelist"><dl><dt><span class="term">!<span class="emphasis"><em>pattern</em></span></span></dt><dd>
				Skip the fields matching the pattern.
				</dd><dt><span class="term"><span class="emphasis"><em>pattern</em></span>/<span class="emphasis"><em>substitution</em></span></span></dt><dd>
				Pass the matching fields and rename them according to the substitution.
				</dd></dl></div><p>
		So in this example <code class="computeroutput">[ '!id', 'size/lot_$&amp;', '.*' ]</code> means:
		skip the field <span class="quote">&#8220;<span class="quote">id</span>&#8221;</span>, rename the field <span class="quote">&#8220;<span class="quote">size</span>&#8221;</span> 
		by prepending <span class="quote">&#8220;<span class="quote">lot_</span>&#8221;</span> to it,
		and pass through the rest of the fields.
		In the renaming pattern, <code class="computeroutput">$&amp;</code> is the reference to the whole original
		field name. If you use the parenthesised groups, they are referred to
		as <code class="computeroutput">$1</code>, <code class="computeroutput">$2</code> and so on. But if you use any of those, don't forget
		to put the pattern into single quotes to prevent the unwanted expansion
		in the double quotes before the projection gets a chance to see it.
		</p><p>
		For an example of why the parenthesised groups can be useful, suppose that
		the row type has multiple account-related elements that all start
		with <span class="quote">&#8220;<span class="quote">acct</span>&#8221;</span>: <code class="computeroutput">acctsrc</code>, <code class="computeroutput">acctinternal</code>, <code class="computeroutput">acctexternal</code>.
		Suppose we want to insert an underscore after <span class="quote">&#8220;<span class="quote">acct</span>&#8221;</span>. This can be achieved
		with the pattern <code class="computeroutput">'acct(.*)/acct_$1'</code>.
		As usual in the Perl regexps, the parenthesised groups are numbered
		left to right, starting with <code class="computeroutput">$1</code>.
		</p><p>
		If a specification element refers to a literal
		field, like here <span class="quote">&#8220;<span class="quote">id</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">size</span>&#8221;</span>, the projection
		checks that the field is actually present
		in the original row type, catching the typos. For the general regular
		expressions it doesn't check whether the pattern matched anything. It's
		not difficult to check but that would preclude the reuse of the same
		patterns on the varying row types, and I'm not sure yet, what is more
		important.
		</p><p>
		The way this whole thing works is that each field gets tested against
		each pattern in order. The first pattern that matches determines what
		happens to this field. If none of the patterns matches, the field gets
		ignored. An important consequence about the skipping patterns is that
		they don't automatically pass through the non-matching fields. You need
		to add an explicit positive pattern at the end of the list to pass the
		fields through. <code class="computeroutput">'.*'</code> serves this purpose in the example.
		</p><p>
		A consequence is that the order of the fields can't be changed
		by the projection.  They are tested in the order they appear in the original
		row type, and are inserted into the projected row type in the same order.
		</p><p>
		Another important point is that the field names in the result must not
		duplicate. It would be an error. Be careful with the substitution
		syntax to avoid creating the duplicate names.
		</p><p>
		A run example from this version, with the same input as before:
		</p><pre class="programlisting"><span class="bold"><strong>tWindow,OP_INSERT,1,AAA,10,10</strong></span>
<span class="bold"><strong>tWindow,OP_INSERT,3,AAA,20,20</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
qWindow.out OP_INSERT symbol="AAA" price="10" lot_size="10"
qWindow.out OP_INSERT symbol="AAA" price="20" lot_size="20"
qWindow.out OP_NOP
<span class="bold"><strong>tWindow,OP_INSERT,5,AAA,30,30</strong></span>
<span class="bold"><strong>qWindow,OP_INSERT</strong></span>
qWindow.out OP_INSERT symbol="AAA" price="20" lot_size="20"
qWindow.out OP_INSERT symbol="AAA" price="30" lot_size="30"
qWindow.out OP_NOP</pre><p>
		The rows returned are the same, but projected and printed in the
		<code class="computeroutput">printP()</code> format.
		</p><p>
		Inside the template the projection works in three steps:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">Triceps::Fields::filterToPairs()</code> does the projection of the field names
		and returns its result as an array of names. The names in the array go in pairs:
		the old name and the new name in each pair. The fields that got skipped
		do not get included in the list. In this example the array would be
		<code class="computeroutput">( "symbol", "symbol", "price", "price", "size", "lot_size" )</code>.
		</li><li class="listitem"><code class="computeroutput">Triceps::Fields::makeTranslation()</code> then takes this array along with the
		original row type and produces the result row type and a function reference
		that does the projection by converting an original row into the projected
		one.
		</li><li class="listitem">
		The template execution then calls this projection function for the result rows.
		</li></ul></div><p>
		The split of work between <code class="computeroutput">filterToPairs()</code> and <code class="computeroutput">makeTranslation()</code> has been
		done partially historically and partially  because sometimes you may want to 
		just get the pair names array
		and then use them on your own instead of calling <code class="computeroutput">makeTranslation()</code>. There
		is one more function that you may find useful if you do the handling
		on your own: <code class="computeroutput">filter()</code>. It takes the same arguments and does the same
		thing as <code class="computeroutput">filterToPairs()</code> but returns the result in a different format.
		It's still an array of strings but it contains only the names of the
		translated field names instead of the pairs, in the order matching the order
		of the original fields. For the fields that have been skipped it contains
		an <code class="computeroutput">undef</code>. For this example it would return
		<code class="computeroutput">( undef, "symbol", "price", "lot_size" )</code>.
		</p><p>
		The calls are:
		</p><pre class="programlisting">@fields = &amp;Triceps::Fields::filter(
  $caller, \@inFields, \@translation);
@pairs = &amp;Triceps::Fields::filterToPairs(
  $caller, \@inFields, \@translation);
($rowType, $projectFunc) = &amp;Triceps::Fields::makeTranslation(
  $optName =&gt; $optValue, ...);</pre><a class="indexterm" name="id510235"></a><p>
		All of them confess on errors, and the argument <code class="computeroutput">$caller</code> is
		used for building the error messages. The options of <code class="computeroutput">makeTranslations()</code> are:
		</p><p>
		<span class="quote">&#8220;<span class="quote">rowTypes</span>&#8221;</span> is a reference to an array of original row types.
		<span class="quote">&#8220;<span class="quote">filterPairs</span>&#8221;</span> is a reference to an array of filter pair arrays. 
		Both of these options are mandatory.  And that's
		right, <code class="computeroutput">makeTranslations()</code> can accept and merge more than one original row type, with a
		separate projection specification for each of them. It's not quite as
		flexible as I'd want it to be, not allowing to reorder and mix the fields
		from different originals (now the fields go in sequence: from the first
		original, from the second original, and so on), but it's a decent
		start. When you combine multiple original row types, you need to be
		particularly careful with avoiding the duplicate field names in the
		result.
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">saveCodeTo</span>&#8221;</span> also allows to save the source code of the generated
		function, same as in the Query5 example in
		<a class="xref" href="#sc_template_codegen" title="10.6. Code generation in the templates">Section 10.6: &#8220;Code generation in the templates&#8221; </a>.
		</p><p>
		The general call form of <code class="computeroutput">makeTranslations()</code> is:
		</p><pre class="programlisting">($rowType, $projectFunc) = &amp;Triceps::Fields::makeTranslation(
  rowTypes =&gt; [ $rt1, $rt2, ..., $rtN ],
  filterPairs =&gt; [ \@pairs1, \@pairs2, ..., \@pairsN ],
  saveCodeTo =&gt; \$codeVar,
);</pre><p>
		One of the result type or projection function referece could have also been
		returned to a place pointed to by an option, like <span class="quote">&#8220;<span class="quote">saveCodeTo</span>&#8221;</span>,
		but since Perl supports returning multiple values from a function, that looks simpler and
		cleaner.
		</p><p>
		The projection function is then called:
		</p><pre class="programlisting">$row = &amp;$projectFunc($origRow1, $origRow2, ..., $origRowN);</pre><p>
		Naturally, <code class="computeroutput">makeTranslations()</code> is a template itself. Let's look
		at its source code, it shows a new trick.
		</p><pre class="programlisting">package Triceps::Fields;

use Carp;

use strict;

sub makeTranslation # (optName =&gt; optValue, ...)
{
  my $opts = {}; # the parsed options
  my $myname = "Triceps::Fields::makeTranslation";

  &amp;Triceps::Opt::parse("Triceps::Fields", $opts, {
      rowTypes =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "ARRAY", "Triceps::RowType") } ],
      filterPairs =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "ARRAY", "ARRAY") } ],
      saveCodeTo =&gt; [ undef, sub { &amp;Triceps::Opt::ck_refscalar(@_) } ],
    }, @_);

  # reset the saved source code
  ${$opts-&gt;{saveCodeTo}} = undef if (defined($opts-&gt;{saveCodeTo}));

  my $rts = $opts-&gt;{rowTypes};
  my $fps = $opts-&gt;{filterPairs};

  confess "$myname: the arrays of row types and filter pairs must be of the same size, got " . ($#{$rts}+1) . " and " . ($#{$fps}+1) . " elements"
    unless ($#{$rts} == $#{$fps});

  my $gencode = '
    sub { # (@rows)
      use strict;
      use Carp;
      confess "template internal error in ' . $myname  . ': result translation expected ' . ($#{$rts}+1) . ' row args, received " . ($#_+1)
        unless ($#_ == ' . $#{$rts} . ');
      # $result_rt comes at compile time from Triceps::Fields::makeTranslation
      return $result_rt-&gt;makeRowArray(';

  my @rowdef; # of the result row type
  for (my $i = 0; $i &lt;= $#{$rts}; $i++) {
    my %origdef = $rts-&gt;[$i]-&gt;getdef();
    my @fp = @{$fps-&gt;[$i]}; # copy the array, because it will be shifted
    while ($#fp &gt;= 0) {
      my $from = shift @fp;
      my $to = shift @fp;
      my $type = $origdef{$from};
      confess "$myname: unknown original field '$from' in the original row type $i:\n" . $rts-&gt;[$i]-&gt;print() . " "
        unless (defined $type);
      push(@rowdef, $to, $type);
      $gencode .= '
        $_[' . $i . ']-&gt;get("' . quotemeta($from) . '"),';
    }
  }

  $gencode .= '
      );
    }';

  my $result_rt = Triceps::wrapfess
    "$myname: Invalid result row type specification:",
    sub { Triceps::RowType-&gt;new(@rowdef); };

  ${$opts-&gt;{saveCodeTo}} = $gencode if (defined($opts-&gt;{saveCodeTo}));

  # compile the translation function
  my $func = eval $gencode
    or confess "$myname: error in compilation of the generated function:\n  $@function text:\n"
    . Triceps::Code::numalign($gencode, "  ") . "\n";

  return ($result_rt, $func);
}</pre><a class="indexterm" name="id510370"></a><p>
		By now almost all the parts of the implementation should look
		familiar to you. It builds the result row definition and the
		projection function code in parallel by iterating through the
		originals. An interesting trick is done with passing the result
		row type into the projection function. The function needs it
		to create the result rows. But it can't be easily placed into
		the function source code. So the closure property of the projection
		function is used: whatever outside <span class="quote">&#8220;<span class="quote">my</span>&#8221;</span> variables occur in the function
		at the time when it's compiled, will have their values compiled
		hardcoded into the function. So the <span class="quote">&#8220;<span class="quote">my</span>&#8221;</span> variable 
		<code class="computeroutput">$result_rt</code> is  set with the result row type, and then the
		projection function gets compiled. The projection function
		refers to <code class="computeroutput">$result_rt</code>, which gets picked up from the parent scope
		and hardcoded in the closure.
		</p><p>
		The computation of the <code class="computeroutput">$result_rt</code> is wrapped in the
		enhanced error reporting, more on that below in
		<a class="xref" href="#sc_template_wrapfess" title="10.8. Error reporting in the templates">Section 10.8: &#8220;Error reporting in the templates&#8221; </a>.
		</p></div><div class="sect1" title="10.8. Error reporting in the templates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_template_wrapfess"></a>10.8. Error reporting in the templates</h2></div></div></div><a class="indexterm" name="id510437"></a><a class="indexterm" name="id510446"></a><a class="indexterm" name="id510460"></a><p>
		When writing the Triceps templates, it's always good to make them
		report any usage errors in the terms of the template (though the extra
		detail doesn't hurt either). That is, if a template builds a
		construction out of the lower-level primitives, and one of these
		primitives fails, the good approach is to not just pass through the
		error from the primitive but wrap it into a high-level explanation.
		</p><p>
		When the errors are reported like the exceptions, which means 
		in Perl by <code class="computeroutput">die()</code> or <code class="computeroutput">confess()</code>, this is not that easy to do well. The basic
		handling is easy, there is just no need to do anything to let the
		exception propagate up, but adding the extra information becomes
		difficult. First, you've got to explicitly check for these errors by
		catching them with <code class="computeroutput">eval()</code>, and only then can you add the extra
		information and re-throw. And then there is this pesky problem of the
		stack traces: if the re-throw uses <code class="computeroutput">confess()</code>, it will likely add a
		duplicate of at least a part of the stack trace that came with the
		underlying error, and if it uses <code class="computeroutput">die()</code>, the stack trace might be
		incomplete since the native XS code in Triceps includes the stack trace only to
		the nearest <code class="computeroutput">eval()</code> to prevent the same problem when unrolling the
		stacks mixed between Perl and Triceps scheduling.
		</p><p>
		Triceps provides a ready solution for this, the function <code class="computeroutput">Triceps::wrapfess()</code>
		that does everything right.  This solution is not even
		limited to Triceps, it can be used with any kind of Perl programs. 
		It has been used in the examples above, and looks as follows:
		</p><pre class="programlisting">my $result_rt = Triceps::wrapfess
  "$myname: Invalid result row type specification:",
  sub { Triceps::RowType-&gt;new(@rowdef); };</pre><p>
		The function <code class="computeroutput">Triceps::wrapfess()</code> is very much like the try/catch, only it has the
		hardcoded catch logic that adds the extra error information and then
		re-throws the exception.
		</p><p>
		Its first argument is the error message that describes the high-level
		problem. This message will get prepended to the error report when the
		error propagates up (and the original error message will get a bit of
		extra indenting, to nest under that high-level explanation).
		</p><p>
		The second argument is the code that might throw an error, like the
		try-block. The result from that block gets passed through as the result
		of <code class="computeroutput">wrapfess()</code>.
		</p><p>
		The full error message might look like this:
		</p><pre class="programlisting">Triceps::Fields::makeTranslation: Invalid result row type specification:
  Triceps::RowType::new: incorrect specification:
    duplicate field name 'f1' for fields 3 and 2
    duplicate field name 'f2' for fields 4 and 1
  Triceps::RowType::new: The specification was: {
    f2 =&gt; int32[]
    f1 =&gt; string
    f1 =&gt; string
    f2 =&gt; float64[]
  } at blib/lib/Triceps/Fields.pm line 209.
  Triceps::Fields::__ANON__ called at blib/lib/Triceps.pm line 192
  Triceps::wrapfess('Triceps::Fields::makeTranslation: Invalid result row type spe...', 'CODE(0x1c531e0)') called at blib/lib/Triceps/Fields.pm line 209
  Triceps::Fields::makeTranslation('rowTypes', 'ARRAY(0x1c533d8)', 'filterPairs', 'ARRAY(0x1c53468)') called at t/Fields.t line 186
  eval {...} called at t/Fields.t line 185</pre><p>
		It contains both the high-level and the detailed description of the
		error, and the stack trace.
		</p><p>
		The stack trace doesn't get indented, no matter how many times the
		message gets wrapped. <code class="computeroutput">Wrapfess()</code> uses a slightly dirty trick for that:
		it assumes that the error messages are indented by the spaces while the
		stack trace from <code class="computeroutput">confess()</code> is indented by a single tab character. So
		the extra spaces of indenting are added only to the lines that don't
		start with a tab.
		</p><p>
		Note also that even though <code class="computeroutput">wrapfess()</code> uses <code class="computeroutput">eval()</code>, there is no <code class="computeroutput">eval</code>
		above it in the stack trace. That's the other part of the magic: since
		that <code class="computeroutput">eval</code> is not meaningful, it gets cut from the stack trace, and
		<code class="computeroutput">wrapfess()</code> also uses it to find its own place in the stack trace, the
		point from which a simple re-confession would dump the duplicate of the
		stack. So it cuts the <code class="computeroutput">eval</code> and everything under it in the original
		stack trace, and then does its own confession, inserting the stack
		trace again. This works very well for the traces thrown by the XS code,
		which actually doesn't write anything below that <code class="computeroutput">eval</code>; <code class="computeroutput">wrapfess()</code> then
		adds the missing part of the stack.
		</p><p>
		Wrapfess() can do a bit more, <code class="computeroutput">$message</code> may be either a string or a code reference, or a reference
		to a scalar variable containing either. The detauls of that are explained in
		<a class="xref" href="#sc_ref_toplevel" title="19.1. Top-level functions reference">Section 19.1: &#8220;Top-level functions reference&#8221; </a>.
		</p></div></div><div class="chapter" title="Chapter 11. Aggregation"><div class="titlepage"><div><div><h2 class="title"><a name="ch_aggregation"></a>Chapter 11. Aggregation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_aggregation_vwap">11.1. The ubiquitous VWAP</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_manual">11.2. Manual aggregation</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_proper">11.3. Introducing the proper aggregation</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_window">11.4. Tricks with aggregation on a sliding window</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_optimized">11.5. Optimized DELETEs</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_additive">11.6. Additive aggregation</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_args">11.7. Computation function arguments</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_multi_idx">11.8. Using multiple indexes</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_simple">11.9. SimpleAggregator</a></span></dt><dt><span class="sect1"><a href="#sc_aggregation_simple_guts">11.10. The guts of SimpleAggregator</a></span></dt></dl></div><div class="sect1" title="11.1. The ubiquitous VWAP"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_vwap"></a>11.1. The ubiquitous VWAP</h2></div></div></div><a class="indexterm" name="id507567"></a><p>
		Every CEP supplier loves an example of VWAP calculation: it's small,
		it's about that quintessential CEP activity: aggregation, and it sounds
		like something from the real world.
		</p><a class="indexterm" name="id495957"></a><p>
		A quick sidebar: what is the VWAP? It's the Value-Weighted Average
		Price: the average price for the shares traded during some period of
		time, usually a day. If you take the price of every share traded during
		the day and calculate the average, you get the VWAP. What is the
		value-weighted part? The shares don't usually get sold one by one.
		They're sold in the variable-sized lots. If you think in the terms of
		lots and not individual shares, you have to weigh the trade prices (not
		to be confused with costs) for the lots proportional to the number of
		shares in them.
		</p><p>
		I've been using VWAP for trying out the different approaches to the aggregation.
		There are multiple ways to do it, from fully manual, to the 
		aggregator infrastructure with manual computation of the aggregations,
		to the simple aggregation functions.
		The cutest version of VWAP so far is implemented
		as a user-defined aggregation function for the SimpleAggregator.
		Here is how it goes:
		</p><pre class="programlisting"># VWAP function definition
my $myAggFunctions = {
  myvwap =&gt; {
    vars =&gt; { sum =&gt; 0, count =&gt; 0, size =&gt; 0, price =&gt; 0 },
    step =&gt; '($%size, $%price) = @$%argiter; '
      . 'if (defined $%size &amp;&amp; defined $%price) '
        . '{$%count += $%size; $%sum += $%size * $%price;}',
    result =&gt; '($%count == 0? undef : $%sum / $%count)',
  },
};

my $uTrades = Triceps::Unit-&gt;new("uTrades");

# the input data
my $rtTrade = Triceps::RowType-&gt;new(
  id =&gt; "int32", # trade unique id
  symbol =&gt; "string", # symbol traded
  price =&gt; "float64",
  size =&gt; "float64", # number of shares traded
);

my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("fifo", Triceps::IndexType-&gt;newFifo())
  )
;

# the aggregation result
my $rtVwap;
my $compText; # for debugging

Triceps::SimpleAggregator::make(
  tabType =&gt; $ttWindow,
  name =&gt; "aggrVwap",
  idxPath =&gt; [ "bySymbol", "fifo" ],
  result =&gt; [
    symbol =&gt; "string", "last", sub {$_[0]-&gt;get("symbol");},
    id =&gt; "int32", "last", sub {$_[0]-&gt;get("id");},
    volume =&gt; "float64", "sum", sub {$_[0]-&gt;get("size");},
    vwap =&gt; "float64", "myvwap", sub { [$_[0]-&gt;get("size"), $_[0]-&gt;get("price")];},
  ],
  functions =&gt; $myAggFunctions,
  saveRowTypeTo =&gt; \$rtVwap,
  saveComputeTo =&gt; \$compText,
);

$ttWindow-&gt;initialize();
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");

# label to print the result of aggregation
my $lbPrint = $uTrades-&gt;makeLabel($rtVwap, "lbPrint",
  undef, sub { # (label, rowop)
    print($_[1]-&gt;printP(), "\n");
  });
$tWindow-&gt;getAggregatorLabel("aggrVwap")-&gt;chain($lbPrint);

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a string opcode
  $uTrades-&gt;makeArrayCall($tWindow-&gt;getInputLabel(), @data);
  $uTrades-&gt;drainFrame(); # just in case, for completeness
}</pre><a class="indexterm" name="id513481"></a><p>
		The aggregators get defined as parts of the table type. 
		<code class="computeroutput">Triceps::SimpleAggregator::make()</code> is a kind of a template
		that adds an aggregator definition to the table type
		that is specified in the option <span class="quote">&#8220;<span class="quote">tabType</span>&#8221;</span>.
		An aggeragtor doesn't live in a vacuum, it always works
		as a part of the table type. As the table gets modified, the
		aggregator also re-computes its aggregation results.
		The fine distinction is that the aggregator is a part
		of the table type, and is common for all the tables of this
		type. But the table stores its aggregation state, and
		when an aggregator runs on a table, it uses and modifies that
		state.
		</p><p>
		The name of the aggregator is how you can find its result
		later in the table: each aggregator has an output label
		created for it, that can be found with 
		<code class="computeroutput">$table-&gt;getAggregatorLabel()</code>. The option <span class="quote">&#8220;<span class="quote">idxPath</span>&#8221;</span> defines
		both the grouping of the rows for this aggregator and their
		order in the group. The index type at the path determines the order
		and its parent defines the groups. In this case the grouping
		happens by symbol, and the rows in the groups go in the FIFO
		order. This means that the aggregation function <code class="computeroutput">last</code>  
		will be selecting the row that has been inserted last,
		in the FIFO order.
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">result</span>&#8221;</span> defines both the row type
		of the result and the rules for its computation. Each field
		is defined there with four elements: name, type, aggregation function name,
		and the function reference to select the value to be aggregated from the
		row. Triceps provides a bunch of pre-defined aggregation functions
		like <code class="computeroutput">first</code>, <code class="computeroutput">last</code>, <code class="computeroutput">sum</code>, <code class="computeroutput">count</code>, <code class="computeroutput">avg</code> and so on. But VWAP is not
		one of them (well, maybe now it should be, but then this example
		would be less interesting). Not to worry, the user can add custom
		aggregation functions, and that's what this example does.
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">functions</span>&#8221;</span> contains the definitions
		of such user-defined aggregation functions. Here it defines the
		function <code class="computeroutput">myvwap</code>. It defines the state variables that will be
		used to keep the intermediate values for a group, a step computation,
		and the result computation. Whenever the group changes, the
		aggregator will reset the state variables to the default values
		and iterate through the new contents of the group. It will
		perform the step computation for each row and collect the
		data in the intermediate variables. After the iteration it will
		perform the result computation and produce the final value.
		</p><p>
		The VWAP computation in a weird one, taking two fields as arguments.
		These two fields get packed into an array reference by 
		</p><pre class="programlisting">sub { [$_[0]-&gt;get("size"), $_[0]-&gt;get("price")];}</pre><p>
		and then the step computation unpacks and handles them.
		In the aggregator computations the syntax <code class="computeroutput">$%name</code>
		refers to the intermediate variables and also to a few pre-defined ones.
		<code class="computeroutput">$%argiter</code> is the value extracted from the current row
		during the iteration.
		</p><p>
		And that's pretty much it: send the rows to the table, the
		iterator state gets updated to match the table contents,
		computes the results and sends them. For example:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,11,abc,123,100</strong></span>
tWindow.aggrVwap OP_INSERT symbol="abc" id="11" volume="100"
    vwap="123"
<span class="bold"><strong>OP_INSERT,12,abc,125,300</strong></span>
tWindow.aggrVwap OP_DELETE symbol="abc" id="11" volume="100"
    vwap="123"
tWindow.aggrVwap OP_INSERT symbol="abc" id="12" volume="400"
    vwap="124.5"
<span class="bold"><strong>OP_INSERT,13,def,200,100</strong></span>
tWindow.aggrVwap OP_INSERT symbol="def" id="13" volume="100"
    vwap="200"
<span class="bold"><strong>OP_INSERT,14,fgh,1000,100</strong></span>
tWindow.aggrVwap OP_INSERT symbol="fgh" id="14" volume="100"
    vwap="1000"
<span class="bold"><strong>OP_INSERT,15,abc,128,300</strong></span>
tWindow.aggrVwap OP_DELETE symbol="abc" id="12" volume="400"
    vwap="124.5"
tWindow.aggrVwap OP_INSERT symbol="abc" id="15" volume="700"
    vwap="126"
<span class="bold"><strong>OP_INSERT,16,fgh,1100,25</strong></span>
tWindow.aggrVwap OP_DELETE symbol="fgh" id="14" volume="100"
    vwap="1000"
tWindow.aggrVwap OP_INSERT symbol="fgh" id="16" volume="125"
    vwap="1020"
<span class="bold"><strong>OP_INSERT,17,def,202,100</strong></span>
tWindow.aggrVwap OP_DELETE symbol="def" id="13" volume="100"
    vwap="200"
tWindow.aggrVwap OP_INSERT symbol="def" id="17" volume="200"
    vwap="201"
<span class="bold"><strong>OP_INSERT,18,def,192,1000</strong></span>
tWindow.aggrVwap OP_DELETE symbol="def" id="17" volume="200"
    vwap="201"
tWindow.aggrVwap OP_INSERT symbol="def" id="18" volume="1200"
    vwap="193.5"</pre><p>
		When a group gets modified, the aggregator first sends a DELETE
		of the old contents, then an INSERT of the new contents. But when the
		first row gets inserted in a group, there is nothing to delete,
		and only INSERT is sent. And the opposite, when the last row
		is deleted from a group, only the DELETE is sent.
		</p><p>
		After this highlight, let's look at the aggregators from the bottom up.
		</p></div><div class="sect1" title="11.2. Manual aggregation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_manual"></a>11.2. Manual aggregation</h2></div></div></div><a class="indexterm" name="id488841"></a><p>
		The table exanmple in
		<a class="xref" href="#sc_table_secondary" title="9.7. Secondary indexes">Section 9.7: &#8220;Secondary indexes&#8221; </a>
		prints the aggregated
		information (the average price of two records). This can be
		fairly easily changed to put the information into the rows and send
		them on as labels. The function <code class="computeroutput">printAverage()</code> has morphed into
		<code class="computeroutput">computeAverage()</code>, while the rest of the example stayed the same
		and is omitted:
		</p><pre class="programlisting">our $rtAvgPrice = Triceps::RowType-&gt;new(
  symbol =&gt; "string", # symbol traded
  id =&gt; "int32", # last trade's id
  price =&gt; "float64", # avg price of the last 2 trades
);

# place to send the average: could be a dummy label, but to keep the
# code smaller also print the rows here, instead of in a separate label
our $lbAverage = $uTrades-&gt;makeLabel($rtAvgPrice, "lbAverage",
  undef, sub { # (label, rowop)
    print($_[1]-&gt;printP(), "\n");
  });

# Send the average price of the symbol in the last modified row
sub computeAverage # (row)
{
  return unless defined $rLastMod;
  my $rhFirst = $tWindow-&gt;findIdx($itSymbol, $rLastMod);
  my $rhEnd = $rhFirst-&gt;nextGroupIdx($itLast2);
  print("Contents:\n");
  my $avg = 0;
  my ($sum, $count);
  my $rhLast;
  for (my $rhi = $rhFirst;
      !$rhi-&gt;same($rhEnd); $rhi = $rhi-&gt;nextIdx($itLast2)) {
    print("  ", $rhi-&gt;getRow()-&gt;printP(), "\n");
    $rhLast = $rhi;
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  if ($count) {
    $avg = $sum/$count;
    $uTrades-&gt;call($lbAverage-&gt;makeRowop(&amp;Triceps::OP_INSERT,
      $rtAvgPrice-&gt;makeRowHash(
        symbol =&gt; $rhLast-&gt;getRow()-&gt;get("symbol"),
        id =&gt; $rhLast-&gt;getRow()-&gt;get("id"),
        price =&gt; $avg
      )
    ));
  }
}

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/);
  $uTrades-&gt;makeArrayCall($tWindow-&gt;getInputLabel(), @data);
  &amp;computeAverage();
  undef $rLastMod; # clear for the next iteration
  $uTrades-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		For the demonstration, the aggregated rows sent to <code class="computeroutput">$lbAverage</code> get
		printed. The rows being aggregated are printed during the iteration
		too, indented after <span class="quote">&#8220;<span class="quote">Contents:</span>&#8221;</span>. And here is a sample
		run's result, with the input records shown in bold:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
lbAverage OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
  id="3" symbol="AAA" price="20" size="20"
lbAverage OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
Contents:
  id="3" symbol="AAA" price="20" size="20"
  id="5" symbol="AAA" price="30" size="30"
lbAverage OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_DELETE,3</strong></span>
Contents:
  id="5" symbol="AAA" price="30" size="30"
lbAverage OP_INSERT symbol="AAA" id="5" price="30"
<span class="bold"><strong>OP_DELETE,5</strong></span>
Contents:</pre><p>
		There are a couple of things to notice about it: it produces only the
		INSERT rowops, no DELETEs, and when the last record of the group is
		removed, that event produces nothing.
		</p><p>
		The first item is mildly problematic because the processing downstream
		from here might not be able to handle the updates properly without the
		DELETE rowops. It can be worked around fairly easily by connecting
		another table to store the aggregation results,
		with the same primary key as the aggregation key. 
		That table would automatically transform
		the repeated INSERTs on the same key to a DELETE-INSERT sequence.
		</p><a class="indexterm" name="id497032"></a><p>
		The second item is actually pretty bad because it means that the last
		record deleted gets stuck in the aggregation results. The Coral8
		solution for this situation is to send a row with all non-key fields
		set to NULL, to reset them (interestingly, it's a relatively recent
		addition, that bug took Coral8 years to notice). But with the opcodes
		available, we can as well send a DELETE rowop with the key fields filled,
		the helper table will fill in the rest of the fields, and produce a
		clean DELETE.
		</p><a class="indexterm" name="id497049"></a><p>
		All this can be done by the following changes. Add the table, remember
		its input label in <code class="computeroutput">$lbAvgPriceHelper</code>. It will be used to send the
		aggregated rows instead of <code class="computeroutput">$tAvgPrice</code>.
		Then still use <code class="computeroutput">$tAvgPrice</code> to print the records coming out, but now
		connect it after the helper table.  And in <code class="computeroutput">computeAverage()</code> change the
		destination label and add the case for when the group becomes empty
		(<code class="computeroutput">$count == 0</code>).
		The rest of the example stays the same.
		</p><pre class="programlisting">our $rtAvgPrice = Triceps::RowType-&gt;new(
  symbol =&gt; "string", # symbol traded
  id =&gt; "int32", # last trade's id
  price =&gt; "float64", # avg price of the last 2 trades
);

our $ttAvgPrice = Triceps::TableType-&gt;new($rtAvgPrice)
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
  )
;
$ttAvgPrice-&gt;initialize();
our $tAvgPrice = $uTrades-&gt;makeTable($ttAvgPrice, "tAvgPrice");
our $lbAvgPriceHelper = $tAvgPrice-&gt;getInputLabel();

# place to send the average: could be a dummy label, but to keep the
# code smaller also print the rows here, instead of in a separate label
our $lbAverage = makePrintLabel("lbAverage", $tAvgPrice-&gt;getOutputLabel());

# Send the average price of the symbol in the last modified row
sub computeAverage2 # (row)
{
  return unless defined $rLastMod;
  my $rhFirst = $tWindow-&gt;findIdx($itSymbol, $rLastMod);
  my $rhEnd = $rhFirst-&gt;nextGroupIdx($itLast2);
  print("Contents:\n");
  my $avg = 0;
  my ($sum, $count);
  my $rhLast;
  for (my $rhi = $rhFirst;
      !$rhi-&gt;same($rhEnd); $rhi = $rhi-&gt;nextIdx($itLast2)) {
    print("  ", $rhi-&gt;getRow()-&gt;printP(), "\n");
    $rhLast = $rhi;
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  if ($count) {
    $avg = $sum/$count;
    $uTrades-&gt;makeHashCall($lbAvgPriceHelper, &amp;Triceps::OP_INSERT,
      symbol =&gt; $rhLast-&gt;getRow()-&gt;get("symbol"),
      id =&gt; $rhLast-&gt;getRow()-&gt;get("id"),
      price =&gt; $avg
    );
  } else {
    $uTrades-&gt;makeHashCall($lbAvgPriceHelper, &amp;Triceps::OP_DELETE,
      symbol =&gt; $rLastMod-&gt;get("symbol"),
    );
  }
}</pre><p>
		The change is straightforward.
		The label <code class="computeroutput">$lbAverage</code> 
		now reverts to just printing the rowops going through it, 
		so it can be created with the template <code class="computeroutput">makePrintLabel()</code> 
		described in
		<a class="xref" href="#sc_template_wrapper" title="10.3. Simple wrapper templates">Section 10.3: &#8220;Simple wrapper templates&#8221; </a>.
		</p><p>
		Then the output for the same input becomes:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
tAvgPrice.out OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
  id="3" symbol="AAA" price="20" size="20"
tAvgPrice.out OP_DELETE symbol="AAA" id="1" price="10"
tAvgPrice.out OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
Contents:
  id="3" symbol="AAA" price="20" size="20"
  id="5" symbol="AAA" price="30" size="30"
tAvgPrice.out OP_DELETE symbol="AAA" id="3" price="15"
tAvgPrice.out OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_DELETE,3</strong></span>
Contents:
  id="5" symbol="AAA" price="30" size="30"
tAvgPrice.out OP_DELETE symbol="AAA" id="5" price="25"
tAvgPrice.out OP_INSERT symbol="AAA" id="5" price="30"
<span class="bold"><strong>OP_DELETE,5</strong></span>
Contents:
tAvgPrice.out OP_DELETE symbol="AAA" id="5" price="30"</pre><p>
		All fixed, the proper DELETEs are coming out.
		The last line shows the empty group contents in the table
		but the DELETE row is still coming out.
		</p><a class="indexterm" name="id530153"></a><p>
		Why should we worry so much about the DELETEs? Because without them,
		relying on just INSERTs for updates, it's easy to create bugs. The last
		example still has an issue with handling the row replacement by
		INSERTs.  Can you spot it from reading the code?
		</p><p>
		Here is run example that highlights the issue (as usual, the input
		lines are in bold):
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
tAvgPrice.out OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
  id="3" symbol="AAA" price="20" size="20"
tAvgPrice.out OP_DELETE symbol="AAA" id="1" price="10"
tAvgPrice.out OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
Contents:
  id="3" symbol="AAA" price="20" size="20"
  id="5" symbol="AAA" price="30" size="30"
tAvgPrice.out OP_DELETE symbol="AAA" id="3" price="15"
tAvgPrice.out OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_INSERT,5,BBB,30,30</strong></span>
Contents:
  id="5" symbol="BBB" price="30" size="30"
tAvgPrice.out OP_INSERT symbol="BBB" id="5" price="30"
<span class="bold"><strong>OP_INSERT,7,AAA,40,40</strong></span>
Contents:
  id="3" symbol="AAA" price="20" size="20"
  id="7" symbol="AAA" price="40" size="40"
tAvgPrice.out OP_DELETE symbol="AAA" id="5" price="25"
tAvgPrice.out OP_INSERT symbol="AAA" id="7" price="30"</pre><p>
		The row with id=5 has been replaced to change the symbol from <span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span> to
		<span class="quote">&#8220;<span class="quote">BBB</span>&#8221;</span>. This act changes both the groups of <span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span> and of <span class="quote">&#8220;<span class="quote">BBB</span>&#8221;</span>, removing the
		row from the first one and inserting it into the second one. Yet only
		the output for <span class="quote">&#8220;<span class="quote">BBB</span>&#8221;</span> came out. The printout of the next row with id=7 and
		symbol=<span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span> shows that the row with id=5 has been indeed removed from
		the group <span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span>. It even corrects the result. But until that row came in,
		the average for the symbol <span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span> remained unchanged and incorrect.
		</p><p>
		There are multiple ways to fix this issue but first it had to be
		noticed. Which requires a lot of attention to detail. It's much better
		to avoid these bugs in the first place by sending the clean and nice
		input.
		</p></div><div class="sect1" title="11.3. Introducing the proper aggregation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_proper"></a>11.3. Introducing the proper aggregation</h2></div></div></div><p>
		Since the manual aggregation is error-prone, Triceps can manage it for
		you and do it right. The only thing you need to do is do the actual
		iteration and computation. Here is the rewrite of the same example with
		a Triceps aggregator:
		</p><pre class="programlisting">my $uTrades = Triceps::Unit-&gt;new("uTrades");

# the input data
my $rtTrade = Triceps::RowType-&gt;new(
  id =&gt; "int32", # trade unique id
  symbol =&gt; "string", # symbol traded
  price =&gt; "float64",
  size =&gt; "float64", # number of shares traded
);

# the aggregation result
my $rtAvgPrice = Triceps::RowType-&gt;new(
  symbol =&gt; "string", # symbol traded
  id =&gt; "int32", # last trade's id
  price =&gt; "float64", # avg price of the last 2 trades
);

# aggregation handler: recalculate the average each time the easy way
sub computeAverage1 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;

  # don't send the NULL record after the group becomes empty
  return if ($context-&gt;groupSize()==0
    || $opcode == &amp;Triceps::OP_NOP);

  my $sum = 0;
  my $count = 0;
  for (my $rhi = $context-&gt;begin(); !$rhi-&gt;isNull();
      $rhi = $context-&gt;next($rhi)) {
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  my $rLast = $context-&gt;last()-&gt;getRow();
  my $avg = $sum/$count;

  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $avg
  );
  $context-&gt;send($opcode, $res);
}

my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("last2",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
      -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
        $rtAvgPrice, "aggrAvgPrice", undef, \&amp;computeAverage1)
      )
    )
  )
;
$ttWindow-&gt;initialize();
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");

# label to print the result of aggregation
my $lbAverage = makePrintLabel("lbAverage",
  $tWindow-&gt;getAggregatorLabel("aggrAvgPrice"));

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a string opcode
  $uTrades-&gt;makeArrayCall($tWindow-&gt;getInputLabel(), @data);
  $uTrades-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		What has changed in this code? The things got rearranged a bit.The
		aggregator is now defined as a part of the table type, so the
		aggregation result row type and its computation function had to be
		moved up.
		</p><a class="indexterm" name="id530309"></a><a class="indexterm" name="id530319"></a><p>
		The AggregatorType object holds the information about the aggregator.
		In the table type, the aggregator type gets attached to an index type
		with <code class="computeroutput">setAggregator()</code>. In this case, to the FIFO index type. 
		The parent of that index type determines the aggregation groups,
		grouping happening by its combined key fields (that is, all the
		key fields of all the indexes in the path starting from the root).
		For aggregation the working or non-working method <code class="computeroutput">getKey()</code> doesn't matter,
		so any of the Hashed, Ordered and Sorted index types can be used.
		The index type where the aggregator type is attached determines the
		order of the rows in the groups. If you use FIFO, the rows will
		be in the order of arrival. If you use Ordered or Sorted, the rows
		will be in the sort order. If you use Hashed, the rows will be
		in some random order, which is not particularly useful.
		</p><p>
		At present an index type may have no more than one aggregator type
		attached to it. There is no particular reason for that, other than that
		it was slightly easier to implement, and that I can't think yet of a
		real-word situation where multiple aggregators on the same index would
		be needed. If this situation will ever occur, this support can be
		added. However a table type may have multiple aggregator types in it,
		on different indexes. You can save a reference to an aggregator
		type in a variable and reuse it in the different table types too
		(though not multiple times in the same table, since that would cause a
		naming conflict).
		</p><p>
		The aggregator type is created with the arguments of 
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		result row type,
		</li><li class="listitem">
		aggregator name, 
		</li><li class="listitem">
		group initialization Perl function (which may be
		<code class="computeroutput">undef</code>, as in this example), 
		</li><li class="listitem">
		group computation Perl function or source code snippet, 
		</li><li class="listitem">
		the optional arguments for the functions. 
		</li></ul></div><p>
		Note that there is a
		difference in naming between the aggregator types and index types: an
		aggregator type knows its name, while an index type does not. An index
		type is given a name only in its hierarchy inside the table type, but
		it does not know its name.
		</p><p>
		When a table is created, it finds all the aggregator types in it, and
		creates an output label for each of them. The names of the aggregator
		types are used as suffixes to the table name. In this example the
		aggregator will have its output label named <span class="quote">&#8220;<span class="quote">tWindow.aggrAvgPrice</span>&#8221;</span>.
		This puts all the aggregator types in the table into the same
		namespace, so make sure to give them different names in the same table
		type. Also avoid the names <span class="quote">&#8220;<span class="quote">in</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> 
		because these are already
		taken by the table's own labels. The aggregator labels in the table can
		be found with
		</p><pre class="programlisting">$aggLabel = $table-&gt;getAggregatorLabel("aggName");</pre><p>
		The aggregator types are theoretically multithreaded but the way the
		Perl threads work, the Perl code has to be recompiled from the source
		code in each thread. So for a table type with aggregators to be
		exportable to the other threads, the aggregators must have their logic
		specified as the Perl source code, not a compiled Perl function.
		</p><p>
		After the logic is moved into a managed aggregator, the main loop
		becomes simpler.  
		</p><p>
		The computation function gets a lot more arguments than it used to. The
		most interesting and most basic ones are <code class="computeroutput">$context</code>, <code class="computeroutput">$opcode</code>, and <code class="computeroutput">$rh</code>.
		The rest are useful in the more complex cases only.
		</p><a class="indexterm" name="id530465"></a><a class="indexterm" name="id530478"></a><p>
		The aggregator type is exactly that: a type. It doesn't know, on which
		table or index, or even index type it will be used. And indeed, it
		might be used on multiple tables and index types. But to do the
		iteration on the rows, the computation function needs to get this
		information somehow. And it does, in the form of aggregator context.
		The manual aggregation used the last table output row to find, on which
		exact group to iterate. The managed aggregator gets the last modified
		row handle as the argument <code class="computeroutput">$rh</code>. But our simple aggregator doesn't even
		need to consult <code class="computeroutput">$rh</code> because the context takes care of finding the
		group too: it knows the exact group and exact index that needs to be
		aggregated (look at the index tree drawings in
		<a class="xref" href="#sc_table_indextree" title="9.10. The index tree">Section 9.10: &#8220;The index tree&#8221; </a>
		for the difference between an index type and an index).
		</p><a class="indexterm" name="id530517"></a><p>
		The context provides its own <code class="computeroutput">begin()</code> and <code class="computeroutput">next()</code> methods. They are
		actually slightly more efficient than the usual table iteration methods
		because they take advantage of that exact known index. The most
		important part, they work differently.
		</p><pre class="programlisting">$rhi = $context-&gt;next($rhi);</pre><p>
		returns a NULL row handle when it reaches the end of the group. Do not,
		I repeat, <span class="bold"><strong>DO NOT</strong></span> use the <code class="computeroutput">$rhi-&gt;next()</code> in the aggregators, or
		you'll get some very wrong results.
		</p><p>
		The context also has a bit more of its own magic.
		</p><pre class="programlisting">$rh = $context-&gt;last();</pre><a class="indexterm" name="id530580"></a><a class="indexterm" name="id530593"></a><a class="indexterm" name="id530607"></a><p>
		returns the last row handle in the group. This comes very handy because
		in most of the cases you want the data from the last row to fill the
		fields that haven't been aggregated as such. This is like the SQL
		function <code class="computeroutput">LAST()</code>. Using the fields from the argument <code class="computeroutput">$rh</code>, unless they
		are the key fields for this group, is generally not a good idea because
		it adds an extra dependency on the order of modifications to the table.
		The <code class="computeroutput">FIRST()</code> or <code class="computeroutput">LAST()</code> (i.e. the 
		context's <code class="computeroutput">begin()</code> or <code class="computeroutput">last()</code>) are much
		better and not any more expensive.
		</p><pre class="programlisting">$size = $context-&gt;groupSize();</pre><a class="indexterm" name="id530665"></a><p>
		returns the number of rows in the group. It's your value of <code class="computeroutput">COUNT(*)</code> in
		SQL terms, and if that's all you need, you don't need to iterate.
		</p><pre class="programlisting">$context-&gt;send($opcode, $row);</pre><p>
		constructs a result rowop and sends it to the aggregator's output
		label. Remember, the aggregator type as such knows nothing about this
		label, so the path through the context is the only path. Note also that
		it takes a row and not a rowop, because a label is needed to construct
		the rowop in the first place.
		</p><pre class="programlisting">$rt = $context-&gt;resultType();</pre><p>
		provides the result row type needed to construct the result row.
		There also are a couple of convenience methods that combine
		the row construction and sending, that can be used instead:
		</p><pre class="programlisting">$context-&gt;makeHashSend ($opcode, $fieldName =&gt; $fieldValue, ...);
$context-&gt;makeArraySend($opcode, @fieldValues);</pre><p>
		The final thing about the aggregator context: it works only inside the
		aggregator computation function. Once the function returns, all its
		methods start returning <code class="computeroutput">undef</code>. So there is no point in trying
		to save it for later in a global variable or such, don't do that.
		</p><p>
		As you can see, <code class="computeroutput">computeAverage()</code> has the same logic as before, only
		now it uses the aggregation context. And I've removed the debugging
		printout of the rows in the group.
		</p><a class="indexterm" name="id530742"></a><p>
		The last unexplained piece is the opcode handling and that comparison
		to <code class="computeroutput">OP_NOP</code>. Basically, the table calls the aggregator computation
		every time something changes in its index. It describes the reason for
		the call in the argument <code class="computeroutput">$aggop</code> (<span class="quote">&#8220;<span class="quote">aggregation operation</span>&#8221;</span>). Depending on
		how clever an aggregator wants to be, it may do something useful on all
		of these occasions, or only on some of them. The simple aggregator that
		doesn't try any smart optimizations but just goes and iterates through
		the rows every time only needs to react in some of the cases. To make
		its life easier, Triceps pre-computes the opcode that should be used
		for the result and puts it into the argument <code class="computeroutput">$opcode</code>. So to
		ignore the non-interesting calls, the simple aggregator computation can
		just return if it sees the opcode <code class="computeroutput">OP_NOP</code>.
		</p><a class="indexterm" name="id530792"></a><p>
		Why does it also check for the group size being 0? Again, Triceps
		provides flexibility in the aggregators. Among other things, it allows to
		implement the logic like Coral8, when on deletion of the last row in
		the group the aggregator would send a row with all non-key fields set
		to NULL (it can take the key fields from the argument <code class="computeroutput">$rh</code>). So for this
		specific purpose the computation function gets called with all rows
		deleted from the group, and <code class="computeroutput">$opcode</code> set to <code class="computeroutput">OP_INSERT</code>. And, by the way,
		a true Coral8-styled aggregator would ignore all the calls where the
		<code class="computeroutput">$opcode</code> is not <code class="computeroutput">OP_INSERT</code>. But the normal aggregators need to avoid
		doing this kind of crap, so they have to ignore the calls where
		<code class="computeroutput">$context-&gt;groupSize()==0</code>.
		</p><p>
		And here is an example of the output from that code
		(as usual, the input lines are in bold):
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="1" price="10"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="3" price="15"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_DELETE,3</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="25"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="30"
<span class="bold"><strong>OP_DELETE,5</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="30"</pre><p>
		As you can see, it's exactly the same as from the manual aggregation
		example with the helper table, minus the debugging printout of the
		group contents. However here it's done without the helper table:
		instead the aggregation function is called before and after each
		update.
		</p><a class="indexterm" name="id530898"></a><p>
		This presents a memory vs CPU compromise: a helper table uses more
		memory but requires less CPU for the aggregation computations
		(presumably, the insertion of the row into the table is less
		computationally intensive than the iteration through the original
		records).
		</p><p>
		The managed aggregators can be made to work with a helper table too:
		just chain a helper table to the aggregator's label, and in the
		aggregator computation add
		</p><pre class="programlisting">return if ($opcode == &amp;Triceps::OP_DELETE
  &amp;&amp; $context-&gt;groupSize() != 1);</pre><p>
		This would skip all the DELETEs except for the last one, before the
		group collapses.
		</p><a class="indexterm" name="id530933"></a><p>
		There is also a way to optimize this logic right inside the aggregator:
		remember the last INSERT row sent, and on DELETE just resend the same
		row, as will be shown in
		<a class="xref" href="#sc_aggregation_optimized" title="11.5. Optimized DELETEs">Section 11.5: &#8220;Optimized DELETEs&#8221; </a>.
		This remembered last state can also be used for the other
		interesting optimizations that will be shown in
		<a class="xref" href="#sc_aggregation_additive" title="11.6. Additive aggregation">Section 11.6: &#8220;Additive aggregation&#8221; </a>.
		</p><a class="indexterm" name="id530967"></a><p>
		Which approach is better, depends on the particular case. If you need
		to store the results of aggregation in a table for the future look-ups
		anyway, then that table is no extra overhead. That's what the
		Aleri system does internally: since each element in its model keeps a
		primary-indexed table (<span class="quote">&#8220;<span class="quote">materialized view</span>&#8221;</span>) of the result, that table
		is used whenever possible to generate the DELETEs without involving any
		logic. Or the extra optimization inside the aggregator can seriously
		improve the performance on the large groups. Sometimes you may want
		both. 
		</p><p>
		Now let's look at the run with the same input that went wrong with
		the manual aggregation:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="1" price="10"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="3" price="15"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_INSERT,5,BBB,30,30</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="25"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="3" price="20"
tWindow.aggrAvgPrice OP_INSERT symbol="BBB" id="5" price="30"
<span class="bold"><strong>OP_INSERT,7,AAA,40,40</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="3" price="20"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="7" price="30"</pre><p>
		Here it goes right. Triceps recognizes that the second INSERT with id=5
		moves the row to another group. So it performs the aggregation logic
		for both groups. First for the group where the row gets removed, it
		updates the aggregator result with a DELETE and INSERT (note that
		id became 3, since it's now the last row left in that group).
		Then for the group where the row gets added, and since there was nothing in
		that group before, it generates only an INSERT.
		</p><a class="indexterm" name="id531042"></a><p>
		The handling of the fatal errors (as in <code class="computeroutput">die()</code>) in the 
		aggregator functions is an interesting subject.
		The errors propagate properly through the table,
		and the table operations confess with the Perl handler's error message.
		But since an error in the aggregator function means that things are going
		very, very wrong, after that the table becomes inoperative and will die
		on all the subsequent operations as well. You need to be very careful
		in writing these functions.
		</p></div><div class="sect1" title="11.4. Tricks with aggregation on a sliding window"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_window"></a>11.4. Tricks with aggregation on a sliding window</h2></div></div></div><p>
		Now it all works as it should, but there is still some room for improvement,
		related to the way the sliding window limits are handled.
		</p><p>
		Let's look again at the sample aggregation output with row deletion, copied
		here for convenience:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="1" price="10"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="3" price="15"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_DELETE,3</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="25"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="30"
<span class="bold"><strong>OP_DELETE,5</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="30"</pre><p>
		When the row with id=3 is deleted, the average price reverts to 30,
		which is the price of the trade with id=5, not the average of trades
		with id 1 and 5. 
		</p><p>
		This is because the table is actually a sliding window, with the
		FIFO index having a limit of 2 rows
		</p><pre class="programlisting">my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("last2",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
      -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
        $rtAvgPrice, "aggrAvgPrice", undef, \&amp;computeAverage1)
      )
    )
  )
;</pre><p>
		When the row with id=5 was inserted,
		it pushed out the row with id=1. Deleting the record with id=3 does not
		put that row with id=1 back. You can see the group contents in an even
		earlier printout with the manual aggregation, also copied here for
		convenience: 
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
lbAverage OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
Contents:
  id="1" symbol="AAA" price="10" size="10"
  id="3" symbol="AAA" price="20" size="20"
lbAverage OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
Contents:
  id="3" symbol="AAA" price="20" size="20"
  id="5" symbol="AAA" price="30" size="30"
lbAverage OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_DELETE,3</strong></span>
Contents:
  id="5" symbol="AAA" price="30" size="30"
lbAverage OP_INSERT symbol="AAA" id="5" price="30"
<span class="bold"><strong>OP_DELETE,5</strong></span>
Contents:</pre><p>
		Like the toothpaste, once out of the tube, it's not easy to put back.
		But for this particular kind of toothpaste there is a trick: keep more
		rows in the group just in case but use only the last few for the
		actual aggregation. To allow an occasional deletion of a single row, we
		can keep 3 rows instead of 2.
		</p><p>
		So, change the table definition:
		</p><pre class="programlisting">...
      Triceps::IndexType-&gt;newFifo(limit =&gt; 3)
...</pre><p>
		and modify the aggregator function to use only the last 2 rows from the
		group, even if more are available:
		</p><pre class="programlisting">sub computeAverage2 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;

  # don't send the NULL record after the group becomes empty
  return if ($context-&gt;groupSize()==0
    || $opcode == &amp;Triceps::OP_NOP);

  my $skip = $context-&gt;groupSize()-2;
  my $sum = 0;
  my $count = 0;
  for (my $rhi = $context-&gt;begin(); !$rhi-&gt;isNull();
      $rhi = $context-&gt;next($rhi)) {
    if ($skip &gt; 0) {
      $skip--;
      next;
    }
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  my $rLast = $context-&gt;last()-&gt;getRow();
  my $avg = $sum/$count;

  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $avg
  );
  $context-&gt;send($opcode, $res);
}</pre><p>
		The output from this version becomes:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="1" price="10"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="3" price="15"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_DELETE,3</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="25"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="20"
<span class="bold"><strong>OP_DELETE,5</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="20"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="1" price="10"</pre><p>
		Now after <code class="computeroutput">OP_DELETE,3</code> the average price becomes 20, the
		average of 10 and 30, because the row with id=1 comes into play again.
		Can you repeat that in the SQLy languages?
		</p><p>
		This version stores one extra row and thus can handle only one deletion
		(until the deleted row's spot gets pushed out of the window naturally,
		then it can handle another). It can not handle the arbitrary
		modifications properly. If you insert another row with id=3 for the
		same symbol <span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span>, the new version will be placed again at the end of the
		window. If it was the last row anyway, that is fine. But if it was not
		the last, as in this example, that would be an incorrect order that
		will produce incorrect results.
		</p><p>
		But just change the table type definition to aggregate on a sorted
		index instead of FIFO and it becomes able to handle the updates
		while keeping the rows in the order of their ids:
		</p><pre class="programlisting">my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("orderById",
      Triceps::SimpleOrderedIndex-&gt;new(id =&gt; "ASC",)
      -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
        $rtAvgPrice, "aggrAvgPrice", undef, \&amp;computeAverage3)
      )
    )
    -&gt;addSubIndex("last3",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 3))
  )
;</pre><p>
		The FIFO index is still there, in parallel, but it doesn't determine
		the order of rows for aggregation any more.
		Here is a sample of this version's work:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="1" price="10"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="3" price="15"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_DELETE,3</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="25"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="20"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="20"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_INSERT,7,AAA,40,40</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="25"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="7" price="35"</pre><p>
		When the row with id=3 gets deleted, the average reverts to the rows 1
		and 5. When the row 3 gets inserted back, the average works on
		rows 3 and 5 again. Then when the row 7 is inserted, the aggregation
		moves up to the rows 5 and 7.
		</p><p>
		The row expiration is still controlled by the FIFO index. So after the
		row 3 is inserted back, the order of rows in the FIFO becomes
		</p><pre class="programlisting">1, 5, 3</pre><p>
		Then when the row 7 is inserted, it advances to
		</p><pre class="programlisting">5, 3, 7</pre><p>
		At this point, until the row 3 gets naturally popped out of the FIFO,
		it's best not to have other deletions nor updates, or the group
		contents may become incorrect.
		</p><a class="indexterm" name="id531399"></a><a class="indexterm" name="id531413"></a><p>
		The FIFO and Ordered index types work in parallel on the same group, and
		the Ordered index always keeps the right order:
		</p><pre class="programlisting">1, 3, 5
3, 5, 7</pre><p>
		At long as the records with the two highest ids are in the group at
		all, the Ordered index will keep them in the right position at the end.
		</p><p>
		In this case we could even make a bit of optimization: turn the sorting
		order around, and have the Ordered index arrange the rows in the
		descending order. Then instead of skipping the rows until the last two,
		just take the first two rows of the reverse order. They'll be iterated
		in the opposite direction but for the averaging it doesn't matter. And
		instead of the last row take the first row of the opposite order. This
		is a simple modification and is left as an exercise for the reader.
		</p><p>
		Thinking further, the sensitivity to the ordering comes largely from
		the FIFO index. If the replacement policy could be done directly on the
		Ordered index, it would become easier. Would be a good thing to add in
		the future. Also, if you keep all the day's trades anyway, you might
		not need to have a replacement policy at all: just pick the last 2
		records for the aggregation. There is currently no way to iterate back
		from the end (another thing to add in the future) but the same trick
		with the opposite order would work. 
		</p><a class="indexterm" name="id531458"></a><p>
		For a new subject, this table type indexes by id twice: once as a
		primary index, another time as a nested one. Are both of them really
		necessary or would just the nested one be good enough? That depends on
		your input data. If you get the DELETEs like <code class="computeroutput">OP_DELETE,3</code> with all the
		other fields as NULL, then a separate primary index is definitely
		needed. But if the DELETEs come exactly as the same records that were
		inserted, only with a different opcode, like <code class="computeroutput">OP_DELETE,3,AAA,20,20</code>
		then the primary index can be skipped because the nested sorted index
		will be able to find the rows correctly and handle them. The bottom
		line is, the fully correct DELETE records are good.
		</p></div><div class="sect1" title="11.5. Optimized DELETEs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_optimized"></a>11.5. Optimized DELETEs</h2></div></div></div><a class="indexterm" name="id531503"></a><p>
		I've already mentioned that the DELETEs coming out of an aggregator do not have
		to be recalculated every time. Instead the rows can be remembered from
		the insert time, and simply re-sent with the new opcode. That allows to
		trade the CPU time for the extra memory. Of course, this works best
		when there are many rows per aggregation group, then more CPU
		time is saved on not iterating through them. How many is <span class="quote">&#8220;<span class="quote">many</span>&#8221;</span>? It
		depends on the particular cases. You'd have to measure. Anyway, here is
		how it's done:
		</p><pre class="programlisting">sub computeAverage4 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;

  # don't send the NULL record after the group becomes empty
  return if ($context-&gt;groupSize()==0
    || $opcode == &amp;Triceps::OP_NOP);
  if ($opcode == &amp;Triceps::OP_DELETE) {
    $context-&gt;send($opcode, $$state);
    return;
  }

  my $sum = 0;
  my $count = 0;
  for (my $rhi = $context-&gt;begin(); !$rhi-&gt;isNull();
      $rhi = $context-&gt;next($rhi)) {
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  my $rLast = $context-&gt;last()-&gt;getRow();
  my $avg = $sum/$count;

  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $avg
  );
  ${$state} = $res;
  $context-&gt;send($opcode, $res);
}

sub initRememberLast #  (@args)
{
  my $refvar;
  return \$refvar;
}

my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("last2",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
      -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
        $rtAvgPrice, "aggrAvgPrice", \&amp;initRememberLast, \&amp;computeAverage4)
      )
    )
  )
;</pre><p>
		The rest of the example stays the same, so it's not shown. Even in the
		part that is shown, very little has changed. 
		</p><a class="indexterm" name="id531552"></a><a class="indexterm" name="id531565"></a><p>
		The aggregator type now has an initialization function. (This function
		is <span class="bold"><strong>not</strong></span> of the same kind as for the sorted index!) This function gets
		called every time a new aggregation group gets created, before the
		first row is inserted into it. It initializes the aggregator group's
		Perl state by creating and returning the state value (the state is per
		aggregator type, so if there are two parallel index types, each with an
		aggregator, each aggregator will have its own group state). 
		</p><p>
		The state is stored in the group as a single Perl variable. So it
		usually is a reference to a more complex object. 
		In this case the value returned is a reference
		to a variable that would contain a Row reference. (Ironically, the
		simplest case looks a bit more confusing than if it were a reference to
		an array or hash). Returning a reference to a <code class="computeroutput">my</code> variable is a way to
		create a reference to an anonymous value: each time <code class="computeroutput">my</code> executes, it
		creates a new value. Which is then kept in a reference after the
		initialization function returns. The next time the function executes,
		<code class="computeroutput">my</code> would create another new value.
		</p><p>
		The computation function has that state passed as an argument and now
		makes use of it. It has two small additions. Before sending a new
		result row, that row gets remembered in the state reference. And then
		before doing any computation the function checks, whether the required
		opcode is DELETE, and if so then simply resends the last result with
		the new opcode. Remember, the rows are not copied but
		reference-counted, so this is fairly cheap.
		</p><p>
		The extra level of referencing is used because simply assigning to
		<code class="computeroutput">$state</code> would only change the local variable and not the value kept in
		the group.
		</p><p>
		However if you change the argument of the function directly, that would
		change the value kept in the group (similar to changing the loop
		variable in a <span class="emphasis"><em>foreach</em></span> loop). So you can save a bit of overhead
		by eliminating the extra indirection. The modified version will be:
		</p><pre class="programlisting">sub computeAverage5 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;

  # don't send the NULL record after the group becomes empty
  return if ($context-&gt;groupSize()==0
    || $opcode == &amp;Triceps::OP_NOP);
  if ($opcode == &amp;Triceps::OP_DELETE) {
    $context-&gt;send($opcode, $state);
    return;
  }

  my $sum = 0;
  my $count = 0;
  for (my $rhi = $context-&gt;begin(); !$rhi-&gt;isNull();
      $rhi = $context-&gt;next($rhi)) {
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  my $rLast = $context-&gt;last()-&gt;getRow();
  my $avg = $sum/$count;

  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $avg
  );
  $_[5] = $res;
  $context-&gt;send($opcode, $res);
}

sub initRememberLast5 #  (@args)
{
  return undef;
}</pre><p>
		Even though the initialization function returns <code class="computeroutput">undef</code>, it still
		must be present. If it's not present, the state argument of the
		comparison function will contain a special hardcoded and unmodifiable
		<code class="computeroutput">undef</code> constant, and nothing could be remembered.
		</p><p>
		And here is an example of its work:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="1" price="10"
<span class="bold"><strong>OP_INSERT,2,BBB,100,100</strong></span>
tWindow.aggrAvgPrice OP_INSERT symbol="BBB" id="2" price="100"
<span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="1" price="10"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="3" price="15"
<span class="bold"><strong>OP_INSERT,4,BBB,200,200</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="BBB" id="2" price="100"
tWindow.aggrAvgPrice OP_INSERT symbol="BBB" id="4" price="150"
<span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="3" price="15"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="25"
<span class="bold"><strong>OP_DELETE,3</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="25"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="5" price="30"
<span class="bold"><strong>OP_DELETE,5</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="5" price="30"</pre><p>
		Since the rows are grouped by the symbol, the symbols <span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">BBB</span>&#8221;</span>
		will have separate aggregation states.
		</p></div><div class="sect1" title="11.6. Additive aggregation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_additive"></a>11.6. Additive aggregation</h2></div></div></div><a class="indexterm" name="id531758"></a><a class="indexterm" name="id531771"></a><p>
		In some cases the aggregation values don't have to be calculated by
		going through all the rows from scratch every time. If you do a sum of
		a field, you can as well add the value of the field when a row is
		inserted and subtract when a row is deleted. Not surprisingly, this is
		called an <span class="quote">&#8220;<span class="quote">additive aggregation</span>&#8221;</span>.
		</p><a class="indexterm" name="id531794"></a><p>
		The averaging can also be done as an additive aggregation: it amounts
		to a sum divided by a count. The sum can obviously be done additively.
		The count is potentially additive too, but even better, we have the
		shortcut of <code class="computeroutput">$context-&gt;groupSize()</code>. Well, at least for the same
		definition of count that has been used previously in the non-additive example. The
		SQL definition of count (and of average) includes only the non-NULL
		values, but in the next example we will go with the Perl approach where
		a NULL is taken to have the same meaning as 0. The proper SQL count
		could not use that shortcut but would still be additive.
		</p><p>
		Triceps provides a way to implement the additive aggregation too. It
		calls the aggregation computation function for each changed row, giving
		it an opportunity to react. The argument <code class="computeroutput">$aggop</code> indicates, what has
		happened. Here is the same example from
		<a class="xref" href="#sc_aggregation_proper" title="11.3. Introducing the proper aggregation">Section 11.3: &#8220;Introducing the proper aggregation&#8221; </a>
		rewritten in an additive way:
		</p><pre class="programlisting">sub computeAverage7 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;
  my $rowchg;

  if ($aggop == &amp;Triceps::AO_BEFORE_MOD) {
    $context-&gt;send($opcode, $state-&gt;{lastrow});
    return;
  } elsif ($aggop == &amp;Triceps::AO_AFTER_DELETE) {
    $rowchg = -1;
  } elsif ($aggop == &amp;Triceps::AO_AFTER_INSERT) {
    $rowchg = 1;
  } else { # AO_COLLAPSE, also has opcode OP_DELETE
    return
  }

  $state-&gt;{price_sum} += $rowchg * $rh-&gt;getRow()-&gt;get("price");

  return if ($context-&gt;groupSize()==0
    || $opcode == &amp;Triceps::OP_NOP);

  my $rLast = $context-&gt;last()-&gt;getRow();
  my $count = $context-&gt;groupSize();
  my $avg = $state-&gt;{price_sum}/$count;
  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $avg
  );
  $state-&gt;{lastrow} = $res;

  $context-&gt;send($opcode, $res);
}

sub initAverage7 #  (@args)
{
  return { lastrow =&gt; undef, price_sum =&gt; 0 };
}</pre><p>
		The tricks of keeping an extra row from
		<a class="xref" href="#sc_aggregation_window" title="11.4. Tricks with aggregation on a sliding window">Section 11.4: &#8220;Tricks with aggregation on a sliding window&#8221; </a>
		could not be used with the additive aggregation. An additive
		aggregation relies on Triceps to tell it, which rows are deleted and
		which inserted, so it can not do any extra skipping easily. The index
		for the aggregation has to be defined with the correct limits. If we
		want an average of the last 2 rows, we set the limit to 2:
		</p><pre class="programlisting">my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("last2",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
      -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
        $rtAvgPrice, "aggrAvgPrice", \&amp;initAverage7, \&amp;computeAverage7)
      )
    )
  )
;</pre><a class="indexterm" name="id526146"></a><p>
		The aggregation state has grown: now it includes not only the last sent
		row but also the sum of the price, which is used for the aggregation,
		kept together in a hash. The last sent row doesn't really have to be
		kept, and I'll show another example without it, but for now let's look
		at how things are done when it is kept.
		</p><p>
		The argument <code class="computeroutput">$aggop</code> describes, why the computation is being called.
		Note that Triceps doesn't know if the aggregation is additive or not.
		It does the calls the same in every case. Just in the previous examples
		we weren't interested in this information and didn't look at it. <code class="computeroutput">$aggop</code>
		contains one of the constant values:
		</p><a class="indexterm" name="id526183"></a><div class="itemizedlist"><a class="indexterm" name="id526318"></a><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">&amp;Triceps::AO_BEFORE_MOD</code>: the group is about to be modified,
		need to send a DELETE of the old aggregated row. The argument <code class="computeroutput">$opcode</code> 
		will always be <code class="computeroutput">OP_DELETE</code>.
		</li><li class="listitem"><code class="computeroutput">&amp;Triceps::AO_AFTER_DELETE</code>: the group has been modified by
		deleting a row from it. The argument <code class="computeroutput">$rh</code> will refer to the row handle
		being deleted. The <code class="computeroutput">$opcode</code> may be either <code class="computeroutput">OP_NOP</code> or <code class="computeroutput">OP_INSERT</code>. A single
		operation on a table may affect multiple rows: an insert may trigger
		the replacement policy in the indexes and cause one or more rows to be
		deleted. If there are multiple rows deleted or inserted in a group, the
		additive aggregator needs to know about all of them to keep its state
		correct but does not need (and even must not) send a new result until
		the last one of them has been processed. The call for the last
		modification will have the opcode of <code class="computeroutput">OP_INSERT</code>. The preceding
		intermediate ones will have the opcode of <code class="computeroutput">OP_NOP</code>. An important point,
		even though a row is being deleted from the group, the aggregator
		opcode is <code class="computeroutput">OP_INSERT</code>, because it inserts the new aggregator state!
		</li><li class="listitem"><code class="computeroutput">&amp;Triceps::AO_AFTER_INSERT</code>: the group has been modified by
		inserting a row into it. Same as for <code class="computeroutput">AO_AFTER_DELETE</code>, <code class="computeroutput">$rh</code> will refer to
		the row handle being inserted, and <code class="computeroutput">$opcode</code> will be <code class="computeroutput">OP_NOP</code> or <code class="computeroutput">OP_INSERT</code>.
		</li><li class="listitem"><code class="computeroutput">&amp;Triceps::AO_COLLAPSE</code>: called after the last row is deleted
		from the group, just before the whole group is collapsed and deleted.
		This allows the aggregator to destroy its state properly. For most of
		the aggregators there is nothing special to be done. The only case when
		you want to do something is if your state causes some circular
		references. Perl doesn't free the circular references until the whole
		interpreter exits, and so you'd have to break the circle to let them be
		freed immediately. The aggregator should not produce any results on
		this call. The <code class="computeroutput">$opcode</code> will be <code class="computeroutput">OP_NOP</code>.
		</li></ul></div><p>
		The computation reacts accordingly: for the before-modification it
		re-sends the old result with the new opcode, for the collapse it does
		nothing, and for after-modification it calculates the sign, whether the
		value from <code class="computeroutput">$rh</code> needs to be added or subtracted from the sum. I'm
		actually thinking, maybe this sign should be passed as a separate
		argument too, and then both the aggregation operation constants
		<code class="computeroutput">AO_AFTER_*</code> can be merged into one. We'll see, maybe it will be changed
		in the future.
		</p><p>
		Then the addition/subtraction is done and the state updated.
		</p><p>
		After that, if the row does not need to be sent (opcode is <code class="computeroutput">OP_NOP</code> or
		group size is 0), the function can as well return here without
		constructing the new row.
		</p><a class="indexterm" name="id526390"></a><p>
		If the row needs to be produced, continue with the same logic as the
		non-additive aggregator, only without iteration through the group. The
		id field in the result is produced by essentially the SQL <code class="computeroutput">LAST()</code> 
		operator. <code class="computeroutput">LAST()</code> and <code class="computeroutput">FIRST()</code> are not additive, they refer to the values
		in the last or first row in the group's order, and simply can not be
		calculated from looking at which rows are being inserted and deleted
		without knowing their order in the group. But they are fast as they are,
		and do not require iteration. The same goes for the row count (as long
		as we don't care about excluding NULLs, violating the SQL semantics).
		And for averaging there is the last step to do after the additive part
		is done: divide the sum by the count.
		</p><p>
		All these non-additive steps are done in this last section, then the
		result row is constructed, remembered and sent.
		</p><p>
		Not all the aggregation operations can be expressed in an additive way.
		It may even vary by the data. For <code class="computeroutput">MAX()</code>, the insertion of a row can be
		always done additively, just comparing the new value with the
		remembered maximum, and replacing it if the new value is greater. The
		deletion can also compare the deleted value with the remembered
		maximum. If the deleted value is less, then the maximum is unchanged.
		But if the deleted value is equal to the maximum, <code class="computeroutput">MAX()</code> has to iterate
		through all the values and find the new maximum. 
		</p><a class="indexterm" name="id526452"></a><p>
		There is also an issue with the floating point precision in the
		additive aggregation. It's not such a big issue if the rows are only
		added and never deleted from the group, but can get much worse with the
		deletion. Let me show it with a sample run of the additive code:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,1,10</strong></span>
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="1" price="1"
<span class="bold"><strong>OP_INSERT,2,AAA,1e20,20</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="1" price="1"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="2" price="5e+19"
<span class="bold"><strong>OP_INSERT,3,AAA,2,10</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="2" price="5e+19"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="3" price="5e+19"
<span class="bold"><strong>OP_INSERT,4,AAA,3,10</strong></span>
tWindow.aggrAvgPrice OP_DELETE symbol="AAA" id="3" price="5e+19"
tWindow.aggrAvgPrice OP_INSERT symbol="AAA" id="4" price="1.5"</pre><p>
		Why is the last result 1.5 while it had to be (2+3)/2 = 2.5? Because
		adding together 1e20 and 2 had pushed the 2 beyond the precision of
		floating-point number. 1e20+2 = 1e20. So when the row with 1e20 was
		deleted from the group and subtracted form the sum, that left 0. Which
		got then averaged with 3, producing 1.5.
		</p><p>
		Of course, with the real stock prices there won't be that much
		variation. But the subtler errors will still accumulate over time, and
		you have to expect them and plan accordingly.
		</p><p>
		Switching to a different subject, the additive aggregation contains
		enough information in its state to generate the result rows quickly
		without an iteration. This means that keeping the saved result row for
		DELETEs doesn't give a whole lot of advantage and adds at least a
		little memory overhead. We can change the code and avoid keeping
		it:
		</p><pre class="programlisting">sub computeAverage8 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;
  my $rowchg;

  if ($aggop == &amp;Triceps::AO_COLLAPSE) {
    return
  } elsif ($aggop == &amp;Triceps::AO_AFTER_DELETE) {
    $state-&gt;{price_sum} -= $rh-&gt;getRow()-&gt;get("price");
  } elsif ($aggop == &amp;Triceps::AO_AFTER_INSERT) {
    $state-&gt;{price_sum} += $rh-&gt;getRow()-&gt;get("price");
  }
  # on AO_BEFORE_MOD do nothing

  return if ($context-&gt;groupSize()==0
    || $opcode == &amp;Triceps::OP_NOP);

  my $rLast = $context-&gt;last()-&gt;getRow();
  my $count = $context-&gt;groupSize();

  $context-&gt;makeHashSend($opcode,
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $state-&gt;{price_sum}/$count,
  );
}

sub initAverage8 #  (@args)
{
  return { price_sum =&gt; 0 };
}</pre><p>
		On <code class="computeroutput">AO_BEFORE_MOD</code> it doesn't do any change to the additive state but then produces
		the result row from that state as usual, using the supplied <code class="computeroutput">$opcode</code> value of
		<code class="computeroutput">OP_DELETE</code>.
		The other change in this example is that the sum gets directly added or
		subtracted in <code class="computeroutput">AO_AFTER_*</code> instead of computing the sign first. It's all
		pretty much self-explanatory.
		</p></div><div class="sect1" title="11.7. Computation function arguments"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_args"></a>11.7. Computation function arguments</h2></div></div></div><a class="indexterm" name="id526579"></a><p>
		Let's look up close at what calls are done to the aggregation
		computation function. Just make a <span class="quote">&#8220;<span class="quote">computation</span>&#8221;</span> that prints the call
		arguments:
		</p><pre class="programlisting">sub computeAverage9 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;

  print(&amp;Triceps::aggOpString($aggop), " ", &amp;Triceps::opcodeString($opcode), " ", $context-&gt;groupSize(), " ", (!$rh-&gt;isNull()? $rh-&gt;getRow()-&gt;printP(): "NULL"), "\n");
}</pre><p>
		It prints the aggregation operation, the result opcode, row count in
		the group, and the argument row (or <span class="quote">&#8220;<span class="quote">NULL</span>&#8221;</span>). The aggregation is done
		as before, on the same FIFO index with the size limit of 2.
		</p><p>
		To show the order of aggregator calls relative to the table label
		calls, I've added the labels that print the updates form the table:
		</p><pre class="programlisting">my $lbPre = makePrintLabel("lbPre", $tWindow-&gt;getPreLabel());
my $lbOut = makePrintLabel("lbOut", $tWindow-&gt;getOutputLabel());</pre><p>
		To make keeping track of the printout easier, I broke up the sequence
		into multiple fragments, with a description after each fragment:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,10,10</strong></span>
tWindow.pre OP_INSERT id="1" symbol="AAA" price="10" size="10"
tWindow.out OP_INSERT id="1" symbol="AAA" price="10" size="10"
AO_AFTER_INSERT OP_INSERT 1 id="1" symbol="AAA" price="10" size="10"
<span class="bold"><strong>OP_INSERT,2,BBB,100,100</strong></span>
tWindow.pre OP_INSERT id="2" symbol="BBB" price="100" size="100"
tWindow.out OP_INSERT id="2" symbol="BBB" price="100" size="100"
AO_AFTER_INSERT OP_INSERT 1 id="2" symbol="BBB" price="100" size="100"</pre><p>
		The INSERT of the first row in each group causes only one call. There is
		no previous value to delete, only a new one to insert. The call happens
		after the row has been inserted into the group.
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,3,AAA,20,20</strong></span>
AO_BEFORE_MOD OP_DELETE 1 NULL
tWindow.pre OP_INSERT id="3" symbol="AAA" price="20" size="20"
tWindow.out OP_INSERT id="3" symbol="AAA" price="20" size="20"
AO_AFTER_INSERT OP_INSERT 2 id="3" symbol="AAA" price="20" size="20"</pre><p>
		Adding the second record in a group means that the aggregation result
		for this group is modified. So first the aggregator is called to delete
		the old result, then the new row gets inserted, and the aggregator is
		called the second time to produce its new result.
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,5,AAA,30,30</strong></span>
AO_BEFORE_MOD OP_DELETE 2 NULL
tWindow.pre OP_DELETE id="1" symbol="AAA" price="10" size="10"
tWindow.out OP_DELETE id="1" symbol="AAA" price="10" size="10"
tWindow.pre OP_INSERT id="5" symbol="AAA" price="30" size="30"
tWindow.out OP_INSERT id="5" symbol="AAA" price="30" size="30"
AO_AFTER_DELETE OP_NOP 2 id="1" symbol="AAA" price="10" size="10"
AO_AFTER_INSERT OP_INSERT 2 id="5" symbol="AAA" price="30" size="30"</pre><p>
		The insertion of the third row in a group triggers the replacement policy in the
		FIFO index. The replacement policy causes the row with id=1 to be
		deleted before the row with id=5 is inserted. For the aggregator result
		it's still a single delete-insert pair: First, before modification, the
		old aggregation result is deleted. Then the contents of the group gets
		modified with both the delete and insert. And then the aggregator gets
		told, what has been modified. The deletion of the row with id=1 is not
		the last step, so that call gets the opcode of <code class="computeroutput">OP_NOP</code>. Note that the
		group size with it is 2, not 1. That's because the aggregator gets
		notified only after all the modifications are already done. So the
		additive part of the computation must never read the group size or do
		any kind of iteration through the group, because that would often cause
		an incorrect result: it has no way to tell, what other modifications
		have been already done to the group. The last <code class="computeroutput">AO_AFTER_INSERT</code> gets the
		opcode of <code class="computeroutput">OP_INSERT</code> which tells the computation to send the new result
		of the aggregation. When the opcode is <code class="computeroutput">OP_INSERT</code>, reading the group
		size and the other group information becomes safe, because by this
		time all the modifications are guaranteed to be done, and the additive
		notifications have caught up with all the changes.
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,3,BBB,20,20</strong></span>
AO_BEFORE_MOD OP_DELETE 2 NULL
AO_BEFORE_MOD OP_DELETE 1 NULL
tWindow.pre OP_DELETE id="3" symbol="AAA" price="20" size="20"
tWindow.out OP_DELETE id="3" symbol="AAA" price="20" size="20"
tWindow.pre OP_INSERT id="3" symbol="BBB" price="20" size="20"
tWindow.out OP_INSERT id="3" symbol="BBB" price="20" size="20"
AO_AFTER_DELETE OP_INSERT 1 id="3" symbol="AAA" price="20" size="20"
AO_AFTER_INSERT OP_INSERT 2 id="3" symbol="BBB" price="20" size="20"</pre><p>
		This insert is of a <span class="quote">&#8220;<span class="quote">dirty</span>&#8221;</span> kind, the one that replaces the row using
		the replacement policy of the hashed primary index, without deleting
		its old state first. It also moves the row from one aggregation group
		to another. So the table logic calls <code class="computeroutput">AO_BEFORE_MOD</code> for each of the
		modified groups, then modifies the contents of the groups, then tells
		both groups about the modifications. In this case both calls with
		<code class="computeroutput">AO_AFTER_*</code> have the opcode of <code class="computeroutput">OP_INSERT</code> because each of them is the
		last and only change to a separate aggregation group.
		</p><pre class="programlisting"><span class="bold"><strong>OP_DELETE,5</strong></span>
AO_BEFORE_MOD OP_DELETE 1 NULL
tWindow.pre OP_DELETE id="5" symbol="AAA" price="30" size="30"
tWindow.out OP_DELETE id="5" symbol="AAA" price="30" size="30"
AO_AFTER_DELETE OP_INSERT 0 id="5" symbol="AAA" price="30" size="30"
AO_COLLAPSE OP_NOP 0 NULL</pre><p>
		This operation removes the last row in a group. It starts as usual with
		deleting the old state. The next <code class="computeroutput">AO_AFTER_DELETE</code> with <code class="computeroutput">OP_INSERT</code> is
		intended for the Coral8-style aggregators that produce only the rows
		with the INSERT opcodes, never DELETEs, to let them insert the NULL (or
		zero) values in all the non-key fields. For the normal aggregators the
		work is all done after <code class="computeroutput">OP_DELETE</code>. That's why all the shown examples were
		checking for <code class="computeroutput">$context-&gt;groupSize() == 0</code> and returning if so. The
		group size will be zero in absolutely no other case than after the
		deletion of the last row. Finally <code class="computeroutput">AO_COLLAPSE</code> allows to clean up the
		aggregator's group state if it needs any cleaning. It has the opcode
		<code class="computeroutput">OP_NOP</code> because no rows need to be sent.
		</p><a class="indexterm" name="id526850"></a><p>
		To recap, the high-level order of the table operation processing is:
		</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
		Execute the replacement policies on all the indexes to find all the
		rows that need to be deleted first.
		</li><li class="listitem">
		If any of the index policies forbid the modification, return 0.
		</li><li class="listitem">
		Call all the aggregators with <code class="computeroutput">AO_BEFORE_MOD</code> on all the affected rows.
		</li><li class="listitem">
		Send these aggregator results.
		</li><li class="listitem"><p>
			For each affected row:
			</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
			Call the "pre" label (if it has any labels chained to it).
			</li><li class="listitem">
			Modify the row in the table.
			</li><li class="listitem">
			Call the "out" label.
			</li></ol></div></li><li class="listitem">
		Call all the aggregators with <code class="computeroutput">AO_AFTER_*</code>, on all the affected rows.
		</li><li class="listitem">
		Send these aggregator results.
		</li></ol></div></div><div class="sect1" title="11.8. Using multiple indexes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_multi_idx"></a>11.8. Using multiple indexes</h2></div></div></div><a class="indexterm" name="id526950"></a><a class="indexterm" name="id526964"></a><p>
		I've mentioned before that the floating numbers are tricky to handle.
		Even without additive aggregation the result depends on the rounding.
		Which in turn depends on the order in which the operations are done.
		Let's look at a version of the aggregation code that highlights this
		issue.
		</p><pre class="programlisting">sub computeAverage10 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;

  # don't send the NULL record after the group becomes empty
  return if ($context-&gt;groupSize()==0
    || $opcode != &amp;Triceps::OP_INSERT);

  my $sum = 0;
  my $count = 0;
  for (my $rhi = $context-&gt;begin(); !$rhi-&gt;isNull();
      $rhi = $context-&gt;next($rhi)) {
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  my $rLast = $context-&gt;last()-&gt;getRow();
  my $avg = $sum/$count;

  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $avg
  );
  $context-&gt;send($opcode, $res);
}

my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("last4",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 4)
      -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
        $rtAvgPrice, "aggrAvgPrice", undef, \&amp;computeAverage10)
      )
    )
  )
;
$ttWindow-&gt;initialize();
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");

# label to print the result of aggregation
my $lbAverage = $uTrades-&gt;makeLabel($rtAvgPrice, "lbAverage",
  undef, sub { # (label, rowop)
    printf("%.17g\n", $_[1]-&gt;getRow()-&gt;get("price"));
  });
$tWindow-&gt;getAggregatorLabel("aggrAvgPrice")-&gt;chain($lbAverage);</pre><p>
		The differences from the previously shown basic aggregation are:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		the FIFO limit has been increased to 4;
		</li><li class="listitem">
		the only result value printed by the <code class="computeroutput">$lbAverage</code> handler is the price,
		and it's printed with a higher precision to make the difference
		visible;
		</li><li class="listitem">
		the aggregator computation only does the inserts, to reduce the clutter
		in the results and highlight the issue.
		</li></ul></div><p>
		And here is an example of how the order of computation matters:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,1,10</strong></span>
1
<span class="bold"><strong>OP_INSERT,2,AAA,1,10</strong></span>
1
<span class="bold"><strong>OP_INSERT,3,AAA,1,10</strong></span>
1
<span class="bold"><strong>OP_INSERT,4,AAA,1e16,10</strong></span>
2500000000000001
<span class="bold"><strong>OP_INSERT,5,BBB,1e16,10</strong></span>
10000000000000000
<span class="bold"><strong>OP_INSERT,6,BBB,1,10</strong></span>
5000000000000000
<span class="bold"><strong>OP_INSERT,7,BBB,1,10</strong></span>
3333333333333333.5
<span class="bold"><strong>OP_INSERT,8,BBB,1,10</strong></span>
2500000000000000</pre><p>
		Of course, the real prices won't vary so wildly. But the other values
		could. This example is specially stacked to demonstrate the point. The
		final results for <span class="quote">&#8220;<span class="quote">AAA</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">BBB</span>&#8221;</span> should be the same but aren't. Why? The
		precision of the 64-bit floating-point numbers is such that adding 1
		to 1e16 makes this 1 fall beyond the precision, and the result is still
		1e16. On the other hand, adding 3 to 1e16 makes at least a part of it
		stick. 1 still falls off but the other 2 of 3 sticks on. Next look at the
		data sets: if you add 1e16+1+1+1, that's adding 1e16+1 repeated three
		times, and the result is still the same unchanged 1e16. But if you add
		1+1+1+1e16, that's adding 3+1e16, and now the result is different and
		more correct. When the averages get computed from these different values
		by dividing the sums by 4, the results are also different.
		</p><p>
		Overall the rule of thumb for adding the floating point numbers is
		this: add them up in the order from the smallest to the largest. (What
		if the numbers can be negative too? I don't know, that goes beyond my
		knowledge of floating point calculations. My guess is that you still
		arrange them in the ascending order, only by the absolute value.) So
		let's do it in the aggregator.
		</p><pre class="programlisting">our $idxByPrice;

# aggregation handler: sum in proper order
sub computeAverage11 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;
  our $idxByPrice;

  # don't send the NULL record after the group becomes empty
  return if ($context-&gt;groupSize()==0
    || $opcode != &amp;Triceps::OP_INSERT);

  my $sum = 0;
  my $count = 0;
  my $end = $context-&gt;endIdx($idxByPrice);
  for (my $rhi = $context-&gt;beginIdx($idxByPrice); !$rhi-&gt;same($end);
      $rhi = $rhi-&gt;nextIdx($idxByPrice)) {
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  my $rLast = $context-&gt;last()-&gt;getRow();
  my $avg = $sum/$count;

  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $avg
  );
  $context-&gt;send($opcode, $res);
}

my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("last4",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 4)
      -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
        $rtAvgPrice, "aggrAvgPrice", undef, \&amp;computeAverage11)
      )
    )
    -&gt;addSubIndex("byPrice",
      Triceps::SimpleOrderedIndex-&gt;new(price =&gt; "ASC",)
      -&gt;addSubIndex("multi", Triceps::IndexType-&gt;newFifo())
    )
  )
;
$ttWindow-&gt;initialize();
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");

$idxByPrice = $ttWindow-&gt;findIndexPath("bySymbol", "byPrice");</pre><a class="indexterm" name="id527136"></a><a class="indexterm" name="id527150"></a><a class="indexterm" name="id527163"></a><p>
		Here another index type is added, ordered by price. It has to be
		non-leaf, with a FIFO index type nested in it, to allow for multiple
		rows having the same price in them. That would work out more
		efficiently if the ordered index could have a multimap mode, but that
		is not supported yet.
		</p><p>
		When the compute function does its iteration, it now goes by that
		index. The aggregator can't be simply moved to that new index type,
		because it still needs to get the last trade id in the order in which the rows
		are inserted into the group. Instead it has to work with two index
		types: the one on which the aggregator is defined, and the additional
		one. The calls for iteration on an additional index are different.
		<code class="computeroutput">$context-&gt;beginIdx()</code> is similar to <code class="computeroutput">$context-&gt;begin()</code> but the end
		condition and the next step are done differently. 
		When <code class="computeroutput">$rhi-&gt;nextIdx()</code> reaches the end of the group,
		it returns not a NULL row handle but a handle value that has to be found in
		advance with <code class="computeroutput">$context-&gt;endIdx()</code>.  Perhaps the
		consistency in this department can be improved in the future.
		</p><p>
		And finally, the reference to that additional index type has to make it
		somehow into the compute function. It can't be given as an argument
		because it's not known yet at the time when the aggregator is
		constructed (and no, reordering the index types won't help because the
		index types are copied when connected to their parents, and we need the
		exact index type that ends up in the assembled table type). So a global
		variable <code class="computeroutput">$idxByPrice</code> is used. The index type reference is found and
		placed there, and later when the compute function runs, it takes the reference from
		the global variable.
		</p><p>
		The printout from this version on the same input is:
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1,AAA,1,10</strong></span>
1
<span class="bold"><strong>OP_INSERT,2,AAA,1,10</strong></span>
1
<span class="bold"><strong>OP_INSERT,3,AAA,1,10</strong></span>
1
<span class="bold"><strong>OP_INSERT,4,AAA,1e16,10</strong></span>
2500000000000001
<span class="bold"><strong>OP_INSERT,5,BBB,1e16,10</strong></span>
10000000000000000
<span class="bold"><strong>OP_INSERT,6,BBB,1,10</strong></span>
5000000000000000
<span class="bold"><strong>OP_INSERT,7,BBB,1,10</strong></span>
3333333333333334
<span class="bold"><strong>OP_INSERT,8,BBB,1,10</strong></span>
2500000000000001</pre><p>
		Now no matter what the order of the row arrival, the prices get added
		up in the same order from the smallest to the largest and produce the
		same correct (inasmuch the floating point precision allows) result.
		</p><p>
		Which index type is used to put the aggregator on, doesn't matter a
		whole lot. The computation can be turned around, with the ordered index
		used as the main one, and the last value from the FIFO index obtained
		with <code class="computeroutput">$context-&gt;lastIdx()</code>:
		</p><pre class="programlisting">our $idxByOrder;

# aggregation handler: sum in proper order
sub computeAverage12 # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;
  our $idxByOrder;

  # don't send the NULL record after the group becomes empty
  return if ($context-&gt;groupSize()==0
    || $opcode != &amp;Triceps::OP_INSERT);

  my $sum = 0;
  my $count = 0;
  for (my $rhi = $context-&gt;begin(); !$rhi-&gt;isNull();
      $rhi = $context-&gt;next($rhi)) {
    $count++;
    $sum += $rhi-&gt;getRow()-&gt;get("price");
  }
  my $rLast = $context-&gt;lastIdx($idxByOrder)-&gt;getRow();
  my $avg = $sum/$count;

  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    symbol =&gt; $rLast-&gt;get("symbol"),
    id =&gt; $rLast-&gt;get("id"),
    price =&gt; $avg
  );
  $context-&gt;send($opcode, $res);
}

my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("last4",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 4)
    )
    -&gt;addSubIndex("byPrice",
      Triceps::SimpleOrderedIndex-&gt;new(price =&gt; "ASC",)
      -&gt;addSubIndex("multi", Triceps::IndexType-&gt;newFifo())
      -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
        $rtAvgPrice, "aggrAvgPrice", undef, \&amp;computeAverage12)
      )
    )
  )
;
$ttWindow-&gt;initialize();
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");

$idxByOrder = $ttWindow-&gt;findIndexPath("bySymbol", "last4");</pre><p>
		The last important note: when aggregating with multiple indexes, always
		use the sibling index types forming the same group or their nested
		sub-indexes (since the actual order is defined by the first leaf
		sub-index anyway). But don't use the random unrelated index types. If
		you do, the context would return some unexpected values for those, and
		you may end up with endless loops.
		</p></div><div class="sect1" title="11.9. SimpleAggregator"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_simple"></a>11.9. SimpleAggregator</h2></div></div></div><a class="indexterm" name="id527345"></a><a class="indexterm" name="id527355"></a><p>
		Even though the writing the aggregation computation functions manually
		gives the flexibility, it's too much work for the simple cases. 
		The SimpleAggregator template takes care of most of that work
		and allows you to specify the aggregation in a way similar to SQL.
		It has been already shown on the VWAP example, ans here is the 
		trade aggregation example from
		<a class="xref" href="#sc_aggregation_proper" title="11.3. Introducing the proper aggregation">Section 11.3: &#8220;Introducing the proper aggregation&#8221; </a>
		rewritten with SimpleAggregator:
		</p><pre class="programlisting">my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("byId",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "id" ])
  )
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
    -&gt;addSubIndex("last2",
      Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
    )
  )
;

# the aggregation result
my $rtAvgPrice;
my $compText; # for debugging

Triceps::SimpleAggregator::make(
  tabType =&gt; $ttWindow,
  name =&gt; "aggrAvgPrice",
  idxPath =&gt; [ "bySymbol", "last2" ],
  result =&gt; [
    symbol =&gt; "string", "last", sub {$_[0]-&gt;get("symbol");},
    id =&gt; "int32", "last", sub {$_[0]-&gt;get("id");},
    price =&gt; "float64", "avg", sub {$_[0]-&gt;get("price");},
  ],
  saveRowTypeTo =&gt; \$rtAvgPrice,
  saveComputeTo =&gt; \$compText,
);

$ttWindow-&gt;initialize();
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");

# label to print the result of aggregation
my $lbAverage = makePrintLabel("lbAverage",
  $tWindow-&gt;getAggregatorLabel("aggrAvgPrice"));</pre><p>
		The main loop and the printing is the same as before. The result
		produced is also exactly the same as before.
		</p><p>
		But the aggregator is created with <code class="computeroutput">Triceps::SimpleAggregator::make()</code>.
		Its arguments are in the option format: the option name-value pairs, in
		any order. 
		</p><pre class="programlisting">$tabType = Triceps::SimpleAggregator::make($optName =&gt; $optValue, ...);</pre><p>
		It returns back the table type that it received as an option.
		But most of the time there is not a whole lot of use to that
		return value, and it gets simply ignored.
		Most of the <span class="quote">&#8220;<span class="quote">options</span>&#8221;</span> are actually mandatory. The
		aggregator type is connected to the table type with the options:
		</p><div class="variablelist"><dl><dt><span class="term">tabType</span></dt><dd>
				Table type to put the aggregator on. It must be un-initialized yet.
				</dd><dt><span class="term">idxPath</span></dt><dd>
				A reference to an array of index names, forming the path to the
				index where the aggregator type will be set.
				</dd><dt><span class="term">name</span></dt><dd>
				The aggregator type name.
				</dd></dl></div><p>
		The result row type and computation is defined with the option
		<span class="quote">&#8220;<span class="quote">result</span>&#8221;</span>: each group of four values in that array defines one result
		field: 
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		The field name. 
		</li><li class="listitem">
		The field type. 
		</li><li class="listitem">
		The aggregation function name used to compute the field. There is no
		way to combine multiple aggregation functions or even an aggregation function
		and any arithmetics in a field computation. The workaround is to compute
		each function in a separate field, and then send the result rows to a
		computational label that would arithmetically combine these fields into one.
		</li><li class="listitem">
		A closure that extracts the aggregation function argument from the row
		(well, it can be any function reference, doesn't have to be an
		anonymous closure). 
		That closure gets the row as the argument <code class="computeroutput">$_[0]</code>
		and returns the extracted value to run the aggregation on. 
		</li></ul></div><p>
		The field name is by convention separated from its definition fields by <code class="computeroutput">=&gt;</code>.
		Remember, it's just a convention, for Perl a <code class="computeroutput">=&gt;</code> is just as good as
		a comma.
		</p><p>
		<code class="computeroutput">SimpleAggregator::make()</code> automatically generates the result row
		type and aggregation function, creates an aggregator type from them,
		and sets it on the index type. 
		The information about the aggregation result
		can be found by traversing through the index type tree, or by
		constructing a table and getting the row type from the aggregator
		result label. However it's often easier to save it during construction,
		and the option (this time an optional one!) <span class="quote">&#8220;<span class="quote">saveRowTypeTo</span>&#8221;</span> allows to
		do this. Give it a reference to a variable, and the row type will be
		placed into that variable.
		</p><p>
		Most of the time the things would just work. However if they don't and
		something dies in the aggregator, you will need the source code of the
		compute function to make sense of these errors. The option
		<code class="computeroutput">saveComputeTo</code> gives a variable to save that source code for future
		perusal and other entertainment. Here is the compute function that 
		gets produced by the example above (it gets implicitly wrapped in a
		<code class="computeroutput">sub { ... }</code>, like any other source code argument):
		</p><pre class="programlisting">  use strict;
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;
  return if ($context-&gt;groupSize()==0 || $opcode == &amp;Triceps::OP_NOP);
  my $v2_count = 0;
  my $v2_sum = 0;
  my $npos = 0;
  for (my $rhi = $context-&gt;begin(); !$rhi-&gt;isNull(); $rhi = $context-&gt;next($rhi)) {
    my $row = $rhi-&gt;getRow();
    # field price=avg
    my $a2 = $args[2]($row);
    { if (defined $a2) { $v2_sum += $a2; $v2_count++; }; }
    $npos++;
  }
  my $rowLast = $context-&gt;last()-&gt;getRow();
  my $l0 = $args[0]($rowLast);
  my $l1 = $args[1]($rowLast);
  $context-&gt;makeArraySend($opcode,
    ($l0), # symbol
    ($l1), # id
    (($v2_count == 0? undef : $v2_sum / $v2_count)), # price
  );</pre><p>
		At the moment the compute function is quite straightforward and just
		does the aggregation from scratch every time. It doesn't support the
		additive aggregation nor the DELETE optimization. It's only smart enough to
		skip the iteration if all the result consists of only aggregation
		functions <code class="computeroutput">first</code>, <code class="computeroutput">last</code>
		and <code class="computeroutput">count_star</code>. It receives the closures for the argument extraction as
		arguments in <code class="computeroutput">@args</code>, SimpleAggregator arranges these arguments
		when it creates the aggregator.
		</p><p>
		The aggregation functions available at the moment are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">first</code></span></dt><dd>
				Value from the first row in the group.
				</dd><dt><span class="term"><code class="computeroutput">last</code></span></dt><dd>
				Value from the last row in the group.
				</dd><dt><span class="term"><code class="computeroutput">count_star</code></span></dt><dd>
				Number of rows in the group, like SQL <code class="computeroutput">COUNT(*)</code>. Since there is
				no argument for this function, use <code class="computeroutput">undef</code> instead of the
				argument closure.
				</dd><dt><span class="term"><code class="computeroutput">sum</code></span></dt><dd>
				Sum of the values.
				</dd><dt><span class="term"><code class="computeroutput">max</code></span></dt><dd>
				The maximal value.
				</dd><dt><span class="term"><code class="computeroutput">min</code></span></dt><dd>
				The minimal value.
				</dd><dt><span class="term"><code class="computeroutput">avg</code></span></dt><dd>
				The average of all the non-NULL values.
				</dd><dt><span class="term"><code class="computeroutput">avg_perl</code></span></dt><dd>
				The average of all values, with NULL values treated in Perl
				fashion as zeroes. So, technically when the example above used
				<code class="computeroutput">avg</code>, it works the same as the previous versions only for the
				non-NULL fields. To be really the same, it should have used
				<code class="computeroutput">avg_perl</code>.
				</dd><dt><span class="term"><code class="computeroutput">nth_simple</code></span></dt><dd>
				The Nth value from the start of the group. This is a tricky
				function because it needs two arguments: the value of N and the
				field selector. Multiple direct arguments will be supported in
				the future but right now it works through a workaround: the
				argument closure must return not just the extracted field but a
				reference to array with two values, the N and the field. For
				example, <code class="computeroutput">sub { [1, $_[0]-&gt;get("id")];}</code>. The N is
				counted starting from 0, so the value of 1 will return the
				second record. This function works in a fairly simple-minded
				and inefficient way at the moment.
				</dd></dl></div><p>
		As usual in Triceps and Perl, the case of the aggregation function name
		matters. The names have to be used in lowercase as shown.
		There will be more functions to come, and you can even already add your own,
		as has been shown in
		<a class="xref" href="#sc_aggregation_vwap" title="11.1. The ubiquitous VWAP">Section 11.1: &#8220;The ubiquitous VWAP&#8221; </a>.
		</p><p>
		The user-defined aggregation functions are defined with the option
		<span class="quote">&#8220;<span class="quote">functions</span>&#8221;</span>. Let's take another look at the code
		from the VWAP example:
		</p><pre class="programlisting"># VWAP function definition
my $myAggFunctions = {
  myvwap =&gt; {
    vars =&gt; { sum =&gt; 0, count =&gt; 0, size =&gt; 0, price =&gt; 0 },
    step =&gt; '($%size, $%price) = @$%argiter; '
      . 'if (defined $%size &amp;&amp; defined $%price) '
        . '{$%count += $%size; $%sum += $%size * $%price;}',
    result =&gt; '($%count == 0? undef : $%sum / $%count)',
  },
};

...

Triceps::SimpleAggregator::make(
  functions =&gt; $myAggFunctions,
);</pre><p>
		The definition of the functions is a reference to a hash, keyed
		by the function name. Each function definition in order is
		a hash of options, keyed by the option name. When
		the SimpleAggregator builds the common computation function,
		it assembles the code by tying together the code fragments
		from these options: 
		Whenever the group changes, the
		aggregator will reset the function state variables to the default values
		and iterate through the new contents of the group. It will
		perform the step computation for each row and collect the
		data in the intermediate variables. After the iteration it will
		perform the result computation of all the functions
		and produce the final value.
		</p><p>
		The expected format of the values of these
		options varies with the option. The option <span class="quote">&#8220;<span class="quote">result</span>&#8221;</span>
		is mandatory, the rest can be skipped if not needed. The supported
		options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">argcount</code></span></dt><dd>
				Integer. Defines the number of arguments of the function, which
				may currently be 0 or 1, with 1 being the default. If this option
				is 0, SimpleAggregator will check that the argument closure
				is <code class="computeroutput">undef</code>.
				If the aggregation function needs more arguments than one,
				they have to be packed into an array or hash, and then its
				reference used as a single argument. The standard function
				<code class="computeroutput">nth_simple</code> and the VWAP function provide the examples
				of how to do this.
				</dd><dt><span class="term"><code class="computeroutput">vars</code></span></dt><dd>
				Reference to a hash. Defines the variables used to
				keep the context of this function during the iteration 
				(the hash keys are the variable names) and their initial values
				(specified as the values in the hash).
				</dd><dt><span class="term"><code class="computeroutput">step</code></span></dt><dd><p>
				String. The code fragment to compute a single step of iteration.
				It can refer to the variables defined in <code class="computeroutput">vars</code> and to a few of
				the pre-defined values using the syntax <code class="computeroutput">$%name</code> (which has
				been chosen because it's illegal in the normal Perl variable syntax).
				When SimpleAggregator generates the code, it creates the actual scope
				variables for everything defined in <code class="computeroutput">vars</code>, then substitutes
				them for the <code class="computeroutput">$%</code> syntax in the string and inserts the result
				into its group iteration code.
				</p><p>
				If this option is not defined, SimpleAggregator assumes that this function
				doesn't need it. If no functions in the aggregation define the <code class="computeroutput">step</code>,
				the iteration does not get included into the generated code altogether.
				</p><p>
				The defined special values are:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">$%argiter</code> - The function's argument extracted from the current row.
					</li><li class="listitem"><code class="computeroutput">$%niter</code> - The number of the current row in the group, starting from 0.
					</li><li class="listitem"><code class="computeroutput">$%groupsize</code> - The size of the group (<code class="computeroutput">$context-&gt;groupSize()</code>).
					</li></ul></div></dd><dt><span class="term"><code class="computeroutput">result</code></span></dt><dd><p>
				String. The code fragment to compute the result of the function.
				This option is mandatory. Works in the same way as <code class="computeroutput">step</code>, only
				gets executed once per call of the computation function, and the defined
				special values are different:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">$%argfirst</code> - The function's argument extracted from the first row.
					</li><li class="listitem"><code class="computeroutput">$%arglast</code> - The function's argument extracted from the last row.
					</li><li class="listitem"><code class="computeroutput">$%groupsize</code> - The size of the group (<code class="computeroutput">$context-&gt;groupSize()</code>).
					</li></ul></div></dd></dl></div><p>
		I can think of many ways the SimpleAggregator can be improved, but for
		now they have been pushed into the future to keep it simple.
		</p></div><div class="sect1" title="11.10. The guts of SimpleAggregator"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_aggregation_simple_guts"></a>11.10. The guts of SimpleAggregator</h2></div></div></div><a class="indexterm" name="id528059"></a><p>
		The implementation of the SimpleAggregator has turned out to be
		surprisingly small. Not quite tiny but still
		small. I've liked it so much that I've even saved the original small
		version in the file <code class="computeroutput">xSimpleAggregator.t</code>. As more features will be
		added, the <span class="quote">&#8220;<span class="quote">official</span>&#8221;</span> version of the SimpleAggregator will grow (and
		already did) but that example file will stay small and simple.
		</p><a class="indexterm" name="id528084"></a><p>
		It's a nice example of yet another kind of template that I want
		to present. I'm going to go through it, interlacing the code with the
		commentary.
		</p><pre class="programlisting">package MySimpleAggregator;
use Carp;

use strict;

our $FUNCTIONS = {
  first =&gt; {
    result =&gt; '$%argfirst',
  },
  last =&gt; {
    result =&gt; '$%arglast',
  },
  count_star =&gt; {
    argcount =&gt; 0,
    result =&gt; '$%groupsize',
  },
  count =&gt; {
    vars =&gt; { count =&gt; 0 },
    step =&gt; '$%count++ if (defined $%argiter);',
    result =&gt; '$%count',
  },
  sum =&gt; {
    vars =&gt; { sum =&gt; 0 },
    step =&gt; '$%sum += $%argiter;',
    result =&gt; '$%sum',
  },
  max =&gt; {
    vars =&gt; { max =&gt; 'undef' },
    step =&gt; '$%max = $%argiter if (!defined $%max || $%argiter &gt; $%max);',
    result =&gt; '$%max',
  },
  min =&gt; {
    vars =&gt; { min =&gt; 'undef' },
    step =&gt; '$%min = $%argiter if (!defined $%min || $%argiter &lt; $%min);',
    result =&gt; '$%min',
  },
  avg =&gt; {
    vars =&gt; { sum =&gt; 0, count =&gt; 0 },
    step =&gt; 'if (defined $%argiter) { $%sum += $%argiter; $%count++; }',
    result =&gt; '($%count == 0? undef : $%sum / $%count)',
  },
  avg_perl =&gt; { # Perl-like treat the NULLs as 0s
    vars =&gt; { sum =&gt; 0 },
    step =&gt; '$%sum += $%argiter;',
    result =&gt; '$%sum / $%groupsize',
  },
  nth_simple =&gt; { # inefficient, need proper multi-args for better efficiency
    vars =&gt; { n =&gt; 'undef', tmp =&gt; 'undef', val =&gt; 'undef' },
    step =&gt; '($%n, $%tmp) = @$%argiter; if ($%n == $%niter) { $%val = $%tmp; }',
    result =&gt; '$%val',
  },
};</pre><p>
		The package name of this saved simple version is MySimpleAggregator,
		to avoid confusion with the <span class="quote">&#8220;<span class="quote">official</span>&#8221;</span> SimpleAggregator class.
		First goes the definition of the aggregation functions.
		They are defined in exactly the same way as the vwap function has been
		shown before.  They are fairly straightforward.
		You can use them as the starting point for adding your own.
		</p><pre class="programlisting">sub make # (optName =&gt; optValue, ...)
{
  my $opts = {}; # the parsed options
  my $myname = "MySimpleAggregator::make";

  &amp;Triceps::Opt::parse("MySimpleAggregator", $opts, {
      tabType =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "Triceps::TableType") } ],
      name =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
      idxPath =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "ARRAY", "") } ],
      result =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "ARRAY") } ],
      saveRowTypeTo =&gt; [ undef, sub { &amp;Triceps::Opt::ck_refscalar(@_) } ],
      saveInitTo =&gt; [ undef, sub { &amp;Triceps::Opt::ck_refscalar(@_) } ],
      saveComputeTo =&gt; [ undef, sub { &amp;Triceps::Opt::ck_refscalar(@_) } ],
    }, @_);</pre><p>
		The options get parsed. Since it's not a proper object constructor but a factory,
		it uses the hash <code class="computeroutput">$opts</code> instead of <code class="computeroutput">$self</code> to save the
		processed copy of the options. This early version doesn't have
		an option for the user-supplied aggregation function definitions.
		</p><pre class="programlisting">  # reset the saved source code
  ${$opts-&gt;{saveInitTo}} = undef if (defined($opts-&gt;{saveInitTo}));
  ${$opts-&gt;{saveComputeTo}} = undef if (defined($opts-&gt;{saveComputeTo}));
  ${$opts-&gt;{saveRowTypeTo}} = undef if (defined($opts-&gt;{saveRowTypeTo}));</pre><p>
		The generated source code will not be placed
		into the <code class="computeroutput">save*</code> references until the table type gets initialized, so for the
		meantime they get filled with <code class="computeroutput">undef</code>s.
		</p><pre class="programlisting">  # find the index type, on which to build the aggregator
  my $idx = $opts-&gt;{tabType}-&gt;findIndexPath(@{$opts-&gt;{idxPath}});
  confess "$myname: the index type is already initialized, can not add an aggregator on it"
    if ($idx-&gt;isInitialized());</pre><p>
		Since the SimpleAggregator uses an existing table with existing index,
		it doesn't require the aggregation key: it just takes an index that
		forms the group, and whatever key that leads to this index becomes the
		aggregation key.
		</p><pre class="programlisting">  # check the result definition and build the result row type and code snippets for the computation
  my $rtRes;
  my $needIter = 0; # flag: some of the functions require iteration
  my $needfirst = 0; # the result needs the first row of the group
  my $needlast = 0; # the result needs the last row of the group
  my $codeInit = ''; # code for function initialization
  my $codeStep = ''; # code for iteration
  my $codeResult = ''; # code to compute the intermediate values for the result
  my $codeBuild = ''; # code to build the result row
  my @compArgs; # the field functions are passed as args to the computation
  {
    my $grpstep = 4; # definition grouped by 4 items per result field
    my @resopt = @{$opts-&gt;{result}};
    my @rtdefRes; # field definition for the result
    my $id = 0; # numeric id of the field

    while ($#resopt &gt;= 0) {
      confess "$myname: the values in the result definition must go in groups of 4"
        unless ($#resopt &gt;= 3);
      my $fld = shift @resopt;
      my $type = shift @resopt;
      my $func = shift @resopt;
      my $funcarg = shift @resopt;

      confess("$myname: the result field name must be a string, got a " . ref($fld) . " ")
        unless (ref($fld) eq '');
      confess("$myname: the result field type must be a string, got a " . ref($type) . " for field '$fld'")
        unless (ref($type) eq '');
      confess("$myname: the result field function must be a string, got a " . ref($func) . " for field '$fld'")
        unless (ref($func) eq '');</pre><p>
		This starts the loop that goes over the result fields and builds the
		code to create them. The code will be built in multiple snippets that
		will eventually be combined to produce the compute function. Since the
		arguments go in groups of 4, it becomes fairly easy to miss one element
		somewhere, and then everything gets real confusing. So the code
		attempts to check the types of the arguments, in hopes of catching
		these off-by-ones as early as possible. The variable <code class="computeroutput">$id</code> will be used
		to produce the unique prefixes for the function's variables.
		</p><pre class="programlisting">      my $funcDef = $FUNCTIONS-&gt;{$func}
        or confess("$myname: function '" . $func . "' is unknown");

      my $argCount = $funcDef-&gt;{argcount};
      $argCount = 1 # 1 is the default value
        unless defined($argCount);
      confess("$myname: in field '$fld' function '$func' requires an argument computation that must be a Perl sub reference")
        unless ($argCount == 0 || ref $funcarg eq 'CODE');
      confess("$myname: in field '$fld' function '$func' requires no argument, use undef as a placeholder")
        unless ($argCount != 0 || !defined $funcarg);

      push(@rtdefRes, $fld, $type);

      push(@compArgs, $funcarg)
        if (defined $funcarg);</pre><p>
		The function definition for a field gets pulled out by name, and
		the arguments of the field are checked for correctness.
		The types of the fields get collected for the row definition, and the
		aggregation argument computation closures (or, technically, functions)
		get also collected, to pass later as the arguments of the compute
		function.
		</p><pre class="programlisting">      # add to the code snippets

      ### initialization
      my $vars = $funcDef-&gt;{vars};
      if (defined $vars) {
        foreach my $v (keys %$vars) {
          # the variable names are given a unique prefix;
          # the initialization values are constants, no substitutions
          $codeInit .= "  my \$v${id}_${v} = " . $vars-&gt;{$v} . ";\n";
        }
      } else {
        $vars = { }; # a dummy
      }</pre><p>
		The initialization fragment gets processed if defined. 
		The unique names for variables are generated from the <code class="computeroutput">$id</code> and the
		variable name in the definition, so that there would be no interference
		between the result fields. And the initialization snippets are collected
		in <code class="computeroutput">$codeInit</code>. The initialization values are not enquoted
		because they are expected to be strings suitable for such use.
		That's why the undefined values in the function defnitions are not
		<code class="computeroutput">undef</code> but <code class="computeroutput">'undef'</code>. If you'd want to initialize
		a variable as a string <code class="computeroutput">"x"</code>, you'd use it as <code class="computeroutput">'"x"'</code>.
		For the numbers it doesn't
		really matter, the numbers just get converted to strings as needed,
		so the zeroes are simply <code class="computeroutput">0</code>s without quoting.
		</p><p>
		Another possibility would be to have the actual values as-is in the hash and then either put
		these values into the argument array passed to the computation
		function or use the closure trick from <code class="computeroutput">Triceps::Fields::makeTranslation()</code> described in
		<a class="xref" href="#sc_template_result" title="10.7. Result projection in the templates">Section 10.7: &#8220;Result projection in the templates&#8221; </a>.
		</p><pre class="programlisting">      ### iteration
      my $step = $funcDef-&gt;{step};
      if (defined $step) {
        $needIter = 1;
        $codeStep .= "    # field $fld=$func\n";
        if (defined $funcarg) {
          # compute the function argument from the current row
          $codeStep .= "    my \$a${id} = \$args[" . $#compArgs ."](\$row);\n";
        }
        # substitute the variables in $step
        $step =~ s/\$\%(\w+)/&amp;replaceStep($1, $func, $vars, $id, $argCount)/ge;
        $codeStep .= "    { $step; }\n";
      }</pre><p>
		Then the iteration fragment gets processed.
		The logic remembers
		in <code class="computeroutput">$needIter</code> if any of the functions involved needs iteration.
		Before the iteration snippet gets collected, it has the <code class="computeroutput">$%</code>
		names substitutted, and placed into a block, just in case if it wants
		to define some local variables.  An extra <span class="quote">&#8220;<span class="quote">;</span>&#8221;</span> is added
		just in case, it doesn't hurt and helps if it was forgotten in the
		function definition.
		</p><pre class="programlisting">      ### result building
      my $result = $funcDef-&gt;{result};
      confess "MySimpleAggregator: internal error in definition of aggregation function '$func', missing result computation"
        unless (defined $result);
      # substitute the variables in $result
      if ($result =~ /\$\%argfirst/) {
        $needfirst = 1;
        $codeResult .= "  my \$f${id} = \$args[" . $#compArgs ."](\$rowFirst);\n";
      }
      if ($result =~ /\$\%arglast/) {
        $needlast = 1;
        $codeResult .= "  my \$l${id} = \$args[" . $#compArgs ."](\$rowLast);\n";
      }
      $result =~ s/\$\%(\w+)/&amp;replaceResult($1, $func, $vars, $id, $argCount)/ge;
      $codeBuild .= "    ($result), # $fld\n";

      $id++;
    }
    $rtRes = Triceps::wrapfess
      "$myname: invalid result row type definition:",
      sub { Triceps::RowType-&gt;new(@rtdefRes); };
  }
  ${$opts-&gt;{saveRowTypeTo}} = $rtRes if (defined($opts-&gt;{saveRowTypeTo}));</pre><p>
		In the same way the result computation is created, and remembers if any
		function wanted the fields from the first or last row. And eventually
		after all the functions have been processed, the result row type is created. 
		If it was asked to save, it gets saved.
		</p><pre class="programlisting">  # build the computation function
  my $compText = "sub {\n";
  $compText .= "  use strict;\n";
  $compText .= "  my (\$table, \$context, \$aggop, \$opcode, \$rh, \$state, \@args) = \@_;\n";
  $compText .= "  return if (\$context-&gt;groupSize()==0 || \$opcode == &amp;Triceps::OP_NOP);\n";
  $compText .= $codeInit;
  if ($needIter) {
    $compText .= "  my \$npos = 0;\n";
    $compText .= "  for (my \$rhi = \$context-&gt;begin(); !\$rhi-&gt;isNull(); \$rhi = \$context-&gt;next(\$rhi)) {\n";
    $compText .= "    my \$row = \$rhi-&gt;getRow();\n";
    $compText .= $codeStep;
    $compText .= "    \$npos++;\n";
    $compText .= "  }\n";
  }
  if ($needfirst) {
    $compText .= "  my \$rowFirst = \$context-&gt;begin()-&gt;getRow();\n";
  }
  if ($needlast) {
    $compText .= "  my \$rowLast = \$context-&gt;last()-&gt;getRow();\n";
  }
  $compText .= $codeResult;
  $compText .= "  \$context-&gt;makeArraySend(\$opcode,\n";
  $compText .= $codeBuild;
  $compText .= "  );\n";
  $compText .= "}\n";

  ${$opts-&gt;{saveComputeTo}} = $compText if (defined($opts-&gt;{saveComputeTo}));</pre><p>
		The compute function gets assembled from the collected fragments.
		The optional parts get included only if some of the functions needed them.
		</p><pre class="programlisting">  # compile the computation function
  my $compFun = eval $compText
    or confess "$myname: error in compilation of the aggregation computation:\n  $@function text:\n"
      . Triceps::Code::numalign($compText, "  ") . "\n";

  # build and add the aggregator
  my $agg = Triceps::wrapfess
    "$myname: internal error: failed to build an aggregator type:",
    sub { Triceps::AggregatorType-&gt;new($rtRes, $opts-&gt;{name}, undef, $compFun, @compArgs); };

  Triceps::wrapfess
    "$myname: failed to set the aggregator in the index type:",
    sub { $idx-&gt;setAggregator($agg); };

  return $opts-&gt;{tabType};
}</pre><p>
		Then the compute function is compiled. In case if the compilation
		fails, the error message will include both the compilation error and
		the text of the auto-generated function. Otherwise there would be no
		way to know, what exactly went wrong. Well, since no user code is
		included into the auto-generated function, it should never fail. Except
		if there is some bad code in the aggregation function definitions. The
		compiled function and collected closures are then used to create the
		aggregator, which should also never fail.
		</p><p>
		The functions that translate the <code class="computeroutput">$%variable</code> names are built after the
		same pattern but have the different built-in variables:
		</p><pre class="programlisting">sub replaceStep # ($varname, $func, $vars, $id, $argCount)
{
  my ($varname, $func, $vars, $id, $argCount) = @_;

  if ($varname eq 'argiter') {
    confess "MySimpleAggregator: internal error in definition of aggregation function '$func', step computation refers to 'argiter' but the function declares no arguments"
      unless ($argCount &gt; 0);
    return "\$a${id}";
  } elsif ($varname eq 'niter') {
    return "\$npos";
  } elsif ($varname eq 'groupsize') {
    return "\$context-&gt;groupSize()";
  } elsif (exists $vars-&gt;{$varname}) {
    return "\$v${id}_${varname}";
  } else {
    confess "MySimpleAggregator: internal error in definition of aggregation function '$func', step computation refers to an unknown variable '$varname'"
  }
}

sub replaceResult # ($varname, $func, $vars, $id, $argCount)
{
  my ($varname, $func, $vars, $id, $argCount) = @_;

  if ($varname eq 'argfirst') {
    confess "MySimpleAggregator: internal error in definition of aggregation function '$func', result computation refers to '$varname' but the function declares no arguments"
      unless ($argCount &gt; 0);
    return "\$f${id}";
  } elsif ($varname eq 'arglast') {
    confess "MySimpleAggregator: internal error in definition of aggregation function '$func', result computation refers to '$varname' but the function declares no arguments"
      unless ($argCount &gt; 0);
    return "\$l${id}";
  } elsif ($varname eq 'groupsize') {
    return "\$context-&gt;groupSize()";
  } elsif (exists $vars-&gt;{$varname}) {
    return "\$v${id}_${varname}";
  } else {
    confess "MySimpleAggregator: internal error in definition of aggregation function '$func', result computation refers to an unknown variable '$varname'"
  }
}</pre><p>
		They check for the references to the undefined variables and confess if
		any are found.  That's it, the whole aggregator generation.
		</p><p>
		Now let's look back at the printout of a generated computation function
		that has been shown above..
		The aggregation results were:
		</p><pre class="programlisting">  result =&gt; [
    symbol =&gt; "string", "last", sub {$_[0]-&gt;get("symbol");},
    id =&gt; "int32", "last", sub {$_[0]-&gt;get("id");},
    price =&gt; "float64", "avg", sub {$_[0]-&gt;get("price");},
  ],</pre><p>
		Which produced the function body:
		</p><pre class="programlisting">  use strict;
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;
  return if ($context-&gt;groupSize()==0 || $opcode == &amp;Triceps::OP_NOP);
  my $v2_count = 0;
  my $v2_sum = 0;
  my $npos = 0;
  for (my $rhi = $context-&gt;begin(); !$rhi-&gt;isNull(); $rhi = $context-&gt;next($rhi)) {
    my $row = $rhi-&gt;getRow();
    # field price=avg
    my $a2 = $args[2]($row);
    { if (defined $a2) { $v2_sum += $a2; $v2_count++; }; }
    $npos++;
  }
  my $rowLast = $context-&gt;last()-&gt;getRow();
  my $l0 = $args[0]($rowLast);
  my $l1 = $args[1]($rowLast);
  $context-&gt;makeArraySend($opcode,
    ($l0), # symbol
    ($l1), # id
    (($v2_count == 0? undef : $v2_sum / $v2_count)), # price
  );</pre><p>
		The fields get assigned the ids 0, 1 and 2. <code class="computeroutput">avg</code> for 
		the <code class="computeroutput">price</code> field is the only function
		here that requires the iteration, and its variables are defined with
		the prefix <code class="computeroutput">$v2_</code>. In the loop the function argument
		closure is called from <code class="computeroutput">$args[2]</code>, 
		and its result is stored in <code class="computeroutput">$a2</code> (again,
		2 here is the id of this field). Then a copy of the step
		computation for <code class="computeroutput">avg</code> is copied in a block, with the
		variables substituted. <code class="computeroutput">$%argiter</code> becomes <code class="computeroutput">$a2</code>, <code class="computeroutput">$%sum</code> becomes
		<code class="computeroutput">$v2_sum</code>, <code class="computeroutput">$%count</code> becomes <code class="computeroutput">$v2_count</code>.
		Then the loop ends.
		</p><p>
		The functions make use of the last row, so <code class="computeroutput">$rowLast</code> is computed.
		The values for the <code class="computeroutput">$%arglast</code> fields 0 and 1 are calculated 
		in <code class="computeroutput">$l0</code> and <code class="computeroutput">$l1</code>.
		Then the result row is created and sent from an array of substituted
		result snippets from all the fields. That's how it all works together.
		</p></div></div><div class="chapter" title="Chapter 12. Joins"><div class="titlepage"><div><div><h2 class="title"><a name="ch_joins"></a>Chapter 12. Joins</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_joins_variety">12.1. Joins variety</a></span></dt><dt><span class="sect1"><a href="#sc_joins_hello">12.2. Hello, joins!</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookup_manual">12.3. The lookup join, done manually</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookupjoin">12.4. The LookupJoin template</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookupjoin_iter">12.5. Manual iteration with LookupJoin</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookupjoin_keys">12.6. The key fields of LookupJoin</a></span></dt><dt><span class="sect1"><a href="#sc_joins_lookupjoin_inside">12.7. A peek inside LookupJoin</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo">12.8. JoinTwo joins two tables</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo_keys">12.9. The key field duplication in JoinTwo</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo_override">12.10. The override options in JoinTwo</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo_inputfilter">12.11. JoinTwo input event filtering</a></span></dt><dt><span class="sect1"><a href="#sc_joins_self_jointwo">12.12. Self-join done with JoinTwo</a></span></dt><dt><span class="sect1"><a href="#sc_joins_self_manual">12.13. Self-join done manually</a></span></dt><dt><span class="sect1"><a href="#sc_joins_self_lookupjoin">12.14. Self-join done with a LookupJoin</a></span></dt><dt><span class="sect1"><a href="#sc_joins_jointwo_glimpse">12.15. A glimpse inside JoinTwo and the hidden options of LookupJoin</a></span></dt></dl></div><div class="sect1" title="12.1. Joins variety"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_variety"></a>12.1. Joins variety</h2></div></div></div><a class="indexterm" name="id476669"></a><p>
		The joins are quite important for the relational data processing, and
		come in many varieties. And the CEP systems have their own specifics.
		Basically, in CEP you want the joins to be processed fast. The CEP
		systems deal with the changing model state, and have to process these
		changes incrementally.
		</p><p>
		A small change should be handled fast. It has to use the indexes to
		find and update all the related result rows. Even though you can make
		it just go sequentially through all the rows and find the relevant
		ones, like in a common database, that's not what you normally want.
		When something like this happens, the usual reaction is <span class="quote">&#8220;<span class="quote">wtf is my
		model suddenly so slow?</span>&#8221;</span> following by an annoyingly long investigation
		into the reasons of the slowness, and then rewriting the model to make
		it work faster. It's better to just prevent the slowness in the first
		place and make sure that the joins always use an index. And since you
		don't have to deal much with the ad-hoc queries when you write a CEP
		model, you can provide all the needed indexes in advance very easily.
		</p><a class="indexterm" name="id512231"></a><a class="indexterm" name="id463214"></a><a class="indexterm" name="id502486"></a><p>
		A particularly interesting kind of joins in this regard is the
		equi-joins: ones that join the rows by the equality of the fields in
		them. They allow a very efficient index look-up. Because of this, they
		are popular in the CEP world. Some systems, like Aleri, support only
		the equi-joins to start with. The other systems are much more efficient
		on the equi-joins than on the other kinds of joins. At the moment
		Triceps follows the fashion of having the advanced support only for the
		equi-joins. Even though the Sorted/Ordered indexes in Triceps should allow the
		range-based comparisons to be efficient too, at the moment there are no
		table methods for the look-up of ranges, they are left for the future
		work. Of course, nothing stops you from copying an equi-join template
		and modifying it to work by a dumb iteration. Just it would be slow,
		and I didn't see much point in it.
		</p><p>
		There also are three common patterns of the join usage.
		</p><a class="indexterm" name="id479514"></a><a class="indexterm" name="id479524"></a><a class="indexterm" name="id479537"></a><p>
		In the first pattern the rows sort of go by and get enriched by looking
		up some information from a table and tacking it onto these rows.
		Sometimes not even tacking it on but maybe just filtering the data:
		passing through some of the rows and throwing away the rest, or
		directing the rows into the different kinds of processing, based on the
		looked-up data. For a reference, in the Coral8 CCL this situation is
		called <span class="quote">&#8220;<span class="quote">stream-to-window joins</span>&#8221;</span>. In Triceps there are no streams and no
		windows, so I just call them the <span class="quote">&#8220;<span class="quote">lookup joins</span>&#8221;</span>.
		</p><a class="indexterm" name="id479565"></a><p>
		In the second pattern multiple stateful tables are joined together.
		Whenever any of the tables changes, the join result also changes, and
		the updates get propagated through. This can be done through lookups,
		but in reality it turns out that defining manually the lookups for the
		every possible table change becomes tedious pretty quickly. This has to
		be addressed by the automation.
		</p><a class="indexterm" name="id483384"></a><p>
		In the third pattern the same table gets joined recursively,
		essentially traversing a representation of a tree stored in that table.
		This actually doesn't work well with the classic SQL unless the
		recursion depth is strictly limited. There are SQL extensions for the
		recursive self-joins in the modern databases but I haven't seen them in the
		CEP systems yet. Anyway, the procedural approach tends to work for this
		situation much better than the SQLy one, so the templates tend to be of
		not much help. I'll show a templated and a manual example of this kind
		for comparison.
		</p></div><div class="sect1" title="12.2. Hello, joins!"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_hello"></a>12.2. Hello, joins!</h2></div></div></div><p>
		As usual, let me show a couple of little teasers before starting the
		long bottom-up discussion. We'll eventually get by the long
		way to the same examples, so here I'll show only some very short
		code snippets and basic explanations.
		</p><pre class="programlisting">our $join = Triceps::LookupJoin-&gt;new(
  name =&gt; "join",
  leftFromLabel =&gt; $lbTrans,
  rightTable =&gt; $tAccounts,
  leftFields =&gt; [ "!acct.*", ".*" ],
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
);</pre><a class="indexterm" name="id512179"></a><p>
		This is a lookup join that gets the incoming rows with transactions
		data from the label <code class="computeroutput">$lbTrans</code>, finds the account translation in the
		table <code class="computeroutput">$tAccounts</code>, and translates the external account representation
		to internal one on its output. The join condition is an equivalent of the
		SQLy
		</p><a class="indexterm" name="id510697"></a><pre class="programlisting">on
  lbTrans.acctSrc = tAccounts.source
  and lbTrans.acctXtrId = tAccounts.external</pre><p>
		The condition looks up the rows in <code class="computeroutput">$tAccounts</code> using the index
		that has the key fields <code class="computeroutput">source</code> and <code class="computeroutput">external</code>. Such index must
		be already defined, or the join will refuse to compile.
		</p><p>
		The result fields will contain all the fields from <code class="computeroutput">$lbTrans</code> except those
		starting with <span class="quote">&#8220;<span class="quote">acct</span>&#8221;</span> plus the field <code class="computeroutput">internal</code> from <code class="computeroutput">$tAccounts</code>
		that becomes renamed to <code class="computeroutput">acct</code>.
		</p><p>
		Next goes a table join:
		</p><pre class="programlisting">our $join = Triceps::JoinTwo-&gt;new(
  name =&gt; "join",
  leftTable =&gt; $tPosition,
  rightTable =&gt; $tToUsd,
  byLeft =&gt; [ "date", "currency" ],
  type =&gt; "inner",
);</pre><a class="indexterm" name="id510779"></a><p>
		It joins the tables <code class="computeroutput">$tPosition</code> and <code class="computeroutput">$tToUsd</code>, with the inner join logic.
		The join condition is on the fields <span class="quote">&#8220;<span class="quote">date</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">currency</span>&#8221;</span> being
		equal in rows in both tables.
		</p></div><div class="sect1" title="12.3. The lookup join, done manually"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_lookup_manual"></a>12.3. The lookup join, done manually</h2></div></div></div><p>
		First let's look at a lookup done manually. It would also establish the
		baseline for the further joins.
		</p><p>
		For the background of the model, let's consider the trade information
		coming in from multiple sources. Each source system has its own
		designation of the accounts on which the trades happen but ultimately
		they are the same accounts. So there is a table that contains the
		translation from the account designations of various external systems
		to our system's own internal account identifier. This gets described
		with the row types:
		</p><pre class="programlisting">our $rtInTrans = Triceps::RowType-&gt;new( # a transaction received
  id =&gt; "int32", # the transaction id
  acctSrc =&gt; "string", # external system that sent us a transaction
  acctXtrId =&gt; "string", # its name of the account of the transaction
  amount =&gt; "int32", # the amount of transaction (int is easier to check)
);

our $rtAccounts = Triceps::RowType-&gt;new( # account translation map
  source =&gt; "string", # external system that sent us a transaction
  external =&gt; "string", # its name of the account in the transaction
  internal =&gt; "int32", # our internal account id
);</pre><p>
		Other than those basics, the rest of information is only minimal, to
		keep the examples smaller. Even the trade ids are expected to be global
		and not per the source systems (which is not realistic but saves
		another little bit of work).
		</p><p>
		The accounts table can be indexed in multiple ways for multiple
		purposes, say:
		</p><pre class="programlisting">our $ttAccounts = Triceps::TableType-&gt;new($rtAccounts)
  -&gt;addSubIndex("lookupSrcExt", # quick look-up by source and external id
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "source", "external" ])
  )
  -&gt;addSubIndex("iterateSrc", # for iteration in order grouped by source
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "source" ])
    -&gt;addSubIndex("iterateSrcExt",
      Triceps::IndexType-&gt;newHashed(key =&gt; [ "external" ])
    )
  )
  -&gt;addSubIndex("lookupIntGroup", # quick look-up by internal id (to multiple externals)
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "internal" ])
    -&gt;addSubIndex("lookupInt", Triceps::IndexType-&gt;newFifo())
  )
;
$ttAccounts-&gt;initialize();</pre><p>
		For our purpose of joining, the first, primary key is the way to go.
		Using the primary key also has the advantage of making sure that there
		is no more than one row for each key value.
		</p><a class="indexterm" name="id480871"></a><a class="indexterm" name="id480885"></a><a class="indexterm" name="id480898"></a><a class="indexterm" name="id480912"></a><p>
		The first manual lookup example will just do the filtering: find, whether there is a match
		in the translation table, and if so then pass the row through. The
		example goes as follows:
		</p><pre class="programlisting">our $uJoin = Triceps::Unit-&gt;new("uJoin");

our $tAccounts = $uJoin-&gt;makeTable($ttAccounts, "tAccounts");

my $lbFilterResult = $uJoin-&gt;makeDummyLabel($rtInTrans, "lbFilterResult");
my $lbFilter = $uJoin-&gt;makeLabel($rtInTrans, "lbFilter", undef, sub {
  my ($label, $rowop) = @_;
  my $row = $rowop-&gt;getRow();
  my $rh = $tAccounts-&gt;findBy(
    source =&gt; $row-&gt;get("acctSrc"),
    external =&gt; $row-&gt;get("acctXtrId"),
  );
  if (!$rh-&gt;isNull()) {
    $uJoin-&gt;call($lbFilterResult-&gt;adopt($rowop));
  }
});

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $lbFilterResult);

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "acct") {
    $uJoin-&gt;makeArrayCall($tAccounts-&gt;getInputLabel(), @data);
  } elsif ($type eq "trans") {
    $uJoin-&gt;makeArrayCall($lbFilter, @data);
  }
  $uJoin-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		The <code class="computeroutput">findBy()</code> is where the join actually happens: the lookup of the data
		in a table by values from another row. Very similar to what the
		basic window example in
		<a class="xref" href="#sc_table_hello" title="9.1. Hello, tables!">Section 9.1: &#8220;Hello, tables!&#8221; </a>
		was doing before. It's <code class="computeroutput">findBy()</code>, without the need for <code class="computeroutput">findByIdx()</code>,
		because in this case the index type used in the accounts table is its
		first leaf index, to which <code class="computeroutput">findBy()</code> defaults.
		After that the fact of
		successful or unsuccessful lookup is used to pass the original row
		through or throw it away. If the found row were used to pick some
		fields from it and stick them into the result, that would be a more
		complete join, more like what you often expect to see.
		</p><p>
		And here is an example of the input processing:
		</p><pre class="programlisting"><span class="bold"><strong>acct,OP_INSERT,source1,999,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source1,2011,2</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,1</strong></span>
<span class="bold"><strong>trans,OP_INSERT,1,source1,999,100</strong></span>
lbFilterResult OP_INSERT id="1" acctSrc="source1" acctXtrId="999"
    amount="100"
<span class="bold"><strong>trans,OP_INSERT,2,source2,ABCD,200</strong></span>
lbFilterResult OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD"
    amount="200"
<span class="bold"><strong>trans,OP_INSERT,3,source2,QWERTY,200</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,QWERTY,2</strong></span>
<span class="bold"><strong>trans,OP_DELETE,3,source2,QWERTY,200</strong></span>
lbFilterResult OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200"
<span class="bold"><strong>acct,OP_DELETE,source1,999,1</strong></span></pre><p>
		It starts with populating the accounts table. Then the transactions that
		find the match pass, and those who don't find don't pass. If more of
		the account translations get added later, the transactions for them
		start passing but as you can see, the result might be slightly
		unexpected: you may get a DELETE that had no matching previous INSERT,
		as happened for the row with id=3.
		This happens because the lookup join keeps no history on its left side
		and can't react properly to the changes to the table on the right.
		Because of this, the lookup joins work best when the reference table
		gets pre-populated in advance and then stays stable.
		</p></div><div class="sect1" title="12.4. The LookupJoin template"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_lookupjoin"></a>12.4. The LookupJoin template</h2></div></div></div><a class="indexterm" name="id531992"></a><a class="indexterm" name="id532001"></a><p>
		When a join has to produce the new rows, with the data from both the
		incoming row and the ones looked up in the reference table, this can
		also be done manually but may be more convenient to do with the
		LookupJoin template. The translation of account to the internal ids can
		be done like this:
		</p><pre class="programlisting">our $join = Triceps::LookupJoin-&gt;new(
  unit =&gt; $uJoin,
  name =&gt; "join",
  leftRowType =&gt; $rtInTrans,
  rightTable =&gt; $tAccounts,
  rightIdxPath =&gt; ["lookupSrcExt"],
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
  isLeft =&gt; 1,
); # would confess by itself on an error

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $join-&gt;getOutputLabel());

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "acct") {
    $uJoin-&gt;makeArrayCall($tAccounts-&gt;getInputLabel(), @data);
  } elsif ($type eq "trans") {
    $uJoin-&gt;makeArrayCall($join-&gt;getInputLabel(), @data);
  }
  $uJoin-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		The join gets defined in the option name-value format. The options <span class="quote">&#8220;<span class="quote">unit</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">name</span>&#8221;</span> are as usual.
		</p><a class="indexterm" name="id532043"></a><p>
		The incoming rows are always on the left side, the table on the right.
		LookupJoin can do either the inner join or the left outer join (since
		it does not react to the changes of the right table and has no access
		to the past data from the left side, the full and right outer joins are not
		available).
		In this case the option <span class="quote">&#8220;<span class="quote">isLeft =&gt; 1</span>&#8221;</span> selects the left outer join.
		The left outer join also happens to be the default if this option is not used.
		</p><p>
		The left side is described by the option <span class="quote">&#8220;<span class="quote">leftRowType</span>&#8221;</span>, and causes the join's input
		label of this row type to be created. The input label can be found with
		<code class="computeroutput">$join-&gt;getInputLabel()</code>.
		</p><p>
		The right side is a table, specified in the option <span class="quote">&#8220;<span class="quote">rightTable</span>&#8221;</span>. The
		lookups in the table are done using a combination of an index and the
		field pairing. The option <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> provides the field pairing. It contains
		the pairs of field names, one from the left, and one from the right,
		for the equal fields. They can be separated by 
		<span class="quote">&#8220;<span class="quote"><code class="computeroutput">,</code></span>&#8221;</span> too, but <span class="quote">&#8220;<span class="quote"><code class="computeroutput">=&gt;</code></span>&#8221;</span>
		feels more idiomatic to me. These fields from the left are translated
		to the right and are used for lookup through the index. The index
		is specified with the path in the option <span class="quote">&#8220;<span class="quote">rightIdxPath</span>&#8221;</span>.
		This option is optional: if it's missing, the template will automatically
		find the index that matches the key fields. The index must exist though,
		if it doesn't exist, LookupJoin can't create it and can't work without
		it either. The index must be a Hashed index.
		</p><a class="indexterm" name="id532116"></a><a class="indexterm" name="id532129"></a><a class="indexterm" name="id532143"></a><p>
		There is no particular reason for it not being a Sorted/Ordered index, other
		that the <code class="computeroutput">getKey()</code> call does not work for these indexes yet, and
		that's what the LookupJoin uses to check that the right-side index key
		matches the join key in <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span>. The order of the fields in the
		option <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> and in the index may vary but the set of the
		fields must be the same.
		</p><p>
		The index may be either a leaf (as in this example) or non-leaf. If
		it's a leaf, it could look up no more than one row per key, and
		LookupJoin uses this internally for a little optimization. Otherwise
		LookupJoin is capable of producing multiple result rows for one input row.
		</p><a class="indexterm" name="id532180"></a><a class="indexterm" name="id532190"></a><p>
		Finally, there is the result row. It is built out of the two original
		rows by picking the fields according to the options <span class="quote">&#8220;<span class="quote">leftFields</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">rightFields</span>&#8221;</span>. If either option is missing, that means 
		<span class="quote">&#8220;<span class="quote">take all the fields</span>&#8221;</span>. 
		The format of these options is from <code class="computeroutput">Triceps::Fields::filterToPairs()</code>
		that has been described in
		<a class="xref" href="#sc_template_result" title="10.7. Result projection in the templates">Section 10.7: &#8220;Result projection in the templates&#8221; </a>.
		So in this example <code class="computeroutput">[ "internal/acct" ]</code> means: pass the field <code class="computeroutput">internal</code>
		but rename it to <code class="computeroutput">acct</code>.
		</p><p>
		Remember that the field names in the result must not
		duplicate. It would be an error. 
		If the duplications happen, the most general solution is to use the
		substitution syntax to rename some of the fields.
		</p><p>
		A fairly common usage in joins is to just give the unique prefixes to
		the left-side and right-side fields. This can be achieved with:
		</p><pre class="programlisting">  leftFields =&gt; [ '.*/left_$&amp;' ],
  rightFields =&gt; [ '.*/right_$&amp;' ],</pre><p>
		The <code class="computeroutput">$&amp;</code> in the substitution gets replaced with the whole matched
		field name. There is also another way to solve a special case of duplication
		that will be shown in a moment.
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">fieldsLeftFirst</span>&#8221;</span> determines, which side will go first in
		the result. By default it's set to 1 (as in this example), and the left
		side goes first. If set to 0, the right side would go first.
		</p><p>
		This setup for the result row types is somewhat clumsy but it's a
		reasonable first attempt. 
		</p><p>
		Now, having gone through the description, an example of how it works:
		</p><pre class="programlisting"><span class="bold"><strong>acct,OP_INSERT,source1,999,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source1,2011,2</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,1</strong></span>
<span class="bold"><strong>trans,OP_INSERT,1,source1,999,100</strong></span>
join.out OP_INSERT id="1" acctSrc="source1" acctXtrId="999"
    amount="100" acct="1"
<span class="bold"><strong>trans,OP_INSERT,2,source2,ABCD,200</strong></span>
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD"
    amount="200" acct="1"
<span class="bold"><strong>trans,OP_INSERT,3,source2,QWERTY,200</strong></span>
join.out OP_INSERT id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200"
<span class="bold"><strong>acct,OP_INSERT,source2,QWERTY,2</strong></span>
<span class="bold"><strong>trans,OP_DELETE,3,source2,QWERTY,200</strong></span>
join.out OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200" acct="2"
<span class="bold"><strong>acct,OP_DELETE,source1,999,1</strong></span></pre><p>
		Same as before, first the accounts table gets populated, then the
		transactions are sent. If an account is not found, this left outer join
		still passes through the original fields from the left side. Adding an
		account later doesn't help the rowops that already went through but the
		new rowops will see it. The same goes for deleting an account, it
		doesn't affect the past rowops either.
		</p><p>
		Now let's take another look at the field duplication problem.
		The most typical case of duplication is in the key fields, when the
		key fields on both sides are named the same. If all the fields from
		both left and right sides were to be included (which is the default),
		the key fields would be included twice, with the same names, and
		cause a conflict. LookupJoin provides a solution for this special
		case, shown in the following example:
		</p><pre class="programlisting">our $rtTrans = Triceps::RowType-&gt;new( # a transaction received
  id =&gt; "int32", # the transaction id
  source =&gt; "string", # external system that sent us a transaction
  external =&gt; "string", # its name of the account of the transaction
  amount =&gt; "int32", # the amount of transaction (int is easier to check)
);

our $tAccounts = $uJoin-&gt;makeTable($ttAccounts, "tAccounts");

our $join = Triceps::LookupJoin-&gt;new(
  unit =&gt; $uJoin,
  name =&gt; "join",
  leftRowType =&gt; $rtTrans,
  rightTable =&gt; $tAccounts,
  byLeft =&gt; [ "source", "external" ],
  fieldsDropRightKey =&gt; 1,
  isLeft =&gt; 1,
); # would confess by itself on an error</pre><p>
		The example does the exact same thing as the last one, only here the fields
		in the incoming rows have been named the same as in the table. This made the
		option <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span> the more convenient way to specify the join 
		condition. And this time there are no explicit options to select the result fields,
		all of them are included. But that would have included the fields
		<span class="quote">&#8220;<span class="quote">source</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">external</span>&#8221;</span> twice, which is illegal.
		The option <span class="quote">&#8220;<span class="quote">fieldsDropRightKey</span>&#8221;</span> set to 1 takes care of that: it automatically
		removes the key fields on the right side from the result.
		This example produces the output that is the same as the last one, only with
		the different field names:
		</p><pre class="programlisting"><span class="bold"><strong>acct,OP_INSERT,source1,999,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source1,2011,2</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,1</strong></span>
<span class="bold"><strong>trans,OP_INSERT,1,source1,999,100</strong></span>
join.out OP_INSERT id="1" source="source1" external="999" amount="100"
    internal="1"
<span class="bold"><strong>trans,OP_INSERT,2,source2,ABCD,200</strong></span>
join.out OP_INSERT id="2" source="source2" external="ABCD"
    amount="200" internal="1"
<span class="bold"><strong>trans,OP_INSERT,3,source2,QWERTY,200</strong></span>
join.out OP_INSERT id="3" source="source2" external="QWERTY"
    amount="200"
<span class="bold"><strong>acct,OP_INSERT,source2,QWERTY,2</strong></span>
<span class="bold"><strong>trans,OP_DELETE,3,source2,QWERTY,200</strong></span>
join.out OP_DELETE id="3" source="source2" external="QWERTY"
    amount="200" internal="2"
<span class="bold"><strong>acct,OP_DELETE,source1,999,1</strong></span></pre><p>
		The left-side data can also be specified in another way: the option
		<span class="quote">&#8220;<span class="quote">leftFromLabel</span>&#8221;</span> provides a label which in turn provides both the input
		row type and the unit. You can still specify the unit option as well
		but it must match the one in the label. This is driven internally by
		<code class="computeroutput">Triceps::Opt::handleUnitTypeLabel()</code>, described in
		<a class="xref" href="#sc_template_options" title="10.5. Template options">Section 10.5: &#8220;Template options&#8221; </a>,
		so it follows the same rules.
		The join still has its own
		input label but it gets automatically chained to the one in the option.
		For an example of such a join:
		</p><pre class="programlisting">our $lbTrans = $uJoin-&gt;makeDummyLabel($rtInTrans, "lbTrans");

our $join = Triceps::LookupJoin-&gt;new(
  name =&gt; "join",
  leftFromLabel =&gt; $lbTrans,
  rightTable =&gt; $tAccounts,
  leftFields =&gt; [ "id", "amount" ],
  fieldsLeftFirst =&gt; 0,
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
  isLeft =&gt; 0,
); # would confess by itself on an error

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $join-&gt;getOutputLabel());

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "acct") {
    $uJoin-&gt;makeArrayCall($tAccounts-&gt;getInputLabel(), @data);
  } elsif ($type eq "trans") {
    $uJoin-&gt;makeArrayCall($lbTrans, @data);
  }
  $uJoin-&gt;drainFrame(); # just in case, for completeness
}</pre><a class="indexterm" name="id532504"></a><p>
		The other options demonstrate the possibilities described in the last
		post. This time it's an inner join, the result has the right-side
		fields going first, and the left-side fields are filtered in the
		result by an explicit list of fields to pass. The right-side index is found 
		automatically.
		</p><p>
		Another way to achieve the same filtering of the left-side fields would
		be by throwing away everything starting with <span class="quote">&#8220;<span class="quote">acct</span>&#8221;</span> and passing through
		the rest:
		</p><pre class="programlisting">  leftFields =&gt; [ "!acct.*", ".*" ],</pre><p>
		And here is an example of a run:
		</p><pre class="programlisting"><span class="bold"><strong>acct,OP_INSERT,source1,999,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source1,2011,2</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,1</strong></span>
<span class="bold"><strong>trans,OP_INSERT,1,source1,999,100</strong></span>
join.out OP_INSERT acct="1" id="1" amount="100"
<span class="bold"><strong>trans,OP_INSERT,2,source2,ABCD,200</strong></span>
join.out OP_INSERT acct="1" id="2" amount="200"
<span class="bold"><strong>trans,OP_INSERT,3,source2,QWERTY,200</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,QWERTY,2</strong></span>
<span class="bold"><strong>trans,OP_DELETE,3,source2,QWERTY,200</strong></span>
join.out OP_DELETE acct="2" id="3" amount="200"
<span class="bold"><strong>acct,OP_DELETE,source1,999,1</strong></span></pre><p>
		The input data is the same as the last time, but the result is
		different. Since it's an inner join, the rows that don't find a match
		don't pass through. And of course the fields are ordered and subsetted
		differently in the result.
		</p><p>
		The next example loses all connection with reality, it just serves to
		demonstrate another ability of LookupJoin: matching multiple rows on
		the right side for an incoming row. The situation itself is obviously
		useful and normal, just it's not what normally happens with the
		account id translation, and I was too lazy to invent another
		realistically-looking example.
		</p><pre class="programlisting">our $ttAccounts2 = Triceps::TableType-&gt;new($rtAccounts)
  -&gt;addSubIndex("iterateSrc", # for iteration in order grouped by source
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "source" ])
    -&gt;addSubIndex("lookupSrcExt",
      Triceps::IndexType-&gt;newHashed(key =&gt; [ "external" ])
      -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
    )
  )
;
$ttAccounts2-&gt;initialize();

our $tAccounts = $uJoin-&gt;makeTable($ttAccounts2, "tAccounts");

our $join = Triceps::LookupJoin-&gt;new(
  unit =&gt; $uJoin,
  name =&gt; "join",
  leftRowType =&gt; $rtInTrans,
  rightTable =&gt; $tAccounts,
  rightIdxPath =&gt; [ "iterateSrc", "lookupSrcExt" ],
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
  #saveJoinerTo =&gt; \$code,
); # would confess by itself on an error</pre><p>
		The main loop is unchanged from the first LookupJoin example, so I
		won't copy it here. Just for something different, the join index here
		is nested, and its path consists of two elements. It's not a leaf index
		either, with one FIFO level under it. It could also have been found
		automatically.  And when the <span class="quote">&#8220;<span class="quote">isLeft</span>&#8221;</span> is not
		specified explicitly, it defaults to 1, making it a left join.
		</p><p>
		The example of a run uses a slightly different input, highlighting the ability to
		match multiple rows:
		</p><pre class="programlisting"><span class="bold"><strong>acct,OP_INSERT,source1,999,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source1,2011,2</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,10</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,100</strong></span>
<span class="bold"><strong>trans,OP_INSERT,1,source1,999,100</strong></span>
join.out OP_INSERT id="1" acctSrc="source1" acctXtrId="999"
    amount="100" acct="1"
<span class="bold"><strong>trans,OP_INSERT,2,source2,ABCD,200</strong></span>
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD"
    amount="200" acct="1"
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD"
    amount="200" acct="10"
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD"
    amount="200" acct="100"
<span class="bold"><strong>trans,OP_INSERT,3,source2,QWERTY,200</strong></span>
join.out OP_INSERT id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200"
<span class="bold"><strong>acct,OP_INSERT,source2,QWERTY,2</strong></span>
<span class="bold"><strong>trans,OP_DELETE,3,source2,QWERTY,200</strong></span>
join.out OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200" acct="2"
<span class="bold"><strong>acct,OP_DELETE,source1,999,1</strong></span></pre><p>
		When a row matches multiple rows in the table, it gets multiplied. The
		join function iterates through the whole matching row group, and for
		each found row creates a result row and calls the output label with it.
		</p><p>
		Now, what if you don't want to get multiple rows back even if they are
		found? Of course, the best way is to just use a leaf index. But once in
		a while you get into situations with the denormalized data in the
		lookup table. You might know in advance that for each row in an index
		group a certain field would be the same. Or you might not care, what
		exact value you get as long as it's from the right group. But you might
		really not want the input rows to multiply when they go through the
		join. LookupJoin has a solution:
		</p><pre class="programlisting">our $join = Triceps::LookupJoin-&gt;new(
  unit =&gt; $uJoin,
  name =&gt; "join",
  leftRowType =&gt; $rtInTrans,
  rightTable =&gt; $tAccounts,
  rightIdxPath =&gt; [ "iterateSrc", "lookupSrcExt" ],
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
  limitOne =&gt; 1,
); # would confess by itself on an error</pre><p>
		The option <span class="quote">&#8220;<span class="quote">limitOne</span>&#8221;</span> changes the processing logic to pick only the
		first matching row. It also optimizes the join function. If <span class="quote">&#8220;<span class="quote">limitOne</span>&#8221;</span> is
		not specified explicitly, the join constructor deduces it magically by
		looking at whether the join index is a leaf or not. Actually, for a
		leaf index it would always override <span class="quote">&#8220;<span class="quote">limitOne</span>&#8221;</span> to 1, even if you
		explicitly set it to 0.
		</p><p>
		With the limit, the same input produces a different output:
		</p><pre class="programlisting"><span class="bold"><strong>acct,OP_INSERT,source1,999,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source1,2011,2</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,10</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,100</strong></span>
<span class="bold"><strong>trans,OP_INSERT,1,source1,999,100</strong></span>
join.out OP_INSERT id="1" acctSrc="source1" acctXtrId="999"
    amount="100" acct="1"
<span class="bold"><strong>trans,OP_INSERT,2,source2,ABCD,200</strong></span>
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD"
    amount="200" acct="1"
<span class="bold"><strong>trans,OP_INSERT,3,source2,QWERTY,200</strong></span>
join.out OP_INSERT id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200"
<span class="bold"><strong>acct,OP_INSERT,source2,QWERTY,2</strong></span>
<span class="bold"><strong>trans,OP_DELETE,3,source2,QWERTY,200</strong></span>
join.out OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200" acct="2"
<span class="bold"><strong>acct,OP_DELETE,source1,999,1</strong></span></pre><p>
		Now it just picks the first matching row instead of multiplying the
		rows.
		</p></div><div class="sect1" title="12.5. Manual iteration with LookupJoin"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_lookupjoin_iter"></a>12.5. Manual iteration with LookupJoin</h2></div></div></div><a class="indexterm" name="id532859"></a><a class="indexterm" name="id532869"></a><p>
		Sometimes you might want to just get the list of the resulting rows
		from LookupJoin and iterate over them by yourself, rather than have it
		call the labels. To be honest, this looked kind of important when I
		wrote LookupJoin first, but by now I don't see a whole lot of use in
		it. By now, if you want to do a manual iteration, calling <code class="computeroutput">findBy()</code> and
		then iterating looks like a more useful option. But at the time there
		was no <code class="computeroutput">findBy()</code>, and this feature came to exist. Here is an example:
		</p><pre class="programlisting">our $join = Triceps::LookupJoin-&gt;new(
  unit =&gt; $uJoin,
  name =&gt; "join",
  leftRowType =&gt; $rtInTrans,
  rightTable =&gt; $tAccounts,
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
  automatic =&gt; 0,
); # would confess by itself on an error

# label to print the changes to the detailed stats
my $lbPrint = makePrintLabel("lbPrint", $join-&gt;getOutputLabel());

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "acct") {
    $uJoin-&gt;makeArrayCall($tAccounts-&gt;getInputLabel(), @data);
  } elsif ($type eq "trans") {
    my $op = shift @data; # drop the opcode field
    my $trans = $rtInTrans-&gt;makeRowArray(@data);
    my @rows = $join-&gt;lookup($trans);
    foreach my $r (@rows) {
      $uJoin-&gt;call($lbPrint-&gt;makeRowop($op, $r));
    }
  }
  $uJoin-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		It copies the first LookupJoin example, only now with a manual iteration. Once the
		option <span class="quote">&#8220;<span class="quote">automatic</span>&#8221;</span> is set to 0 for the join, the method
		<code class="computeroutput">$join-&gt;lookup()</code> becomes available to perform the lookup and return
		the result rows in an array (the data sent to the input label keeps
		working as usual, sending the result rows to the output label). This
		involves the extra overhead of keeping all the result rows (and there
		might be lots of them) in an array, so by default the join is compiled
		in an automatic-only mode.
		</p><p>
		Since <code class="computeroutput">lookup()</code> returns rows, not rowops, and knows nothing
		about the opcodes, those had to be handled separately around the lookup.
		There is a way to achieve a similar result using the streaming functions
		that returns the rowops. It will be described in
		<a class="xref" href="#sc_strf_templates" title="15.8. Streaming functions and template results">Section 15.8: &#8220;Streaming functions and template results&#8221; </a>.
		</p><p>
		The result is the same as for the first example, only the name of the
		result label differs:
		</p><pre class="programlisting"><span class="bold"><strong>acct,OP_INSERT,source1,999,1</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source1,2011,2</strong></span>
<span class="bold"><strong>acct,OP_INSERT,source2,ABCD,1</strong></span>
<span class="bold"><strong>trans,OP_INSERT,1,source1,999,100</strong></span>
lbPrint OP_INSERT id="1" acctSrc="source1" acctXtrId="999"
    amount="100" acct="1"
<span class="bold"><strong>trans,OP_INSERT,2,source2,ABCD,200</strong></span>
lbPrint OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD"
    amount="200" acct="1"
<span class="bold"><strong>trans,OP_INSERT,3,source2,QWERTY,200</strong></span>
lbPrint OP_INSERT id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200"
<span class="bold"><strong>acct,OP_INSERT,source2,QWERTY,2</strong></span>
<span class="bold"><strong>trans,OP_DELETE,3,source2,QWERTY,200</strong></span>
lbPrint OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY"
    amount="200" acct="2"
<span class="bold"><strong>acct,OP_DELETE,source1,999,1</strong></span></pre><p>
		The print label is still connected to the output label of the LookupJoin,
		but it's done purely for the convenience of its creation. Since no rowops
		get sent to the LookupJoin's input, none get to its output, and none
		get from there to the output label. Instead the main loop creates and sends the
		rowops directly to the output label when it iterates through the lookup
		results. Because of this the label name in the output is the name of
		the output label.
		</p></div><div class="sect1" title="12.6. The key fields of LookupJoin"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_lookupjoin_keys"></a>12.6. The key fields of LookupJoin</h2></div></div></div><a class="indexterm" name="id533039"></a><p>
		The key fields are the ones that participate in the join condition.
		I use these terms interchangeably because by the definition of
		LookupJoin, these fields must be the key fields in the join index
		in the right-side table. LookupJoin has a few more facilities for their
		handling that haven't been shown yet.
		</p><p>
		First, the join condition can be specified as the
		<code class="computeroutput">Triceps::Fields::filterToPairs()</code> patterns in the option
		<span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span>. The options <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span> are mutually exclusive and one of them
		must be present. The condition
		</p><pre class="programlisting">by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],</pre><p>
		can be also specified as:
		</p><pre class="programlisting">byLeft =&gt; [ "acctSrc/source", "acctXtrId/external" ],</pre><p>
		The option name <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span> says that the pattern specification is for the
		fields on the left side (there is no symmetric <span class="quote">&#8220;<span class="quote">byRight</span>&#8221;</span>). The
		substitutions produce the matching field names for the right side.
		Unlike the result pattern, here the fields that do not find a match do
		not get included in the key. It's as if an implicit <code class="computeroutput">"!.*"</code> gets added at
		the end. In fact, <code class="computeroutput">"!.*"</code> really does get added implicitly at the end.
		</p><p>
		Of course, for the example above either option doesn't make much
		difference. It starts making the difference when the key fields follow
		a pattern. For example, if the key fields on both sides have the names
		<code class="computeroutput">acctSrc</code> and <code class="computeroutput">acctXtrId</code>, the specification with the <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span>
		becomes a little simpler:
		</p><pre class="programlisting">byLeft =&gt; [ "acctSrc", "acctXtrId" ],</pre><p>
		Even more so if the key is long, common on both sides, and all the
		fields have a common prefix. Such as:
		</p><pre class="programlisting">k_AccountSystem
k_AccountId
k_InstrumentSystem
k_InstrumentId
k_TransactionDate
k_SettlementDate</pre><p>
		Then the join condition can be specified simply as:
		</p><pre class="programlisting">byLeft =&gt; [ "k_.*" ],</pre><p>
		If say the settlement date doesn't matter for a particular join, it can be excluded:
		</p><pre class="programlisting">byLeft =&gt; [ "!k_SettlementDate", "k_.*" ],</pre><p>
		If the right side represents a swap of securities, it might have two
		parts to it, each describing its half with its key:
		</p><pre class="programlisting">BorrowAccountSystem
BorrowAccountId
BorrowInstrumentSystem
BorrowInstrumentId
BorrowTransactionDate
BorrowSettlementDate
LoanAccountSystem
LoanAccountId
LoanInstrumentSystem
LoanInstrumentId
LoanTransactionDate
LoanSettlementDate</pre><p>
		Then the join of the one-sided rows with the borrow part condition can be done using:
		</p><pre class="programlisting">byLeft =&gt; [ 'k_(.*)/Borrow$1' ],</pre><p>
		The key patterns make the long keys easier to drag around.
		</p><a class="indexterm" name="id533205"></a><p>
		Second, key fields of LookupJoin don't have to be of the same type on
		the left and on the right side. Since the key building for lookup is
		done through Perl, the key values get automatically converted as
		needed. 
		</p><p>
		A caveat is that the conversion might be not exactly direct. If a
		string gets converted to a number, then any string values that do not
		look like numbers will be converted to 0. A conversion between a string
		and a floating-point number, in either direction, is likely to lose
		precision. A conversion between int64 and int32 may cause the upper
		bits to be truncated. So what gets looked up may be not what you
		expect.
		</p><p>
		I'm not sure yet if I should add the requirement for the types being
		exactly the same. The automatic conversions seem to be convenient, just
		use them with care. I suppose, when the joins will get eventually
		implemented in the C++ code, this freedom would go away because it's
		much easier and more efficient in C++ to copy the field values as-is
		than to convert them.
		</p><p>
		The only thing currently checked is whether a field is represented in
		Perl as a scalar or an array, and that must match on the left and on
		the right. Note that the array <code class="computeroutput">uint8[]</code> gets represented in Perl as a
		scalar string, so an <code class="computeroutput">uint8[]</code> field can be matched with other scalars
		but not with the other arrays.
		</p><a class="indexterm" name="id533256"></a><p>
		Third, the key fields have the problem of duplication. The LookupJoin is
		by definition an equi-join, it joins together the rows that have the
		same values in a set of key fields. If all the fields from both sides
		are to be included in the result, they key values will be present in it
		twice, once from the left side, once from the right side. This is not
		what is usually wanted, and the good practice is to let these fields
		through from one side and filter out from the other side.
		</p><p>
		Letting these fields through on the left side is usually the better
		choice. For the inner joins it doesn't really matter but for the
		left outer joins it works much better than the with letting through
		the fields from the right side. The reason is that when the join
		doesn't find the match on the right side, all the right-side
		fields will be NULL. If you pass through the key fields only from the
		right side, they will contain NULL, and this is probably not what
		you want.
		</p><p>
		However if for some reason, be it the order of the fields or the
		better field types on the right side, you really want to pass the
		key fields only from the right side, you can. LookupJoin provides
		a special magic act enabled by the option
		</p><pre class="programlisting">  fieldsMirrorKey =&gt; 1</pre><p>
		Then if the row is not found on the right side, a special right-side
		row will be created with the key fields copied from the left side,
		and it will be used to produce the result row. With
		<span class="quote">&#8220;<span class="quote">fieldsMirrorKey</span>&#8221;</span> you are guaranteed to always have the
		key values present on the right side.
		</p></div><div class="sect1" title="12.7. A peek inside LookupJoin"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_lookupjoin_inside"></a>12.7. A peek inside LookupJoin</h2></div></div></div><a class="indexterm" name="id533316"></a><p>
		I won't be describing in the details the internals of LookupJoin. They
		seem a bit too big and complicated. Partially it's because the code is
		of an older origin, and not using all the newer calls. Partially it's
		because when I wrote it, I've tried to optimize by translating the rows
		to an array format instead of referring to the fields by names, and
		that made the code more tricky. Partially, the code has grown more
		complex due to all the added options. And partially the functionality
		just is a little tricky by itself.
		</p><p>
		But, for debugging purposes, the LookupJoin constructor can return the
		auto-generated code of the joiner function. It's done with the option
		<span class="quote">&#8220;<span class="quote">saveJoinerTo</span>&#8221;</span>:
		</p><pre class="programlisting">  saveJoinerTo =&gt; \$code,</pre><p>
		This will cause the auto-generated code to be placed into the variable
		<code class="computeroutput">$code</code>. I've collected a few such examples in this section.
		They provide a glimpse into the internal workings of the
		joiner. It's definitely a quite advanced topic, but it's helpful if you
		want to know, what is really going on in there.
		</p><p>
		The joiner code from the example
		</p><pre class="programlisting">our $join = Triceps::LookupJoin-&gt;new(
  unit =&gt; $uJoin,
  name =&gt; "join",
  leftRowType =&gt; $rtInTrans,
  rightTable =&gt; $tAccounts,
  rightIdxPath =&gt; ["lookupSrcExt"],
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
  isLeft =&gt; 1,
); # would confess by itself on an error</pre><p>
		that was shown first in the
		<a class="xref" href="#sc_joins_lookupjoin" title="12.4. The LookupJoin template">Section 12.4: &#8220;The LookupJoin template&#8221; </a>
		is this:
		</p><pre class="programlisting">sub # ($inLabel, $rowop, $self)
{
  my ($inLabel, $rowop, $self) = @_;
  #print STDERR "DEBUGX LookupJoin " . $self-&gt;{name} . " in: ", $rowop-&gt;printP(), "\n";

  my $opcode = $rowop-&gt;getOpcode(); # pass the opcode
  my $row = $rowop-&gt;getRow();

  my @leftdata = $row-&gt;toArray();

  my $resRowType = $self-&gt;{resultRowType};
  my $resLabel = $self-&gt;{outputLabel};

  my $lookuprow = $self-&gt;{rightRowType}-&gt;makeRowHash(
    "source" =&gt; $leftdata[1],
    "external" =&gt; $leftdata[2],
    );

  #print STDERR "DEBUGX " . $self-&gt;{name} . " lookup: ", $lookuprow-&gt;printP(), "\n";
  my $rh = $self-&gt;{rightTable}-&gt;findIdx($self-&gt;{rightIdxType}, $lookuprow);

  my @rightdata; # fields from the right side, defaults to all-undef, if no data found
  my @result; # the result rows will be collected here

  if (!$rh-&gt;isNull()) {
    #print STDERR "DEBUGX " . $self-&gt;{name} . " found data: " . $rh-&gt;getRow()-&gt;printP() . "\n";
    @rightdata = $rh-&gt;getRow()-&gt;toArray();
  }

    my @resdata = ($leftdata[0],
    $leftdata[1],
    $leftdata[2],
    $leftdata[3],
    $rightdata[2],
    );
    my $resrowop = $resLabel-&gt;makeRowop($opcode, $resRowType-&gt;makeRowArray(@resdata));
    #print STDERR "DEBUGX " . $self-&gt;{name} . " +out: ", $resrowop-&gt;printP(), "\n";
    $resLabel-&gt;getUnit()-&gt;call($resrowop);

}</pre><p>
		From the example with the manual iteration:
		</p><pre class="programlisting">our $join = Triceps::LookupJoin-&gt;new(
  unit =&gt; $uJoin,
  name =&gt; "join",
  leftRowType =&gt; $rtInTrans,
  rightTable =&gt; $tAccounts,
  rightIdxPath =&gt; ["lookupSrcExt"],
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
  automatic =&gt; 0,
); # would confess by itself on an error</pre><p>
		comes this code:
		</p><pre class="programlisting">sub  # ($self, $row)
{
  my ($self, $row) = @_;

  #print STDERR "DEBUGX LookupJoin " . $self-&gt;{name} . " in: ", $row-&gt;printP(), "\n";

  my @leftdata = $row-&gt;toArray();

  my $lookuprow = $self-&gt;{rightRowType}-&gt;makeRowHash(
    "source" =&gt; $leftdata[1],
    "external" =&gt; $leftdata[2],
    );

  #print STDERR "DEBUGX " . $self-&gt;{name} . " lookup: ", $lookuprow-&gt;printP(), "\n";
  my $rh = $self-&gt;{rightTable}-&gt;findIdx($self-&gt;{rightIdxType}, $lookuprow);

  my @rightdata; # fields from the right side, defaults to all-undef, if no data found
  my @result; # the result rows will be collected here

  if (!$rh-&gt;isNull()) {
    #print STDERR "DEBUGX " . $self-&gt;{name} . " found data: " . $rh-&gt;getRow()-&gt;printP() . "\n";
    @rightdata = $rh-&gt;getRow()-&gt;toArray();
  }

    my @resdata = ($leftdata[0],
    $leftdata[1],
    $leftdata[2],
    $leftdata[3],
    $rightdata[2],
    );
    push @result, $self-&gt;{resultRowType}-&gt;makeRowArray(@resdata);
    #print STDERR "DEBUGX " . $self-&gt;{name} . " +out: ", $result[$#result]-&gt;printP(), "\n";
  return @result;
}</pre><p>
		It takes different arguments because now it's not an input label handler
		but a common function that gets called from both the label handler and the
		<code class="computeroutput">lookup()</code> method. And it collects the rows in an array to be returned
		instead of immediately passing them on.
		</p><p>
		From the example with multiple rows matching on the right side
		</p><pre class="programlisting">our $join = Triceps::LookupJoin-&gt;new(
  unit =&gt; $uJoin,
  name =&gt; "join",
  leftRowType =&gt; $rtInTrans,
  rightTable =&gt; $tAccounts,
  rightIdxPath =&gt; [ "iterateSrc", "lookupSrcExt" ],
  rightFields =&gt; [ "internal/acct" ],
  by =&gt; [ "acctSrc" =&gt; "source", "acctXtrId" =&gt; "external" ],
); # would confess by itself on an error</pre><p>
		comes this code:
		</p><pre class="programlisting">sub # ($inLabel, $rowop, $self)
{
  my ($inLabel, $rowop, $self) = @_;
  #print STDERR "DEBUGX LookupJoin " . $self-&gt;{name} . " in: ", $rowop-&gt;printP(), "\n";

  my $opcode = $rowop-&gt;getOpcode(); # pass the opcode
  my $row = $rowop-&gt;getRow();

  my @leftdata = $row-&gt;toArray();

  my $resRowType = $self-&gt;{resultRowType};
  my $resLabel = $self-&gt;{outputLabel};

  my $lookuprow = $self-&gt;{rightRowType}-&gt;makeRowHash(
    "source" =&gt; $leftdata[1],
    "external" =&gt; $leftdata[2],
    );

  #print STDERR "DEBUGX " . $self-&gt;{name} . " lookup: ", $lookuprow-&gt;printP(), "\n";
  my $rh = $self-&gt;{rightTable}-&gt;findIdx($self-&gt;{rightIdxType}, $lookuprow);

  my @rightdata; # fields from the right side, defaults to all-undef, if no data found
  my @result; # the result rows will be collected here

  if ($rh-&gt;isNull()) {
    #print STDERR "DEBUGX " . $self-&gt;{name} . " found NULL\n";

    my @resdata = ($leftdata[0],
    $leftdata[1],
    $leftdata[2],
    $leftdata[3],
    $rightdata[2],
    );
    my $resrowop = $resLabel-&gt;makeRowop($opcode, $resRowType-&gt;makeRowArray(@resdata));
    #print STDERR "DEBUGX " . $self-&gt;{name} . " +out: ", $resrowop-&gt;printP(), "\n";
    $resLabel-&gt;getUnit()-&gt;call($resrowop);

  } else {
    #print STDERR "DEBUGX " . $self-&gt;{name} . " found data: " . $rh-&gt;getRow()-&gt;printP() . "\n";
    my $endrh = $self-&gt;{rightTable}-&gt;nextGroupIdx($self-&gt;{iterIdxType}, $rh);
    for (; !$rh-&gt;same($endrh); $rh = $self-&gt;{rightTable}-&gt;nextIdx($self-&gt;{rightIdxType}, $rh)) {
      @rightdata = $rh-&gt;getRow()-&gt;toArray();
    my @resdata = ($leftdata[0],
    $leftdata[1],
    $leftdata[2],
    $leftdata[3],
    $rightdata[2],
    );
    my $resrowop = $resLabel-&gt;makeRowop($opcode, $resRowType-&gt;makeRowArray(@resdata));
    #print STDERR "DEBUGX " . $self-&gt;{name} . " +out: ", $resrowop-&gt;printP(), "\n";
    $resLabel-&gt;getUnit()-&gt;call($resrowop);

    }
  }
}</pre><p>
		It's more complicated in two ways: If a match is found, it has to
		iterate through the whole matching group. And if the match is not
		found, it still has to produce a result row for the left join with a
		separate code fragment.
		</p></div><div class="sect1" title="12.8. JoinTwo joins two tables"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_jointwo"></a>12.8. JoinTwo joins two tables</h2></div></div></div><a class="indexterm" name="id533514"></a><a class="indexterm" name="id533524"></a><p>
		Fundamentally, joining the two tables is kind of like the two
		symmetrical copies of LookupJoin, each of them reacting to the
		changes in one table and doing look-ups in another table. 
		For all I can tell, the CEP systems with the insert-only stream model
		tend to start with the assumption that the LookupJoin (or whetever they
		call it) is good enough. Then it turns out that manually writing the
		join twice where it can be done once is a pain. So the table-to-table
		join gets added. Then the interesting nuances crop up, since a correct
		table-to-table join has more to it than just two stream-to-table
		joins.  Then it turns
		out that it would be real convenient to propagate the deletes through
		the join, and that gets added as a special feature behind the scenes.
		</p><p>
		In Triceps, JoinTwo is the template for joining the tables. And actually
		it is translated under the hood to two LookupJoins, but it has
		more on top of them.
		</p><p>
		In a common
		database a join query causes a join plan to be created: on what table
		to iterate, and in which to look up next. A CEP system deals with the
		changing data, and a join has to react to the data changes on each of its
		input tables. It must have multiple plans, one for starting from each
		of the tables. And essentially a LookupJoin embodies such a plan, and
		JoinTwo makes two of them.
		</p><p>
		Why only two? Because it's the minimal usable number. The join logic is
		tricky, so it's better to work out the kinks on something simpler first. And
		it still can be scaled to many tables by joining them in stages. It's
		not quite as efficient as a direct join of multiple tables, because the
		result of each stage has to be put into a table, but it does the job.
		</p><p>
		I'll be doing the demonstrations of the table joins on an application
		example from the area of stock lending. Think of a large multinational
		broker that wants to keep track of its lending activities. It has many
		customers to whom the stock can be loaned or from whom it can be
		borrowed. This information comes as the records of positions, of how
		many shares are loaned or borrowed for each customer, and at what
		contractual price. And since the clients are from all around the world,
		the prices may be in different currencies. A simplified and much
		shortened version of the position information may look like this:
		</p><pre class="programlisting">our $rtPosition = Triceps::RowType-&gt;new( # a customer account position
  date =&gt; "int32", # as of which date, in format YYYYMMDD
  customer =&gt; "string", # customer account id
  symbol =&gt; "string", # stock symbol
  quantity =&gt; "float64", # number of shares
  price =&gt; "float64", # share price in local currency
  currency =&gt; "string", # currency code of the price
);</pre><p>
		Then we want to aggregate these data in different ways, getting the
		broker-wide summaries by the symbol, by customer etc. The aggregation
		is updated as the business day goes on. At the end of the business day
		the state of the day freezes, and the new day's initial data is loaded.
		That's why the business date is part of the schema. If you wonder, the
		next day's initial data is usually the same as at the end of the
		previous day, except where some contractual conditions change. The
		detailed position data is thrown away after a few days, or even right
		at the end of the day, but the aggregation results from the end of the
		day are kept for a longer history.
		</p><p>
		There is a problem with summing up the monetary values: they come in
		different currencies and can not be added up directly. If we want to
		get this kind of summaries, we have to translate all of them to a
		single reference currency. That's what the sample joins will be doing:
		finding the translation rates to the US dollars. The currency rates
		come in the translation schema:
		</p><pre class="programlisting">our $rtToUsd = Triceps::RowType-&gt;new( # a currency conversion to USD
  date =&gt; "int32", # as of which date, in format YYYYMMDD
  currency =&gt; "string", # currency code
  toUsd =&gt; "float64", # multiplier to convert this currency to USD
);</pre><p>
		Since the currency rates change all the time, to make sense of a
		previous day's position, the previous day's rates need to be kept around,
		and so the rates are also marked with a date.
		</p><p>
		Having the mood set, here is the first example of a model with an inner
		join:
		</p><pre class="programlisting"># exchange rates, to convert all currencies to USD
our $ttToUsd = Triceps::TableType-&gt;new($rtToUsd)
  -&gt;addSubIndex("primary",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date", "currency" ])
  )
  -&gt;addSubIndex("byDate", # for cleaning by date
    Triceps::SimpleOrderedIndex-&gt;new(date =&gt; "ASC")
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
;
$ttToUsd-&gt;initialize();

# the positions in the original currency
our $ttPosition = Triceps::TableType-&gt;new($rtPosition)
  -&gt;addSubIndex("primary",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date", "customer", "symbol" ])
  )
  -&gt;addSubIndex("currencyLookup", # for joining with currency conversion
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date", "currency" ])
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
  -&gt;addSubIndex("byDate", # for cleaning by date
    Triceps::SimpleOrderedIndex-&gt;new(date =&gt; "ASC")
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
;
$ttPosition-&gt;initialize();

our $uJoin = Triceps::Unit-&gt;new("uJoin");

our $tToUsd = $uJoin-&gt;makeTable($ttToUsd, "tToUsd");
our $tPosition = $uJoin-&gt;makeTable($ttPosition, "tPosition");

our $join = Triceps::JoinTwo-&gt;new(
  name =&gt; "join",
  leftTable =&gt; $tPosition,
  rightTable =&gt; $tToUsd,
  byLeft =&gt; [ "date", "currency" ],
  type =&gt; "inner",
); # would confess by itself on an error

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $join-&gt;getOutputLabel());

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "cur") {
    $uJoin-&gt;makeArrayCall($tToUsd-&gt;getInputLabel(), @data);
  } elsif ($type eq "pos") {
    $uJoin-&gt;makeArrayCall($tPosition-&gt;getInputLabel(), @data);
  }
  $uJoin-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		The example just does the joining, leaving the aggregation to the
		imagination of the reader. The result of a JoinTwo is not stored in a
		table. It is a stream of ephemeral updates, same as for LookupJoin. If
		you want to keep them, you can put them into a table yourself (and
		maybe do the aggregation in the same table).
		</p><p>
		Both of the joined tables must provide a Hashed index for the efficient
		joining. In this case it will be <span class="quote">&#8220;<span class="quote">currencyLookup</span>&#8221;</span> on the left and
		<span class="quote">&#8220;<span class="quote">primary</span>&#8221;</span> on the right, found automatically by the key fields.
		The index may be leaf (selecting one row per key) or non-leaf
		(containing multiple rows per key) but it must be there. This makes
		sure that the joins are always efficient and you don't have to hunt for
		why your model is suddenly so slow.
		</p><a class="indexterm" name="id533667"></a><p>
		There are two ways to provide the join condition: either specify
		it explicitly in the option <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span>,
		or specify the indexes in both tables and have the key fields in them
		paired together. Or you can specify both, as long as the information stays consistent.
		For example, the join in this example could also be written as:
		</p><pre class="programlisting">our $join = Triceps::JoinTwo-&gt;new(
  name =&gt; "join",
  leftTable =&gt; $tPosition,
  leftIdxPath =&gt; [ "currencyLookup" ],
  rightTable =&gt; $tToUsd,
  rightIdxPath =&gt; [ "primary" ],
  type =&gt; "inner",
); # would confess by itself on an error</pre><p>
		When the key fields in the indexes are paired up together, it's done
		in the order they go in the index specifications. Once again, the fields are paired not
		by name but by order. If the indexes are nested, the outer indexes
		precede in the order. For example, the <code class="computeroutput">$ttToUsd</code> could have the same
		index done in a nested way and it would work just as well:
		</p><pre class="programlisting">  -&gt;addSubIndex("byDate",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date" ])
    -&gt;addSubIndex("primary",
      Triceps::IndexType-&gt;newHashed(key =&gt; [ "currency" ])
    )
  )</pre><a class="indexterm" name="id533725"></a><p>
		Same as with LookupJoin, currently only the Hashed indexes are
		supported, and must go through all the path. The outer index <span class="quote">&#8220;<span class="quote">byDate</span>&#8221;</span>
		here can not be a Sorted/Ordered index, that would be an error and the
		join will refuse to accept it.
		</p><p>
		If the order of key fields in the <code class="computeroutput">$ttToUsd</code> index were
		changed to be different from <code class="computeroutput">$ttPosition</code>, like this
		</p><pre class="programlisting">  -&gt;addSubIndex("primary",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "currency", "date" ])
  )</pre><p>
		then it would be a mess for the automatic pairing by index.
		The wrong fields would be matched up in the
		join condition, which would become 
		<code class="computeroutput">(tPosition.date == tToUsd.currency &amp;&amp; tPosition.currency == tToUsd.date)</code>, 
		and everything would go horribly wrong.
		It would be no problem at all for selecting the pairing explicitly
		with the <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> options and letting the join find the
		index, which is the recommended way.
		</p><a class="indexterm" name="id533786"></a><p>
		JoinTwo is much less lenient than LookupJoin as the key field
		types go. It requires the types of the matching fields to be exactly
		the same. Partially, for the reasons of catching the wrong field pairing by order,
		partially for the sake of the result consistency. JoinTwo does the
		look-ups in both directions. And think about what happens if a string field
		and an int32 field get matched up, and then the non-numeric strings
		turn up in the string field, containing things like 
		<span class="quote">&#8220;<span class="quote">abc</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">qwerty</span>&#8221;</span>. Those strings on the left side
		will match the rows with numeric 0 on the right side. But then if the
		row with 0 on the right side changes, it would look for the string <span class="quote">&#8220;<span class="quote">0</span>&#8221;</span>
		on the left, which would not find either <span class="quote">&#8220;<span class="quote">abc</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">qwerty</span>&#8221;</span>. The state
		of the join will become a mess. So no automatic key type conversions
		here.
		</p><p>
		By the way, even though JoinTwo doesn't refuse to have the float64 key
		fields, using them is a bad idea. The floating-point values are subject
		to non-obvious rounding. And if you have two floating-point values that
		print the same, this doesn't mean that they are internally the same
		down to the last bit (because the printing involves the conversion to
		decimal that involves rounding). The joining requires that the values
		are exactly equal. Because of this the joining on a floating-point
		field is rife with unpleasant surprises. Better don't do it. A possible
		solution is to round values by converting them to integers (scaled by
		multiplying by a fixed factor to get essentially a fixed-point value).
		You can even convert them back from fixed-point to floating-point and
		still join on these floating-point values, because the same values
		would always be produced from integers in exactly the same way, and
		will be exactly the same.
		</p><p>
		More of the JoinTwo options closely parallel those in LookupJoin.
		Obviously, <span class="quote">&#8220;<span class="quote">name</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">rightTable</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">rightIdxPath</span>&#8221;</span> are the same, with
		the added symmetrical <span class="quote">&#8220;<span class="quote">leftTable</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">leftIdxPath</span>&#8221;</span>. There is no <span class="quote">&#8220;<span class="quote">unit</span>&#8221;</span>
		option though, the unit is always taken from the tables (which must
		belong to the same unit).
		The option to save the source code of the generated joiner code has
		been split in two: <span class="quote">&#8220;<span class="quote">leftSaveJoinerTo</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">rightSaveJoinerTo</span>&#8221;</span>. Since
		JoinTwo has to react to the updates from both sides, is has to have two
		handlers. And since internally it uses two LookupJoin for this purpose,
		these happen to be the joiner functions of the left and right
		LookupJoin.
		</p><a class="indexterm" name="id533877"></a><p>
		The option <span class="quote">&#8220;<span class="quote">type</span>&#8221;</span> selects the join mode. The inner join is the
		default, and would have been used even if this option was not
		specified.
		</p><a class="indexterm" name="id533898"></a><p>
		The options controlling the result are also the same as in LookupJoin: <span class="quote">&#8220;<span class="quote">leftFields</span>&#8221;</span>,
		<span class="quote">&#8220;<span class="quote">rightFields</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">fieldsLeftFirst</span>&#8221;</span>. There is
		no option <span class="quote">&#8220;<span class="quote">fieldsDropRightKey</span>&#8221;</span>,
		JoinTwo always excludes the duplicate key fields automatically.
		The results in this example include all the fields from both sides by default.
		</p><p>
		The joins are currently not equipped to actually compute the translated
		prices directly. They can only look up the information for it, and the
		computation can be done later, before or during the aggregation.
		</p><p>
		That's enough explanations for now, let's look at the result. The
		input rows are shown as usual in bold, and to make keeping track easier,
		I broke up the output into short snippets with commentary after each one.
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_INSERT,20120310,USD,1</strong></span>
<span class="bold"><strong>cur,OP_INSERT,20120310,GBP,2</strong></span>
<span class="bold"><strong>cur,OP_INSERT,20120310,EUR,1.5</strong></span></pre><p>
		Inserting the reference currencies produces no result, since it's an
		inner join and they have no matching positions yet.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_INSERT,20120310,one,AAA,100,15,USD</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="one"
    symbol="AAA" quantity="100" price="15" currency="USD" toUsd="1"
<span class="bold"><strong>pos,OP_INSERT,20120310,two,AAA,100,8,GBP</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2"</pre><p>
		Now the positions arrive and find the matching translations to USD. The
		label names on the output are an interesting artifact of all the
		chained labels receiving the original rowop that refers to the first
		label in the chain. Which happens to be the output label of a
		LookupJoin inside JoinTwo. It works conveniently for the
		demonstrational purposes, since the name of that LookupJoin shows whether
		the row that triggered the result came from the left or right side of
		the JoinTwo.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_INSERT,20120310,three,AAA,100,300,RUR</strong></span></pre><p>
		This position is out of luck: no translation for its currency. The
		inner join is actually not a good choice here. If a row does not pass
		through because of the lack of translation, it gets excluded even from
		the aggregations that do not require the translation, such as those
		that total up the quantity of a particular symbol across all the
		customers. A left outer join would have been suited better.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_INSERT,20120310,three,BBB,200,80,GBP</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2"</pre><p>
		Another position arrives, same as before.
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_INSERT,20120310,RUR,0.04</strong></span>
join.rightLookup.out OP_INSERT date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"
    toUsd="0.04"</pre><p>
		The translation for RUR finally comes in. The position in RUR can now
		find its match and propagate through.
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_DELETE,20120310,GBP,2</strong></span>
join.rightLookup.out OP_DELETE date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2"
join.rightLookup.out OP_DELETE date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2"
<span class="bold"><strong>cur,OP_INSERT,20120310,GBP,2.2</strong></span>
join.rightLookup.out OP_INSERT date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2.2"
join.rightLookup.out OP_INSERT date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2.2"</pre><p>
		An exchange rate update for GBP arrives. It amounts to <span class="quote">&#8220;<span class="quote">delete the old
		translation and then insert a new one</span>&#8221;</span>. Each of these operations
		updates the state of the join: the disappearing translation causes all
		the GBP positions to be deleted from the result, and the new
		translation inserts them back, with the new value of toUsd.
		Which is the correct behavior: to make an up date to the result
		positions, they have to be deleted and then inserted witn the new values.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_DELETE,20120310,one,AAA,100,15,USD</strong></span>
join.leftLookup.out OP_DELETE date="20120310" customer="one"
    symbol="AAA" quantity="100" price="15" currency="USD" toUsd="1"
<span class="bold"><strong>pos,OP_INSERT,20120310,one,AAA,200,16,USD</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="one"
    symbol="AAA" quantity="200" price="16" currency="USD" toUsd="1"</pre><p>
		A position update arrives. Again, it's a delete-and-insert, and
		propagates through the join as such.
		</p><p>
		That's the end of the first example. The commentary said that the
		left outer join would have been better for the logic, so let's make
		one for the left outer join.  All we need to change is the join type option:
		</p><a class="indexterm" name="id534730"></a><pre class="programlisting">our $join = Triceps::JoinTwo-&gt;new(
  name =&gt; "join",
  leftTable =&gt; $tPosition,
  rightTable =&gt; $tToUsd,
  byLeft =&gt; [ "date", "currency" ],
  type =&gt; "left",
); # would confess by itself on an error</pre><p>
		Now the positions would pass through even if the currency translation
		is not available. The same input now produces a different result:
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_INSERT,20120310,USD,1</strong></span>
<span class="bold"><strong>cur,OP_INSERT,20120310,GBP,2</strong></span>
<span class="bold"><strong>cur,OP_INSERT,20120310,EUR,1.5</strong></span>
<span class="bold"><strong>pos,OP_INSERT,20120310,one,AAA,100,15,USD</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="one"
    symbol="AAA" quantity="100" price="15" currency="USD" toUsd="1"
<span class="bold"><strong>pos,OP_INSERT,20120310,two,AAA,100,8,GBP</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2"</pre><p>
		So far things are going the same as for the inner join.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_INSERT,20120310,three,AAA,100,300,RUR</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"</pre><p>
		The first difference: even though there is no translation for RUR, the
		row still passes through (with the field <code class="computeroutput">toUsd</code> being NULL).
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_INSERT,20120310,three,BBB,200,80,GBP</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2"</pre><p>
		This is also unchanged.
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_INSERT,20120310,RUR,0.04</strong></span>
join.rightLookup.out OP_DELETE date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"
join.rightLookup.out OP_INSERT date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"
    toUsd="0.04"</pre><p>
		The second difference: since this row from the left side has already
		passed through, just sending another INSERT for it would make the data
		inconsistent. The original result without the translation must be
		deleted first, and then a new one, with translation, inserted. JoinTwo
		is smart enough to figure it out all by itself.
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_DELETE,20120310,GBP,2</strong></span>
join.rightLookup.out OP_DELETE date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2"
join.rightLookup.out OP_INSERT date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP"
join.rightLookup.out OP_DELETE date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2"
join.rightLookup.out OP_INSERT date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP"</pre><p>
		The same logic works for the deletes, only backwards: when the
		translation for GBP is deleted, the result rows that used it change to
		the lose the translation.
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_INSERT,20120310,GBP,2.2</strong></span>
join.rightLookup.out OP_DELETE date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP"
join.rightLookup.out OP_INSERT date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2.2"
join.rightLookup.out OP_DELETE date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP"
join.rightLookup.out OP_INSERT date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2.2"</pre><p>
		And again, when the new translation for GBP comes in, the DELETE-INSERT
		sequence is done for each of the rows. As you can see, the update of
		the GBP translation in the last two snippets worked in not the most efficient way.
		Fundamentally, if we knew that a DELETE of GBP will be immediately
		followed by an INSERT, we could skip inserting and then deleting the
		rows with the NULL in <code class="computeroutput">toUsd</code>. But we don't know, and in Triceps there is
		no way to know it.
		</p><a class="indexterm" name="id534918"></a><a class="indexterm" name="id534931"></a><p>
		If you really, really want to avoid the propagation of these
		intermediate changes, insert after the join a Collapse template described in 
		<a class="xref" href="#sc_other_collapse" title="14.2. Collapsed updates">Section 14.2: &#8220;Collapsed updates&#8221; </a>,
		and flush it only
		after the whole update has been processed. There will be more overhead
		in the Collapse itself, but all the logic below it will skip the
		intermediate changes. If this logic below is heavy-weight, that might
		be an overall win. A caveat though: a Collapse requires that the data
		has a primary key, a JoinTwo doesn't require its result (nor its
		inputs) to have a primary key. Because of this, the collapse might not
		work right with every possible join, you'd have to limit yourself to
		the joins that produce the data with a primary key.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_DELETE,20120310,one,AAA,100,15,USD</strong></span>
join.leftLookup.out OP_DELETE date="20120310" customer="one"
    symbol="AAA" quantity="100" price="15" currency="USD" toUsd="1"
<span class="bold"><strong>pos,OP_INSERT,20120310,one,AAA,200,16,USD</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="one"
    symbol="AAA" quantity="200" price="16" currency="USD" toUsd="1"</pre><p>
		And the rest is again the same as with an inner join.
		</p><a class="indexterm" name="id534986"></a><p>
		JoinTwo can do a right outer join too, just use the type <span class="quote">&#8220;<span class="quote">right</span>&#8221;</span>. It
		works in exactly the same way as the left outer join, just with a
		different table. So much the same that it's not even worth a separate
		example.
		</p><a class="indexterm" name="id535008"></a><a class="indexterm" name="id535022"></a><a class="indexterm" name="id535031"></a><p>
		Now, the full outer join. 
		The full outer joins usually
		get used with a variation of the <span class="quote">&#8220;<span class="quote">fork-join</span>&#8221;</span> topology described in the
		<a class="xref" href="#sc_other_diamond" title="14.1. The dreaded diamond">Section 14.1: &#8220;The dreaded diamond&#8221; </a>.
		In it the processing of a row can be forked into
		multiple parallel paths, each path doing an optional part of the
		comuptation and either providing a result row or not,
		eventually with all the parts merged back together into one row. 
		The full outer join is a convenient
		way to do this merge: the paths that didn't produce the result get
		quietly ignored, and the results that were produced get merged back
		into a single row. The row in such situations is usually identified by
		a primary key, so the partial results can find each other. This scheme
		makes the most sense when the paths are executed in the parallel
		threads, or when the processing on some paths may get delayed and then
		continued later. If the processing is single-threaded and fast, Triceps
		provides a more convenient procedural way of getting the same result:
		just call every path in order and merge the results from them
		procedurally, and you won't have to keep the intermediate results in
		their tables forever, nor delete them manually.
		</p><p>
		Even though that use is typical, it has only the 1:1 record matching
		and does not highlight all the abilities of the JoinTwo. So, let's come
		up with another example that does.
		</p><p>
		The positions-and-currencies do not lend itself easily to 
		a full outer join but we'll make them do.  Suppose that you want to get the total count of
		positions (per symbol, or altogether), or maybe the total value, for
		every currency. Including those for which we have the exchange rates
		but no positions, for them the count should simply be 0 (or maybe
		NULL). And those for which there are positions but no exchange rate translations.
		This is a job for a full outer join, followed by an aggregation. The
		join has the type <span class="quote">&#8220;<span class="quote">outer</span>&#8221;</span> and looks like this:
		</p><pre class="programlisting">our $join = Triceps::JoinTwo-&gt;new(
  name =&gt; "join",
  leftTable =&gt; $tPosition,
  rightTable =&gt; $tToUsd,
  byLeft =&gt; [ "date", "currency" ],
  type =&gt; "outer",
); # would confess by itself on an error</pre><p>
		As before, the aggregation part will be left to the
		imagination of the reader. 
		This join has the many-to-one (M:1) row matching, since there might be
		multiple positions on the left matching one currency rate translation
		on the right. This will create interesting effects in the output,
		let's look at it:
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_INSERT,20120310,GBP,2</strong></span>
join.rightLookup.out OP_INSERT date="20120310" currency="GBP"
    toUsd="2"</pre><p>
		The first translation gets through, even though there is no position for it yet.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_INSERT,20120310,two,AAA,100,8,GBP</strong></span>
join.leftLookup.out OP_DELETE date="20120310" currency="GBP" toUsd="2"
join.leftLookup.out OP_INSERT date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2"</pre><p>
		The first position for an existing translation comes in. Now the GBP
		row has a match, so the unmatched row gets deleted and a matched one
		gets inserted instead.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_INSERT,20120310,three,BBB,200,80,GBP</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2"</pre><p>
		The second position for GBP works differently: since there is no
		unmatched row any more (it was taken care of by the first position),
		there is nothing to delete. Just the second matched row gets
		inserted. 
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_INSERT,20120310,three,AAA,100,300,RUR</strong></span>
join.leftLookup.out OP_INSERT date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"</pre><p>
		The position without a matching currency get through as well.
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_INSERT,20120310,RUR,0.04</strong></span>
join.rightLookup.out OP_DELETE date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"
join.rightLookup.out OP_INSERT date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"
    toUsd="0.04"</pre><p>
		Now the RUR translation becomes available and it has to do the same
		things as we've seen before, only on the other side: delete the
		unmatched record and replace it with the matched one.
		</p><pre class="programlisting"><span class="bold"><strong>cur,OP_DELETE,20120310,GBP,2</strong></span>
join.rightLookup.out OP_DELETE date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2"
join.rightLookup.out OP_INSERT date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP"
join.rightLookup.out OP_DELETE date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2"
join.rightLookup.out OP_INSERT date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP"
<span class="bold"><strong>cur,OP_INSERT,20120310,GBP,2.2</strong></span>
join.rightLookup.out OP_DELETE date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP"
join.rightLookup.out OP_INSERT date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2.2"
join.rightLookup.out OP_DELETE date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP"
join.rightLookup.out OP_INSERT date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2.2"</pre><p>
		Then the GBP translation gets updated. First the old translation gets
		deleted and then the new one inserted. When the translation gets
		deleted, all the positions in GBP lose their match. So the matched rows
		gets deleted and replaced with the unmatched ones. When the new GBP
		translation is inserted, the replacement goes in the other
		direction.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_DELETE,20120310,three,BBB,200,80,GBP</strong></span>
join.leftLookup.out OP_DELETE date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2.2"</pre><p>
		When this position goes away, the row gets deleted from the result as
		well. However it was not the only position in GBP, so there is no need
		to insert an unmatched record for GBP.
		</p><pre class="programlisting"><span class="bold"><strong>pos,OP_DELETE,20120310,three,AAA,100,300,RUR</strong></span>
join.leftLookup.out OP_DELETE date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"
    toUsd="0.04"
join.leftLookup.out OP_INSERT date="20120310" currency="RUR"
    toUsd="0.04"</pre><p>
		This position was the last one in RUR. So when it gets deleted, the RUR
		translation has no match any more. That means, after deleting the
		matched row from the results, the unmatched row has to be
		inserted to keep the balance right.
		</p><a class="indexterm" name="id535269"></a><p>
		This business with keeping track of the unmatched rows is
		not unique to the full outer joins. Remember, it was showing in the
		left outer joins too, and the right outer joins are no exception
		either. When the first matching row gets inserted or the last matching
		row gets deleted on the side that is opposite to the "outer side", the
		unmatched rows have to be handled in the result. (That would be the
		right side for the left outer joins, the left side for the right outer
		joins, and either side for the full outer joins).
		The special thing about the M:1 (and 1:M and M:M) joins is that
		there may be more than one matching row.
		On insertion, the second and following matching rows produce a different 
		effect than the first one. On deletion, the opposite: all the
		rows but the last work differently from the last one.
		It's not limited to the full outer joins. M:1 or M:M with a right outer
		join, and 1:M or M:M with a left outer join will do it too.
		</p><p>
		If you're like me, by now you'd be wondering, how does it work? If the
		<span class="quote">&#8220;<span class="quote">opposite side</span>&#8221;</span> is of <span class="quote">&#8220;<span class="quote">one</span>&#8221;</span> variety (:1 or 1:), which can be known from
		it using a leaf index for the join, then every insert is the first
		insert of a matching row for this key, and every delete is the delete
		of the last row for this key. Which means, do the empty-match business
		every time.
		</p><p>
		If the <span class="quote">&#8220;<span class="quote">opposite side</span>&#8221;</span> is of the <span class="quote">&#8220;<span class="quote">many</span>&#8221;</span> variety (:M or M:), with a
		non-leaf index, then things get more complicated. The join works by
		processing the rowops coming out of the argument tables. When it gets
		the rowop in such a situation, it goes to the table and checks, was it
		the first (or last) row for this key? And then uses this knowledge to
		act.
		</p></div><div class="sect1" title="12.9. The key field duplication in JoinTwo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_jointwo_keys"></a>12.9. The key field duplication in JoinTwo</h2></div></div></div><a class="indexterm" name="id535332"></a><p>
		JoinTwo in its raw form has the same problem of the key field duplication
		as LookupJoin (described in
		<a class="xref" href="#sc_joins_lookupjoin_keys" title="12.6. The key fields of LookupJoin">Section 12.6: &#8220;The key fields of LookupJoin&#8221; </a>).
		It's a more high-level template, so it solves this problem automatically,
		removing the duplicate fields from the result by default.
		</p><p>
		But the problem in JoinTwo is even worse
		because the table-to-table outer joins must work with the updates from
		any side. If a row finds no match in the outer join, the other side
		and all the fields in that other side will be NULL. If only the fields from that other
		side pass through into the result, the result will contain NULLs in
		the key fields, which would be very wrong.
		Thus JoinTwo has even more magic built into it: it knows how to
		have the key fields copied into the result from whatever
		side happens to be present for a particular row, and does this by default. 
		The other way to think about it is that it makes these fields always available on both sides.
		</p><p>
		The default behavior is good enough for most situations. But if you want
		more control,
		it's done with the option <span class="quote">&#8220;<span class="quote">fieldsUniqKey</span>&#8221;</span>. The default value
		of this option is <span class="quote">&#8220;<span class="quote">first</span>&#8221;</span>. It means: Enable the magic for copying the
		fields from the non-NULL side to the NULL side. Look at the option
		<span class="quote">&#8220;<span class="quote">fieldsLeftFirst</span>&#8221;</span> and figure out, which side goes first in the result.
		Let the key fields pass on that side unchanged (though the user can
		block them on that side manually too, or possibly rename them, it's his
		choice). On the other side, automatically generate the blocking specs
		for the key fields and prepend them to that side's result
		specification. It's smart enough to know that an undefined <span class="quote">&#8220;<span class="quote">leftFields</span>&#8221;</span>
		or <span class="quote">&#8220;<span class="quote">rightFields</span>&#8221;</span> means the same as <span class="quote">&#8220;<span class="quote">.*</span>&#8221;</span>, so an undefined result spec is
		replaced by the blocking specs followed by <span class="quote">&#8220;<span class="quote">.*</span>&#8221;</span>. If you later call the
		methods
		</p><pre class="programlisting">$fspec = $join-&gt;getLeftFields();
$fspec = $join-&gt;getRightFields();</pre><p>
		then you will actually get back the modified field specs.
		</p><p>
		If you want the key fields to be present in a different location in the
		result, you can set <span class="quote">&#8220;<span class="quote">fieldsUniqKey</span>&#8221;</span> to <span class="quote">&#8220;<span class="quote">left</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">right</span>&#8221;</span>. That will
		make them pass through on the selected side, and the blocking would be
		automatically added on the other side.
		</p><p>
		For more control yet, set this option to <span class="quote">&#8220;<span class="quote">manual</span>&#8221;</span>. The magic for making
		the key fields available on both sides will still be enabled, but no
		automatic blocking. You can pick and choose the result fields manually,
		exactly as you want. Remember though that there can't be multiple
		fields with the same name in the result, so if both sides have these
		fields named the same, you've got to block or rename one of the two
		copies.
		</p><p>
		The final choice is <span class="quote">&#8220;<span class="quote">none</span>&#8221;</span>: it simply disables the key field magic.
		</p></div><div class="sect1" title="12.10. The override options in JoinTwo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_jointwo_override"></a>12.10. The override options in JoinTwo</h2></div></div></div><a class="indexterm" name="id535457"></a><p>
		Normally JoinTwo tries to work in a consistent manner, refusing to do
		the unsafe things that might corrupt the data. But if you really,
		really want, and are really sure of what you're doing, there are
		options to override these restrictions.
		</p><a class="indexterm" name="id535476"></a><a class="indexterm" name="id535490"></a><a class="indexterm" name="id535503"></a><p>
		If you set
		</p><pre class="programlisting">  overrideSimpleMinded =&gt; 1,</pre><a class="indexterm" name="id535527"></a><a class="indexterm" name="id535536"></a><p>
		then the logic that produces the DELETE-INSERT sequences for the outer
		joins gets disabled. The only reason I can think of to use this option
		is if you want to simulate a CEP system that has no concept of opcodes.
		So if your data is INSERT-only and you want to produce the INSERT-only
		data too, and want the dumbed-down logic, this option is your solution.
		</p><a class="indexterm" name="id535553"></a><p>
		The option
		</p><pre class="programlisting">  overrideKeyTypes =&gt; 1,</pre><p>
		disables the check for the exact match of the key field types. This
		might come helpful for example if you have an int32 field on one side
		and an int64 field on the other side, and you know that in reality they
		would always stay within the int32 range. Or if you have an integer on
		one side and a string that always contains an integer on the other
		side. Since you know that the type conversions can always be done with
		no loss, you can safely override the type check and still get the
		correct result.
		</p></div><div class="sect1" title="12.11. JoinTwo input event filtering"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_jointwo_inputfilter"></a>12.11. JoinTwo input event filtering</h2></div></div></div><a class="indexterm" name="id535595"></a><p>
		Let's look at how the business day logic interacts with the joins. It's
		typical for the business applications to keep the full data for the
		current day, or a few recent days, then clear the data that became old
		and maybe keep it only in an aggregated form.
		</p><p>
		So, let's add the business day logic to the left join example. It uses
		the indexes by date to find the rows that have become old:
		</p><pre class="programlisting"># exchange rates, to convert all currencies to USD
our $ttToUsd = Triceps::TableType-&gt;new($rtToUsd)
  -&gt;addSubIndex("primary",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date", "currency" ])
  )
  -&gt;addSubIndex("byDate", # for cleaning by date
    Triceps::SimpleOrderedIndex-&gt;new(date =&gt; "ASC")
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
;
$ttToUsd-&gt;initialize();

# the positions in the original currency
our $ttPosition = Triceps::TableType-&gt;new($rtPosition)
  -&gt;addSubIndex("primary",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date", "customer", "symbol" ])
  )
  -&gt;addSubIndex("currencyLookup", # for joining with currency conversion
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "date", "currency" ])
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
  -&gt;addSubIndex("byDate", # for cleaning by date
    Triceps::SimpleOrderedIndex-&gt;new(date =&gt; "ASC")
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
;
$ttPosition-&gt;initialize();

# remember the indexes for the future use
our $ixtToUsdByDate = $ttToUsd-&gt;findSubIndex("byDate");
our $ixtPositionByDate = $ttPosition-&gt;findSubIndex("byDate");

# Go through the table and clear all the rows where the field "date"
# is less than the date argument. The index type orders the table by date.
sub clearByDate($$$) # ($table, $ixt, $date)
{
  my ($table, $ixt, $date) = @_;

  my $next;
  for (my $rhit = $table-&gt;beginIdx($ixt); !$rhit-&gt;isNull(); $rhit = $next) {
    last if (($rhit-&gt;getRow()-&gt;get("date")) &gt;= $date);
    $next = $rhit-&gt;nextIdx($ixt); # advance before removal
    $table-&gt;remove($rhit);
  }
}</pre><p>
		The table types are the same as have been already shown before, they've been
		copied here for convenience. <code class="computeroutput">clearByDate()</code> is an universal function that
		can clear the contents of any table by date, provided that the date is
		in the field <span class="quote">&#8220;<span class="quote">date</span>&#8221;</span> and the index type on this table that orders the
		rows by date is given as an argument. The index with ordering by date
		must be not just a leaf Ordered index, but have a FIFO index nested in it.
		Without that FIFO index, the Ordered index would allow only one row for
		each date.
		</p><p>
		The main loop gets extended with a few more commands:
		</p><pre class="programlisting">our $businessDay = undef;

our $join = Triceps::JoinTwo-&gt;new(
  name =&gt; "join",
  leftTable =&gt; $tPosition,
  rightTable =&gt; $tToUsd,
  byLeft =&gt; [ "date", "currency" ],
  type =&gt; "left",
); # would confess by itself on an error

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $join-&gt;getOutputLabel());

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "cur") {
    $uJoin-&gt;makeArrayCall($tToUsd-&gt;getInputLabel(), @data);
  } elsif ($type eq "pos") {
    $uJoin-&gt;makeArrayCall($tPosition-&gt;getInputLabel(), @data);
  } elsif ($type eq "day") { # set the business day
    $businessDay = $data[0] + 0; # convert to an int
  } elsif ($type eq "clear") { # clear the previous day
    # flush the left side first, because it's an outer join
    &amp;clearByDate($tPosition, $ixtPositionByDate, $businessDay);
    &amp;clearByDate($tToUsd, $ixtToUsdByDate, $businessDay);
  }
  $uJoin-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		The roll-over to the next business day (after the input data previously
		shown with the left join example) then looks like this:
		</p><pre class="programlisting"><span class="bold"><strong>day,20120311</strong></span>
<span class="bold"><strong>clear</strong></span>
join.leftLookup.out OP_DELETE date="20120310" customer="two"
    symbol="AAA" quantity="100" price="8" currency="GBP" toUsd="2.2"
join.leftLookup.out OP_DELETE date="20120310" customer="three"
    symbol="AAA" quantity="100" price="300" currency="RUR"
    toUsd="0.04"
join.leftLookup.out OP_DELETE date="20120310" customer="three"
    symbol="BBB" quantity="200" price="80" currency="GBP" toUsd="2.2"
join.leftLookup.out OP_DELETE date="20120310" customer="one"
    symbol="AAA" quantity="200" price="16" currency="USD" toUsd="1"</pre><p>
		Clearing the left-side table before the right-side one is more
		efficient than the other way around, since this is a left outer join,
		and since it's an M:1 join. If the
		right-side table were cleared first, it would first update all the
		result records to change all the right-side fields in them to NULL, and
		then the clearing of the left-side table would finally delete these
		rows. Clearing the left side first removes this churn: it deletes all
		the rows from the result right away, and then when the right side is
		cleared, it still tries to look up the matching rows but finds nothing
		and produces no result. For an inner join the order would
		not matter: either one would produce the same amount of churn.
		For a full outer join, the M:1 consideration would come into play,
		and removing the rows from the left side first would still be more
		efficient. This way when it removes multiple position rows that match the same currency,
		all of them but one generate the simple DELETEs, and only the last
		one would follow up with an INSERT that has only the right-side data
		in it. That row with the right-side data will get deleted when the
		currency row gets deleted from the right side. If the right side were deleted
		first, deleting each row on the right side would cause an output
		of a DELETE-INSERT result pair for each of its matching 
		position rows from the
		left side, and would produce more churn. For the 1:1 or M:M full
		outer joins, the order would not matter.
		</p><p>
		If you don't want these deletions to propagate though the rest of your
		model, you can just put a filtering logic after the join, to throw away
		all the modifications for the previous days. Through don't forget that
		you would have then to delete the previous-day data from the rest of
		the model's tables manually.
		</p><p>
		If you want to keep only the aggregated data, you may want to pass the
		join output to the aggregator without filtering and then filter the
		aggregator's output, thus stopping the updates to the aggregation
		results. You may even have a special logic in the aggregator, that
		would ignore the groups of the previous days. Such optimization
		of the aggregation filtering will be shown in the
		<a class="xref" href="#sc_time_limited" title="13.1. Time-limited propagation">Section 13.1: &#8220;Time-limited propagation&#8221; </a>.
		And they aren't any
		less efficient than filtering on the output of the join, because if you
		filter after the join, you'd still have to remove the rows from the
		aggregation table, and would still have to filter after the aggregation
		too.
		</p><p>
		Now, suppose that you want to be extra optimal and don't want any join
		look-ups to happen at all when you delete the old data. JoinTwo has a
		feature that lets you do that. You can make it receive the events not
		directly from the tables but after filtering, using the options
		<span class="quote">&#8220;<span class="quote">leftFromLabel</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">rightFromLabel</span>&#8221;</span>:
		</p><pre class="programlisting">our $lbPositionCurrent = $uJoin-&gt;makeDummyLabel(
  $tPosition-&gt;getRowType, "lbPositionCurrent");
our $lbPositionFilter = $uJoin-&gt;makeLabel($tPosition-&gt;getRowType,
  "lbPositionFilter", undef, sub {
    if ($_[1]-&gt;getRow()-&gt;get("date") &gt;= $businessDay) {
      $uJoin-&gt;call($lbPositionCurrent-&gt;adopt($_[1]));
    }
  });
$tPosition-&gt;getOutputLabel()-&gt;chain($lbPositionFilter);

our $lbToUsdCurrent = $uJoin-&gt;makeDummyLabel(
  $tToUsd-&gt;getRowType, "lbToUsdCurrent");
our $lbToUsdFilter = $uJoin-&gt;makeLabel($tToUsd-&gt;getRowType,
  "lbToUsdFilter", undef, sub {
    if ($_[1]-&gt;getRow()-&gt;get("date") &gt;= $businessDay) {
      $uJoin-&gt;call($lbToUsdCurrent-&gt;adopt($_[1]));
    }
  });
$tToUsd-&gt;getOutputLabel()-&gt;chain($lbToUsdFilter);

our $join = Triceps::JoinTwo-&gt;new(
  name =&gt; "join",
  leftTable =&gt; $tPosition,
  leftFromLabel =&gt; $lbPositionCurrent,
  rightTable =&gt; $tToUsd,
  rightFromLabel =&gt; $lbToUsdCurrent,
  byLeft =&gt; [ "date", "currency" ],
  type =&gt; "left",
); # would confess by itself on an error</pre><p>
		The same clearing now looks like this:
		</p><pre class="programlisting"><span class="bold"><strong>day,20120311</strong></span>
<span class="bold"><strong>clear</strong></span></pre><p>
		No output is coming from the join whatsoever. It all gets cut off
		before it reaches the join. It's not such a great gain though. Remember
		that if you want to keep the aggregated data, you would still have to
		delete the original rows manually from the aggregation table afterwards. And the
		filtering logic will add overhead, not only during the clearing but all
		the time.
		</p><p>
		If you're not careful with the filtering conditions, it's also easy to
		make the results of the join inconsistent. This example filters both
		input tables on the same key field, with the same condition, so the
		output will stay always consistent. But if any of these elements were
		missing, it becomes possible to produce inconsistent output that has
		the DELETEs of different rows than INSERTs, and deletions of the rows
		that haven't been inserted in the first place. The reason is that even
		though the input events are filtered, the table look-ups done by JoinTwo aren't. 
		If some row comes from the right side and gets thrown away by the filter, and then
		another row comes on the left side, passes the filter, and then finds a
		match in that thrown-away right-side row, it will use that row in the
		result. And the join would think that the right-side row has already
		been seen, and would produce an incorrect update.
		</p><p>
		So these options don't make a whole lot of a win but make a major
		opportunity for a mess, and probably should never be used. And will
		probably be deleted in the future, unless someone finds a good use for
		them. They have been added because at the time they provided a roundabout way to do
		a self-join. But the later fixes to the Table logic make the self-joins
		possible without this kind of perversions.
		</p></div><div class="sect1" title="12.12. Self-join done with JoinTwo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_self_jointwo"></a>12.12. Self-join done with JoinTwo</h2></div></div></div><a class="indexterm" name="id535833"></a><p>
		The self-joins happen when a table is joined to itself.
		For an example of a model with self-joins, let's look at the Forex
		trading. People exchange the currencies in every possible
		direction in multiple markets. The Forex exchange rates are quoted
		for every pair of currencies, in every direction.
		</p><p>
		Naturally, if you exchange one currency into another and then back into
		the first one, you normally end up with less money than you've started
		with. The rest becomes the transaction cost and lines the pockets of
		the brokers, market makers and exchanges.
		</p><p>
		However once in a while some interesting things happen. If the
		exchange rates between the different currencies become disbalanced, you
		may be able to exchange the currency A for currency B for currency C
		and back for currency A, and end up with more money than you've started
		with. (You don't have to do it in sequence, you would normally do all
		three transactions in parallel). However it's a short-lived
		opportunity: as you perform the transactions, you'll be changing the
		involved exchange rates towards the balance, and you won't be the only
		one exploiting this opportunity, so you better act fast. This activity
		of bringing the market into balance while simultaneously extracting
		profit is called <span class="quote">&#8220;<span class="quote">arbitration</span>&#8221;</span>.
		</p><p>
		So let's make a model that will detect such arbitration opportunities,
		for the following automated execution. Mind you, it's all grossly
		simplified, but it shows the gist of it. And most importantly, it uses
		the self-joins. Here we go:
		</p><pre class="programlisting">our $rtRate = Triceps::RowType-&gt;new( # an exchange rate between two currencies
  ccy1 =&gt; "string", # currency code
  ccy2 =&gt; "string", # currency code
  rate =&gt; "float64", # multiplier when exchanging ccy1 to ccy2
);

# all exchange rates
our $ttRate = Triceps::TableType-&gt;new($rtRate)
  -&gt;addSubIndex("byCcy1",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy1" ])
    -&gt;addSubIndex("byCcy12",
      Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy2" ])
    )
  )
  -&gt;addSubIndex("byCcy2",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy2" ])
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
;
$ttRate-&gt;initialize();

our $uArb = Triceps::Unit-&gt;new("uArb");

our $tRate = $uArb-&gt;makeTable($ttRate, "tRate");

our $join1 = Triceps::JoinTwo-&gt;new(
  name =&gt; "join1",
  leftTable =&gt; $tRate,
  leftIdxPath =&gt; [ "byCcy2" ],
  leftFields =&gt; [ "ccy1", "ccy2", "rate/rate1" ],
  rightTable =&gt; $tRate,
  rightIdxPath =&gt; [ "byCcy1" ],
  rightFields =&gt; [ "ccy2/ccy3", "rate/rate2" ],
); # would die by itself on an error
our $ttJoin1 = Triceps::TableType-&gt;new($join1-&gt;getResultRowType())
  -&gt;addSubIndex("byCcy123",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy1", "ccy2", "ccy3" ])
  )
  -&gt;addSubIndex("byCcy31",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "ccy3", "ccy1" ])
    -&gt;addSubIndex("grouping", Triceps::IndexType-&gt;newFifo())
  )
;
$ttJoin1-&gt;initialize();
our $tJoin1 = $uArb-&gt;makeTable($ttJoin1, "tJoin1");
$join1-&gt;getOutputLabel()-&gt;chain($tJoin1-&gt;getInputLabel());

our $join2 = Triceps::JoinTwo-&gt;new(
  name =&gt; "join2",
  leftTable =&gt; $tJoin1,
  leftIdxPath =&gt; [ "byCcy31" ],
  rightTable =&gt; $tRate,
  rightIdxPath =&gt; [ "byCcy1", "byCcy12" ],
  rightFields =&gt; [ "rate/rate3" ],
  # the field ordering in the indexes is already right, but
  # for clarity add an explicit join condition too
  byLeft =&gt; [ "ccy3/ccy1", "ccy1/ccy2" ],
); # would die by itself on an error

# now compute the resulting circular rate and filter the profitable loops
our $rtResult = Triceps::RowType-&gt;new(
  $join2-&gt;getResultRowType()-&gt;getdef(),
  looprate =&gt; "float64",
);
my $lbResult = $uArb-&gt;makeDummyLabel($rtResult, "lbResult");
my $lbCompute = $uArb-&gt;makeLabel($join2-&gt;getResultRowType(), "lbCompute", undef, sub {
  my ($label, $rowop) = @_;
  my $row = $rowop-&gt;getRow();
  my $looprate = $row-&gt;get("rate1") * $row-&gt;get("rate2") * $row-&gt;get("rate3");

  if ($looprate &gt; 1) {
    $uArb-&gt;makeHashCall($lbResult, $rowop-&gt;getOpcode(),
      $row-&gt;toHash(),
      looprate =&gt; $looprate,
    );
  } else {
      print("__", $rowop-&gt;printP(), "looprate=$looprate \n"); # for debugging
  }
});
$join2-&gt;getOutputLabel()-&gt;chain($lbCompute);

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $lbResult);
#makePrintLabel("lbPrintJoin1", $join1-&gt;getOutputLabel());
#makePrintLabel("lbPrintJoin2", $join2-&gt;getOutputLabel());

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "rate") {
    $uArb-&gt;makeArrayCall($tRate-&gt;getInputLabel(), @data);
  }
  $uArb-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		The rate quotes will be coming into <code class="computeroutput">$tRate</code>. The indexes are
		provided to both work with the self-joins and to have a primary index
		as the first leaf.
		</p><p>
		There are no special options for the self-join in JoinTwo: just use the same table
		for both the left and right side. The first join represents two exchange
		transactions, so it's done by matching the second currency of the first
		quote to the first currency of the second quote. The result contains
		three currency names and two rate multipliers.

		The second join adds one more rate multiplier, returning back to the
		first currency. Now to learn the effect of
		the circular conversion we only need to multiply all the multipliers.
		If it comes out below 1, the cycling transaction would return a loss,
		if above 1, a profit.
		</p><p>
		The label <code class="computeroutput">$lbCompute</code> with Perl handler performs the multiplication, and if the
		result is over 1, passes the result to the next label <code class="computeroutput">$lbResult</code>, from which then
		the data gets printed. I've also added a debugging printout in case if
		the row doesn't get through. That one starts with <span class="quote">&#8220;<span class="quote"><code class="computeroutput">__</code></span>&#8221;</span> and helps seeing
		what goes on inside when no result is coming out.
		</p><p>
		Finally, the main loop reads the data and puts it into the rates table,
		thus driving the logic.
		</p><p>
		Now let's take a look at an example of a run, with interspersed commentary.
		</p><pre class="programlisting"><span class="bold"><strong>rate,OP_INSERT,EUR,USD,1.48</strong></span>
<span class="bold"><strong>rate,OP_INSERT,USD,EUR,0.65</strong></span>
<span class="bold"><strong>rate,OP_INSERT,GBP,USD,1.98</strong></span>
<span class="bold"><strong>rate,OP_INSERT,USD,GBP,0.49</strong></span></pre><p>
		The rate quotes start coming in. Note that the rates are separate for
		each direction of exchange. So far nothing happens because there aren't
		enough quotes to complete a loop of three steps.
		</p><pre class="programlisting"><span class="bold"><strong>rate,OP_INSERT,EUR,GBP,0.74</strong></span>
__join2.leftLookup.out OP_INSERT ccy1="EUR" ccy2="GBP" rate1="0.74"
    ccy3="USD" rate2="1.98" rate3="0.65" looprate=0.95238
__join2.leftLookup.out OP_INSERT ccy1="USD" ccy2="EUR" rate1="0.65"
    ccy3="GBP" rate2="0.74" rate3="1.98" looprate=0.95238
__join2.rightLookup.out OP_INSERT ccy1="GBP" ccy2="USD" rate1="1.98"
    ccy3="EUR" rate2="0.65" rate3="0.74" looprate=0.95238
<span class="bold"><strong>rate,OP_INSERT,GBP,EUR,1.30</strong></span>
__join2.leftLookup.out OP_INSERT ccy1="GBP" ccy2="EUR" rate1="1.3"
    ccy3="USD" rate2="1.48" rate3="0.49" looprate=0.94276
__join2.leftLookup.out OP_INSERT ccy1="USD" ccy2="GBP" rate1="0.49"
    ccy3="EUR" rate2="1.3" rate3="1.48" looprate=0.94276
__join2.rightLookup.out OP_INSERT ccy1="EUR" ccy2="USD" rate1="1.48"
    ccy3="GBP" rate2="0.49" rate3="1.3" looprate=0.94276</pre><p>
		Now there are enough currencies in play to complete the loop. None of
		them get the loop rate over 1 though, so the only printouts are from
		the debugging logic. There are only two loops, but each of them is
		printed three times. Why? It's a loop, so you can start from each of
		its elements and come back to the same element. One row for each
		starting point. And the joins find all of them.
		</p><p>
		To find and eliminate the duplicates, the order of currencies in the
		rows can be rotated to put the alphabetically lowest currency code
		first. Note that they can't be just sorted because the relative order
		matters. Trading in the order GBP-USD-EUR will give a different result
		than GBP-EUR-USD. The relative order has to be preserved. I didn't put
		any such elimination into the example to keep it smaller.
		</p><pre class="programlisting"><span class="bold"><strong>rate,OP_DELETE,EUR,USD,1.48</strong></span>
__join2.leftLookup.out OP_DELETE ccy1="EUR" ccy2="USD" rate1="1.48"
    ccy3="GBP" rate2="0.49" rate3="1.3" looprate=0.94276
__join2.leftLookup.out OP_DELETE ccy1="GBP" ccy2="EUR" rate1="1.3"
    ccy3="USD" rate2="1.48" rate3="0.49" looprate=0.94276
__join2.rightLookup.out OP_DELETE ccy1="USD" ccy2="GBP" rate1="0.49"
    ccy3="EUR" rate2="1.3" rate3="1.48" looprate=0.94276
<span class="bold"><strong>rate,OP_INSERT,EUR,USD,1.28</strong></span>
__join2.leftLookup.out OP_INSERT ccy1="EUR" ccy2="USD" rate1="1.28"
    ccy3="GBP" rate2="0.49" rate3="1.3" looprate=0.81536
__join2.leftLookup.out OP_INSERT ccy1="GBP" ccy2="EUR" rate1="1.3"
    ccy3="USD" rate2="1.28" rate3="0.49" looprate=0.81536
__join2.rightLookup.out OP_INSERT ccy1="USD" ccy2="GBP" rate1="0.49"
    ccy3="EUR" rate2="1.3" rate3="1.28" looprate=0.81536</pre><p>
		Someone starts changing lots of euros for dollars, and the rate moves.
		No good news for us yet though.
		</p><pre class="programlisting"><span class="bold"><strong>rate,OP_DELETE,USD,EUR,0.65</strong></span>
__join2.leftLookup.out OP_DELETE ccy1="USD" ccy2="EUR" rate1="0.65"
    ccy3="GBP" rate2="0.74" rate3="1.98" looprate=0.95238
__join2.leftLookup.out OP_DELETE ccy1="GBP" ccy2="USD" rate1="1.98"
    ccy3="EUR" rate2="0.65" rate3="0.74" looprate=0.95238
__join2.rightLookup.out OP_DELETE ccy1="EUR" ccy2="GBP" rate1="0.74"
    ccy3="USD" rate2="1.98" rate3="0.65" looprate=0.95238
<span class="bold"><strong>rate,OP_INSERT,USD,EUR,0.78</strong></span>
lbResult OP_INSERT ccy1="USD" ccy2="EUR" rate1="0.78" ccy3="GBP"
    rate2="0.74" rate3="1.98" looprate="1.142856"
lbResult OP_INSERT ccy1="GBP" ccy2="USD" rate1="1.98" ccy3="EUR"
    rate2="0.78" rate3="0.74" looprate="1.142856"
lbResult OP_INSERT ccy1="EUR" ccy2="GBP" rate1="0.74" ccy3="USD"
    rate2="1.98" rate3="0.78" looprate="1.142856"</pre><p>
		The rate for dollars-to-euros follows its opposite. This creates an
		arbitration opportunity! Step two: trade in the direction
		USD-EUR-GBP-USD, step three: PROFIT!!!
		</p><pre class="programlisting"><span class="bold"><strong>rate,OP_DELETE,EUR,GBP,0.74</strong></span>
lbResult OP_DELETE ccy1="EUR" ccy2="GBP" rate1="0.74" ccy3="USD"
    rate2="1.98" rate3="0.78" looprate="1.142856"
lbResult OP_DELETE ccy1="USD" ccy2="EUR" rate1="0.78" ccy3="GBP"
    rate2="0.74" rate3="1.98" looprate="1.142856"
lbResult OP_DELETE ccy1="GBP" ccy2="USD" rate1="1.98" ccy3="EUR"
    rate2="0.78" rate3="0.74" looprate="1.142856"
<span class="bold"><strong>rate,OP_INSERT,EUR,GBP,0.64</strong></span>
__join2.leftLookup.out OP_INSERT ccy1="EUR" ccy2="GBP" rate1="0.64"
    ccy3="USD" rate2="1.98" rate3="0.78" looprate=0.988416
__join2.leftLookup.out OP_INSERT ccy1="USD" ccy2="EUR" rate1="0.78"
    ccy3="GBP" rate2="0.64" rate3="1.98" looprate=0.988416
__join2.rightLookup.out OP_INSERT ccy1="GBP" ccy2="USD" rate1="1.98"
    ccy3="EUR" rate2="0.78" rate3="0.64" looprate=0.988416</pre><p>
		Our trading (and perhaps other people's trading too) moves the exchange
		rate of euros to pounds. And with that the balance of currencies is
		restored, and the arbitration opportunity disappears.
		</p><p>
		Now let's have a look inside JoinTwo. What is so special about the
		self-join? Normally the join works on two separate tables. They get
		updated one at a time. Even if some common reason causes both tables to
		be updated, the update arrives from one table first. The join sees this
		incoming update, looks in the unchanged second table, produces an
		updated result. Then the update from the second table comes to the
		join, which takes it, looks in the already modified first table, and
		produces another updated result.
		</p><p>
		If both inputs are from the same table, this logic breaks. Two copies
		of the updates will arrive, but by the time the first one arrives, the
		contents of the table has been already changed. When the join looks in
		the table, it gets the unexpected results and creates a mess.
		</p><p>
		But JoinTwo has a fix for this. It makes use of the Pre label of the
		table for its left-side update (the right side would have worked just
		as good, it's just a random choice):
		</p><pre class="programlisting">  my $selfJoin = $self-&gt;{leftTable}-&gt;same($self-&gt;{rightTable});
  if ($selfJoin &amp;&amp; !defined $self-&gt;{leftFromLabel}) {
    # one side must be fed from Pre label (but still let the user override)
    $self-&gt;{leftFromLabel} = $self-&gt;{leftTable}-&gt;getPreLabel();
  }</pre><p>
		This way when the join sees the first update, the table hasn't changed
		yet. And then the second copy of that update comes though the normal
		output label, after the table has been modified. Everything just works
		out as normal and the self-joins produce the correct result.
		</p><p>
		Normally you don't need to concern yourself with this, except if you're
		trying to filter the data coming to the join. Then remember that for
		<span class="quote">&#8220;<span class="quote">leftFromLabel</span>&#8221;</span> you have to receive the data from the table's
		<code class="computeroutput">getPreLabel()</code>, not <code class="computeroutput">getOutputLabel()</code>.
		</p></div><div class="sect1" title="12.13. Self-join done manually"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_self_manual"></a>12.13. Self-join done manually</h2></div></div></div><a class="indexterm" name="id536200"></a><a class="indexterm" name="id536213"></a><p>
		In many cases the self-joins are better
		suited to be done by the manual looping through the data. This is
		especially true if the table represents a tree, linked by the
		parent-child node id and the processing has to navigate through the
		tree. Indeed, if the tree may be of an arbitrary depth, there is no way
		to handle if with the common joins, you will need as many joins as
		the depth of the tree (through there are some SQL extensions for the
		recursive self-joins).
		</p><p>
		The arbitration example can also be conveniently rewritten through the
		manual loops. The input row type, table type, table, unit, and the main
		loop do not change, so I won't copy them the second time. The rest of
		the code is:
		</p><pre class="programlisting">our $rtResult = Triceps::RowType-&gt;new(
  ccy1 =&gt; "string", # currency code
  ccy2 =&gt; "string", # currency code
  ccy3 =&gt; "string", # currency code
  rate1 =&gt; "float64",
  rate2 =&gt; "float64",
  rate3 =&gt; "float64",
  looprate =&gt; "float64",
);
my $ixtCcy1 = $ttRate-&gt;findSubIndex("byCcy1");
my $ixtCcy12 = $ixtCcy1-&gt;findSubIndex("byCcy12");

my $lbResult = $uArb-&gt;makeDummyLabel($rtResult, "lbResult");
my $lbCompute = $uArb-&gt;makeLabel($rtRate, "lbCompute", undef, sub {
  my ($label, $rowop) = @_;
  my $row = $rowop-&gt;getRow();
  my $ccy1 = $row-&gt;get("ccy1");
  my $ccy2 = $row-&gt;get("ccy2");
  my $rate1 = $row-&gt;get("rate");

  my $rhi = $tRate-&gt;findIdxBy($ixtCcy1, ccy1 =&gt; $ccy2);
  my $rhiEnd = $rhi-&gt;nextGroupIdx($ixtCcy12);
  for (; !$rhi-&gt;same($rhiEnd); $rhi = $rhi-&gt;nextIdx($ixtCcy12)) {
    my $row2 = $rhi-&gt;getRow();
    my $ccy3 = $row2-&gt;get("ccy2");
    my $rate2 = $row2-&gt;get("rate");

    my $rhj = $tRate-&gt;findIdxBy($ixtCcy12, ccy1 =&gt; $ccy3, ccy2 =&gt; $ccy1);
    # it's a leaf primary index, so there may be no more than one match
    next
      if ($rhj-&gt;isNull());
    my $row3 = $rhj-&gt;getRow();
    my $rate3 = $row3-&gt;get("rate");
    my $looprate = $rate1 * $rate2 * $rate3;

    # now build the row in normalized order of currencies
    print("____Order before: $ccy1, $ccy2, $ccy3\n");
    my $result;
    if ($ccy2 lt $ccy3) {
      if ($ccy2 lt $ccy1) { # rotate left
        $result = $lbResult-&gt;makeRowopHash($rowop-&gt;getOpcode(),
          ccy1 =&gt; $ccy2,
          ccy2 =&gt; $ccy3,
          ccy3 =&gt; $ccy1,
          rate1 =&gt; $rate2,
          rate2 =&gt; $rate3,
          rate3 =&gt; $rate1,
          looprate =&gt; $looprate,
        );
      }
    } else {
      if ($ccy3 lt $ccy1) { # rotate right
        $result = $lbResult-&gt;makeRowopHash($rowop-&gt;getOpcode(),
          ccy1 =&gt; $ccy3,
          ccy2 =&gt; $ccy1,
          ccy3 =&gt; $ccy2,
          rate1 =&gt; $rate3,
          rate2 =&gt; $rate1,
          rate3 =&gt; $rate2,
          looprate =&gt; $looprate,
        );
      }
    }
    if (!defined $result) { # use the straight order
      $result = $lbResult-&gt;makeRowopHash($rowop-&gt;getOpcode(),
        ccy1 =&gt; $ccy1,
        ccy2 =&gt; $ccy2,
        ccy3 =&gt; $ccy3,
        rate1 =&gt; $rate1,
        rate2 =&gt; $rate2,
        rate3 =&gt; $rate3,
        looprate =&gt; $looprate,
      );
    }
    if ($looprate &gt; 1) {
      $uArb-&gt;call($result);
    } else {
      print("__", $result-&gt;printP(), "\n"); # for debugging
    }
  }
});
$tRate-&gt;getOutputLabel()-&gt;chain($lbCompute);
makePrintLabel("lbPrint", $lbResult);</pre><p>
		Whenever a new rowop is processed in the table, it goes to the 
		label <code class="computeroutput">$lbCompute</code>. The row in this rowop is the first leg of the triangle. The loop
		then finds all the possible second legs that can be connected to the
		first leg. And then for each second leg it checks whether it can make
		the third leg back to the original currency. If it can, good, we've
		found a candidate for a result row.
		</p><p>
		The way the loops work, this time there is no triplication. But the
		same triangle still can be found starting from any of its three
		currencies. This means that to keep the data consistent, no matter what
		was the first currency in a particular run, it still must produce the
		exact same result row. To achieve that, the currencies get rotated as
		explained in the previous section, making sure that the first currency is has
		the lexically smallest name. These if-else statements do that by
		selecting the direction of rotation (if any) and build the result
		record in one of three ways.
		</p><p>
		Finally it compares the combined rate to 1, and if greater then sends
		the result. If not, a debugging printout starting with <span class="quote">&#8220;<span class="quote"><code class="computeroutput">__</code></span>&#8221;</span> prints the
		row, so that is can be seen. Another debugging printout prints the
		original order of the currencies, letting us check that the rotation
		was performed correctly.
		</p><p>
		On feeding the same input data this code produces the result:
		</p><pre class="programlisting"><span class="bold"><strong>rate,OP_INSERT,EUR,USD,1.48</strong></span>
<span class="bold"><strong>rate,OP_INSERT,USD,EUR,0.65</strong></span>
<span class="bold"><strong>rate,OP_INSERT,GBP,USD,1.98</strong></span>
<span class="bold"><strong>rate,OP_INSERT,USD,GBP,0.49</strong></span>
<span class="bold"><strong>rate,OP_INSERT,EUR,GBP,0.74</strong></span>
____Order before: EUR, GBP, USD
__lbResult OP_INSERT ccy1="EUR" ccy2="GBP" ccy3="USD" rate1="0.74"
    rate2="1.98" rate3="0.65" looprate="0.95238"
<span class="bold"><strong>rate,OP_INSERT,GBP,EUR,1.30</strong></span>
____Order before: GBP, EUR, USD
__lbResult OP_INSERT ccy1="EUR" ccy2="USD" ccy3="GBP" rate1="1.48"
    rate2="0.49" rate3="1.3" looprate="0.94276"
<span class="bold"><strong>rate,OP_DELETE,EUR,USD,1.48</strong></span>
____Order before: EUR, USD, GBP
__lbResult OP_DELETE ccy1="EUR" ccy2="USD" ccy3="GBP" rate1="1.48"
    rate2="0.49" rate3="1.3" looprate="0.94276"
<span class="bold"><strong>rate,OP_INSERT,EUR,USD,1.28</strong></span>
____Order before: EUR, USD, GBP
__lbResult OP_INSERT ccy1="EUR" ccy2="USD" ccy3="GBP" rate1="1.28"
    rate2="0.49" rate3="1.3" looprate="0.81536"
<span class="bold"><strong>rate,OP_DELETE,USD,EUR,0.65</strong></span>
____Order before: USD, EUR, GBP
__lbResult OP_DELETE ccy1="EUR" ccy2="GBP" ccy3="USD" rate1="0.74"
    rate2="1.98" rate3="0.65" looprate="0.95238"
<span class="bold"><strong>rate,OP_INSERT,USD,EUR,0.78</strong></span>
____Order before: USD, EUR, GBP
lbResult OP_INSERT ccy1="EUR" ccy2="GBP" ccy3="USD" rate1="0.74"
    rate2="1.98" rate3="0.78" looprate="1.142856"
<span class="bold"><strong>rate,OP_DELETE,EUR,GBP,0.74</strong></span>
____Order before: EUR, GBP, USD
lbResult OP_DELETE ccy1="EUR" ccy2="GBP" ccy3="USD" rate1="0.74"
    rate2="1.98" rate3="0.78" looprate="1.142856"
<span class="bold"><strong>rate,OP_INSERT,EUR,GBP,0.64</strong></span>
____Order before: EUR, GBP, USD
__lbResult OP_INSERT ccy1="EUR" ccy2="GBP" ccy3="USD" rate1="0.64"
    rate2="1.98" rate3="0.78" looprate="0.988416"</pre><p>
		It's the same result as before, only without the triplicates. And you
		can see that the rotation logic works right. The manual self-joining
		has produced the result without triplicates, without an intermediate
		table, and for me writing and understanding its logic is much easier
		than with the <span class="quote">&#8220;<span class="quote">proper</span>&#8221;</span> joins. I'd say that the manual self-join is a
		winner in every respect.
		</p><p>
		An interesting thing is that this manual logic produces the same result
		independently of whether it's connected to the Output or Pre label of
		the table. Try changing it, it works the same. This is because the
		original row is taken directly from the input rowop, and never
		participates in the join again; it's never read from the table by any
		of the loops. If it were read again from the table by the loops, the
		table connection would matter. And the correct one would be fairly weird:
		the INSERT rowops would have to be processed coming from the Output
		label, the DELETE rowops coming from the Pre label.
		</p><p>
		This is because the row has to be in the table to be found. And for an
		INSERT the row gets there only after it goes through the table and
		comes out on the Output label. But for a DELETE the row would get
		already deleted from the table by that time. Instead it has to be
		handled before that, on the Pre label, when the table only prepares to
		delete it.
		</p><a class="indexterm" name="id536423"></a><p>
		If you look at the version with JoinTwo, that's also how an inner
		self-join works. Since it's an inner join, both rows on both sides must
		be present to produce a result. An INSERT first arrives from the Pre
		label on the left side, doesn't find itself in the table, and produces
		no result (again, we're talking here about the situation when a row has
		to get joined to itself; it might well find the other pairs for itself
		and produce a result for them but not for itself joined with itself).
		Then it arrives the second time from the Output label on the right
		side. Now it looks in the table, and finds itself, and produces the
		result (an INSERT coming form the join). A DELETE also first arrives
		from the Pre label on the left side. It finds its copy in the table and
		produces the result (a DELETE coming from the join). When the second
		copy of the row arrives from the Output label on the right side, it
		doesn't find its copy in the table any more, and produces nothing. In
		the end it's the same thing, an INSERT comes out of the join triggered
		by the table Output label, a DELETE comes out of the join triggered by
		the table Pre label. It's not a whimsy, it's caused by the requirements
		of the correctness. The manual self-join would have to mimic this order
		to produce the correct result. In such a situation perhaps JoinTwo
		would be easier to use than doing things manually.
		</p></div><div class="sect1" title="12.14. Self-join done with a LookupJoin"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_self_lookupjoin"></a>12.14. Self-join done with a LookupJoin</h2></div></div></div><a class="indexterm" name="id536459"></a><a class="indexterm" name="id536472"></a><p>
		The experience with the manual join has made me think about using a
		similar approach to avoid triplication of the data in the version with
		join templates. And after some false-starts, I've realized that what
		that version needs is the LookupJoins. They replace the loops. So, one
		more version is:
		</p><pre class="programlisting">our $join1 = Triceps::LookupJoin-&gt;new(
  name =&gt; "join1",
  leftFromLabel =&gt; $tRate-&gt;getOutputLabel(),
  leftFields =&gt; [ "ccy1", "ccy2", "rate/rate1" ],
  rightTable =&gt; $tRate,
  rightIdxPath =&gt; [ "byCcy1" ],
  rightFields =&gt; [ "ccy2/ccy3", "rate/rate2" ],
  byLeft =&gt; [ "ccy2/ccy1" ],
  isLeft =&gt; 0,
); # would die by itself on an error

our $join2 = Triceps::LookupJoin-&gt;new(
  name =&gt; "join2",
  leftFromLabel =&gt; $join1-&gt;getOutputLabel(),
  rightTable =&gt; $tRate,
  rightIdxPath =&gt; [ "byCcy1", "byCcy12" ],
  rightFields =&gt; [ "rate/rate3" ],
  byLeft =&gt; [ "ccy3/ccy1", "ccy1/ccy2" ],
  isLeft =&gt; 0,
); # would die by itself on an error

# now compute the resulting circular rate and filter the profitable loops
our $rtResult = Triceps::RowType-&gt;new(
  $join2-&gt;getResultRowType()-&gt;getdef(),
  looprate =&gt; "float64",
);
my $lbResult = $uArb-&gt;makeDummyLabel($rtResult, "lbResult");
my $lbCompute = $uArb-&gt;makeLabel($join2-&gt;getResultRowType(), "lbCompute", undef, sub {
  my ($label, $rowop) = @_;
  my $row = $rowop-&gt;getRow();

  my $ccy1 = $row-&gt;get("ccy1");
  my $ccy2 = $row-&gt;get("ccy2");
  my $ccy3 = $row-&gt;get("ccy3");
  my $rate1 = $row-&gt;get("rate1");
  my $rate2 = $row-&gt;get("rate2");
  my $rate3 = $row-&gt;get("rate3");
  my $looprate = $rate1 * $rate2 * $rate3;

  # now build the row in normalized order of currencies
  print("____Order before: $ccy1, $ccy2, $ccy3\n");
  my $result;
  if ($ccy2 lt $ccy3) {
    if ($ccy2 lt $ccy1) { # rotate left
      $result = $lbResult-&gt;makeRowopHash($rowop-&gt;getOpcode(),
        ccy1 =&gt; $ccy2,
        ccy2 =&gt; $ccy3,
        ccy3 =&gt; $ccy1,
        rate1 =&gt; $rate2,
        rate2 =&gt; $rate3,
        rate3 =&gt; $rate1,
        looprate =&gt; $looprate,
      );
    }
  } else {
    if ($ccy3 lt $ccy1) { # rotate right
      $result = $lbResult-&gt;makeRowopHash($rowop-&gt;getOpcode(),
        ccy1 =&gt; $ccy3,
        ccy2 =&gt; $ccy1,
        ccy3 =&gt; $ccy2,
        rate1 =&gt; $rate3,
        rate2 =&gt; $rate1,
        rate3 =&gt; $rate2,
        looprate =&gt; $looprate,
      );
    }
  }
  if (!defined $result) { # use the straight order
    $result = $lbResult-&gt;makeRowopHash($rowop-&gt;getOpcode(),
      ccy1 =&gt; $ccy1,
      ccy2 =&gt; $ccy2,
      ccy3 =&gt; $ccy3,
      rate1 =&gt; $rate1,
      rate2 =&gt; $rate2,
      rate3 =&gt; $rate3,
      looprate =&gt; $looprate,
    );
  }
  if ($looprate &gt; 1) {
    $uArb-&gt;call($result);
  } else {
    print("__", $result-&gt;printP(), "\n"); # for debugging
  }
});
$join2-&gt;getOutputLabel()-&gt;chain($lbCompute);</pre><p>
		It produces the exact same result as the version with the manual loops,
		with the only minor difference of the field order in the result
		rows.
		</p><p>
		And, in retrospect, I should have probably made a function for the row
		rotation, so that I would not have to copy that code here.
		</p><p>
		Well, it works the same as the version with the loops and maybe even
		looks a little bit neater, but in practice it's much harder to write,
		debug and understand. The caveat for the situation where the incoming
		row might participate in the join the second time applies to this
		version of the code as well. The same thing about the Pre and Output
		labels would have to be done, resulting in four LookupJoins instead
		of two. Each pair would become a manually-built analog of JoinTwo, and
		probably it's easier to use a JoinTwo to start with.
		</p></div><div class="sect1" title="12.15. A glimpse inside JoinTwo and the hidden options of LookupJoin"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_joins_jointwo_glimpse"></a>12.15. A glimpse inside JoinTwo and the hidden options of LookupJoin</h2></div></div></div><a class="indexterm" name="id536546"></a><a class="indexterm" name="id536556"></a><p>
		The internals of JoinTwo provide an interesting example of a template
		that builds upon other template (LookupJoin).
		For a while JoinTwo was compact and straightforward, and easy to
		demonstrate. Then it has grown all these extra features, options and
		error checks, and became quite complicated. So I'll show only the
		selected portions of the JoinTwo constructor, with the gist of its
		functionality:
		</p><pre class="programlisting">...
  my $selfJoin = $self-&gt;{leftTable}-&gt;same($self-&gt;{rightTable});
  if ($selfJoin &amp;&amp; !defined $self-&gt;{leftFromLabel}) {
    # one side must be fed from Pre label (but still let the user override)
    $self-&gt;{leftFromLabel} = $self-&gt;{leftTable}-&gt;getPreLabel();
  }
...

  my ($leftLeft, $rightLeft);
  if ($self-&gt;{type} eq "inner") {
    $leftLeft = 0;
    $rightLeft = 0;
  } elsif ($self-&gt;{type} eq "left") {
    $leftLeft = 1;
    $rightLeft = 0;
  } elsif ($self-&gt;{type} eq "right") {
    $leftLeft = 0;
    $rightLeft = 1;
  } elsif ($self-&gt;{type} eq "outer") {
    $leftLeft = 1;
    $rightLeft = 1;
  } else {
    Carp::confess("Unknown value '" . $self-&gt;{type} . "' of option 'type', must be one of inner|left|right|outer");
  }

  $self-&gt;{leftRowType} = $self-&gt;{leftTable}-&gt;getRowType();
  $self-&gt;{rightRowType} = $self-&gt;{rightTable}-&gt;getRowType();
...

  for my $side ( ("left", "right") ) {
    if (defined $self-&gt;{"${side}FromLabel"}) {
...
    } else {
      $self-&gt;{"${side}FromLabel"} = $self-&gt;{"${side}Table"}-&gt;getOutputLabel();
    }

    my @keys;
    ($self-&gt;{"${side}IdxType"}, @keys) = $self-&gt;{"${side}Table"}-&gt;getType()-&gt;findIndexKeyPath(@{$self-&gt;{"${side}IdxPath"}});
    # would already confess if the index is not found

    if (!$self-&gt;{overrideSimpleMinded}) {
      if (!$self-&gt;{"${side}IdxType"}-&gt;isLeaf()

      &amp;&amp; ($self-&gt;{type} ne "inner" &amp;&amp; $self-&gt;{type} ne $side) ) {
        my $table = $self-&gt;{"${side}Table"};
        my $ixt = $self-&gt;{"${side}IdxType"};
        if ($selfJoin &amp;&amp; $side eq "left") {
          # the special case, reading from the table's Pre label;
          # must adjust the count for what will happen after the row gets processed
          $self-&gt;{"${side}GroupSizeCode"} = sub { # (opcode, row)
            if (&amp;Triceps::isInsert($_[0])) {
              $table-&gt;groupSizeIdx($ixt, $_[1])+1;
            } else {
              $table-&gt;groupSizeIdx($ixt, $_[1])-1;
            }
          };
        } else {
          $self-&gt;{"${side}GroupSizeCode"} = sub { # (opcode, row)
            $table-&gt;groupSizeIdx($ixt, $_[1]);
          };
        }
      }
    }

...
  my $fieldsMirrorKey = 1;
  my $uniq = $self-&gt;{fieldsUniqKey};
  if ($uniq eq "first") {
    $uniq = $self-&gt;{fieldsLeftFirst} ? "left" : "right";
  }
  if ($uniq eq "none") {
    $fieldsMirrorKey = 0;
  } elsif ($uniq eq "manual") {
    # nothing to do
  } elsif ($uniq =~ /^(left|right)$/) {
    my($side, @keys);
    if ($uniq eq "left") {
      $side = "right";
      @keys = @rightkeys;
    } else {
      $side = "left";
      @keys = @leftkeys;
    }
    if (!defined $self-&gt;{"${side}Fields"}) {
      $self-&gt;{"${side}Fields"} = [ ".*" ]; # the implicit pass-all
    }
    unshift(@{$self-&gt;{"${side}Fields"}}, map("!$_", @keys) );
  } else {
    Carp::confess("Unknown value '" . $self-&gt;{fieldsUniqKey} . "' of option 'fieldsUniqKey', must be one of none|manual|left|right|first");
  }

  # now create the LookupJoins
  $self-&gt;{leftLookup} = Triceps::LookupJoin-&gt;new(
    unit =&gt; $self-&gt;{unit},
    name =&gt; $self-&gt;{name} . ".leftLookup",
    leftRowType =&gt; $self-&gt;{leftRowType},
    rightTable =&gt; $self-&gt;{rightTable},
    rightIdxPath =&gt; $self-&gt;{rightIdxPath},
    leftFields =&gt; $self-&gt;{leftFields},
    rightFields =&gt; $self-&gt;{rightFields},
    fieldsLeftFirst =&gt; $self-&gt;{fieldsLeftFirst},
    fieldsMirrorKey =&gt; $fieldsMirrorKey,
    by =&gt; \@leftby,
    isLeft =&gt; $leftLeft,
    automatic =&gt; 1,
    oppositeOuter =&gt; ($rightLeft &amp;&amp; !$self-&gt;{overrideSimpleMinded}),
    groupSizeCode =&gt; $self-&gt;{leftGroupSizeCode},
    saveJoinerTo =&gt; $self-&gt;{leftSaveJoinerTo},
  );
  $self-&gt;{rightLookup} = Triceps::LookupJoin-&gt;new(
    unit =&gt; $self-&gt;{unit},
    name =&gt; $self-&gt;{name} . ".rightLookup",
    leftRowType =&gt; $self-&gt;{rightRowType},
    rightTable =&gt; $self-&gt;{leftTable},
    rightIdxPath =&gt; $self-&gt;{leftIdxPath},
    leftFields =&gt; $self-&gt;{rightFields},
    rightFields =&gt; $self-&gt;{leftFields},
    fieldsLeftFirst =&gt; !$self-&gt;{fieldsLeftFirst},
    fieldsMirrorKey =&gt; $fieldsMirrorKey,
    by =&gt; \@rightby,
    isLeft =&gt; $rightLeft,
    automatic =&gt; 1,
    oppositeOuter =&gt; ($leftLeft &amp;&amp; !$self-&gt;{overrideSimpleMinded}),
    groupSizeCode =&gt; $self-&gt;{rightGroupSizeCode},
    saveJoinerTo =&gt; $self-&gt;{rightSaveJoinerTo},
  );

  # create the output label
  $self-&gt;{outputLabel} = $self-&gt;{unit}-&gt;makeDummyLabel($self-&gt;{leftLookup}-&gt;getResultRowType(), $self-&gt;{name} . ".out");

  # and connect them together
  $self-&gt;{leftFromLabel}-&gt;chain($self-&gt;{leftLookup}-&gt;getInputLabel());
  $self-&gt;{rightFromLabel}-&gt;chain($self-&gt;{rightLookup}-&gt;getInputLabel());
  $self-&gt;{leftLookup}-&gt;getOutputLabel()-&gt;chain($self-&gt;{outputLabel});
  $self-&gt;{rightLookup}-&gt;getOutputLabel()-&gt;chain($self-&gt;{outputLabel});</pre><p>
		In the end it boils down to two LookupJoins, with the options
		computed from the JoinTwo's options. But you might notice that there
		are a few LookupJoin options that haven't been described before.
		</p><p>
		Despite the title of the section, these options aren't really hidden,
		just they aren't particularly useful unless you want to use a
		LookupJoin as a part of a multi-sided join, like JoinTwo does. It's
		even hard to explain what do they do without explaining the JoinTwo
		first. If you're not interested in such details, you can as well skip
		them.
		</p><p>
		So, setting
		</p><pre class="programlisting">  oppositeOuter =&gt; 1,</pre><p>
		tells that this LookupJoin is a part of an outer join, with the
		opposite side (right side, for this LookupJoin) being an outer one
		(well, this side might be outer too if <code class="computeroutput">isLeft =&gt; 1</code>, but that's a
		whole separate question). This enables the logic that checks whether
		the row inserted here is the first one that matches a row in the
		right-side table, and whether the row deleted here was the last one
		that matches. If the condition is satisfied, not a simple INSERT or
		DELETE rowop is produced but a correct DELETE-INSERT pair that replaces
		the old state with the new one. It has been described in detail in
		<a class="xref" href="#sc_joins_jointwo" title="12.8. JoinTwo joins two tables">Section 12.8: &#8220;JoinTwo joins two tables&#8221; </a>.
		</p><p>
		But how does it know whether the current row if the first one or last
		one or neither? After all, LookupJoin doesn't have any access to the
		left-side table. 
		</p><p>
		It has two ways to know.
		First, by default it simply assumes that it's an one-to-something (1:1
		or 1:M) join. Then there may be no more than one matching row on this
		side, and every row inserted is the first one, and every row deleted is
		the last one. Then it does the DELETE-INSERT trick every time.
		</p><p>
		Second, the option
		</p><pre class="programlisting">  groupSizeCode =&gt; \&amp;groupSizeComputation,</pre><p>
		can be used to compute the current group size for the current row. It
		provides a function that does the computation and gets called as
		</p><pre class="programlisting">$gsz = &amp;{$self-&gt;{groupSizeCode}}($opcode, $row);</pre><p>
		Note that it doesn't get the table reference nor the index type
		reference as arguments, so it has to be a closure with the references compiled into
		it. JoinTwo does it with the definition
		</p><pre class="programlisting">sub { # (opcode, row)
  $table-&gt;groupSizeIdx($ixt, $_[1]);
}</pre><p>
		Why not just pass the table and index type references to JoinTwo and
		let it do the same computation without the mess of the closure
		references? Because the group size computation may need to be
		different. When the JoinTwo does a self-join, it feeds the left side
		from the table's Pre label, and the normal group size computation would
		be incorrect because the rowop didn't get applied to the table yet.
		Instead it has to predict what will happen when the rowop will get
		applied:
		</p><pre class="programlisting">sub { # (opcode, row)
  if (&amp;Triceps::isInsert($_[0])) {
    $table-&gt;groupSizeIdx($ixt, $_[1])+1;
  } else {
    $table-&gt;groupSizeIdx($ixt, $_[1])-1;
  }
}</pre><p>
		If you set the option <span class="quote">&#8220;<span class="quote">groupSizeCode</span>&#8221;</span> to <code class="computeroutput">undef</code>, that's the default
		value that triggers the one-to-something behavior.
		</p><p>
		The option
		</p><pre class="programlisting">  fieldsMirrorKey =&gt; 1,</pre><p>
		has been already described.
		It enables another magic behavior: mirroring the values of key fields to
		both sides before they are used to produce the result row.  This is the heavy
		machinery that underlies the JoinTwo's high-level option
		<span class="quote">&#8220;<span class="quote">fieldsUniqKey</span>&#8221;</span>. But it hasn't been described yet that
		the mirroring goes both ways: If this is a left join
		and no matching row is found on the right, the values of the key fields
		will be copied from the left to the right. If the option
		<span class="quote">&#8220;<span class="quote">oppositeOuter</span>&#8221;</span> is set and causes a row with the empty left side to be
		produced as a part of DELETE-INSERT pair, the key fields will be copied
		from the right to the left.
		</p></div></div><div class="chapter" title="Chapter 13. Time processing"><div class="titlepage"><div><div><h2 class="title"><a name="ch_time"></a>Chapter 13. Time processing</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_time_limited">13.1. Time-limited propagation</a></span></dt><dt><span class="sect1"><a href="#sc_time_periodic">13.2. Periodic updates</a></span></dt><dt><span class="sect1"><a href="#sc_time_issues">13.3. The general issues of time processing</a></span></dt></dl></div><div class="sect1" title="13.1. Time-limited propagation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_time_limited"></a>13.1. Time-limited propagation</h2></div></div></div><a class="indexterm" name="id502472"></a><a class="indexterm" name="id473037"></a><p>
		When aggregating data, often the results of the aggregation stay
		relevant longer than the original data.
		</p><p>
		For example, in the financials the data gets collected and aggregated
		for the current business day. After the day is closed, the day's
		detailed data are not interesting any more, and can be deleted in
		preparation for the next day. However the daily results stay
		interesting for a long time, and may even be archived for years.
		</p><p>
		This is not limited to the financials. A long time ago, in the times of
		slow and expensive Internet connections, I've done a traffic accounting
		system. It did the same: as the time went by, less and less detail was
		kept about the traffic usage. The modern accounting of the
		click-through advertisement also works in a similar way.
		</p><a class="indexterm" name="id485368"></a><p>
		An easy way to achieve this result is to put a filter on the way of the
		aggregation results. It would compare the current idea of time and the
		time in the rows going by, and throw away the rows that are too old.
		This can be done as a label that gets the data from the aggregator and
		then forwards or doesn't forward the data to the real destination,
		and has been already shown. This solves the
		propagation problem but as the obsolete original data gets deleted, the
		aggregator will still be churning and producing the updates, only to
		have them thrown away at the filter. A more efficient way is to stop
		the churn by placing the filter right into the aggregator.
		</p><a class="indexterm" name="id476141"></a><p>
		The next example demonstrates such an aggregator, in a simplified
		version of that traffic accounting system that I've once done. The
		example is actually about more than just stopping the data propagation.
		That stopping accounts for about three lines in it. But I also want to show
		a simple example of traffic accounting as such. And to show that the
		lack of the direct time support in Triceps does not stop you from doing
		any time-based processing. Because of this I'll show the whole example
		and not just snippets from it. But since the example is biggish, I'll
		paste it into the text in pieces with commentaries for each piece.
		</p><pre class="programlisting">our $uTraffic = Triceps::Unit-&gt;new("uTraffic");

# one packet's header
our $rtPacket = Triceps::RowType-&gt;new(
  time =&gt; "int64", # packet's timestamp, microseconds
  local_ip =&gt; "string", # string to make easier to read
  remote_ip =&gt; "string", # string to make easier to read
  local_port =&gt; "int32",
  remote_port =&gt; "int32",
  bytes =&gt; "int32", # size of the packet
);

# an hourly summary
our $rtHourly = Triceps::RowType-&gt;new(
  time =&gt; "int64", # hour's timestamp, microseconds
  local_ip =&gt; "string", # string to make easier to read
  remote_ip =&gt; "string", # string to make easier to read
  bytes =&gt; "int64", # bytes sent in an hour
);</pre><p>
		The router to the ISP forwards us the packet header
		information from all the packets that go though the outside link. The
		<code class="computeroutput">local_ip</code> is always the address of a machine on our network, <code class="computeroutput">remote_ip</code>
		outside our network, no matter in which direction the packet went. With
		a slow and expensive connection, we want to know two things: First,
		that the provider's billing at the end of the month is correct. Second,
		to be able to find out the high traffic users, when was the traffic
		used, and then maybe look at the remote addresses and decide
		whether that traffic was used for the business purposes or not.
		This example goes up to aggregation of the hourly summaries and then
		stops, since the further aggregation by days and months is
		straightforward to do.
		</p><a class="indexterm" name="id486506"></a><p>
		If there is no traffic for a while, the router is expected to
		periodically communicate its changing idea of time as the same kind of
		records but with the non-timestamp fields as NULLs. That by the way is
		the right way to communicate the time-based information between two
		machines: do not rely on any local synchronization and timeouts but
		have the master send the periodic time updates to the slave even if it
		has no data to send. The logic is then driven by the time reported by
		the master. A nice side effect is that the logic can also easily be
		replayed later, using these timestamps and without any concern of the
		real time. If there are multiple masters, the slave would have to order
		the data coming from them according to the timestamps, thus
		synchronizing them together.
		</p><p>
		The hourly data drops the port information, and sums up the traffic
		between two addresses in the hour. It still has the timestamp but now
		this timestamp is rounded to the start of the hour:
		</p><pre class="programlisting"># compute an hour-rounded timestamp
sub hourStamp # (time)
{
  return $_[0]  - ($_[0] % (1000*1000*3600));
}</pre><p>
		Next, to the aggregation. The SimpleAggregator has no provision
		for filtering in it, the aggregation has to be done raw.
		</p><pre class="programlisting"># the current hour stamp that keeps being updated
our $currentHour;

# aggregation handler: recalculate the summary for the last hour
sub computeHourly # (table, context, aggop, opcode, rh, state, args...)
{
  my ($table, $context, $aggop, $opcode, $rh, $state, @args) = @_;
  our $currentHour;

  # don't send the NULL record after the group becomes empty
  return if ($context-&gt;groupSize()==0
    || $opcode == &amp;Triceps::OP_NOP);

  my $rhFirst = $context-&gt;begin();
  my $rFirst = $rhFirst-&gt;getRow();
  my $hourstamp = &amp;hourStamp($rFirst-&gt;get("time"));

  return if ($hourstamp &lt; $currentHour);

  if ($opcode == &amp;Triceps::OP_DELETE) {
    $context-&gt;send($opcode, $$state);
    return;
  }

  my $bytes = 0;
  for (my $rhi = $rhFirst; !$rhi-&gt;isNull();
      $rhi = $context-&gt;next($rhi)) {
    $bytes += $rhi-&gt;getRow()-&gt;get("bytes");
  }

  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    time =&gt; $hourstamp,
    local_ip =&gt; $rFirst-&gt;get("local_ip"),
    remote_ip =&gt; $rFirst-&gt;get("remote_ip"),
    bytes =&gt; $bytes,
  );
  ${$state} = $res;
  $context-&gt;send($opcode, $res);
}

sub initHourly #  (@args)
{
  my $refvar;
  return \$refvar;
}</pre><p>
		The aggregation doesn't try to optimize by being additive, to keep the
		example simpler. The model keeps the notion of the current hour. As
		soon as the hour stops being current, the aggregation for it stops. The
		result of that aggregation will then be kept unchanged in the hourly
		result table, no matter what happens to the original data.
		</p><p>
		The tables are defined and connected thusly:
		</p><pre class="programlisting"># the full stats for the recent time
our $ttPackets = Triceps::TableType-&gt;new($rtPacket)
  -&gt;addSubIndex("byHour",
    Triceps::IndexType-&gt;newPerlSorted("byHour", undef, sub {
      return &amp;hourStamp($_[0]-&gt;get("time")) &lt;=&gt; &amp;hourStamp($_[1]-&gt;get("time"));
    })
    -&gt;addSubIndex("byIP",
      Triceps::IndexType-&gt;newHashed(key =&gt; [ "local_ip", "remote_ip" ])
      -&gt;addSubIndex("group",
        Triceps::IndexType-&gt;newFifo()
        -&gt;setAggregator(Triceps::AggregatorType-&gt;new(
          $rtHourly, "aggrHourly", \&amp;initHourly, \&amp;computeHourly)
        )
      )
    )
  )
;

$ttPackets-&gt;initialize();
our $tPackets = $uTraffic-&gt;makeTable($ttPackets, "tPackets");

# the aggregated hourly stats, kept longer
our $ttHourly = Triceps::TableType-&gt;new($rtHourly)
  -&gt;addSubIndex("byAggr",
    Triceps::SimpleOrderedIndex-&gt;new(
      time =&gt; "ASC", local_ip =&gt; "ASC", remote_ip =&gt; "ASC")
  )
;

$ttHourly-&gt;initialize();
our $tHourly = $uTraffic-&gt;makeTable($ttHourly, "tHourly");

# connect the tables
$tPackets-&gt;getAggregatorLabel("aggrHourly")-&gt;chain($tHourly-&gt;getInputLabel());</pre><p>
		The table of incoming packets has a 3-level index: it starts with being
		sorted by the hour part of the timestamp, then goes by the ip addresses
		to complete the aggregation key, and then a FIFO for each aggregation
		group. Arguably, maybe it would have been better to include the ip
		addresses straight into the top-level sorting index, I don't know, and
		it doesn't seem worth measuring. The top-level ordering by the hour is
		important, it will be used to delete the rows that have become old.
		</p><a class="indexterm" name="id464427"></a><p>
		The table of hourly aggregated stats uses the same kind of index, only
		now there is no need for a FIFO because there is only one row per this
		key. And the timestamp is already rounded to the hour right in the
		rows, so a SimpleOrderedIndex can be used without writing a manual
		comparison function, and the ip fields have been merged into it too.
		</p><p>
		The output of the aggregator on the packets table is connected to the
		input of the hourly table.
		</p><pre class="programlisting"># label to print the changes to the detailed stats
makePrintLabel("lbPrintPackets", $tPackets-&gt;getOutputLabel());
# label to print the changes to the hourly stats
makePrintLabel("lbPrintHourly", $tHourly-&gt;getOutputLabel());

# dump a table's contents
sub dumpTable # ($table)
{
  my $table = shift;
  for (my $rhit = $table-&gt;begin(); !$rhit-&gt;isNull(); $rhit = $rhit-&gt;next()) {
    print($rhit-&gt;getRow()-&gt;printP(), "\n");
  }
}

# how long to keep the detailed data, hours
our $keepHours = 2;

# flush the data older than $keepHours from $tPackets
sub flushOldPackets
{
  my $earliest = $currentHour - $keepHours * (1000*1000*3600);
  my $next;
  # the default iteration of $tPackets goes in the hour stamp order
  for (my $rhit = $tPackets-&gt;begin(); !$rhit-&gt;isNull(); $rhit = $next) {
    last if (&amp;hourStamp($rhit-&gt;getRow()-&gt;get("time")) &gt;= $earliest);
    $next = $rhit-&gt;next(); # advance before removal
    $tPackets-&gt;remove($rhit);
  }
}</pre><p>
		The print labels generate the debugging output that shows what is going
		on with both tables.  Next go a couple of helper functions.
		</p><p>
		The <code class="computeroutput">dumpTable()</code> is a straightforward iteration through a table and
		print. It can be used on any table, <code class="computeroutput">printP()</code> takes care of any
		differences.
		</p><p>
		The flushing goes through the packets table and deletes the rows that
		belong to an older hour than the current one or <code class="computeroutput">$keepHours</code> before it.
		For this to work right, the rows must go in the order of the hour
		stamps, which the outer index <span class="quote">&#8220;<span class="quote">byHour</span>&#8221;</span> takes care of.
		</p><p>
		All the time-related logic expects that the time never goes backwards.
		This is a simplification to make the example shorter, a production code
		can not assume this.
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "new") {
    my $rowop = $tPackets-&gt;getInputLabel()-&gt;makeRowopArray(@data);
    # update the current notion of time (simplistic)
    $currentHour = &amp;hourStamp($rowop-&gt;getRow()-&gt;get("time"));
    if (defined($rowop-&gt;getRow()-&gt;get("local_ip"))) {
      $uTraffic-&gt;call($rowop);
    }
    &amp;flushOldPackets(); # flush the packets
    $uTraffic-&gt;drainFrame(); # just in case, for completeness
  } elsif ($type eq "dumpPackets") {
    &amp;dumpTable($tPackets);
  } elsif ($type eq "dumpHourly") {
    &amp;dumpTable($tHourly);
  }
}</pre><p>
		The final part is the main loop.
		The input comes in the CSV form as a command followed by more data. If
		the command is <span class="quote">&#8220;<span class="quote">new</span>&#8221;</span> then the data is the opcode and data fields, as it
		would be sent by the router. The commands <span class="quote">&#8220;<span class="quote">dumpPackets</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">dumpHourly</span>&#8221;</span> are used to print the contents of the tables, to see, what
		is going on in them.
		</p><p>
		In an honest implementation there would be a separate label that would
		differentiate between a reported packet and just a time update from the
		router. Here for simplicity this logic is placed right into the main
		loop. On each input record it updates the model's idea of the current
		timestamp, then if there is a packet data, it gets processed, and
		finally the rows that have become too old for the new timestamp get
		flushed.
		</p><p>
		Now a run of the model. Its printout is also broken up into the
		separately commented pieces. Of course, it's not like a real run, it
		just contains one or two packets per hour to show how things work.
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330886011000000,1.2.3.4,5.6.7.8,2000,80,100</strong></span>
tPackets.out OP_INSERT time="1330886011000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="100"
tHourly.out OP_INSERT time="1330884000000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="100"
<span class="bold"><strong>new,OP_INSERT,1330886012000000,1.2.3.4,5.6.7.8,2000,80,50</strong></span>
tHourly.out OP_DELETE time="1330884000000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="100"
tPackets.out OP_INSERT time="1330886012000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="50"
tHourly.out OP_INSERT time="1330884000000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="150"</pre><p>
		The two input rows in the first hour refer to the same connection, so
		they go into the same group and get aggregated together in the hourly
		table. The rows for the current hour in the hourly table get updated
		immediately as more data comes in. The <code class="computeroutput">tHourly.out OP_DELETE</code>
		comes out even before <code class="computeroutput">tPackets.out OP_INSERT</code> because it's
		driven by the output of the aggregator on <code class="computeroutput">$tPackets</code>, and the operation
		<code class="computeroutput">AO_BEFORE_MOD</code> on the aggregator that drives the deletion
		is executed before <code class="computeroutput">$tPackets</code> gets modified.
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330889811000000,1.2.3.4,5.6.7.8,2000,80,300</strong></span>
tPackets.out OP_INSERT time="1330889811000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="300"
tHourly.out OP_INSERT time="1330887600000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="300"</pre><p>
		Only one packet arrives in the next hour. 
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330894211000000,1.2.3.5,5.6.7.9,3000,80,200</strong></span>
tPackets.out OP_INSERT time="1330894211000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" local_port="3000" remote_port="80" bytes="200"
tHourly.out OP_INSERT time="1330891200000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" bytes="200"
<span class="bold"><strong>new,OP_INSERT,1330894211000000,1.2.3.4,5.6.7.8,2000,80,500</strong></span>
tPackets.out OP_INSERT time="1330894211000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="500"
tHourly.out OP_INSERT time="1330891200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="500"</pre><p>
		And two more packets in the next hour. They are for the different
		connections, so they do not get summed together in the aggregation.
		When the hour changes again, the old data will start being deleted
		(because of <code class="computeroutput">$keepHours = 2</code>, which ends up keeping the
		current hour and two before it), so
		let's take a snapshot of the tables' contents.
		</p><pre class="programlisting"><span class="bold"><strong>dumpPackets</strong></span>
time="1330886011000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="100"
time="1330886012000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="50"
time="1330889811000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="300"
time="1330894211000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="500"
time="1330894211000000" local_ip="1.2.3.5" remote_ip="5.6.7.9"
    local_port="3000" remote_port="80" bytes="200"
<span class="bold"><strong>dumpHourly</strong></span>
time="1330884000000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="150"
time="1330887600000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="300"
time="1330891200000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="500"
time="1330891200000000" local_ip="1.2.3.5" remote_ip="5.6.7.9"
    bytes="200"</pre><p>
		The packets table shows all the 5 packets received so far, and the
		hourly aggregation results for all 3 hours (with two separate
		aggregation groups in the same last hour, for different ip pairs).
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330896811000000,1.2.3.5,5.6.7.9,3000,80,10</strong></span>
tPackets.out OP_INSERT time="1330896811000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" local_port="3000" remote_port="80" bytes="10"
tHourly.out OP_INSERT time="1330894800000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" bytes="10"
tPackets.out OP_DELETE time="1330886011000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="100"
tPackets.out OP_DELETE time="1330886012000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="50"</pre><p>
		When the next hour's packet arrives, it gets processed as usual, but
		then the removal logic finds the packet rows that have become too old
		to keep. It kicks in and deletes them. But notice that the deletions
		affect only the packets table, the aggregator ignores this activity as
		too old and does not propagate it to the hourly table. 
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330900411000000,1.2.3.4,5.6.7.8,2000,80,40</strong></span>
tPackets.out OP_INSERT time="1330900411000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="40"
tHourly.out OP_INSERT time="1330898400000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="40"
tPackets.out OP_DELETE time="1330889811000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="300"</pre><p>
		One more hour's packet, flushes out the data for another hour. 
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330904011000000</strong></span>
tPackets.out OP_DELETE time="1330894211000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="500"
tPackets.out OP_DELETE time="1330894211000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" local_port="3000" remote_port="80" bytes="200"</pre><p>
		And just a time update for another hour, when no packets have been
		received. The removal logic still kicks in and works the same
		way, deleting raw data for one more hour. After all this activity let's
		dump the tables again:
		</p><pre class="programlisting"><span class="bold"><strong>dumpPackets</strong></span>
time="1330896811000000" local_ip="1.2.3.5" remote_ip="5.6.7.9"
    local_port="3000" remote_port="80" bytes="10"
time="1330900411000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="40"
<span class="bold"><strong>dumpHourly</strong></span>
time="1330884000000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="150"
time="1330887600000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="300"
time="1330891200000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="500"
time="1330891200000000" local_ip="1.2.3.5" remote_ip="5.6.7.9"
    bytes="200"
time="1330894800000000" local_ip="1.2.3.5" remote_ip="5.6.7.9"
    bytes="10"
time="1330898400000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="40"</pre><p>
		The packets table only has the data for the last 3 hours (there are no
		rows for the last hour because none have arrived). But the hourly table
		contains all the history. The rows weren't getting deleted here.
		</p></div><div class="sect1" title="13.2. Periodic updates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_time_periodic"></a>13.2. Periodic updates</h2></div></div></div><a class="indexterm" name="id529077"></a><a class="indexterm" name="id529091"></a><p>
		In the previous example if we keep aggregating the data from hours to days
		and the days to months, then the arrival of each new packet will update
		the whole chain. Sometimes that's what we want, sometimes it isn't. The
		daily stats might be fed into some complicated computation, with nobody
		looking at the results until the next day. In this situation each
		packet will trigger these complicated computations, for no good reason,
		since nobody cares for them until the day is closed.
		</p><p>
		These unnecessary computations can be prevented by disconnecting the
		daily data from the hourly data, and performing the manual aggregation
		only when the day changes. Then these complicated computations would
		happen only once a day, not many times per second.
		</p><p>
		Here is how the last example gets amended to produce the once-a-day
		daily summaries of all the traffic (as before, in multiple snippets,
		this time showing only the added or changed code):
		</p><pre class="programlisting"># an hourly summary, now with the day extracted
our $rtHourly = Triceps::RowType-&gt;new(
  time =&gt; "int64", # hour's timestamp, microseconds
  day =&gt; "string", # in YYYYMMDD
  local_ip =&gt; "string", # string to make easier to read
  remote_ip =&gt; "string", # string to make easier to read
  bytes =&gt; "int64", # bytes sent in an hour
);

# a daily summary: just all traffic for that day
our $rtDaily = Triceps::RowType-&gt;new(
  day =&gt; "string", # in YYYYMMDD
  bytes =&gt; "int64", # bytes sent in an hour
);</pre><p>
		The hourly rows get an extra field, for convenient aggregation by day.
		And the daily rows are introduced.
		The notion of the day is calculated as:
		</p><pre class="programlisting"># compute the date of a timestamp, a string YYYYMMDD
sub dateStamp # (time)
{
  my @ts = gmtime($_[0]/1000000); # microseconds to seconds
  return sprintf("%04d%02d%02d", $ts[5]+1900, $ts[4]+1, $ts[3]);
}

# the current hour stamp that keeps being updated
our $currentHour = undef;
# the current day stamp that keeps being updated
our $currentDay = undef;</pre><p>
		The calculation is done in GMT, so that the code produces the same
		result all around the world. If you're doing this kind of project for
		real, you may want to use the local time zone instead (but be careful
		with the changing daylight saving time).
		</p><p>
		And the model keeps a global notion of the current day in addition to
		the current hour.
		</p><pre class="programlisting"># aggregation handler: recalculate the summary for the last hour
sub computeHourlywDay # (table, context, aggop, opcode, rh, state, args...)
{
...
  my $res = $context-&gt;resultType()-&gt;makeRowHash(
    time =&gt; $hourstamp,
    day =&gt; &amp;dateStamp($hourstamp),
    local_ip =&gt; $rFirst-&gt;get("local_ip"),
    remote_ip =&gt; $rFirst-&gt;get("remote_ip"),
    bytes =&gt; $bytes,
  );
  ${$state} = $res;
  $context-&gt;send($opcode, $res);
}</pre><p>
		The packets-to-hour aggregation function now populates this extra field,
		the rest of it stays the same.
		</p><pre class="programlisting"># the aggregated hourly stats, kept longer
our $ttHourly = Triceps::TableType-&gt;new($rtHourly)
  -&gt;addSubIndex("byAggr",
    Triceps::SimpleOrderedIndex-&gt;new(
      time =&gt; "ASC", local_ip =&gt; "ASC", remote_ip =&gt; "ASC")
  )
  -&gt;addSubIndex("byDay",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "day" ])
    -&gt;addSubIndex("group",
      Triceps::IndexType-&gt;newFifo()
    )
  )
;

$ttHourly-&gt;initialize();
our $tHourly = $uTraffic-&gt;makeTable($ttHourly, "tHourly");

# remember the daily secondary index type
our $idxHourlyByDay = $ttHourly-&gt;findSubIndex("byDay");
our $idxHourlyByDayGroup = $idxHourlyByDay-&gt;findSubIndex("group");</pre><p>
		The hourly table type grows an extra secondary index for the manuall
		aggregation into the daily data.
		</p><pre class="programlisting"># the aggregated daily stats, kept even longer
our $ttDaily = Triceps::TableType-&gt;new($rtDaily)
  -&gt;addSubIndex("byDay",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "day" ])
  )
;

$ttDaily-&gt;initialize();
our $tDaily = $uTraffic-&gt;makeTable($ttDaily, "tDaily");

# label to print the changes to the daily stats
makePrintLabel("lbPrintDaily", $tDaily-&gt;getOutputLabel());</pre><p>
		And a table for the daily data is created but not connected to any
		other tables.
		</p><p>
		Instead it gets updated manually with the function that performs the
		manual aggregation of the hourly data:
		</p><pre class="programlisting"># the manual aggregation of a day's data
sub computeDay # ($dateStamp)
{
  our $uTraffic;
  my $bytes = 0;

  my $rhFirst = $tHourly-&gt;findIdxBy($idxHourlyByDay, day =&gt; $_[0]);
  my $rhEnd = $rhFirst-&gt;nextGroupIdx($idxHourlyByDayGroup);
  for (my $rhi = $rhFirst;
      !$rhi-&gt;same($rhEnd); $rhi = $rhi-&gt;nextIdx($idxHourlyByDay)) {
    $bytes += $rhi-&gt;getRow()-&gt;get("bytes");
  }
  $uTraffic-&gt;makeHashCall($tDaily-&gt;getInputLabel(), "OP_INSERT",
    day =&gt; $_[0],
    bytes =&gt; $bytes,
  );
}</pre><p>
		This logic doesn't check whether any data for that day existed. If none
		did, it would just produce a row with traffic of 0 bytes anyway. This
		is different from the normal aggregation but here may actually be
		desirable: it shows for sure that yes, the aggregation for that day
		really did happen.
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "new") {
    my $rowop = $tPackets-&gt;getInputLabel()-&gt;makeRowopArray(@data);
    # update the current notion of time (simplistic)
    $currentHour = &amp;hourStamp($rowop-&gt;getRow()-&gt;get("time"));
    my $lastDay = $currentDay;
    $currentDay = &amp;dateStamp($currentHour);
    if (defined($rowop-&gt;getRow()-&gt;get("local_ip"))) {
      $uTraffic-&gt;call($rowop);
    }
    &amp;flushOldPackets(); # flush the packets
    if (defined $lastDay &amp;&amp; $lastDay ne $currentDay) {
      &amp;computeDay($lastDay); # manual aggregation
    }
    $uTraffic-&gt;drainFrame(); # just in case, for completeness
  } elsif ($type eq "dumpPackets") {
    &amp;dumpTable($tPackets);
  } elsif ($type eq "dumpHourly") {
    &amp;dumpTable($tHourly);
  } elsif ($type eq "dumpDaily") {
    &amp;dumpTable($tDaily);
  }
}</pre><p>
		The main loop gets extended with the day-keeping logic and with the
		extra command to dump the daily data.
		It now maintains the current day, and after the packet computation is
		done, looks, whether the day has changed. If it did, it calls the
		manual aggregation of the last day.
		</p><p>
		And here is an example of its work:
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330886011000000,1.2.3.4,5.6.7.8,2000,80,100</strong></span>
tPackets.out OP_INSERT time="1330886011000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="100"
tHourly.out OP_INSERT time="1330884000000000" day="20120304"
    local_ip="1.2.3.4" remote_ip="5.6.7.8" bytes="100"
<span class="bold"><strong>new,OP_INSERT,1330886012000000,1.2.3.4,5.6.7.8,2000,80,50</strong></span>
tHourly.out OP_DELETE time="1330884000000000" day="20120304"
    local_ip="1.2.3.4" remote_ip="5.6.7.8" bytes="100"
tPackets.out OP_INSERT time="1330886012000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="50"
tHourly.out OP_INSERT time="1330884000000000" day="20120304"
    local_ip="1.2.3.4" remote_ip="5.6.7.8" bytes="150"
<span class="bold"><strong>new,OP_INSERT,1330889811000000,1.2.3.4,5.6.7.8,2000,80,300</strong></span>
tPackets.out OP_INSERT time="1330889811000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="300"
tHourly.out OP_INSERT time="1330887600000000" day="20120304"
    local_ip="1.2.3.4" remote_ip="5.6.7.8" bytes="300"</pre><p>
		So far all the 3 packets are for the same day, and nothing new has
		happened. 
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330972411000000,1.2.3.5,5.6.7.9,3000,80,200</strong></span>
tPackets.out OP_INSERT time="1330972411000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" local_port="3000" remote_port="80" bytes="200"
tHourly.out OP_INSERT time="1330970400000000" day="20120305"
    local_ip="1.2.3.5" remote_ip="5.6.7.9" bytes="200"
tPackets.out OP_DELETE time="1330886011000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="100"
tPackets.out OP_DELETE time="1330886012000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="50"
tPackets.out OP_DELETE time="1330889811000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="300"
tDaily.out OP_INSERT day="20120304" bytes="450"</pre><p>
		When a packet for the next day arrives, it has three effects: 
		</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
		inserts the packet data as usual, 
		</li><li class="listitem">
		finds that the previous packet data is obsolete and flushes it (without
		upsetting the hourly summaries), and 
		</li><li class="listitem">
		finds that the day has changed and performs the
		manual aggregation of last day's hourly data into daily.
		</li></ol></div><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1331058811000000</strong></span>
tPackets.out OP_DELETE time="1330972411000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" local_port="3000" remote_port="80" bytes="200"
tDaily.out OP_INSERT day="20120305" bytes="200"</pre><p>
		A time update for the yet next day flushes out the previous day's
		detailed packets and again builds the daily summary of that day.
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1331145211000000</strong></span>
tDaily.out OP_INSERT day="20120306" bytes="0"</pre><p>
		Yet another day's time roll now has no old data to delete (since none
		arrived in the previous day) but still produces the daily summary of 0
		bytes.
		</p><pre class="programlisting"><span class="bold"><strong>dumpDaily</strong></span>
day="20120305" bytes="200"
day="20120304" bytes="450"
day="20120306" bytes="0"</pre><p>
		This shows the eventual contents of the daily summaries. The order of
		the rows is fairly random, because of the hashed index. Note that the
		hourly summaries weren't flushed either, they are all still there too.
		If you want them eventually deleted after some time, you would need to
		provide more of the manual logic for that.
		</p></div><div class="sect1" title="13.3. The general issues of time processing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_time_issues"></a>13.3. The general issues of time processing</h2></div></div></div><a class="indexterm" name="id534406"></a><p>
		After a couple of examples, it's time to do some generalizations.
		What these examples did manually, with the data expiration
		by time, the more mature CEP systems do internally, using the
		statements for the time-based work.
		</p><p>
		Which isn't always better though. The typical issues are with:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		fast replay of data,
		</li><li class="listitem">
		order of execution,
		</li><li class="listitem">
		synchronization between modules.
		</li></ul></div><a class="indexterm" name="id534441"></a><a class="indexterm" name="id534451"></a><a class="indexterm" name="id534460"></a><a class="indexterm" name="id534470"></a><p>
		The problem with the fast replay is that those time based-statements
		use the real time and not the timestamps from the incoming rows. Sure,
		in Coral8 you can use the incoming row timestamps but they still are
		expected to have the time generally synchronized with the local clock
		(they are an attempt to solve the inter-module synchronization problem,
		not fast replay). You can't run them fast. And considering the Coral8
		fashion of dropping the data when the input buffer overflows, you don't
		want to feed the data into it too fast to start with. In the Aleri
		system you can accelerate the time but it's by a fixed factor. You can
		run the logical time there say 10 times faster and feed the data 10
		times faster but there are no timestamps in the input rows, and you
		simply can't feed the data precisely enough to reproduce the exact
		timing. And 10 times faster is not the same thing as just as fast as
		possible. I don't know for sure what the StreamBase does, it seems to
		have the time acceleration by a fixed rate too. Esper apparently
		allows the full control over timing, but I don't know much about it.
		</p><p>
		Your typical problem with fast replay in Coral8/CCL is this: you create
		a time limited window
		</p><pre class="programlisting">create window ... keep 3 hours;</pre><p>
		and then feed the data for a couple of days in say 20 minutes. Provided
		that you don't feed it too fast and none of it gets dropped, all of the
		data ends up in the window and none of it expires, since the window
		goes by the physical time, and the physical time was only 20 minutes.
		The first issue is that you may not have enough memory to store the
		data for two days, and everything would run out of memory and crash.
		The second issue is that if you want to do some time-based aggregation
		relying on the window expiration, you're out of luck.
		</p><p>
		Why would you want to feed the data so fast in the first place? Two reasons:
		</p><div class="orderedlist"><a class="indexterm" name="id534527"></a><a class="indexterm" name="id534537"></a><ol class="orderedlist" type="1"><li class="listitem">
		Testing. When you test your time-based logic, you don't want your unit
		test to take 3 hours, let alone multiple days. You also want your unit
		tests to be fully repeatable, without any fuzz.
		</li><li class="listitem">
		State restoration after a planned shutdown or crash. No matter what
		everyone says, the built-in persistence features work right only for a
		small subset of the simple models. Getting the persistence work for the
		more complex models is difficult, and for all I know nobody has
		bothered to get it working right. The best approach in reality is to
		preserve a subset of the state, and get the rest of it by replaying the
		recent input data after restart. The faster you re-feed the data, the
		faster your model comes back online. (Incidentally, that's what Aleri
		does with the <span class="quote">&#8220;<span class="quote">persistent source streams</span>&#8221;</span>, only losing all the timing
		information of the rows and having the same above-mentioned issue as
		CCL).
		</li></ol></div><a class="indexterm" name="id528239"></a><p>
		Next issue, the execution order. The last example was relying on
		<code class="computeroutput">$currentHour</code> being updated before <code class="computeroutput">flushOldPackets()</code> runs. Otherwise the
		deletions would propagate through the aggregator where they should
		not. In a system like Aleri with each element running in its own
		thread there is no way to ensure any particular timing between the
		threads. In a system with single-threaded logic, like Coral8/Sybase or
		StreamBase, there is a way. But getting the order right is tricky. It
		depends on what the compiler and scheduler decide, and may require a
		few attempts to get the order right. 
		Well, technically, Aleri can control the time too: you can run in
		artificial time, setting and stopping it. So you can stop the time, set
		to record timestamp, feed the record, wait for processing to complete,
		advance time, wait for any time-based processing to complete, and so
		on. I'm not sure if it made to Sybase R5, but it definitely worked on
		Aleri. However there was no tool that did it for you easily, and also
		all these synchronous calls present a pretty high overhead.
		</p><p>
		The procedural execution makes things much more straightforward.
		</p><p>
		Now, the synchronization between modules. When the data is passed
		between multiple threads or processes, there is always a jigger in the
		way the data goes through the inter-process communications and even
		more so through the network. Relying on the timing of the data after it
		arrives is usually a bad idea if you want to get any repeatability and
		precision. Instead the data has to be timestamped by the sender and
		then these timestamps used by the receiver instead of the real time.
		</p><p>
		And Coral8 allows you to do so. But what if there is no data coming?
		What do you do with the time-based processing? The Coral8 approach is
		to allow some delay and then proceed at the rate of the local clock.
		Note that the logical time is not exactly the same as the local clock,
		it generally gets behind the local clock by no more than the delay
		amount, or might go faster if the sender's clock goes faster. The
		question is, what delay amount do you choose? If you make it too short,
		the small hiccups in the data flow throw the timing off, the local
		clock runs ahead, and then the incoming data gets thrown away because
		it's too old. If you make it too long, you potentially add a large
		amount of latency. As it turns out, no reasonable amount of delay works
		well with Coral8. To get things working at least sort of reliably, you
		need horrendous delays, on the order of 10 seconds or more. Even then
		the sender may get hit by a long-running request and the connection
		would go haywire anyway. 
		</p><p>
		The only reliable solution is to drive the time completely by the
		sender. Even if there is no data to send, it must still send the
		periodic time updates, and the receiver must use the incoming
		timestamps for its time-based processing. Sending one or even ten
		time-update packets per second is not a whole lot of overhead, and sure
		works much better than the 10-second delays. And along the way it gives
		the perfect repeatability and fast replay for the unit testing. So
		unless your CEP system can be controlled in this way, getting any
		decent distributed timing control requires doing it manually. The
		reality is that Aleri can't, Coral8 can't, the Sybase R4/R5 descended
		from them can't, and I could not find anything related to the time
		control in the StreamBase documentation, so my guess is that it can't
		either.
		</p><p>
		And if you have to control the time-based processing manually, doing it
		in the procedural way is at least easier.
		</p><p>
		An interesting side subject is the relation of the logical time to the
		real time. If the input data arrives faster than the CEP model can
		process it, the logical time will be getting behind the real time. Or
		if the data is fed at the artificially accelerated rate, the logical
		time will be getting ahead of the real time. There could even be a
		combination thereof: making the "real" time also artificial (driven by
		the sender) and artificially make the data get behind it for the
		testing purposes. The getting-behind can be detected and used to change
		the algorithm. For example, if we aggregate the traffic data in
		multiple stages, to the hour, to the day and to the month, the whole
		chain does not have to be updated on every packet Just update the first
		level on every packet, and then propagate further when the traffic
		burst subsides and gives the model a breather.
		</p><p>
		So far the major CEP systems don't seem to have a whole lot of direct
		support for it. There are ways to reduce the load by reducing the
		update frequency to a fixed period (like the <code class="computeroutput">OUTPUT EVERY</code> statement in
		CCL, or periodic subscription in Aleri), but not much of the load-based
		kind. If the system provides ways to get both the real time and logical
		time of the row, the logic can be implemented manually. But the
		optimizations of the time-reading, like in Coral8, might make it
		unstable.
		</p><p>
		The way to do it in Triceps is by handling it in the Perl (or C++) code
		of the main event loop. When it has no data to read, it can create an
		<span class="quote">&#8220;<span class="quote">idle</span>&#8221;</span> row that would push through the results as a more efficient
		batch.
		</p></div></div><div class="chapter" title="Chapter 14. The other templates and solutions"><div class="titlepage"><div><div><h2 class="title"><a name="ch_other"></a>Chapter 14. The other templates and solutions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_other_diamond">14.1. The dreaded diamond</a></span></dt><dt><span class="sect1"><a href="#sc_other_collapse">14.2. Collapsed updates</a></span></dt><dt><span class="sect1"><a href="#sc_other_chunks_del">14.3. Large deletes in small chunks</a></span></dt></dl></div><div class="sect1" title="14.1. The dreaded diamond"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_other_diamond"></a>14.1. The dreaded diamond</h2></div></div></div><a class="indexterm" name="id492997"></a><a class="indexterm" name="id491347"></a><p>
		The <span class="quote">&#8220;<span class="quote">diamond</span>&#8221;</span> is a particular topology of the data flow, when the
		computation separates based on some condition and then merges again.
		Like in
		<a class="xref" href="#fig_other_diamond" title="Figure 14.1. The diamond topology.">Figure 14.1</a>.
		It is also known as <span class="quote">&#8220;<span class="quote">fork-join</span>&#8221;</span> (the <span class="quote">&#8220;<span class="quote">join</span>&#8221;</span> here has nothing to do with
		the SQL join, it just means that the arrows merge to the same block).
		</p><div class="figure"><a name="fig_other_diamond"></a><div class="figure-contents"><div><img src="diamond-000.lowres.png" width="NaN" alt="The diamond topology."></div></div><p class="title"><b>Figure 14.1. The diamond topology.</b></p></div><br class="figure-break"><a class="indexterm" name="id477499"></a><p>
		This topology is a known source of two problems. The first problem is
		about the execution order.  To make things easier to see, let's
		consider a simple example.  Suppose the rows come into the block A with
		the schema:
		</p><pre class="programlisting">key =&gt; string,
value =&gt; int32,</pre><p>
		And come out of the blocks B and C into D with schema
		</p><pre class="programlisting">key =&gt; string,
value =&gt; int32,
negative =&gt; int32,</pre><p>
		With the logic in the blocks being:
		</p><pre class="programlisting">A:
  if value &lt; 0 then B else C
B:
  negative = 1
C:
  negative = 0</pre><p>
		Yes, this is a very dumb example that can usually be handled by a
		conditional expression in a single block. But that's to keep it
		small and simple. A real example would often include some SQL joins, with
		different joins done on condition.
		</p><p>
		Suppose A then gets the input, in CSV form:
		</p><pre class="programlisting">INSERT,key1,10
DELETE,key1,10
INSERT,key1,20
DELETE,key1,20
INSERT,key1,-1</pre><p>
		What arrives at D should be 
		</p><pre class="programlisting">INSERT,key1,10,0
DELETE,key1,10,0
INSERT,key1,20,0
DELETE,key1,20,0
INSERT,key1,-1,1</pre><p>
		And with the first four rows this is not a problem: they follow the
		same path and are queued sequentially, so the order is preserved. But
		the last row follows a different path. And the last two rows logically
		represent a single update and would likely arrive closely together. The
		last row might happen to overtake the one before it, and D would see
		the incorrect result:
		</p><pre class="programlisting">INSERT,key1,10,0
DELETE,key1,10,0
INSERT,key1,20,0
INSERT,key1,-1,1
DELETE,key1,20,0</pre><p>
		If all these input rows arrive closely one after another, the last row
		might overtake even more of them and produce an even more disturbing
		result like
		</p><pre class="programlisting">INSERT,key1,-1,1
INSERT,key1,10,0
DELETE,key1,10,0
INSERT,key1,20,0
DELETE,key1,20,0</pre><p>
		Such misorderings may also happen between the rows with different keys.
		Those are usually less of a problem, because usually if D keeps a
		table, the rows with different keys may be updated in any order without
		losing the meaning. But in case if D keeps a FIFO index (say, for
		a window based on a row count), and the two keys fall into the same
		FIFO bucket, their misordering would also affect the logic.
		</p><p>
		The reasons for this can be subdivided further into two classes:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		asynchronous execution,
		</li><li class="listitem">
		incorrect scheduling in the synchronous execution.
		</li></ul></div><a class="indexterm" name="id534273"></a><p>
		If each block executes asynchronously in its own thread, there is no
		way to predict, in which order they will actually execute. If some data
		is sent to B and C at about the same time, it becomes a race between
		them. One of the paths might also be longer than the other, making one
		alternative always win the race. This kind of problems is fairly common
		for the Aleri system that is highly multithreaded. But this is the
		problem of absolutely any CEP engine if you split the execution by
		multiple threads or processes.
		</p><p>
		But the single-threaded execution is not necessarily a cure either.
		Then the order of execution is up to the scheduler. And if the
		scheduler gets all these rows close together, and then decides to
		process all the input of A, then all the input of B, of C and of D,
		then D will receive the rows in the order:
		</p><pre class="programlisting">INSERT,key1,-1,1
INSERT,key1,10,0
DELETE,key1,10,0
INSERT,key1,20,0
DELETE,key1,20,0</pre><a class="indexterm" name="id534303"></a><p>
		Which is typical for, say, Coral8 if all the input rows arrive in a
		single bundle (see also the 
		<a class="xref" href="#sc_sched_no_bundling" title="7.6. No bundling">Section 7.6: &#8220;No bundling&#8221; </a>).
		</p><p>
		The multithreaded case in Triceps will be discussed separately in
		<a class="xref" href="#sc_mt_main_reorder" title="16.10. The threaded dreaded diamond and data reordering">Section 16.10: &#8220;The threaded dreaded diamond and data reordering&#8221; </a>.
		</p><p>
		When the single-threaded scheduling is concerned, Triceps provides two
		answers.
		</p><p>
		First, the conditional logic can often be expressed procedurally:
		</p><pre class="programlisting">if ($a-&gt;get("value") &lt; 0) {
  D($rtD-&gt;makeRowHash($a-&gt;toHash(), negative =&gt; 1));
} else {
  D($rtD-&gt;makeRowHash($a-&gt;toHash(), negative =&gt; 0));
}</pre><p>
		The procedural if-else logic can easily handle not only the simple
		expressions but things like look-ups and modifications in the tables.
		</p><p>
		Second, if the logic is broken into the separate labels, the label call
		semantics provides the same ordering as well:
		</p><pre class="programlisting">$lbA = $unit-&gt;makeLabel($rtA, "A", undef, sub {
  my $rop = $_[1];
  my $op = $rop-&gt;getOpcode(); my $a = $rop-&gt;getRow();
  if ($a-&gt;get("value") &lt; 0) {
    $unit-&gt;call($lbB-&gt;makeRowop($op, $a));
  } else {
    $unit-&gt;call($lbC-&gt;makeRowop($op, $a));
  }
});

$lbB = $unit-&gt;makeLabel($rtA, "B", undef, sub {
  my $rop = $_[1];
  my $op = $rop-&gt;getOpcode(); my $a = $rop-&gt;getRow();
  $unit-&gt;makeHashCall($lbD, $op, $a-&gt;toHash(), negative =&gt; 1);
});

$lbC = $unit-&gt;makeLabel($rtA, "C", undef, sub {
  my $rop = $_[1];
  my $op = $rop-&gt;getOpcode(); my $a = $rop-&gt;getRow();
  $unit-&gt;makeHashCall($lbD, $op, $a-&gt;toHash(), negative =&gt; 0);
});</pre><a class="indexterm" name="id487786"></a><p>
		When the label A calls the label B or C, which calls the label D, A
		does not get to see its next input row until the whole chain of calls
		to D and beyond completes. B and C may be replaced with the label
		chains of arbitrary complexity, including loops, without disturbing the
		logic.
		</p><p>
		The second problem with the diamond topology
		happens when the blocks B and C keep the state, and the
		input data gets updated by simply re-sending a record with the same
		key. This kind of updates is typical for the systems that do not have
		the concept of opcodes.
		</p><p>
		Consider a CCL example (approximate, since I can't test it) that gets
		the reports about borrowing and loaning securities, using the sign of
		the quantity to differentiate between borrows (-) and loans (+).
		It then sums up the borrows and loans separately:
		</p><a class="indexterm" name="id529143"></a><pre class="programlisting">create schema s_A (
  id integer,
  symbol string,
  quantity long
);
create input stream i_A schema s_A;

create schema s_D (
  symbol string,
  borrowed boolean, // flag: loaned or borrowed
  quantity long
);
// aggregated data
create public window w_D schema s_D
keep last per symbol, borrowed;

// collection of borrows
create public window w_B schema s_A keep last per id;
// collection of loans
create public window w_C schema s_A keep last per id;

insert when quantity &lt; 0
  then w_B
  else w_C
select * from i_A;

// borrows aggregation
insert into w_D
select
  symbol,
  true,
  sum(quantity)
group by symbol
from w_B;

// loans aggregation
insert into w_D
select
  symbol,
  false,
  sum(quantity)
group by symbol
from w_C;</pre><p>
		It works OK until a row with the same id gets updated to a different
		sign of quantity:
		</p><pre class="programlisting">1,AAA,100
....
1,AAA,-100</pre><p>
		If the quantity kept the same sign, the new row would simply replace
		the old one in w_B or w_C, and the aggregation result would be right
		again. But when the sign changes, the new row goes into a different
		direction than the previous one. Now it ends up with both w_B and w_C
		having rows with the same id: one old and one new!
		</p><p>
		In this case really the problem is at the <span class="quote">&#8220;<span class="quote">fork</span>&#8221;</span> part of the <span class="quote">&#8220;<span class="quote">diamond</span>&#8221;</span>,
		the merging part of it is just along for the ride, carrying the
		incorrect results.
		</p><p>
		This problem does not happen in the systems that have both inserts and
		deletes. Then the data sequence becomes
		</p><pre class="programlisting">INSERT,1,AAA,100
....
DELETE,1,AAA,100
INSERT,1,AAA,-100</pre><p>
		The DELETE goes along the same branch as the first insert and undoes
		its effect, then the second INSERT goes into the other branch.
		</p><p>
		Since Triceps has both INSERT and DELETE opcodes, it's immune to this
		problem, as long as the input data has the correct DELETEs in it.
		</p><p>
		If you wonder, the CCL example can be fixed too but in a more
		round-about way, by adding a couple of statements before the
		<span class="quote">&#8220;<span class="quote">insert-when</span>&#8221;</span> statement:
		</p><pre class="programlisting">on w_A
delete from w_B
  where w_A.id = w_B.id;

on w_A
delete from w_C
  where w_A.id = w_C.id;</pre><p>
		This generates the matching DELETEs. Of course, if you want, you can
		use this way with Triceps too.
		</p></div><div class="sect1" title="14.2. Collapsed updates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_other_collapse"></a>14.2. Collapsed updates</h2></div></div></div><a class="indexterm" name="id529243"></a><p>
		First, a note: the collapse described here has nothing to do with the collapsing
		of the aggregation groups. It's just the same word reused for a different
		purpose.
		</p><a class="indexterm" name="id529258"></a><a class="indexterm" name="id529267"></a><a class="indexterm" name="id525887"></a><p>
		Sometimes the exact sequence of how a row at a particular key was
		updated does not matter, the only interesting part is the end result.
		Like the <code class="computeroutput">OUTPUT EVERY</code> statement in CCL or the pulsed subscription in
		Aleri. It doesn't have to be time-driven either: if the data comes in
		as batches, it makes sense to collapse the modifications from the whole
		batch into one, and send it at the end of the batch.
		</p><p>
		To do this in Triceps, I've made a template. Here is an example of its
		use with interspersed commentary: 
		</p><pre class="programlisting">our $rtData = Triceps::RowType-&gt;new(
  # mostly copied from the traffic aggregation example
  local_ip =&gt; "string",
  remote_ip =&gt; "string",
  bytes =&gt; "int64",
);</pre><p>
		The meaning of the rows is not particularly important for this example.
		It just uses a pair of the IP addresses as the collapse key. The
		collapse absolutely needs a primary key, since it has to track and
		collapse multiple updates to the same row.
		</p><pre class="programlisting">my $unit = Triceps::Unit-&gt;new("unit");

my $collapse = Triceps::Collapse-&gt;new(
  unit =&gt; $unit,
  name =&gt; "collapse",
  data =&gt; [
    name =&gt; "idata",
    rowType =&gt; $rtData,
    key =&gt; [ "local_ip", "remote_ip" ],
  ],
);</pre><p>
		Most of the options are self-explanatory. The dataset is defined with
		nested options to make the API extensible, to allow multiple datasets
		to be defined in the future. But at the moment only one is allowed. A
		dataset collapses the data at one label: an input label and an output
		label get defined for it, just as for the table. The data arrives at
		the input label, gets collapsed by the primary key, and then stays in
		the Collapse until the flush. When the Collapse gets flushed, the data
		is sent out of its output label. After the flush, the Collapse has no
		data in it, and starts collecting the updates again from scratch. The
		labels gets named by connecting the names of the Collapse element, of
		the dataset, and <span class="quote">&#8220;<span class="quote">in</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span>. For this Collapse, the label names will
		be <span class="quote">&#8220;<span class="quote">collapse.idata.in</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">collapse.idata.out</span>&#8221;</span>.
		</p><p>
		Note that the dataset options are specified in a referenced array, not
		a hash! If you try to use a hash, it will fail. When specifying the
		dataset options, put the <span class="quote">&#8220;<span class="quote">name</span>&#8221;</span> first. It's used in the error
		messages about any issues in the dataset, and the code really expects
		the name to go first.
		</p><p>
		Like with the other shown templates, if something goes wrong, Collapse
		will confess.
		</p><pre class="programlisting">my $lbPrint = makePrintLabel("print", $collapse-&gt;getOutputLabel("idata"));</pre><p>
		The print label gets connected to the Collapse's output
		label. The method to get the collapse's output label is very much like
		table's. Only it gets the dataset name as an argument.
		</p><pre class="programlisting">sub mainloop($$$) # ($unit, $datalabel, $collapse)
{
  my $unit = shift;
  my $datalabel = shift;
  my $collapse = shift;
  while(&lt;STDIN&gt;) {
    chomp;
    my @data = split(/,/); # starts with a command, then string opcode
    my $type = shift @data;
    if ($type eq "data") {
      my $rowop = $datalabel-&gt;makeRowopArray(@data);
      $unit-&gt;call($rowop);
      $unit-&gt;drainFrame(); # just in case, for completeness
    } elsif ($type eq "flush") {
      $collapse-&gt;flush();
    }
  }
}

&amp;mainloop($unit, $collapse-&gt;getInputLabel($collapse-&gt;getDatasets()), $collapse);</pre><p>
		There will be a second example, so I've placed the main loop into a
		function. It works in the same way as in the examples before: extracts
		the data from the CSV format and sends it to a label. The first column
		contains the command: <span class="quote">&#8220;<span class="quote">data</span>&#8221;</span> sends the data, and <span class="quote">&#8220;<span class="quote">flush</span>&#8221;</span> performs the
		flush from the Collapse. The flush marks the end of the batch. Here is
		an example of a run, with the input lines shown as usual in bold:
		</p><pre class="programlisting"><span class="bold"><strong>data,OP_INSERT,1.2.3.4,5.6.7.8,100</strong></span>
<span class="bold"><strong>data,OP_INSERT,1.2.3.4,6.7.8.9,1000</strong></span>
<span class="bold"><strong>data,OP_DELETE,1.2.3.4,6.7.8.9,1000</strong></span>
<span class="bold"><strong>flush</strong></span>
collapse.idata.out OP_INSERT local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="100"</pre><p>
		The row for (1.2.3.4, 5.6.7.8) gets plainly inserted, and goes through
		on the flush. The row for (1.2.3.4, 6.7.8.9) gets first inserted and then
		deleted, so by the flush time it becomes a no-operation.
		</p><pre class="programlisting"><span class="bold"><strong>data,OP_DELETE,1.2.3.4,5.6.7.8,100</strong></span>
<span class="bold"><strong>data,OP_INSERT,1.2.3.4,5.6.7.8,200</strong></span>
<span class="bold"><strong>data,OP_INSERT,1.2.3.4,6.7.8.9,2000</strong></span>
<span class="bold"><strong>flush</strong></span>
collapse.idata.out OP_DELETE local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="200"
collapse.idata.out OP_INSERT local_ip="1.2.3.4" remote_ip="6.7.8.9"
    bytes="2000"</pre><p>
		The original row for (1.2.3.4, 5.6.7.8) gets modified, and the modification
		goes through. The new row for (1.2.3.4, 6.7.8.9) gets inserted now,
		and also goes through.
		</p><pre class="programlisting"><span class="bold"><strong>data,OP_DELETE,1.2.3.4,6.7.8.9,2000</strong></span>
<span class="bold"><strong>data,OP_INSERT,1.2.3.4,6.7.8.9,3000</strong></span>
<span class="bold"><strong>data,OP_DELETE,1.2.3.4,6.7.8.9,3000</strong></span>
<span class="bold"><strong>data,OP_INSERT,1.2.3.4,6.7.8.9,4000</strong></span>
<span class="bold"><strong>data,OP_DELETE,1.2.3.4,6.7.8.9,4000</strong></span>
<span class="bold"><strong>flush</strong></span>
collapse.idata.out OP_DELETE local_ip="1.2.3.4" remote_ip="6.7.8.9"
    bytes="2000"</pre><p>
		The row for (1.2.3.4, 6.7.8.9) now gets modified twice, and after that
		deleted. After collapse it becomes the deletion of the original row,
		the one that was inserted before the previous flush.
		</p><p>
		The Collapse also allows to specify the row type and the input
		connection for a dataset in a different way:
		</p><pre class="programlisting">my $lbInput = $unit-&gt;makeDummyLabel($rtData, "lbInput");

my $collapse = Triceps::Collapse-&gt;new(
  name =&gt; "collapse",
  data =&gt; [
    name =&gt; "idata",
    fromLabel =&gt; $lbInput,
    key =&gt; [ "local_ip", "remote_ip" ],
  ],
);

&amp;mainloop($unit, $lbInput, $collapse);</pre><p>
		Normally <code class="computeroutput">$lbInput</code> would be not a dummy label but the output label of
		some element. The dataset option <span class="quote">&#8220;<span class="quote">fromLabel</span>&#8221;</span> tells that the dataset input will
		be coming from that label. So the Collapse can automatically both copy
		its row type for the dataset, and also chain the dataset's input label
		to that label. And also allowing to skip the option <span class="quote">&#8220;<span class="quote">unit</span>&#8221;</span>
		at the main level.
		It's a pure convenience, allowing to skip the manual
		steps. In the future a Collapse dataset should probably take a whole list of source
		labels and chain itself to all of them, but for now only one.
		</p><p>
		This example produces exactly the same output as the previous one, so
		there is no use in copying it again.
		</p><p>
		Another item that hasn't been shown yet, you can get the list of
		dataset names (well, currently only one name):
		</p><pre class="programlisting">@names = $collapse-&gt;getDatasets();</pre><p>
		The Collapse implementation is reasonably small, and is another worthy
		example to show. It's a common template, with no code
		generation whatsoever, just a combination of ready components. As with
		SimpleAggregator, the current Collapse is quite simple and will grow
		more features over time, so I've copied the original simple version
		into <code class="computeroutput">t/xCollapse.t</code> to stay there unchanged.
		</p><p>
		The most notable thing about Collapse is that it took just about an
		hour to write the first version of it and another three or so hours to
		test it. Which is a lot less than the similar code in the Aleri or
		Coral8 code base took. The reason for this is that Triceps provides the
		fairly flexible base data structures that can be combined easily
		directly in a scripting language. There is no need to re-do a lot from
		scratch every time, just take something and add a little bit on top.
		</p><p>
		So here it is, with the interspersed commentary.
		</p><pre class="programlisting">sub new # ($class, $optName =&gt; $optValue, ...)
{
  my $class = shift;
  my $self = {};

  &amp;Triceps::Opt::parse($class, $self, {
    unit =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::Unit") } ],
    name =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    data =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "ARRAY") } ],
  }, @_);

  # Keeps the names of the datasets in the order they have been defined
  # (since the hash loses the order).
  $self-&gt;{dsetnames} = [];

  # parse the data element
  my %data_unparsed = @{$self-&gt;{data}};
  my $dataset = {};
  &amp;Triceps::Opt::parse("$class data set (" . ($data_unparsed{name} or 'UNKNOWN') . ")", $dataset, {
    name =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    key =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "ARRAY", "") } ],
    rowType =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::RowType"); } ],
    fromLabel =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::Label"); } ],
  }, @{$self-&gt;{data}});</pre><p>
		The options parsing goes as usual. The option <span class="quote">&#8220;<span class="quote">data</span>&#8221;</span> is parsed again
		for the options inside it, and those are placed into the hash
		<code class="computeroutput">%$dataset</code>.
		</p><pre class="programlisting">  # save the dataset for the future
  push @{$self-&gt;{dsetnames}}, $dataset-&gt;{name};
  $self-&gt;{datasets}{$dataset-&gt;{name}} = $dataset;
  # check the options
  &amp;Triceps::Opt::handleUnitTypeLabel("Triceps::Collapse data set (". $dataset-&gt;{name} . ")",
    "unit at the main level", \$self-&gt;{unit},
    "rowType", \$dataset-&gt;{rowType},
    "fromLabel", \$dataset-&gt;{fromLabel});
  my $lbFrom = $dataset-&gt;{fromLabel};</pre><p>
		If <span class="quote">&#8220;<span class="quote">fromLabel</span>&#8221;</span> is used, the row type and possibly unit are found from it
		by <code class="computeroutput">Triceps::Opt::handleUnitTypeLabel()</code>. Or if the unit was specified
		explicitly, it gets checked for consistency with the label's unit. See
		<a class="xref" href="#sc_template_options" title="10.5. Template options">Section 10.5: &#8220;Template options&#8221; </a>
		for more detail. The early version of Collapse in <code class="computeroutput">t/xCollapse.t</code> actually
		pre-dates <code class="computeroutput">Triceps::Opt::handleUnitTypeLabel()</code>, and there the similar
		functionality is done manually.
		</p><pre class="programlisting">  # create the tables
  $dataset-&gt;{tt} = Triceps::TableType-&gt;new($dataset-&gt;{rowType})
    -&gt;addSubIndex("primary",
      Triceps::IndexType-&gt;newHashed(key =&gt; $dataset-&gt;{key})
    );
  Triceps::wrapfess
    "$myname: Collapse table type creation error for dataset '" . $dataset-&gt;{name} . "':",
    sub { $dataset-&gt;{tt}-&gt;initialize(); };

  Triceps::wrapfess
    "$myname: Collapse internal error: insert table creation for dataset '" . $dataset-&gt;{name} . "':",
    sub { $dataset-&gt;{tbInsert} = $self-&gt;{unit}-&gt;makeTable($dataset-&gt;{tt}, $self-&gt;{name} . "." . $dataset-&gt;{name} . ".tbInsert"); };

  Triceps::wrapfess
    "$myname: Collapse internal error: delete table creation for dataset '" . $dataset-&gt;{name} . "':",
    sub { $dataset-&gt;{tbDelete} = $self-&gt;{unit}-&gt;makeTable($dataset-&gt;{tt}, $self-&gt;{name} . "." . $dataset-&gt;{name} . ".tbDelete"); };</pre><p>
		The state is kept in two tables. The reason for their existence is that after
		collapsing, the Collapse may send for each key one of:
		</p><p>

		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		a single INSERT rowop, if the row was not there before and became inserted, 
		</li><li class="listitem">
		a DELETE rowop if the row was there before and then became deleted, 
		</li><li class="listitem">
		a DELETE followed by an INSERT if the row was there but then changed its value,
		</li><li class="listitem">
		or nothing if the row was not there before, and then was inserted and deleted,
		or if there was no change to the row.
		</li></ul></div><p>

		</p><p>
		Accordingly, this state is kept in two tables: one contains the DELETE
		part, another the INSERT part for each key, and either part may be
		empty (or both, if the row at that key has not been changed). After
		each flush both tables become empty, and then start collecting the
		modifications again.
		</p><pre class="programlisting">  # create the labels
  Triceps::wrapfess
    "$myname: Collapse internal error: input label creation for dataset '" . $dataset-&gt;{name} . "':",
    sub { $dataset-&gt;{lbIn} = $self-&gt;{unit}-&gt;makeLabel($dataset-&gt;{rowType}, $self-&gt;{name} . "." . $dataset-&gt;{name} . ".in",
      undef, \&amp;_handleInput, $self, $dataset); };

  Triceps::wrapfess
    "$myname: Collapse internal error: output label creation for dataset '" . $dataset-&gt;{name} . "':",
    sub { $dataset-&gt;{lbOut} = $self-&gt;{unit}-&gt;makeDummyLabel($dataset-&gt;{rowType}, $self-&gt;{name} . "." . $dataset-&gt;{name} . ".out"); };</pre><p>
		The input and output labels get created. The input label has the
		function with the processing logic set as its handler. The output label
		is just a dummy. Note that the tables don't get connected anywhere,
		they are just used as storage, without any immediate reactions to their
		modifications.
		</p><pre class="programlisting">  # chain the input label, if any
  if (defined $lbFrom) {
    Triceps::wrapfess
      "$myname: Collapse internal error: input label chaining for dataset '" . $dataset-&gt;{name} . "' to '" . $lbFrom-&gt;getName() . "' failed:",
      sub { $lbFrom-&gt;chain($dataset-&gt;{lbIn}); };
    delete $dataset-&gt;{fromLabel}; # no need to keep the reference any more, avoid a reference cycle
  }</pre><p>
		And if the <span class="quote">&#8220;<span class="quote">fromLabel</span>&#8221;</span> was used, the Collapse gets connected to it. After
		that there is no good reason to keep a separate reference to that
		label, especially considering that it creates a reference loop
		that would not be cleaned until the input label get cleaned by the unit. 
		So it gets deleted early instead.
		</p><pre class="programlisting">  bless $self, $class;
  return $self;
}</pre><p>
		The final blessing is boilerplate. The constructor creates the data
		structures but doesn't implement any logic. The logic goes next:
		</p><pre class="programlisting"># (protected)
# handle one incoming row on a dataset's input label
sub _handleInput # ($label, $rop, $self, $dataset)
{
  my $label = shift;
  my $rop = shift;
  my $self = shift;
  my $dataset = shift;

  if ($rop-&gt;isInsert()) {
    # Simply add to the insert table: the effect is the same, independently of
    # whether the row was previously deleted or not. This also handles correctly
    # multiple inserts without a delete between them, even though this kind of
    # input is not really expected.
    $dataset-&gt;{tbInsert}-&gt;insert($rop-&gt;getRow());</pre><p>
		The Collapse object knows nothing about the data that went through it
		before. After each flush it starts again from scratch. It expects
		that the stream of rows is self-consistent, and makes the conclusions
		about the previous data based on the new data it sees. An INSERT rowop
		may mean one of two things: either there was no previous record with
		this key, or there was a previous record with this key and then it got
		deleted. The Delete table can be used to differentiate between these situations:
		if there was a row that was then deleted, the Delete table would
		contain that row. But for the INSERT it doesn't matter: in either case
		it just inserts the new row into the Insert table. If there was no such
		row before, it would be the new INSERT. If there was such a row before,
		it would be an INSERT following a DELETE.
		</p><pre class="programlisting">  } elsif($rop-&gt;isDelete()) {
    # If there was a row in the insert table, delete that row (undoing the previous insert).
    # Otherwise it means that there was no previous insert seen in this round, so this must be a
    # deletion of a row inserted in the previous round, so insert it into the delete table.
    if (! $dataset-&gt;{tbInsert}-&gt;deleteRow($rop-&gt;getRow())) {
      $dataset-&gt;{tbDelete}-&gt;insert($rop-&gt;getRow());
    }
  }
}</pre><p>
		The DELETE case is more interesting. If we see a DELETE rowop, this
		means that either there was an INSERT sent before the last flush and
		now that INSERT becomes undone, or that there was an INSERT after the
		flush, which also becomes undone. The actions for these cases are
		different: if the INSERT was before the flush, this row should go into
		the Delete table, and eventually propagate as a DELETE during the next
		flush. If the last INSERT was after the flush, then its row would be
		stored in the Insert table, and now we just need to delete that row and
		pretend that it has never been.
		</p><p>
		That's what the logic does: first it tries to remove from the Insert
		table. If succeeded, then it was an INSERT after the flush, that became
		undone now, and there is nothing more to do. If there was no row to
		delete, this means that the INSERT must have happened before the last
		flush, and we need to remember this row in the Delete table and pass it
		on in the next flush.
		</p><p>
		This logic is not resistant to the incorrect data sequences. If there
		ever are two DELETEs for the same key in a row (which should never
		happen in a correct sequence), the second DELETE will end up in the
		Delete table.
		</p><pre class="programlisting"># Unlatch and flush the collected data, then latch again.
sub flush # ($self)
{
  my $self = shift;
  my $unit = $self-&gt;{unit};
  my $OP_INSERT = &amp;Triceps::OP_INSERT;
  my $OP_DELETE = &amp;Triceps::OP_DELETE;
  foreach my $dataset (values %{$self-&gt;{datasets}}) {
    my $tbIns = $dataset-&gt;{tbInsert};
    my $tbDel = $dataset-&gt;{tbDelete};
    my $lbOut = $dataset-&gt;{lbOut};
    my $next;
    # send the deletes always before the inserts
    for (my $rh = $tbDel-&gt;begin(); !$rh-&gt;isNull(); $rh = $next) {
      $next = $rh-&gt;next(); # advance the irerator before removing
      $tbDel-&gt;remove($rh);
      $unit-&gt;call($lbOut-&gt;makeRowop($OP_DELETE, $rh-&gt;getRow()));
    }
    for (my $rh = $tbIns-&gt;begin(); !$rh-&gt;isNull(); $rh = $next) {
      $next = $rh-&gt;next(); # advance the irerator before removing
      $tbIns-&gt;remove($rh);
      $unit-&gt;call($lbOut-&gt;makeRowop($OP_INSERT, $rh-&gt;getRow()));
    }
  }
}</pre><p>
		The flushing is fairly straightforward: first it sends on all the
		DELETEs, then all the INSERTs, clearing the tables along the way. At
		first I've though of matching the DELETEs and INSERTs together, sending
		them next to each other in case if both are available for some key.
		It's not that difficult to do. But then I've realized that it doesn't
		matter and just did it the simple way.
		</p><pre class="programlisting"># Get the input label of a dataset.
# Confesses on error.
sub getInputLabel($$) # ($self, $dsetname)
{
  my ($self, $dsetname) = @_;
  confess "Unknown dataset '$dsetname'"
    unless exists $self-&gt;{datasets}{$dsetname};
  return $self-&gt;{datasets}{$dsetname}{lbIn};
}

# Get the output label of a dataset.
# Confesses on error.
sub getOutputLabel($$) # ($self, $dsetname)
{
  my ($self, $dsetname) = @_;
  confess "Unknown dataset '$dsetname'"
    unless exists $self-&gt;{datasets}{$dsetname};
  return $self-&gt;{datasets}{$dsetname}{lbOut};
}

# Get the lists of datasets (currently only one).
sub getDatasets($) # ($self)
{
  my $self = shift;
  return @{$self-&gt;{dsetnames}};
}</pre><p>
		The getter functions are fairly simple. The only catch is that the code
		has to check for <code class="computeroutput">exists</code> before it reads the value of
		<code class="computeroutput">$self-&gt;{datasets}{$dsetname}{lbOut}</code>. Otherwise, if an
		incorrect <code class="computeroutput">$dsetname</code> is used, the reading would return an <code class="computeroutput">undef</code>
		but along the way would create an unpopulated
		<code class="computeroutput">$self-&gt;{datasets}{$dsetname}</code>. Which would then cause a crash when
		<code class="computeroutput">flush()</code> tries to iterate through it and finds the dataset options
		missing.
		</p><p>
		That's it, Collapse in a nutshell! Another way to do the collapse will
		be shown in
		<a class="xref" href="#sc_strf_collapse" title="15.2. Streaming functions by example, another version of Collapse">Section 15.2: &#8220;Streaming functions by example, another version of Collapse&#8221; </a>.
		And one more piece to it is shown in
		<a class="xref" href="#sc_strf_templates" title="15.8. Streaming functions and template results">Section 15.8: &#8220;Streaming functions and template results&#8221; </a>.
		</p></div><div class="sect1" title="14.3. Large deletes in small chunks"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_other_chunks_del"></a>14.3. Large deletes in small chunks</h2></div></div></div><a class="indexterm" name="id525468"></a><a class="indexterm" name="id525478"></a><p>
		If you have worked with Coral8 and similar CEP systems, you should be
		familiar with the situation when you ask it to delete a million rows
		from the table and the model goes into self-contemplation for half an
		hour, not reacting to any requests. It starts responding again only
		when the deletes are finished. That's because the execution is
		single-threaded, and deleting a million rows takes time.
		</p><p>
		Triceps is succeptible to the same issue. So, how to avoid it? Even
		better, how to make the deletes work <span class="quote">&#8220;<span class="quote">in the background</span>&#8221;</span>, at a low
		priority, kicking in only when there is no other pending requests?
		</p><p>
		The solution is do do it in smaller chunks. Delete a few rows (say, a
		thousand or so) then check if there are any other requests. Keep
		processing these other request until the model becomes idle. Then
		continue with deleting the next chunk of rows.
		</p><p>
		Let's make a small example of it. First, let's make a table.
		</p><pre class="programlisting">our $uChunks = Triceps::Unit-&gt;new("uChunks");

# data is just some dumb easily-generated filler
our $rtData = Triceps::RowType-&gt;new(
  s =&gt; "string",
  i =&gt; "int32",
);

# the data is auto-generated by a sequence
our $seq = 0;

our $ttData = Triceps::TableType-&gt;new($rtData)
  -&gt;addSubIndex("fifo", Triceps::IndexType-&gt;newFifo())
;
$ttData-&gt;initialize();
our $tData = $uChunks-&gt;makeTable($ttData, "tJoin1");
makePrintLabel("lbPrintData", $tData-&gt;getOutputLabel());</pre><p>
		The data in the table is completely silly, just something to put in
		there. Even the index is a simple FIFO, just something to keep the
		table together. 
		</p><p>
		Next, the clearing logic.
		</p><pre class="programlisting"># notifications about the clearing
our $rtNote = Triceps::RowType-&gt;new(
  text =&gt; "string",
);

# rowops to run when the model is otherwise idle
our $trayIdle = $uChunks-&gt;makeTray();

our $lbReportNote = $uChunks-&gt;makeDummyLabel($rtNote, "lbReportNote"
);
makePrintLabel("lbPrintNote", $lbReportNote);

# code that clears the table in small chunks
our $lbClear = $uChunks-&gt;makeLabel($rtNote, "lbClear", undef, sub {
  $tData-&gt;clear(2); # no more than 2 rows deleted per run
  if ($tData-&gt;size() &gt; 0) {
    $trayIdle-&gt;push($_[0]-&gt;adopt($_[1]));
  } else {
    $uChunks-&gt;makeHashCall($lbReportNote, "OP_INSERT",
      text =&gt; "done clearing",
    );
  }
});</pre><p>
		We want to get a notification when the clearing is done. This
		notification will be sent as a rowop with row type <code class="computeroutput">$rtNote</code> to the
		label <code class="computeroutput">$lbReportNote</code>. Which then just gets printed, so that we can
		see it. In a production system it would be sent back to the
		requestor.
		</p><p>
		The clearing is initiated by sending a row (of the same type <code class="computeroutput">$rtNote</code>) to
		the label <code class="computeroutput">$lbClear</code>. Which does the job and then sends the notification of completion.
		In the real world not the whole table would probably be erased but only
		the old data, from before a certain date, like was shown in the
		<a class="xref" href="#sc_joins_jointwo_inputfilter" title="12.11. JoinTwo input event filtering">Section 12.11: &#8220;JoinTwo input event filtering&#8221; </a>.
		Here for simplicity all the data get wiped out.
		</p><a class="indexterm" name="id525594"></a><a class="indexterm" name="id525607"></a><p>
		But the method <code class="computeroutput">clear()</code> stops after the number of deleted rows reaches the limit.
		Since it's real inconvenient to play with a million rows, we'll play
		with just a few rows. And so the chunk size limit is also set smaller,
		to just two rows instead of a thousand. When the limit is reached and there
		still are rows left in the table, the
		code pushes the command row into the idle tray for later rescheduling and
		returns. The adoption part is not strictly necessary, and this small
		example would work fine without it. But it's a safeguard for the more
		complicated programs that may have the labels chained, with our
		clearing label being just one link in a chain. If the incoming rowop
		gets rescheduled as is, the whole chain will get executed again. which
		might not be desirable. Re-adopting it to our label will cause only our
		label (okay, and everything chained from it) to be executed.
		</p><p>
		How would the rowops in the idle tray get executed? In the real world,
		the main loop logic would be like this pseudocode:
		</p><pre class="programlisting">while(1) {
  if (idle tray is empty)
    timeout = infinity;
  else
    timeout = 0;
  poll(file descriptors, timeout);
  if (poll timed out)
    run the idle tray;
  else
    process the incoming data;
}</pre><p>
		The example from
		<a class="xref" href="#sc_sched_mainloop_socket" title="7.9. Main loop with a socket">Section 7.9: &#8220;Main loop with a socket&#8221; </a>
		can be extended to work like this.
		But it's hugely inconvenient for a toy demonstration, getting the
		timing right would be a major pain. So instead let's just add the
		command <span class="quote">&#8220;<span class="quote">idle</span>&#8221;</span> to the main loop, to trigger the idle logic at will.
		The main loop of the example is:
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  if ($type eq "data") {
    my $count = shift @data;
    for (; $count &gt; 0; $count--) {
      ++$seq;
      $uChunks-&gt;makeHashCall($tData-&gt;getInputLabel(), "OP_INSERT",
        s =&gt; ("data_" . $seq),
        i =&gt; $seq,
      );
    }
  } elsif ($type eq "dump") {
    for (my $rhit = $tData-&gt;begin(); !$rhit-&gt;isNull(); $rhit = $rhit-&gt;next()) {
      print("dump: ", $rhit-&gt;getRow()-&gt;printP(), "\n");
    }
    for my $r ($trayIdle-&gt;toArray()) {
      print("when idle: ", $r-&gt;printP(), "\n");
    }
  } elsif ($type eq "clear") {
    $uChunks-&gt;makeHashCall($lbClear, "OP_INSERT",
      text =&gt; "clear",
    );
  } elsif ($type eq "idle") {
    $uChunks-&gt;schedule($trayIdle);
    $trayIdle-&gt;clear();
  }
  $uChunks-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		The data is put into the table by the main loop in a silly way:
		When we send the command like <span class="quote">&#8220;<span class="quote"><code class="computeroutput">data,3</code></span>&#8221;</span>, the mail loop will insert 3 new
		rows into the table. The contents is generated with sequential numbers,
		so the rows can be told apart. As the table gets changed, the updates
		get printed by the label <code class="computeroutput">lbPrintData</code>. 
		</p><p>
		The command <span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span> dumps the contents of both the
		table and of the idle tray.
		</p><p>
		The command <span class="quote">&#8220;<span class="quote">clear</span>&#8221;</span> issues a clearing request by calling
		the label <code class="computeroutput">$lbClear</code>. The first chunk gets cleared right away
		but then the control returns back to the main loop. If not all the data
		were cleared, an idle rowop will be placed into the idle tray.
		</p><p>
		The command <span class="quote">&#8220;<span class="quote">idle</span>&#8221;</span> that simulates the input idleness will
		then pick up that rowop from the idle tray and reschedule it.
		</p><p>
		All the pieces have been put together, let's run the code. The commentary
		are interspersed, and as usual, the input lines are shown in bold:
		</p><pre class="programlisting"><span class="bold"><strong>data,1</strong></span>
tJoin1.out OP_INSERT s="data_1" i="1"
<span class="bold"><strong>clear</strong></span>
tJoin1.out OP_DELETE s="data_1" i="1"
lbReportNote OP_INSERT text="done clearing"</pre><p>
		This is pretty much a dry run: put in one row (less than the chunk
		size), see it deleted on clearing. And see the completion reported
		afterwards.
		</p><pre class="programlisting"><span class="bold"><strong>data,5</strong></span>
tJoin1.out OP_INSERT s="data_2" i="2"
tJoin1.out OP_INSERT s="data_3" i="3"
tJoin1.out OP_INSERT s="data_4" i="4"
tJoin1.out OP_INSERT s="data_5" i="5"
tJoin1.out OP_INSERT s="data_6" i="6"</pre><p>
		Add more data, which will be enough for three chunks.
		</p><pre class="programlisting"><span class="bold"><strong>clear</strong></span>
tJoin1.out OP_DELETE s="data_2" i="2"
tJoin1.out OP_DELETE s="data_3" i="3"</pre><p>
		Now the clearing does one chunk and stops, waiting for the idle condition.
		</p><pre class="programlisting"><span class="bold"><strong>dump</strong></span>
dump: s="data_4" i="4"
dump: s="data_5" i="5"
dump: s="data_6" i="6"
when idle: lbClear OP_INSERT text="clear"</pre><p>
		See what's inside: the remaining 3 rows, and a row in the idle tray
		saying that the clearing is in progress. 
		</p><pre class="programlisting"><span class="bold"><strong>idle</strong></span>
tJoin1.out OP_DELETE s="data_4" i="4"
tJoin1.out OP_DELETE s="data_5" i="5"</pre><p>
		The model goes idle once more, one more chunk of two rows gets deleted. 
		</p><pre class="programlisting"><span class="bold"><strong>data,1</strong></span>
tJoin1.out OP_INSERT s="data_7" i="7"
<span class="bold"><strong>dump</strong></span>
dump: s="data_6" i="6"
dump: s="data_7" i="7"
when idle: lbClear OP_INSERT text="clear"</pre><p>
		What will happen if we add more data in between the chunks of clearing?
		Let's see, let's add one more row. It shows up in the table as usual.
		</p><pre class="programlisting"><span class="bold"><strong>idle</strong></span>
tJoin1.out OP_DELETE s="data_6" i="6"
tJoin1.out OP_DELETE s="data_7" i="7"
lbReportNote OP_INSERT text="done clearing"
<span class="bold"><strong>dump</strong></span>
<span class="bold"><strong>idle</strong></span></pre><p>
		On the next idle condition the clearing picks up whatever was in
		the table for the next chunk. Since there were only two rows left, it's
		the last chunk, and the clearing reports a successful completion. And a
		dump shows that there is nothing left in the table nor in the idle
		tray. The next idle condition does nothing, because the idle tray
		is empty.
		</p><p>
		The deletion could also be interrupted and cancelled, by removing
		the row from the idle tray. That would involve converting the tray
		to an array, finding and deleting the right rowop, and converting the
		array back into the tray. Overall it's fairly straightforward.
		The search in the array is linear but there should not be that
		many idle requests, so it should be quick enough.
		</p><p>
		The delete-by-chunks logic can be made into a template, just I'm not
		sure yet what is the best way to do it. It would have to have a lot of
		configurable parts.
		</p><p>
		On another subject, scheduling the things to be done on idle adds an
		element of unpredictability to the model. It's impossible to predict
		the exact timing of the incoming requests, and the idle work may get
		inserted between any of them. Presumably it's OK because the data being
		deleted should not be participating in any logic at this time any more.
		For repeatability in the unit tests, make the chunk size adjustable and
		adjust it to a size larger than the biggest amount of data used in the
		unit tests.
		</p><p>
		A similar logic can also be used in querying the data. But it's more
		difficult. For deletion the continuation is easy: just take the first
		row in the index, and it will be the place to continue (because the
		index is ordered correctly, and because the previous rows are getting
		deleted). For querying you would have to remember the next row handle
		and continue from it. Which is OK if it can not get deleted in the
		meantime. But if it can get deleted, you'll have to keep track of that
		too, and advance to the next row handle when this happens. And if you
		want to receive a full snapshot with the following subscription to all
		updates, you'd have to check whether the modified rows are before or
		after the marked handle, and pass them through if they are before it,
		letting the user see the updates to the data already received. And
		since the data is being sent to the user, filling up the output buffer
		and stopping would stop the whole model too, and not restart until the
		user reads the buffered data. So there has to be a flow control logic
		that would stop the query when output buffer fills up, return to the
		normal operation, and then reschedule the idle job for the query only
		when the output buffer drains down. I've kind of started on doing an
		example of the chunked query too, but then because of all these
		complications decided to leave it for later.
		</p></div></div><div class="chapter" title="Chapter 15. Streaming functions"><div class="titlepage"><div><div><h2 class="title"><a name="ch_strf"></a>Chapter 15. Streaming functions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_strf_intro">15.1. Introduction to streaming functions</a></span></dt><dt><span class="sect1"><a href="#sc_strf_collapse">15.2. Streaming functions by example, another version of Collapse</a></span></dt><dt><span class="sect1"><a href="#sc_strf_keyed_collapse">15.3. Collapse with grouping by key with streaming functions</a></span></dt><dt><span class="sect1"><a href="#sc_strf_translation">15.4. Table-based translation with streaming functions</a></span></dt><dt><span class="sect1"><a href="#sc_strf_loops">15.5. Streaming functions and loops</a></span></dt><dt><span class="sect1"><a href="#sc_strf_pipelines">15.6. Streaming functions and pipelines</a></span></dt><dt><span class="sect1"><a href="#sc_strf_tables">15.7. Streaming functions and tables</a></span></dt><dt><span class="sect1"><a href="#sc_strf_templates">15.8. Streaming functions and template results</a></span></dt><dt><span class="sect1"><a href="#sc_strf_recursion">15.9. Streaming functions and recursion</a></span></dt><dt><span class="sect1"><a href="#sc_strf_more_recursion">15.10. Streaming functions and more recursion</a></span></dt><dt><span class="sect1"><a href="#sc_strf_units">15.11. Streaming functions and unit boundaries</a></span></dt><dt><span class="sect1"><a href="#sc_strf_call">15.12. The ways to call a streaming function</a></span></dt><dt><span class="sect1"><a href="#sc_strf_scheduling">15.13. The gritty details of streaming functions scheduling</a></span></dt></dl></div><div class="sect1" title="15.1. Introduction to streaming functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_intro"></a>15.1. Introduction to streaming functions</h2></div></div></div><a class="indexterm" name="id463520"></a><a class="indexterm" name="id495251"></a><a class="indexterm" name="id470190"></a><p>
		The streaming functions are a cool and advanced
		concept. I've never seen it anywhere before, and for all I know I have
		invented it.
		</p><p>
		First let's look at the differences between the common functions and
		macros (or templates and such), shown in
		<a class="xref" href="#fig_strf_fmac" title="Figure 15.1. The difference between the function and macro calls.">Figure 15.1</a>.
		</p><div class="figure"><a name="fig_strf_fmac"></a><div class="figure-contents"><div><img src="func-010-fmac.lowres.png" width="NaN" alt="The difference between the function and macro calls."></div></div><p class="title"><b>Figure 15.1. The difference between the function and macro calls.</b></p></div><br class="figure-break"><p>
		What happens during a function call? Some code
		(marked with the light bluish color) is happily zooming along when it
		decides to call a function. It prepares some arguments and jumps to the
		function code (reddish). The function executes, computes its result and
		jumps back to the point right after it has been called from. Then the
		original code continues from there (the slightly darker bluish color).
		</p><p>
		What happens during a macro (or template) invocation? It starts with
		some code zooming along in the same way, however when the macro call
		time comes, it prepares the arguments and then does nothing. It gets
		away with it because the compiler has done the work: it has placed the
		macro code right where it's called, so there is no need for jumps.
		After the macro is done, again it does nothing: the compiler has placed
		the next code to execute right after it, so it just continues on its
		way.
		</p><p>
		So far it's pretty equivalent. An interesting difference happens when
		the function or macro is called from more than one place. With a macro,
		another copy of the macro is created, inserted between its call and
		return points. That's why in the figure the macro is shown twice. But
		with the function, the same function code is executed every time, and then returns
		back to the caller. That's why in the figure there are two function
		callers with their paths through the same function. But how does the
		function know, where should it jump on return? The caller tells it by
		pushing the return address onto the stack. When the function is done,
		it pops this address from the stack and jumps there.
		</p><p>
		Still, it looks all the same. A macro call is a bit more efficient,
		except when a large complex macro is called from many places, then it
		becomes more efficient as a function. However there is another
		difference if the function or macro holds some context (say, a static
		variable): each invocation of the macro will get its own context but
		all the function calls will share the same context. The only way to
		share the context with a macro is to pass some global context as its
		argument (or you can use a separately defined global variable if you're
		willing to dispense with some strict modularity).
		</p><a class="indexterm" name="id519637"></a><a class="indexterm" name="id519647"></a><a class="indexterm" name="id519657"></a><p>
		Now let's switch to the CEP world. The Sybase or StreamBase modules are
		essentially macros, and so are the Triceps templates. When such a macro
		gets instantiated, a whole new copy of it gets created with its
		tables/windows and streams/labels. Its input and output streams/labels
		get all connected in a fixed way. The limitation is that if the macro
		contains any tables, each instantiation gets another copy of them. Well, in
		Triceps you can use a table as an argument to a template. In the other
		systems I think you still can't, so if you want to work with a common
		table in a module, you have to make up the query-response patterns,
		like the one described in
		<a class="xref" href="#sc_template_intro" title="10.1. Comparative modularity">Section 10.1: &#8220;Comparative modularity&#8221; </a>.
		</p><p>
		In a query-response pattern there is some common sub-model, with a
		stream (in Triceps terms, a label, but here we're talking the other
		systems) for the queries to come in and a stream for the results to
		come out (both sides might have not only one but multiple streams).
		There are multiple inputs connected, from all the request sources, and
		the outputs are connected back to all the request sources. All the
		request sources (i.e. callers) get back the whole output of the
		pattern, so they need to identify, what output came from their input,
		and ignore the rest. They do this by adding the unique ids to their
		queries, and filter the results. In the end, it looks <span class="emphasis"><em>almost</em></span>
		like a function but with much pain involved.
		</p><p>
		To make it look quite like a function, one thing is needed: the
		selective connection of the result streams (or, returning to the
		Triceps terminology, labels) to the caller. Connect the output labels,
		send some input, have it processed and send the result through the
		connection, disconnect the output labels. And what you get is a
		streaming function. It's very much like a common function but working
		on the streaming data arguments and results.
		</p><p>
		The 
		<a class="xref" href="#fig_strf_query" title="Figure 15.2. The query patterns and streaming functions.">Figure 15.2</a>
		highlights the similarity and differences between the
		query patterns and the streaming functions.
		</p><div class="figure"><a name="fig_strf_query"></a><div class="figure-contents"><div><img src="func-020-query.lowres.png" width="NaN" alt="The query patterns and streaming functions."></div></div><p class="title"><b>Figure 15.2. The query patterns and streaming functions.</b></p></div><br class="figure-break"><p>
		The thick lines show where the data goes
		during one concrete call. The thin lines show the connections that do
		exist but without the data going through them at the moment (they will
		be used during the other calls, from these other callers). The dashed
		thin line shows the connection that doesn't exist at the moment. It
		will be created when needed (and at that time the thick arrow from the
		streaming function to what is now the current return would disappear).
		</p><p>
		The particular beauty of the streaming functions for Triceps is that
		the other callers don't even need to exist yet. They can be created
		and connected dynamically, do their job, call the function, use its
		result, and then be disposed of. The calling side in Triceps doesn't
		have to be streaming either: it could as well be procedural.  
		</p></div><div class="sect1" title="15.2. Streaming functions by example, another version of Collapse"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_collapse"></a>15.2. Streaming functions by example, another version of Collapse</h2></div></div></div><p>
		The streaming functions have proved quite useful in Triceps,
		in particular the inter-thread communications use an interface
		derived from them. But the ironic part is that
		coming up with the good examples of the streaming function usage in
		Triceps is surprisingly difficult. The flexibility of
		Triceps is the problem. If all you have is SQL, the streaming functions
		become pretty much a must. But if you can write the procedural code,
		most things are easier that way, with the normal procedural functions. 
		For a streaming function to become
		beneficial, it has to be written in SQLy primitives (such as tables,
		joins) and not be easily reducible to the procedural code.
		The streaming function examples that aren't big enough for their own file
		are collected in <code class="computeroutput">t/xFn.t</code>.
		</p><a class="indexterm" name="id529666"></a><a class="indexterm" name="id529675"></a><p>
		The most distilled example I've come up with is for the implementation of
		Collapse. The original implementation of Collapse is described in 
		<a class="xref" href="#sc_other_collapse" title="14.2. Collapsed updates">Section 14.2: &#8220;Collapsed updates&#8221; </a>.
		The <code class="computeroutput">flush()</code> there goes in a loop
		deleting the all rows from the state tables and sending them as rowops
		to the output.
		</p><p>
		The deletion of all the rows can nowadays be done easier with the Table
		method <code class="computeroutput">clear()</code>. However by itself it doesn't solve the problem of
		sending the output. It sends the deleted rows to the table's output
		label but we can't just connect the output of the state tables to the
		Collapse output: then it would also pick up all the intermediate
		changes! The data needs to be picked up from the tables output
		selectively, only in <code class="computeroutput">flush()</code>.
		</p><p>
		This makes it a good streaming function: the body of the function
		consists of running <code class="computeroutput">clear()</code> on the state tables, and its result is
		whatever comes on the output labels of the tables.
		</p><p>
		Since most of the logic remains unchanged, I've implemented this new
		version of Collapse in <code class="computeroutput">t/xFn.t</code> as a subclass that extends and replaces some of the
		code with its own:
		</p><pre class="programlisting">package FnCollapse;

sub CLONE_SKIP { 1; }

our @ISA=qw(Triceps::Collapse);

sub new # ($class, $optName =&gt; $optValue, ...)
{
  my $class = shift;
  my $self = $class-&gt;SUPER::new(@_);
  # Now add an FnReturn to the output of the dataset's tables.
  # One return is enough for both.
  # Also create the bindings for sending the data.
  foreach my $dataset (values %{$self-&gt;{datasets}}) {
    my $fret = Triceps::FnReturn-&gt;new(
      name =&gt; $self-&gt;{name} . "." . $dataset-&gt;{name} . ".retTbl",
      labels =&gt; [
        del =&gt; $dataset-&gt;{tbDelete}-&gt;getOutputLabel(),
        ins =&gt; $dataset-&gt;{tbInsert}-&gt;getOutputLabel(),
      ],
    );
    $dataset-&gt;{fret} = $fret;

    # these variables will be compiled into the binding snippets
    my $lbOut = $dataset-&gt;{lbOut};
    my $unit = $self-&gt;{unit};
    my $OP_INSERT = &amp;Triceps::OP_INSERT;
    my $OP_DELETE = &amp;Triceps::OP_DELETE;

    my $fbind = Triceps::FnBinding-&gt;new(
      name =&gt; $self-&gt;{name} . "." . $dataset-&gt;{name} . ".bndTbl",
      on =&gt; $fret,
      unit =&gt; $unit,
      labels =&gt; [
        del =&gt; sub {
          if ($_[1]-&gt;isDelete()) {
            $unit-&gt;call($lbOut-&gt;adopt($_[1]));
          }
        },
        ins =&gt; sub {
          if ($_[1]-&gt;isDelete()) {
            $unit-&gt;call($lbOut-&gt;makeRowop($OP_INSERT, $_[1]-&gt;getRow()));
          }
        },
      ],
    );
    $dataset-&gt;{fbind} = $fbind;
  }
  bless $self, $class;
  return $self;
}

# Override the base-class flush with a different implementation.
sub flush # ($self)
{
  my $self = shift;
  foreach my $dataset (values %{$self-&gt;{datasets}}) {
    # The binding takes care of producing and directing
    # the output. AutoFnBind will unbind when the block ends.
    my $ab = Triceps::AutoFnBind-&gt;new(
      $dataset-&gt;{fret} =&gt; $dataset-&gt;{fbind}
    );
    $dataset-&gt;{tbDelete}-&gt;clear();
    $dataset-&gt;{tbInsert}-&gt;clear();
  }
}</pre><a class="indexterm" name="id529752"></a><a class="indexterm" name="id529296"></a><p>
		<code class="computeroutput">new()</code> adds the streaming function elements in each data set. They
		consist of two parts: FnReturn defines the return value of a streaming
		function (there is no formal definition of the body or the entry point
		since they are quite flexible), and FnBinding defines a call of the
		streaming function. In this case the function is called in only one
		place, so one FnBinding is defined. If called from multiple places,
		there would be multiple FnBindings.
		</p><p>
		When a normal procedural function is called, the return address
		provides the connection to get the result back from it to the caller.
		In a streaming function, the FnBinding connects the result labels to
		the caller's further processing of the returned data. Unlike the
		procedural functions, the data is not returned in one step (run the
		function, compute the value, return it). Instead the return value of a
		streaming function is a stream of rowops. As each of them is sent to a
		return label, it goes through the binding and to the caller's further
		processing. Then the streaming function continues, producing the next
		rowop, and so on.
		</p><p>
		If this sounds complicated, please realize that here we're dealing with
		the assembly language equivalent for streaming functions. I expect that
		over time the more high-level primitives will be developed and it 
		will become easier.
		</p><p>
		The second source of complexity is that the arguments of a streaming
		function are not computed in one step either. You don't normally have a
		full set of rows to send to a streaming function in one go. Instead you
		set up the streaming call to bind the result, then you pump the argument rowops
		to the function's input, creating them in whatever way you wish.
		</p><p>
		Getting back to the definition of a streaming function, FnReturn
		defines a set of labels, each with a logical name. In this case the
		names are <span class="quote">&#8220;<span class="quote">del</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">ins</span>&#8221;</span>. The labels inside FnReturn are a special
		variety of dummy labels, but they are chained to some real labels that
		send the result of the function. The snippet
		</p><pre class="programlisting">del =&gt; $dataset-&gt;{tbDelete}-&gt;getOutputLabel(),</pre><p>
		says <span class="quote">&#8220;<span class="quote">create a return label named <span class="quote">&#8216;<span class="quote">del</span>&#8217;</span> and chain it from the
		tbDelete's output label</span>&#8221;</span>. The FnReturn normally does its chaining
		with <code class="computeroutput">chainFront()</code>, unless the option <code class="computeroutput">chainFront =&gt; 0</code>
		tells it otherwise. But in this particular case the chaining order wouldn't matter.
		There are more details to the naming and label
		creation but let's not get bogged in them now.
		</p><p>
		The FnBinding defines a matching set of labels, with the same logical
		names. It's like a receptacle and a plug: you put the plug into the
		receptacle and get the data flowing, you unplug it and the data flow
		stops. The Perl version of FnBinding provides a convenience: when it
		gets a code reference instead of a label, it automatically creates a
		label with that code for its handler.
		</p><p>
		In this case both binding labels forward the data to the Collapse's
		output label. Only the one for the Insert table has to change the
		opcodes to OP_INSERT. The check
		</p><pre class="programlisting">if ($_[1]-&gt;isDelete()) ...</pre><p>
		is really redundant, to be on the safe side, since we know that when
		the data will be flowing, all of it will be coming from the table
		clearing and have the opcodes of OP_DELETE.
		</p><a class="indexterm" name="id529407"></a><a class="indexterm" name="id538824"></a><p>
		The actual call happens in <code class="computeroutput">flush()</code>: Triceps::AutoFnBind is a constructor
		of the scope object that does the <span class="quote">&#8220;<span class="quote">plug into receptable</span>&#8221;</span>
		thing, with automatic unplugging when the object returned by it gets
		destroyed on leaving the block scope. If you want to do things
		manually, FnReturn has the methods <code class="computeroutput">push()</code> and
		<code class="computeroutput">pop()</code> but the scoped binding is safer and easier.  Once the
		binding is done, the data is sent through the function by calling
		<code class="computeroutput">clear()</code> on both tables. And then the block ends,
		<code class="computeroutput">$ab</code> get destroyed, AutoFnBind destructor undoes the binding, and 
		thus the streaming function call completes.
		</p><p>
		The result produced by this version of Collapse is exactly the same as
		by the original version. And even when we get down to grits, it's
		produced with the exact same logical sequence: the rows are sent out as
		they are deleted from the state tables. But it's structured
		differently: instead of the procedural deletion and sending of the
		rows, the internal machinery of the tables gets invoked, and the
		results of that machinery are then converted to the form suitable for
		the collapse results and propagated to the output.
		</p><p>
		Philosophically, it could be argued, what is the body of this function?
		Is it just the internal logic of the table delection, that gets
		triggered by <code class="computeroutput">clear()</code> in the caller? Or are the <code class="computeroutput">clear()</code> calls also a
		part of the function body? But it practice it just doesn't matter,
		whatever. 
		</p></div><div class="sect1" title="15.3. Collapse with grouping by key with streaming functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_keyed_collapse"></a>15.3. Collapse with grouping by key with streaming functions</h2></div></div></div><a class="indexterm" name="id538909"></a><a class="indexterm" name="id538919"></a><p>
		The Collapse as shown before sends all the collected deletes before all
		the collected inserts. For example, if it has collected the updates for
		four rows, the output will be (assuming that the Collapse element is
		named <code class="computeroutput">collapse</code> and the data set in it is named <code class="computeroutput">idata</code>):
		</p><pre class="programlisting">collapse.idata.out OP_DELETE local_ip="3.3.3.3" remote_ip="7.7.7.7"
    bytes="100"
collapse.idata.out OP_DELETE local_ip="2.2.2.2" remote_ip="6.6.6.6"
    bytes="100"
collapse.idata.out OP_DELETE local_ip="4.4.4.4" remote_ip="8.8.8.8"
    bytes="100"
collapse.idata.out OP_DELETE local_ip="1.1.1.1" remote_ip="5.5.5.5"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="3.3.3.3" remote_ip="7.7.7.7"
    bytes="300"
collapse.idata.out OP_INSERT local_ip="2.2.2.2" remote_ip="6.6.6.6"
    bytes="300"
collapse.idata.out OP_INSERT local_ip="4.4.4.4" remote_ip="8.8.8.8"
    bytes="300"
collapse.idata.out OP_INSERT local_ip="1.1.1.1" remote_ip="5.5.5.5"
    bytes="300"</pre><p>
		What if you want the updates produced as deletes immediately followed
		by the matching inserts with the same key?  Like this:
		</p><pre class="programlisting">collapse.idata.out OP_DELETE local_ip="3.3.3.3" remote_ip="7.7.7.7"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="3.3.3.3" remote_ip="7.7.7.7"
    bytes="300"
collapse.idata.out OP_DELETE local_ip="2.2.2.2" remote_ip="6.6.6.6"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="2.2.2.2" remote_ip="6.6.6.6"
    bytes="300"
collapse.idata.out OP_DELETE local_ip="4.4.4.4" remote_ip="8.8.8.8"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="4.4.4.4" remote_ip="8.8.8.8"
    bytes="300"
collapse.idata.out OP_DELETE local_ip="1.1.1.1" remote_ip="5.5.5.5"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="1.1.1.1" remote_ip="5.5.5.5"
    bytes="300"</pre><p>
		With the procedural version it would have required doing a look-up in the Insert
		table after processing each row in the Delete table and handling it if
		found. So I've left it out to avoid complicating that example. But in
		the streaming function form it becomes easy, just change the binding 
		of the <span class="quote">&#8220;<span class="quote">del</span>&#8221;</span> label a little bit:
		</p><pre class="programlisting">    my $lbInsInput = $dataset-&gt;{tbInsert}-&gt;getInputLabel();

    my $fbind = Triceps::FnBinding-&gt;new(
      name =&gt; $self-&gt;{name} . "." . $dataset-&gt;{name} . ".bndTbl",
      on =&gt; $fret,
      unit =&gt; $unit,
      labels =&gt; [
        del =&gt; sub {
          if ($_[1]-&gt;isDelete()) {
            $unit-&gt;call($lbOut-&gt;adopt($_[1]));
            # If the INSERT is available after this DELETE, this
            # will produce it.
            $unit-&gt;call($lbInsInput-&gt;adopt($_[1]));
          }
        },
        ins =&gt; sub {
          if ($_[1]-&gt;isDelete()) {
            $unit-&gt;call($lbOut-&gt;makeRowop($OP_INSERT, $_[1]-&gt;getRow()));
          }
        },
      ],
    );</pre><p>
		The <span class="quote">&#8220;<span class="quote">del</span>&#8221;</span> binding first sends the result out as usual and then forwards
		the DELETE rowop to the Insert table's input. Which then causes the
		INSERT rowop to be sent if a match is found. Mind you, the look-up and
		conditional processing still happens. But now it all happens inside the
		table machinery, all you need to do is add one more line to invoke it.
		</p><p>
		Let's talk through in a little more detail, what happens when the clearing of
		the Delete table deletes the row with <code class="computeroutput">(local_ip="3.3.3.3" remote_ip="7.7.7.7")</code>.
		</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
			The Delete table sends a rowop with this row and OP_DELETE to its
			output label <code class="computeroutput">collapse.idata.tbDelete.out</code>.
			</li><li class="listitem">
			Which then gets forwarded to a chained label in the FnReturn,
			<code class="computeroutput">collapse.idata.retTbl.del</code>.
			</li><li class="listitem">
			FnReturn has an FnBinding pushed into it, so the rowop passes to the
			matching label in the binding, <code class="computeroutput">collapse.idata.bndTbl.del</code>.
			</li><li class="listitem">
			The Perl handler of that label gets called, first forwards the
			rowop to the Collapse output label <code class="computeroutput">collapse.idata.out</code>, and then to
			the Insert table's input label <code class="computeroutput">collapse.idata.tbInsert.in</code>.
			</li><li class="listitem">
			The Insert table looks up the row by the key, finds it, removes it
			from the table, and sends an OP_DELETE rowop to its output label
			<code class="computeroutput">collapse.idata.tbInsert.out</code>.
			</li><li class="listitem">
			Which then gets forwarded to a chained label in the FnReturn,
			<code class="computeroutput">collapse.idata.retTbl.ins</code>.
			</li><li class="listitem">
			FnReturn has an FnBinding pushed into it, so the rowop passes to the
			matching label in the binding, <code class="computeroutput">collapse.idata.bndTbl.ins</code>.
			</li><li class="listitem">
			The Perl handler of that label gets called and sends the rowop with
			the opcode changed to OP_INSERT to the Collapse output label
			<code class="computeroutput">collapse.idata.out</code>.
			</li></ol></div><p>
		It's a fairly complicated sequence but all you needed to do was to add
		one line of code. The downside of course is that if something goes not
		the way you expected, you'd have to trace and understand the whole
		long sequence (that's the typical trouble with the SQL-based systems).
		</p><p>
		When the INSERTs are sent after DELETEs, their rows are removed
		from the Insert table too, so the following <code class="computeroutput">clear()</code> of the Insert table
		won't find them any more and won't send any duplicates; it will send
		only the inserts for which there were no matching deletes.
		</p><p>
		And of course if there is only a DELETE collected for a certain
		key, not an update, there will be no matching row in the Insert
		table, so the forwarded DELETE request will have no effect
		and produce no output from the Insert table.
		</p><p>
		You may notice that the code in the <span class="quote">&#8220;<span class="quote">del</span>&#8221;</span> handler only forwards the
		rows around, and that can be replaced by a chaining:
		</p><pre class="programlisting">    my $lbDel = $unit-&gt;makeDummyLabel(
      $dataset-&gt;{tbDelete}-&gt;getOutputLabel()-&gt;getRowType(),
      $self-&gt;{name} . "." . $dataset-&gt;{name} . ".lbDel");
    $lbDel-&gt;chain($lbOut);
    $lbDel-&gt;chain($lbInsInput);

    my $fbind = Triceps::FnBinding-&gt;new(
      name =&gt; $self-&gt;{name} . "." . $dataset-&gt;{name} . ".bndTbl",
      on =&gt; $fret,
      unit =&gt; $unit,
      labels =&gt; [
        del =&gt; $lbDel,
        ins =&gt; sub {
          $unit-&gt;call($lbOut-&gt;makeRowop($OP_INSERT, $_[1]-&gt;getRow()));
        },
      ],
    );</pre><a class="indexterm" name="id539164"></a><p>
		This shows another way of label definition in FnBinding: an actual
		label is created first and then given to the FnBinding, instead of letting
		it automatically create a label from the code. The condition
		<span class="quote">&#8220;<span class="quote"><code class="computeroutput">if ($_[1]-&gt;isDelete())</code></span>&#8221;</span> has been removed 
		from the <span class="quote">&#8220;<span class="quote">ins</span>&#8221;</span> part, since
		it's really redundant and the <span class="quote">&#8220;<span class="quote">del</span>&#8221;</span> part with its chaining doesn't do
		this check anyway.
		</p><p>
		This code works just as well and even more efficiently than the
		previous version, since no Perl code needs to be invoked for <span class="quote">&#8220;<span class="quote">del</span>&#8221;</span>, it
		all propagates internally through the chaining. However the price is
		that the DELETE rowops coming out of the output label will have the
		head-of-the-chain label in them:
		</p><pre class="programlisting">collapse.idata.lbDel OP_DELETE local_ip="3.3.3.3" remote_ip="7.7.7.7"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="3.3.3.3" remote_ip="7.7.7.7"
    bytes="300"
collapse.idata.lbDel OP_DELETE local_ip="2.2.2.2" remote_ip="6.6.6.6"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="2.2.2.2" remote_ip="6.6.6.6"
    bytes="300"
collapse.idata.lbDel OP_DELETE local_ip="4.4.4.4" remote_ip="8.8.8.8"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="4.4.4.4" remote_ip="8.8.8.8"
    bytes="300"
collapse.idata.lbDel OP_DELETE local_ip="1.1.1.1" remote_ip="5.5.5.5"
    bytes="100"
collapse.idata.out OP_INSERT local_ip="1.1.1.1" remote_ip="5.5.5.5"
    bytes="300"</pre><p>
		The <span class="quote">&#8220;<span class="quote">ins</span>&#8221;</span> side can't be handled just by chaining because it has to
		replace the opcode in the rowops. Another potential way to handle
		this would be to define various preprogrammed label types in C++ for many primitive
		operations, like replacing the opcode, and then build the models by combining
		them.
		</p><a class="indexterm" name="id539227"></a><p>
		The final item is that the code shown in this section involved a recursive
		call of the streaming function. Its output from the <span class="quote">&#8220;<span class="quote">del</span>&#8221;</span> label got fed
		back to the function, producing more output on the <span class="quote">&#8220;<span class="quote">ins</span>&#8221;</span> label. This
		worked because it invoked a different code path in the streaming
		function than the one that produced the <span class="quote">&#8220;<span class="quote">del</span>&#8221;</span> data. If it were to form
		a topological loop back to the same path with the same labels, that
		would have been an error. The more advanced use of recursion is
		possible and will be discussed in more detail later. 
		</p></div><div class="sect1" title="15.4. Table-based translation with streaming functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_translation"></a>15.4. Table-based translation with streaming functions</h2></div></div></div><p>
		Next I want to show an example that is in its essence kind of dumb. The
		same thing is easier to do in Triceps with templates. And the whole
		premise is not exactly great either. But it provides an opportunity to
		show more of the streaming functions, in a set-up that is closer to the
		SQL-based systems.
		</p><a class="indexterm" name="id539271"></a><a class="indexterm" name="id539280"></a><p>
		The background is as follows: There happen to be multiple ways to
		identify the securities (stock shares and such). <span class="emphasis"><em>RIC</em></span> is the identifier
		used by Reuters (and quite often by the other data suppliers too),
		consisting of the ticker symbol on an exchange, a dot, and the coded name of the
		exchange (such as <span class="quote">&#8220;<span class="quote">L</span>&#8221;</span> for the London stock exchange or 
		<span class="quote">&#8220;<span class="quote">N</span>&#8221;</span> for the New York stock exchange). 
		<span class="emphasis"><em>ISIN</em></span> is the international standard alphanumeric identifier. A security
		(and some of its creative equivalents) might happen to be listed on
		multiple exchanges, each listing having its own RIC. And if you wonder,
		the ticker names are allocated separately by each exchange and may differ.
		But all of these RICs refer
		to the same security, thus translating to the
		same ISIN (there might be multiple ISINs too but that's another story).
		A large financial company would want to track a security all around the
		world. To aggregate the data on the security worldwide, it has to
		identify it by ISIN, but the data feed might be coming in as RIC only.
		The translation of RIC to ISIN is then done by the table during
		processing. The RIC is not thrown away either, it shows the detail of
		what and where had happened. But ISIN is added for the aggregation on it.
		</p><p>
		The data might be coming from multiple feeds, and there are multiple
		kinds of data: trades, quotes, lending quotes and so on, each with its
		own schema and its own aggregations. However the step of RIC-to-ISIN
		translation is the same for all of them, is done by the same table, and
		can be done in one place. Of course, multithreading can add more
		twists here but for now we're talking about a simple single-threaded
		example.
		</p><p>
		An extra complexity is that in the real world the translation table
		might be incomplete. However some feeds might provide both RICs and
		ISINs in their records, so the pairs that aren't in the reference table
		yet, can be inserted there and used for the following translations.
		This is actually not such a great idea, because it means that there
		might be previous records that went through before the translation
		became available. A much better way would be to do the translation as a
		join, where the update to a reference table would update any previous
		records as well. But then there would not be much use for a streaming
		function in it. As I've said before, it's a rather dumb example.
		</p><p>
		The streaming function will work like this: It will get an argument
		pair of (RIC, ISIN) from an incoming record. Either component of this
		pair might be empty. Since the rest of the record is wildly different
		for different feeds, the rest of the record is left off at this point,
		and the uniform argument of (RIC, ISIN) is given to the function. The
		function will consult its table, see if it can add more information
		from there, or add more information from the argument into the table,
		and return the hopefully enriched pair (RIC, ISIN) with an empty ISIN
		field replaced by the right value, to the caller.
		</p><p>
		The function is defined like this:
		</p><pre class="programlisting">my $rtIsin = Triceps::RowType-&gt;new(
  ric =&gt; "string",
  isin =&gt; "string",
);

my $ttIsin = Triceps::TableType-&gt;new($rtIsin)
  -&gt;addSubIndex("byRic", Triceps::IndexType-&gt;newHashed(key =&gt; [ "ric" ])
);
$ttIsin-&gt;initialize();

my $tIsin = $unit-&gt;makeTable($ttIsin, "tIsin");

# the results will come from here
my $fretLookupIsin = Triceps::FnReturn-&gt;new(
  name =&gt; "fretLookupIsin",
  unit =&gt; $unit,
  labels =&gt; [
    result =&gt; $rtIsin,
  ],
);

# The function argument: the input data will be sent here.
my $lbLookupIsin = $unit-&gt;makeLabel($rtIsin, "lbLookupIsin", undef, sub {
  my $row = $_[1]-&gt;getRow();
  if ($row-&gt;get("ric")) {
    my $argrh = $tIsin-&gt;makeRowHandle($row);
    my $rh = $tIsin-&gt;find($argrh);
    if ($rh-&gt;isNull()) {
      if ($row-&gt;get("isin")) {
        $tIsin-&gt;insert($argrh);
      }
    } else {
      $row = $rh-&gt;getRow();
    }
  }
  $unit-&gt;call($fretLookupIsin-&gt;getLabel("result")-&gt;makeRowop("OP_INSERT", $row));
});</pre><p>
		The <code class="computeroutput">$fretLookupIsin</code> is the function result, <code class="computeroutput">$lbLookupIsin</code> is the
		function input. In this example the result label in FnReturn is defined
		differently than in the previous ones: not by a source label but by a
		row type. This label doesn't get chained to anything, instead the
		procedural code in the function finds it as <code class="computeroutput">$fretLookupIsin-&gt;getLabel("result")</code> and
		calls it directly.
		</p><p>
		Then the ISIN translation code for some trades feed would look as
		follows (remember, supposedly there would be many feeds, each one with its
		own schema, but for the example I show only one):
		</p><pre class="programlisting">my $rtTrade = Triceps::RowType-&gt;new(
  ric =&gt; "string",
  isin =&gt; "string",
  size =&gt; "float64",
  price =&gt; "float64",
);

my $lbTradeEnriched = $unit-&gt;makeDummyLabel($rtTrade, "lbTradeEnriched");
my $lbTrade = $unit-&gt;makeLabel($rtTrade, "lbTrade", undef, sub {
  my $rowop = $_[1];
  my $row = $rowop-&gt;getRow();
  Triceps::FnBinding::call(
    name =&gt; "callTradeLookupIsin",
    on =&gt; $fretLookupIsin,
    unit =&gt; $unit,
    rowop =&gt; $lbLookupIsin-&gt;makeRowopHash("OP_INSERT",
      ric =&gt; $row-&gt;get("ric"),
      isin =&gt; $row-&gt;get("isin"),
    ),
    labels =&gt; [
      result =&gt; sub { # a label will be created from this sub
        $unit-&gt;call($lbTradeEnriched-&gt;makeRowop($rowop-&gt;getOpcode(),
          $row-&gt;copymod(
            isin =&gt; $_[1]-&gt;getRow()-&gt;get("isin")
          )
        ));
      },
    ],
  );
});</pre><p>
		The label <code class="computeroutput">$lbTrade</code> receives the incoming trades, calls the streaming
		function to enrich them with the ISIN data, and forwards the enriched
		data to the label <code class="computeroutput">$lbTradeEnriched</code>. The function call is done
		differently in this example. Rather than create a FnBinding object and
		then use it with a scoped AutoFnBind, it uses the convenience function
		<code class="computeroutput">FnBinding::call()</code> that wraps all that logic. It's simpler to use,
		without all these extra objects, but the price is the efficiency: it
		ends up creating a new FnBinding object for every call. That's where a
		compiler would be very useful, it could take a call like this,
		translate it to the internal objects once, and then keep reusing them.
		</p><a class="indexterm" name="id539436"></a><a class="indexterm" name="id539446"></a><p>
		The <code class="computeroutput">FnBinding::call()</code> option <span class="quote">&#8220;<span class="quote">name</span>&#8221;</span> gives a 
		name that is used for the error messages and
		also to produce the names of the temporary objects it creates. The option <span class="quote">&#8220;<span class="quote">on</span>&#8221;</span>
		tells, which streaming function is being called (by specifying its
		FnReturn). The option <span class="quote">&#8220;<span class="quote">rowop</span>&#8221;</span> gives the arguments of the streaming
		functions. There are multiple ways to do that: option <span class="quote">&#8220;<span class="quote">rowop</span>&#8221;</span> for a
		single rowop, <span class="quote">&#8220;<span class="quote">rowops</span>&#8221;</span> for an array of rowops, <span class="quote">&#8220;<span class="quote">tray</span>&#8221;</span> for a tray, and
		<span class="quote">&#8220;<span class="quote">code</span>&#8221;</span> for a procedural code snippet that would send the inputs
		to the streaming function. And
		<span class="quote">&#8220;<span class="quote">labels</span>&#8221;</span> as usual connects the results of the function, either to the
		existing labels, or by creating labels automatically from the snippets of code.
		</p><a class="indexterm" name="id539499"></a><p>
		The result handling in this example demonstrates the technique that I call the
		<span class="quote">&#8220;<span class="quote">implicit join</span>&#8221;</span>: The function gets a portion of data from an original
		row, does some transformation and returns the data back. This data is
		then joined with the original row. The code knows, what this original
		row was, it gets remembered in the variable <code class="computeroutput">$row</code>. The semantics of the
		call guarantees that nothing else has happened during the function
		call, and that <code class="computeroutput">$row</code> is still the current row. Then the function result
		gets joined with <code class="computeroutput">$row</code>, and the produced data is sent further on its
		way. The variable <code class="computeroutput">$row</code> could be either a global one, or as shown here a
		scoped variable that gets embedded into a closure function.
		</p><p>
		The rest of the example, the dispatcher part, is:
		</p><pre class="programlisting"># print what is going on
my $lbPrintIsin = makePrintLabel("printIsin", $tIsin-&gt;getOutputLabel());
my $lbPrintTrade = makePrintLabel("printTrade", $lbTradeEnriched);

# the main loop
my %dispatch = (
  isin =&gt; $tIsin-&gt;getInputLabel(),
  trade =&gt; $lbTrade,
);

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/); # starts with a command, then string opcode
  my $type = shift @data;
  my $lb = $dispatch{$type};
  my $rowop = $lb-&gt;makeRowopArray(@data);
  $unit-&gt;call($rowop);
  $unit-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		And an example of running, with the input lines shown in bold:
		</p><pre class="programlisting"><span class="bold"><strong>isin,OP_INSERT,ABC.L,US0000012345</strong></span>
tIsin.out OP_INSERT ric="ABC.L" isin="US0000012345"
<span class="bold"><strong>isin,OP_INSERT,ABC.N,US0000012345</strong></span>
tIsin.out OP_INSERT ric="ABC.N" isin="US0000012345"
<span class="bold"><strong>isin,OP_INSERT,DEF.N,US0000054321</strong></span>
tIsin.out OP_INSERT ric="DEF.N" isin="US0000054321"
<span class="bold"><strong>trade,OP_INSERT,ABC.L,,100,10.5</strong></span>
lbTradeEnriched OP_INSERT ric="ABC.L" isin="US0000012345" size="100"
    price="10.5"
<span class="bold"><strong>trade,OP_DELETE,ABC.N,,200,10.5</strong></span>
lbTradeEnriched OP_DELETE ric="ABC.N" isin="US0000012345" size="200"
    price="10.5"
<span class="bold"><strong>trade,OP_INSERT,GHI.N,,300,10.5</strong></span>
lbTradeEnriched OP_INSERT ric="GHI.N" isin="" size="300" price="10.5"
<span class="bold"><strong>trade,OP_INSERT,,XX0000012345,400,10.5</strong></span>
lbTradeEnriched OP_INSERT ric="" isin="XX0000012345" size="400"
    price="10.5"
<span class="bold"><strong>trade,OP_INSERT,GHI.N,XX0000012345,500,10.5</strong></span>
tIsin.out OP_INSERT ric="GHI.N" isin="XX0000012345"
lbTradeEnriched OP_INSERT ric="GHI.N" isin="XX0000012345" size="500"
    price="10.5"
<span class="bold"><strong>trade,OP_INSERT,GHI.N,,600,10.5</strong></span>
lbTradeEnriched OP_INSERT ric="GHI.N" isin="XX0000012345" size="600"
    price="10.5"</pre><p>
		The table gets pre-populated with a few translations, and the first few
		trades use them. Then goes the example of a non-existing translation,
		which gets eventually added from the incoming data (see that the trade
		with <code class="computeroutput">(GHI.N, XX0000012345)</code> both updates the ISIN table and sends through
		the trade record), and the following trades can then use this newly
		added translation but obviously the older ones do not get updated. 
		</p></div><div class="sect1" title="15.5. Streaming functions and loops"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_loops"></a>15.5. Streaming functions and loops</h2></div></div></div><a class="indexterm" name="id539651"></a><a class="indexterm" name="id539661"></a><a class="indexterm" name="id539670"></a><a class="indexterm" name="id539684"></a><p>
		The streaming functions can be used to replace the topological loops
		(where the connection between the labels go in circles) with the
		procedural ones. Just make the body of the loop into a streaming
		function and connect its output with its own input (and of course also
		to the loop results). Then call this function in a procedural
		while-loop until the data stop circulating.
		</p><p>
		The way the streaming functions have been described so far, there is a
		catch, even two of them: First, with such a connection, the output of
		the streaming function would immediately circulate to its input, and
		would try to keep circulating until the loop is done, with no need for
		a while-loop. Second, as soon as it attempts to circulate, the
		scheduler will detect a recursive call and die (unless you change
		the recursion settings, however this is not a good reason to change them).
		</p><p>
		But there is also a solution that has not been described yet: an
		FnBinding can collect the incoming rowops in a tray instead of
		immediately forwarding them. This tray can be called later, after the
		original function call completes. This way the iteration has its data collected, 
		the function completes, and then the next iteration of the while-loop starts,
		sending the data from the previous iteration. When there is nothing to
		send any more, the loop completes.
		</p><a class="indexterm" name="id539719"></a><a class="indexterm" name="id539729"></a><p>
		Using this logic, let's rewrite the Fibonacci example with the
		streaming function loops. Its original version and description of the
		logic can be found in 
		<a class="xref" href="#sc_sched_topo_loops" title="7.7. Topological loops">Section 7.7: &#8220;Topological loops&#8221; </a>.
		</p><p>
		The new version is:
		</p><pre class="programlisting">my $uFib = Triceps::Unit-&gt;new("uFib");

###
# A streaming function that computes one step of a
# Fibonacci number, will be called repeatedly.

# Type of its input and output.
my $rtFib = Triceps::RowType-&gt;new(
  iter =&gt; "int32", # number of iterations left to do
  cur =&gt; "int64", # current number
  prev =&gt; "int64", # previous number
);

# Input:
#   $lbFibCompute: request to do a step. iter will be decremented,
#     cur moved to prev, new value of cur computed.
# Output (by FnReturn labels):
#   "next": data to send to the next step, if the iteration
#     is not finished yet (iter in the produced row is &gt;0).
#   "result": the result data if the iretaion is finished
#     (iter in the produced row is 0).
# The opcode is preserved through the computation.

my $frFib = Triceps::FnReturn-&gt;new(
  name =&gt; "Fib",
  unit =&gt; $uFib,
  labels =&gt; [
    next =&gt; $rtFib,
    result =&gt; $rtFib,
  ],
);

my $lbFibCompute = $uFib-&gt;makeLabel($rtFib, "FibCompute", undef, sub {
  my $row = $_[1]-&gt;getRow();
  my $prev = $row-&gt;get("cur");
  my $cur = $prev + $row-&gt;get("prev");
  my $iter = $row-&gt;get("iter") - 1;
  $uFib-&gt;makeHashCall($frFib-&gt;getLabel($iter &gt; 0? "next" : "result"), $_[1]-&gt;getOpcode(),
    iter =&gt; $iter,
    cur =&gt; $cur,
    prev =&gt; $prev,
  );
});

# End of streaming function
###

my $lbPrint = $uFib-&gt;makeLabel($rtFib, "Print", undef, sub {
  print($_[1]-&gt;getRow()-&gt;get("cur"));
});

# binding to run the Triceps steps in a loop
my $fbFibLoop = Triceps::FnBinding-&gt;new(
  name =&gt; "FibLoop",
  on =&gt; $frFib,
  withTray =&gt; 1,
  labels =&gt; [
    next =&gt; $lbFibCompute,
    result =&gt; $lbPrint,
  ],
);

my $lbMain = $uFib-&gt;makeLabel($rtFib, "Main", undef, sub {
  my $row = $_[1]-&gt;getRow();
  {
    my $ab = Triceps::AutoFnBind-&gt;new($frFib, $fbFibLoop);

    # send the request into the loop
    $uFib-&gt;makeHashCall($lbFibCompute, $_[1]-&gt;getOpcode(),
      iter =&gt; $row-&gt;get("iter"),
      cur =&gt; 0, # the "0-th" number
      prev =&gt; 1,
    );

    # now keep cycling the loop until it's all done
    while (!$fbFibLoop-&gt;trayEmpty()) {
      $fbFibLoop-&gt;callTray();
    }
  }
  print(" is Fibonacci number ", $row-&gt;get("iter"), "\n");
});

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/);
  $uFib-&gt;makeArrayCall($lbMain, @data);
  $uFib-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		It produces the same output as before (as usual,
		the lines in bold are the input lines):
		</p><pre class="programlisting"><span class="bold"><strong>OP_INSERT,1</strong></span>
1 is Fibonacci number 1
<span class="bold"><strong>OP_DELETE,2</strong></span>
1 is Fibonacci number 2
<span class="bold"><strong>OP_INSERT,5</strong></span>
5 is Fibonacci number 5
<span class="bold"><strong>OP_INSERT,6</strong></span>
8 is Fibonacci number 6</pre><p>
		The option <span class="quote">&#8220;<span class="quote">withTray</span>&#8221;</span> of FnBind is what makes it collect the rowops in
		a tray. The rowops are not the original incoming ones but already
		translated to call the FnBinding's output labels. The method <code class="computeroutput">callTray()</code>
		swaps the tray with a fresh one and then calls the original tray with
		the collected rowops. There are more methods for the tray control:
		<code class="computeroutput">swapTray()</code> swaps the tray with a fresh one and returns the original
		one, which can then be read or called; <code class="computeroutput">traySize()</code> returns not just the
		emptiness condition but the whole size of the tray.
		</p><p>
		The whole loop runs in one binding scope, because it doesn't change
		with the iterations. The first row primes the loop, and then it
		continues while there is anything to circulate.
		</p><p>
		This example sent both the next iteration rows and the result rows
		through the binding. But for the result rows it doesn't have to. They
		can be sent directly out of the loop:
		</p><pre class="programlisting">my $lbFibCompute = $uFib-&gt;makeLabel($rtFib, "FibCompute", undef, sub {
  my $row = $_[1]-&gt;getRow();
  my $prev = $row-&gt;get("cur");
  my $cur = $prev + $row-&gt;get("prev");
  my $iter = $row-&gt;get("iter") - 1;
  $uFib-&gt;makeHashCall($iter &gt; 0? $frFib-&gt;getLabel("next") : $lbPrint, $_[1]-&gt;getOpcode(),
    iter =&gt; $iter,
    cur =&gt; $cur,
    prev =&gt; $prev,
  );
});</pre><p>
		The printed result is exactly the same as in the previous example. 
		</p></div><div class="sect1" title="15.6. Streaming functions and pipelines"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_pipelines"></a>15.6. Streaming functions and pipelines</h2></div></div></div><a class="indexterm" name="id539882"></a><a class="indexterm" name="id539892"></a><p>
		The streaming functions can be arranged into a pipeline by binding the
		result of one function to the input of another one. Fundamentally, the
		pipelines in the world of streaming functions are analogs of the nested
		calls with the common functions. For example, a pipeline (written for
		shortness in the Unix way)
		</p><pre class="programlisting">a | b | c</pre><p>
		is an analog of the common function calls
		</p><pre class="programlisting">c(b(a()))</pre><p>
		Of course, if the pipeline is fixed, it can as well be connected
		directly with the label chaining and then stay like this. A more
		interesting case is when the pipeline needs to be reconfigured
		dynamically based on the user requests.

		An interesting example of pipeline usage comes from the data security.
		A client may connect to a CEP model element in a clear-text or
		encrypted way. In the encrypted way the data received from the client
		needs to be decrypted, then processed, and then the results encrypted
		before sending them back:
		</p><pre class="programlisting">receive | decrypt | process | encrypt | send</pre><p>
		In the clear-text mode the pipeline becomes shorter:
		</p><pre class="programlisting">receive | process | send</pre><p>
		Let's make an example around this idea: To highlight the flexibility,
		the configuration will be selectable for each input line. If the input
		starts with a <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span>, it will be considered encrypted, otherwise
		clear-text. Since the actual security is not important for the example, it will be
		simulated by encoding the text in hex (each byte of data becomes two
		hexadecimal digits). The real encryption, such as SSL, would of course
		require the key negotiation, but this little example just skips over
		this part, since it has no key.

		First, define the input and output (receive and send) endpoints:
		</p><pre class="programlisting"># All the input and output gets converted through an intermediate
# format of a row with one string field.
my $rtString = Triceps::RowType-&gt;new(
  s =&gt; "string"
);

# All the input gets sent here.
my $lbReceive = $unit-&gt;makeDummyLabel($rtString, "lbReceive");
my $retReceive = Triceps::FnReturn-&gt;new(
  name =&gt; "retReceive",
  labels =&gt; [
    data =&gt; $lbReceive,
  ],
);

# The binding that actually prints the output.
my $bindSend = Triceps::FnBinding-&gt;new(
  name =&gt; "bindSend",
  on =&gt; $retReceive, # any matching return will do
  unit =&gt; $unit,
  labels =&gt; [
    data =&gt; sub {
      print($_[1]-&gt;getRow()-&gt;get("s"), "\n");
    },
  ],
);</pre><a class="indexterm" name="id539974"></a><p>
		The same row type <code class="computeroutput">$rtString</code> will be used for the whole pipeline,
		sending through the arbitrary strings of text. The binding <code class="computeroutput">$bindSend</code> is
		defined on <code class="computeroutput">$retReceive</code>, so they can actually be short-circuited
		together. But they don't have to. <code class="computeroutput">$bindSend</code> can be bound to any
		matching return. The matching return is defined as having the same
		number of labels in it, with matching row types. The names of the
		labels don't matter but their order does. It's a bit tricky: when a
		binding is created, the labels in it get connected to the return on
		which it's defined by name. But at this point each of them gets
		assigned a number, in order the labels went in that original return.
		After that only this number matters: if this binding gets connected to
		another matching return, it will get the data from the return's label
		with the same number, not the same name.
		</p><p>
		Next step, define the endpoints for the processing: the dispatcher and
		the output label. All of them use the same row type and matching
		returns. The actual processing will eventually be hard-connected
		between these endpoints.
		</p><pre class="programlisting">my %dispatch; # the dispatch table will be set here

# The binding that dispatches the input data
my $bindDispatch = Triceps::FnBinding-&gt;new(
  name =&gt; "bindDispatch",
  on =&gt; $retReceive,
  unit =&gt; $unit,
  labels =&gt; [
    data =&gt; sub {
      my @data = split(/,/, $_[1]-&gt;getRow()-&gt;get("s")); # starts with a command, then string opcode
      my $type = shift @data;
      my $lb = $dispatch{$type};
      my $rowop = $lb-&gt;makeRowopArray(@data);
      $unit-&gt;call($rowop);
    },
  ],
);

# All the output gets converted to rtString and sent here.
my $lbOutput = $unit-&gt;makeDummyLabel($rtString, "lbOutput");
my $retOutput = Triceps::FnReturn-&gt;new(
  name =&gt; "retOutput",
  labels =&gt; [
    data =&gt; $lbOutput,
  ],
);</pre><p>
		And now the filters for encryption and decryption. Each of them has a
		binding for its input and a return for its output. The actual
		pseudo-encryption transformation is done with Perl functions <code class="computeroutput">unpack()</code>
		and <code class="computeroutput">pack()</code>.
		</p><pre class="programlisting"># The encryption pipeline element.
my $retEncrypt = Triceps::FnReturn-&gt;new(
  name =&gt; "retEncrypt",
  unit =&gt; $unit,
  labels =&gt; [
    data =&gt; $rtString,
  ],
);
my $lbEncrypt = $retEncrypt-&gt;getLabel("data");
my $bindEncrypt = Triceps::FnBinding-&gt;new(
  name =&gt; "bindEncrypt",
  on =&gt; $retReceive,
  unit =&gt; $unit,
  labels =&gt; [
    data =&gt; sub {
      my $s = $_[1]-&gt;getRow()-&gt;get("s");
      $unit-&gt;makeArrayCall($lbEncrypt, "OP_INSERT", unpack("H*", $s));
    },
  ],
);

# The decryption pipeline element.
my $retDecrypt = Triceps::FnReturn-&gt;new(
  name =&gt; "retDecrypt",
  unit =&gt; $unit,
  labels =&gt; [
    data =&gt; $rtString,
  ],
);
my $lbDecrypt = $retDecrypt-&gt;getLabel("data");
my $bindDecrypt = Triceps::FnBinding-&gt;new(
  name =&gt; "bindDecrypt",
  on =&gt; $retReceive,
  unit =&gt; $unit,
  labels =&gt; [
    data =&gt; sub {
      my $s = $_[1]-&gt;getRow()-&gt;get("s");
      $unit-&gt;makeArrayCall($lbDecrypt, "OP_INSERT", pack("H*", $s));
    },
  ],
);</pre><p>
		Then goes the body of the model. It defines the actual row types for
		the data that gets parsed from strings and the business logic (which is
		pretty simple, increasing an integer field). The dispatch table
		connects the dispatcher with the business logic, and the conversion
		from the data rows to the plain text rows is done with template
		<code class="computeroutput">makePipePrintLabel()</code>. This template is very similar to the template
		<code class="computeroutput">makePrintLabel()</code> that was shown in 
		<a class="xref" href="#sc_template_wrapper" title="10.3. Simple wrapper templates">Section 10.3: &#8220;Simple wrapper templates&#8221; </a>.
		</p><pre class="programlisting">sub makePipePrintLabel($$$) # ($print_label_name, $parent_label, $out_label)
{
  my $name = shift;
  my $lbParent = shift;
  my $lbOutput = shift;
  my $unit = $lbOutput-&gt;getUnit();
  my $lb = $lbParent-&gt;getUnit()-&gt;makeLabel($lbParent-&gt;getType(), $name,
    undef, sub { # (label, rowop)
      $unit-&gt;makeArrayCall(
        $lbOutput, "OP_INSERT", $_[1]-&gt;printP());
    });
  $lbParent-&gt;chain($lb);
  return $lb;
}

# The body of the model: pass through the name, increase the count.
my $rtData = Triceps::RowType-&gt;new(
  name =&gt; "string",
  count =&gt; "int32",
);

my $lbIncResult = $unit-&gt;makeDummyLabel($rtData, "result");
my $lbInc = $unit-&gt;makeLabel($rtData, "inc", undef, sub {
  my $row = $_[1]-&gt;getRow();
  $unit-&gt;makeHashCall($lbIncResult, $_[1]-&gt;getOpcode(),
    name  =&gt; $row-&gt;get("name"),
    count =&gt; $row-&gt;get("count") + 1,
  );
});
makePipePrintLabel("printResult", $lbIncResult, $lbOutput);

%dispatch = (
  inc =&gt; $lbInc,
);</pre><p>
		Finally, the main loop. It will check the input lines for the leading
		<span class="quote">&#8220;<span class="quote">+</span>&#8221;</span> and construct one or the other pipeline for processing. Of course,
		the pipelines don't have to be constructed in the main loop. They could
		have been constructed in the handler of <code class="computeroutput">$lbReceive</code> just as well (then
		it would need a separate label to send its result to, and to include
		into <code class="computeroutput">$retReceive</code>).
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  my $ab;
  chomp;
  if (/^\+/) {
    $ab = Triceps::AutoFnBind-&gt;new(
      $retReceive =&gt; $bindDecrypt,
      $retDecrypt =&gt; $bindDispatch,
      $retOutput =&gt; $bindEncrypt,
      $retEncrypt =&gt; $bindSend,
    );
    $_ = substr($_, 1);
  } else {
    $ab = Triceps::AutoFnBind-&gt;new(
      $retReceive =&gt; $bindDispatch,
      $retOutput =&gt; $bindSend,
    );
  };
  $unit-&gt;makeArrayCall($lbReceive, "OP_INSERT", $_);
  $unit-&gt;drainFrame();
}</pre><a class="indexterm" name="id540150"></a><p>
		The constructor of AutoFnBind can accept
		multiple return-binding pairs. It will bind them all, and unbind them
		back on its object destruction. It's the same thing as creating
		multiple AutoFnBind objects, one for each pair, only more efficient.

		And here is an example of a run (as usual the input lines are in bold,
		and the long lines get wrapped):
		</p><pre class="programlisting"><span class="bold"><strong>inc,OP_INSERT,abc,1</strong></span>
result OP_INSERT name="abc" count="2"
<span class="bold"><strong>inc,OP_DELETE,def,100</strong></span>
result OP_DELETE name="def" count="101"
<span class="bold"><strong>+696e632c4f505f494e534552542c6162632c32</strong></span>
726573756c74204f505f494e53455254206e616d653d226162632220636f756e743d2
  2332220
<span class="bold"><strong>+696e632c4f505f44454c4554452c6465662c313031</strong></span>
726573756c74204f505f44454c455445206e616d653d226465662220636f756e743d2
  23130322220</pre><p>
		What is in the encrypted data? The input lines have been produced by
		running a Perl expression manually:
		</p><pre class="programlisting">$ perl -e 'print((unpack "H*", "inc,OP_INSERT,abc,2"), "\n");'
696e632c4f505f494e534552542c6162632c32
$ perl -e 'print((unpack "H*", "inc,OP_DELETE,def,101"), "\n");'
696e632c4f505f44454c4554452c6465662c313031</pre><p>
		They and their results can be decoded by running another Perl expression:
		</p><pre class="programlisting">$ perl -e 'print((pack "H*", "726573756c74204f505f494e53455254206e616
  d653d226162632220636f756e743d22332220"), "\n");'
result OP_INSERT name="abc" count="3"
$ perl -e 'print((pack "H*", "726573756c74204f505f44454c455445206e616
  d653d226465662220636f756e743d223130322220"), "\n");'
result OP_DELETE name="def" count="102"</pre></div><div class="sect1" title="15.7. Streaming functions and tables"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_tables"></a>15.7. Streaming functions and tables</h2></div></div></div><a class="indexterm" name="id540236"></a><a class="indexterm" name="id540246"></a><p>
		Sometimes you might want to collect a table's reaction to
		an operation on it and process it manually afterwards.
		Triceps 1.0 had a special feature called <span class="quote">&#8220;<span class="quote">copy tray</span>&#8221;</span>
		to support that but starting with the version 2.0 the
		streaming functions solve this problem much better, replacing
		the copy trays.
		</p><p>
		If you connect the table's output to a FnReturn and then
		push a binding with a tray onto it, the table's output
		will be collected on that tray. There is even a Table
		method that creates this FnReturn:
		</p><pre class="programlisting">$fret = $table-&gt;fnReturn();</pre><p>
		The return contains the labels <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span> (more
		on that one below) and the named labels for
		all aggregators. The FnReturn object is created on the first call of
		this method and is kept in the table. All the following calls return
		the same object. This has some interesting consequences for the <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span>
		label: the rowop for the <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> label doesn't get created at all if
		there is nothing chained from that label. But when the FnReturn gets
		created, one of its labels gets chained from the <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> label. Which
		means that once you call <code class="computeroutput">$table-&gt;fnReturn()</code> for the first time, you
		will see that table's <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> label called in all the traces. It's not a
		huge extra overhead, but still something to keep in mind and not be
		surprised when calling <code class="computeroutput">fnReturn()</code> changes all your traces.
		</p><p>
		The following code demonstrates the use of an FnReturn to collect
		the changes done to a table on insert:
		</p><pre class="programlisting">my $fret1 = $t1-&gt;fnReturn();
my $fbind1 = Triceps::FnBinding-&gt;new(
    unit =&gt; $unit,
    name =&gt; "fbind1",
    on =&gt; $fret1,
    withTray =&gt; 1,
    labels =&gt; [
        out =&gt; sub { }, # another way to make a dummy
    ],
);

$fret1-&gt;push($fbind1);
$t1-&gt;insert($row1);
$fret1-&gt;pop($fbind1);

# $tray contains the rowops produced by the update
my $tray = $fbind1-&gt;swapTray(); # get the updates on an insert
my @rowops = $tray-&gt;toArray();</pre><p>
		And then you could for example check if any rowop has the DELETE opcode,
		this meaning that an old row was displaced by this insert. Of course,
		this is not the most efficient way. Placing the check into the label handler
		would be a better approach. And you don't even have to collect the rowops
		in a tray, you can as well compute the result on the fly:
		</p><pre class="programlisting">my $seenDelete;

my $fret1 = $t1-&gt;fnReturn();
my $fbind1 = Triceps::FnBinding-&gt;new(
    unit =&gt; $unit,
    name =&gt; "fbind1",
    on =&gt; $fret1,
    labels =&gt; [
        out =&gt; sub {
      $seenDelete = 1 if ($_[1]-&gt;isDelete());
    }
    ],
);

$fret1-&gt;push($fbind1);
$seenDelete = 0;
$t1-&gt;insert($row1);
$fret1-&gt;pop($fbind1);

if ($seenDelete) {
  # there was a displacement
}</pre><p>
		The variable <code class="computeroutput">$seenDelete</code> is remembered in the closure function
		that handles the <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span> label and sets it accordingly.
		</p><p>
		In both examples the binding doesn't have to be created from scratch
		each time. Creating it once and then reusing as needed would be more
		efficient.
		</p><p>
		And of course the use of an FnReturn doesn't preclude you from connecting
		the table outputs as usual.
		</p><a class="indexterm" name="id540388"></a><p>
		Another feature where the tables and streaming functions intersect is the table
		dumping. It allows to iterate on a table in a functional manner.
		</p><p>
		The label <span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span> is present in the table and its FnReturn. Whenever the
		method <code class="computeroutput">Table::dumpAll()</code> is called, it sends the whole contents of the table to
		that label. Then you can set a binding on the table's FnReturn, call
		<code class="computeroutput">dumpAll()</code>, and the binding will iterate through the whole table's
		contents.
		</p><p>
		If you want to get the dump label explicitly, you can do it with
		</p><pre class="programlisting">my $dlab = $table-&gt;getDumpLabel();</pre><p>
		Normally the only reason to do that would be to add it to another
		FnReturn (besides the table's FnReturn). Chaining anything else
		directly to this label would not make much sense, because the dump of
		the table can be called from many places, and the directly chained
		label will receive data every time the dump is called.
		</p><p>
		The grand plan is also to add the dumping by a a condition that selects
		a sub-index, but it's not implemented yet. You can select an index for
		an alternative ordering but all the rows get dumped in any case.
		</p><p>
		The method <code class="computeroutput">dumpAllIdx()</code> is the one that
		sends the rows in the order of a chosen index, rather than the default first
		leaf index:
		</p><pre class="programlisting">$table-&gt;dumpAll();
$table-&gt;dumpAllIdx($indexType);</pre><p>
		As usual, the index type must belong to the exact type of this table. For example:
		</p><pre class="programlisting">$table-&gt;dumpAllIdx($table-&gt;getType()-&gt;findIndexPath("cb"), "OP_NOP");</pre><p>
		The typical usage looks like this:
		</p><pre class="programlisting">Triceps::FnBinding::call(
  name =&gt; "iterate",
  on =&gt; $table-&gt;fnReturn(),
  unit =&gt; $unit,
  labels =&gt; [
    dump =&gt; sub { ... },
  ],
  code =&gt; sub {
    $table-&gt;dumpAll();
  },
);</pre><p>
		It's less efficient than the normal iteration but sometimes comes
		handy.
		</p><p>
		Normally the rowops are sent with the opcode OP_INSERT. But the opcode
		can also be specified explicitly:
		</p><pre class="programlisting">$table-&gt;dumpAll($opcode);
$table-&gt;dumpAllIdx($indexType, $opcode);</pre><p>
		And some more interesting examples will be forthcoming in
		<a class="xref" href="#sc_strf_units" title="15.11. Streaming functions and unit boundaries">Section 15.11: &#8220;Streaming functions and unit boundaries&#8221; </a>
		and
		<a class="xref" href="#sc_tql_join_internals" title="17.6. Internals of a TQL join">Section 17.6: &#8220;Internals of a TQL join&#8221; </a>.
		</p></div><div class="sect1" title="15.8. Streaming functions and template results"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_templates"></a>15.8. Streaming functions and template results</h2></div></div></div><a class="indexterm" name="id540532"></a><a class="indexterm" name="id540542"></a><p>
		The same way as the FnReturns can be used to get back the direct
		results of the operations on the tables, they can be also used on the
		templates in general. Indeed, it's a good idea to have a method that
		would create an FnReturn in all the templates. So I went ahead and
		added it to the LookupJoin, JoinTwo and Collapse.
		</p><a class="indexterm" name="id540558"></a><a class="indexterm" name="id540568"></a><a class="indexterm" name="id540577"></a><p>
		For the joins, the resulting FnReturn has one label <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span>. It's created
		similarly to the table's:
		</p><pre class="programlisting">my $fret = $join-&gt;fnReturn();</pre><p>
		And then it can be used as usual. The implementation of this method is
		fairly simple:
		</p><pre class="programlisting">sub fnReturn # (self)
{
  my $self = shift;
  if (!defined $self-&gt;{fret}) {
    $self-&gt;{fret} = Triceps::FnReturn-&gt;new(
      name =&gt; $self-&gt;{name} . ".fret",
      labels =&gt; [
        out =&gt; $self-&gt;{outputLabel},
      ],
    );
  }
  return $self-&gt;{fret};
}</pre><p>
		All this makes the method <code class="computeroutput">lookup()</code> of LookupJoin essentially redundant,
		since now pretty much all the same can be done with the streaming
		function API, and even better, because it provides the opcodes on
		rowops, can handle the full processing, and calls the rowops one by one
		without necessarily creating an array. But it could happen yet that the
		<code class="computeroutput">lookup()</code> has some more convenient uses too, so I didn't remove it yet.
		</p><p>
		For Collapse the interface is a little more complicated: the FnReturn
		contains a label for each data set, named the same as the data set. The
		order of labels follows the order of the data set definitions (though
		right now it's kind of moot, because only one data set is supported).
		The implementation is:
		</p><pre class="programlisting">sub fnReturn # (self)
{
  my $self = shift;
  if (!defined $self-&gt;{fret}) {
    my @labels;
    for my $n (@{$self-&gt;{dsetnames}}) {
      push @labels, $n, $self-&gt;{datasets}{$n}{lbOut};
    }
    $self-&gt;{fret} = Triceps::FnReturn-&gt;new(
      name =&gt; $self-&gt;{name} . ".fret",
      labels =&gt; \@labels,
    );
  }
  return $self-&gt;{fret};
}</pre><p>
		Use these examples to write the <code class="computeroutput">fnReturn()</code> in your templates. 
		</p></div><div class="sect1" title="15.9. Streaming functions and recursion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_recursion"></a>15.9. Streaming functions and recursion</h2></div></div></div><a class="indexterm" name="id540672"></a><a class="indexterm" name="id540682"></a><p>
		Let's look again at the pipeline example. Suppose we want to do the
		encryption twice (you know, maybe we have a secure channel to a
		semi-trusted intermediary who can can read the envelopes and forward
		the encrypted messages he can't read to the final destination). The
		pipeline becomes
		</p><pre class="programlisting">decrypt | decrypt | process | encrypt | encrypt</pre><p>
		Or if you want to think about it in a more function-like notation,
		rather than a pipeline, the logic can also be expressed as:
		</p><pre class="programlisting">encrypt(encrypt(process(decrypt(decrypt(data)))))</pre><p>
		However it would not work directly: a decrypt function has only one
		output and it can not have two bindings at the same time, it would not
		know which one to use at any particular time.
		</p><p>
		Instead you can make decrypt into a template, instantiate it twice, and
		connect into a pipeline. It's very much like what the Unix shell does:
		it instantiates a new process for each part of its pipeline.
		</p><p>
		But there is also another possibility: instead of assembling the whole
		pipeline in advance, do it in steps.
		</p><p>
		Start by adding this option in every binding:
		</p><pre class="programlisting">withTray =&gt; 1,</pre><p>
		This will make all the bindings collect the result on a tray instead of
		sending it on immediately. Then modify the main loop:
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;

  # receive
  my $abReceive = Triceps::AutoFnBind-&gt;new(
    $retReceive =&gt; $bindDecrypt,
  );
  $unit-&gt;makeArrayCall($lbReceive, "OP_INSERT", $_);

  # 1st decrypt
  my $abDecrypt1 = Triceps::AutoFnBind-&gt;new(
    $retDecrypt =&gt; $bindDecrypt,
  );
  $bindDecrypt-&gt;callTray();

  # 2nd decrypt
  my $abDecrypt2 = Triceps::AutoFnBind-&gt;new(
    $retDecrypt =&gt; $bindDispatch,
  );
  $bindDecrypt-&gt;callTray();

  # processing
  my $abProcess = Triceps::AutoFnBind-&gt;new(
    $retOutput =&gt; $bindEncrypt,
  );
  $bindDispatch-&gt;callTray();

  # 1st encrypt
  my $abEncrypt1 = Triceps::AutoFnBind-&gt;new(
    $retEncrypt =&gt; $bindEncrypt,
  );
  $bindEncrypt-&gt;callTray();

  # 2nd encrypt
  my $abEncrypt2 = Triceps::AutoFnBind-&gt;new(
    $retEncrypt =&gt; $bindSend,
  );
  $bindEncrypt-&gt;callTray();

  # send
  $bindSend-&gt;callTray();
}</pre><p>
		Here I've dropped the encrypted-or-unencrypted choice to save the
		space, the data is always encrypted twice. The <code class="computeroutput">drainFrame()</code> call has
		been dropped because with the way the function calls work here 
		there is no chance that it could be useful. The rest of the code stays the same.
		</p><p>
		The bindings have been split in stages. The next binding
		is set in each stage, and the data from the previous binding gets sent into it. The
		binding method <code class="computeroutput">callTray()</code> replaces the tray in the binding with an
		empty one, and then calls all the rowops collected on the old tray (and
		if you wonder what then happens to the old tray, it gets discarded).
		Because of this the first decryption stage with binding
		</p><pre class="programlisting">my $abDecrypt1 = Triceps::AutoFnBind-&gt;new(
  $retDecrypt =&gt; $bindDecrypt,
);</pre><p>
		doesn't send the data circling forever. It just does one pass through
		the decryption and prepares for the second pass.
		</p><p>
		Every time <code class="computeroutput">AutoFnBind-&gt;new()</code> runs, it doesn't replace the binding of
		the FnReturn but pushes a new binding onto the FnReturn's stack. Each
		FnReturn has its own stack of bindings (this way it's easier to manage
		than a single stack). When an AutoFnBind gets destroyed, it pops the
		binding from the return's stack. And yes, if you specify multiple
		bindings in one AutoFnBind, all of them get pushed on construction and
		popped on destruction. In this case all the auto-binds are in the same
		block, so they will all be destroyed at the end of block in the
		opposite order. Which means that in effect the code is equivalent to
		the nested blocks. And the version with explicit nexted blocks
		might be easier for you to think of:
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;

  # receive
  my $abReceive = Triceps::AutoFnBind-&gt;new(
    $retReceive =&gt; $bindDecrypt,
  );
  $unit-&gt;makeArrayCall($lbReceive, "OP_INSERT", $_);

  {
    # 1st decrypt
    my $abDecrypt1 = Triceps::AutoFnBind-&gt;new(
      $retDecrypt =&gt; $bindDecrypt,
    );
    $bindDecrypt-&gt;callTray();

    {
      # 2nd decrypt
      my $abDecrypt1 = Triceps::AutoFnBind-&gt;new(
        $retDecrypt =&gt; $bindDispatch,
      );
      $bindDecrypt-&gt;callTray();

      {
        # processing
        my $abProcess = Triceps::AutoFnBind-&gt;new(
          $retOutput =&gt; $bindEncrypt,
        );
        $bindDispatch-&gt;callTray();

        {
          # 1st encrypt
          my $abEncrypt1 = Triceps::AutoFnBind-&gt;new(
            $retEncrypt =&gt; $bindEncrypt,
          );
          $bindEncrypt-&gt;callTray();

          {
            # 2nd encrypt
            my $abEncrypt1 = Triceps::AutoFnBind-&gt;new(
              $retEncrypt =&gt; $bindSend,
            );
            $bindEncrypt-&gt;callTray();

            # send
            $bindSend-&gt;callTray();
          }
        }
      }
    }
  }
}</pre><p>
		An interesting consequence of all this nesting, pushing and popping is
		that you can put the inner calls into the procedural loops if you wish.
		For example, if you want to process every input line thrice:
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;

  # receive
  my $abReceive = Triceps::AutoFnBind-&gt;new(
    $retReceive =&gt; $bindDecrypt,
  );

  for (my $i = 0; $i &lt; 3; $i++) {
    $unit-&gt;makeArrayCall($lbReceive, "OP_INSERT", $_);

    {
      # 1st decrypt
      my $abDecrypt1 = Triceps::AutoFnBind-&gt;new(
        $retDecrypt =&gt; $bindDecrypt,
      );
      $bindDecrypt-&gt;callTray();

      {
        # 2nd decrypt
        my $abDecrypt1 = Triceps::AutoFnBind-&gt;new(
          $retDecrypt =&gt; $bindDispatch,
        );
        $bindDecrypt-&gt;callTray();

        {
          # processing
          my $abProcess = Triceps::AutoFnBind-&gt;new(
            $retOutput =&gt; $bindEncrypt,
          );
          $bindDispatch-&gt;callTray();

          {
            # 1st encrypt
            my $abEncrypt1 = Triceps::AutoFnBind-&gt;new(
              $retEncrypt =&gt; $bindEncrypt,
            );
            $bindEncrypt-&gt;callTray();

            {
              # 2nd encrypt
              my $abEncrypt1 = Triceps::AutoFnBind-&gt;new(
                $retEncrypt =&gt; $bindSend,
              );
              $bindEncrypt-&gt;callTray();

              # send
              $bindSend-&gt;callTray();
            }
          }
        }
      }
    }
  }
}</pre><p>
		This code will run the whole pipeline three times for each input line,
		and print out three output lines. The following example of the
		output has both the input and the output lines wrapped, since
		they are hugely long:
		</p><pre class="programlisting"><span class="bold"><strong>363936653633326334663530356634393465353334353532353432633631363236</strong></span>
<span class="bold"><strong>  3332633332</strong></span>
373236353733373536633734323034663530356634393465353334353532353432
  3036653631366436353364323236313632363332323230363336663735366537
  3433643232333332323230
373236353733373536633734323034663530356634393465353334353532353432
  3036653631366436353364323236313632363332323230363336663735366537
  3433643232333332323230
373236353733373536633734323034663530356634393465353334353532353432
  3036653631366436353364323236313632363332323230363336663735366537
  3433643232333332323230</pre><p>
		If you wonder, what is the meaning of these lines, they are the same as
		before. The input is :
		</p><pre class="programlisting">inc,OP_INSERT,abc,2</pre><p>
		And each line of output is:
		</p><pre class="programlisting">result OP_INSERT name="abc" count="3"</pre><p>
		I suppose, it would be more entertaining if the processing weren't just
		incrementing a value in the input data but incrementing some static
		counter, then the three output lines would be different.
		</p><p>
		However this is not the only way to do the block nesting. The contents
		of the FnBinding's tray is not affected in any way by the binding being
		pushed or popped. It stays there throughout, until it's explicitly
		flushed by <code class="computeroutput">callTray()</code>. So it could use the blocks formed in a more
		pipeline-like fashion (as opposed to the more function-call-like fashion
		shown before):
		</p><pre class="programlisting">while(&lt;STDIN&gt;) {
  chomp;

  # receive
  {
    my $abReceive = Triceps::AutoFnBind-&gt;new(
      $retReceive =&gt; $bindDecrypt,
    );
    $unit-&gt;makeArrayCall($lbReceive, "OP_INSERT", $_);
  }

  # 1st decrypt
  {
    my $abDecrypt1 = Triceps::AutoFnBind-&gt;new(
      $retDecrypt =&gt; $bindDecrypt,
    );
    $bindDecrypt-&gt;callTray();
  }

  # 2nd decrypt
  {
    my $abDecrypt1 = Triceps::AutoFnBind-&gt;new(
      $retDecrypt =&gt; $bindDispatch,
    );
    $bindDecrypt-&gt;callTray();
  }

  # processing
  {
    my $abProcess = Triceps::AutoFnBind-&gt;new(
      $retOutput =&gt; $bindEncrypt,
    );
    $bindDispatch-&gt;callTray();
  }

  # 1st encrypt
  {
    my $abEncrypt1 = Triceps::AutoFnBind-&gt;new(
      $retEncrypt =&gt; $bindEncrypt,
    );
    $bindEncrypt-&gt;callTray();
  }

  # 2nd encrypt
  {
    my $abEncrypt1 = Triceps::AutoFnBind-&gt;new(
      $retEncrypt =&gt; $bindSend,
    );
    $bindEncrypt-&gt;callTray();
  }

  # send
  $bindSend-&gt;callTray();
}</pre><p>
		After each stage, its binding is popped but the tray is carried through
		to the next stage.
		</p><p>
		Which way of blocking is better? I'd say they're pretty equivalent in
		functionality, and your preference would depend on what style you
		prefer to express. 
		</p></div><div class="sect1" title="15.10. Streaming functions and more recursion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_more_recursion"></a>15.10. Streaming functions and more recursion</h2></div></div></div><a class="indexterm" name="id548101"></a><a class="indexterm" name="id548110"></a><p>
		There are great many slightly different ways to use recursion with
		the streaming functions. This section goes through them with examples
		of the Fibonacci numbers computed in all these ways. You can as well
		skip over this section if you're not particularly interested in
		the details of recursive execution.
		</p><p>
		All the examples from this section (and most of others from this chapter)
		are locates in <code class="computeroutput">t/xFn.t</code>.
		The first example uses the dumb recursive calls.
		It's a real dumb recursive way, with two recursive calls and thus the
		exponential execution time, just to show
		how they can be done. This simplest and most straightforward way goes 
		as follows:
		</p><pre class="programlisting">my $uFib = Triceps::Unit-&gt;new("uFib");
$uFib-&gt;setMaxRecursionDepth(100);

# Type the data going into the function
my $rtFibArg = Triceps::RowType-&gt;new(
  idx =&gt; "int32", # the index of Fibonacci number to generate
);

# Type of the function result
my $rtFibRes = Triceps::RowType-&gt;new(
  idx =&gt; "int32", # the index of Fibonacci number
  fib =&gt; "int64", # the generated Fibonacci number
);

###
# A streaming function that computes a Fibonacci number.

# Input:
#   $lbFibCompute: request to compute the number.
# Output (by FnReturn labels):
#   "result": the computed value.
# The opcode is preserved through the computation.

my $frFib = Triceps::FnReturn-&gt;new(
  name =&gt; "Fib",
  unit =&gt; $uFib,
  labels =&gt; [
    result =&gt; $rtFibRes,
  ],
);

my $lbFibResult = $frFib-&gt;getLabel("result");

my $lbFibCompute; # must be defined before assignment, for recursion
$lbFibCompute = $uFib-&gt;makeLabel($rtFibArg, "FibCompute", undef, sub {
  my $row = $_[1]-&gt;getRow();
  my $op = $_[1]-&gt;getOpcode();
  my $idx = $row-&gt;get("idx");
  my $res;

  if ($idx &lt; 1) {
    $res = 0;
  } elsif($idx == 1) {
    $res = 1;
  } else {
    my ($prev1, $prev2);
    Triceps::FnBinding::call(
      name =&gt; "FibCompute.call1",
      on =&gt; $frFib,
      unit =&gt; $uFib,
      labels =&gt; [
        result =&gt; sub {
          $prev1 = $_[1]-&gt;getRow()-&gt;get("fib");
        }
      ],
      rowop =&gt; $lbFibCompute-&gt;makeRowopHash($op,
        idx =&gt; $idx - 1,
      ),
    );
    Triceps::FnBinding::call(
      name =&gt; "FibCompute.call2",
      on =&gt; $frFib,
      unit =&gt; $uFib,
      labels =&gt; [
        result =&gt; sub {
          $prev2 = $_[1]-&gt;getRow()-&gt;get("fib");
        }
      ],
      rowop =&gt; $lbFibCompute-&gt;makeRowopHash($op,
        idx =&gt; $idx - 2,
      ),
    );
    $res = $prev1 + $prev2;
  }
  $uFib-&gt;makeHashCall($frFib-&gt;getLabel("result"), $op,
    idx =&gt; $idx,
    fib =&gt; $res,
  );
});

# End of streaming function
###

# binding to call the Fibonacci function and print the result
my $fbFibCall = Triceps::FnBinding-&gt;new(
  name =&gt; "FibCall",
  on =&gt; $frFib,
  unit =&gt; $uFib,
  labels =&gt; [
    result =&gt; sub {
      my $row = $_[1]-&gt;getRow();
      print($row-&gt;get("fib"), " is Fibonacci number ", $row-&gt;get("idx"), "\n");
    }
  ],
);

while(&lt;STDIN&gt;) {
  chomp;
  my @data = split(/,/);
  $uFib-&gt;callBound(
    $lbFibCompute-&gt;makeRowopArray(@data),
    $frFib =&gt; $fbFibCall,
  );
  $uFib-&gt;drainFrame(); # just in case, for completeness
}</pre><p>
		The calling sequence had become different than in the looping version
		but the produced result is exactly the same.  The streaming function
		now receives an argument row and produces a result row. The unit's
		recursion depth limit had to be adjusted to permit the recursion.
		</p><p>
		The recursive calls are done through the <code class="computeroutput">FnBinding::call()</code>, with a
		closure for the result handling label. That closure can access the
		scope of its creator and place the result into its local variable.
		After both intermediate results are computed, the final result
		computation takes place and sends out the result row. 
		</p><p>
		The <code class="computeroutput">FnBinding::call()</code> creates a brand new binding
		for each call. So no matter how deep is the recursion, each
		function call will get a separate binding that knows how to
		put the results into the correct place.
		</p><p>
		If the streaming function were to return more than one
		rowop, the closure would have to collect them all into
		a variable. The further processing can not be done until
		the function completes. The bindings with trays cannot
		be used because <code class="computeroutput">FnBinding::call()</code> disposes of
		the binding before it returns, so there is no chance to
		extract the tray from the binding. Perhaps this can be improved
		in the future. But there is another way to use trays that
		will be shown below.
		</p><p>
		And just to show yet another technique, the main loop is also different:
		instead of creating an AutoFnBind manually, it uses the Unit's
		method <code class="computeroutput">callBound()</code> that is more compact to write and
		slightly more efficient. It's a great method if you have all the
		rowops for the call available upfront. It's first argument is a rowop
		or a tray or a reference to an array of rowops. The rest are the pairs
		of FnReturns and FnBindings. The bindings are pushed onto the FnReturns,
		then the rowops are called, then the bindings are popped. It replaces
		a whole block that would contain an AutoFnBind and the calls.
		</p><p>
		<code class="computeroutput">FnBinding:call()</code> with closures is easy to use but it creates a closure
		and an FnBinding object on each run. Can things be rearranged to reuse
		the same objects? With some effort, they can:
		</p><pre class="programlisting">###
# A streaming function that computes a Fibonacci number.

# Input:
#   $lbFibCompute: request to compute the number.
# Output (by FnReturn labels):
#   "result": the computed value.
# The opcode is preserved through the computation.

my @stackFib; # stack of the function states
my $stateFib; # The current state

my $frFib = Triceps::FnReturn-&gt;new(
  name =&gt; "Fib",
  unit =&gt; $uFib,
  labels =&gt; [
    result =&gt; $rtFibRes,
  ],
  onPush =&gt; sub { push @stackFib, $stateFib; $stateFib = { }; },
  onPop =&gt; sub { $stateFib = pop @stackFib; },
);

my $lbFibResult = $frFib-&gt;getLabel("result");

# Declare the label &amp; binding variables in advance, to define them sequentially.
my ($lbFibCompute, $fbFibPrev1, $fbFibPrev2);
$lbFibCompute = $uFib-&gt;makeLabel($rtFibArg, "FibCompute", undef, sub {
  my $row = $_[1]-&gt;getRow();
  my $op = $_[1]-&gt;getOpcode();
  my $idx = $row-&gt;get("idx");

  if ($idx &lt;= 1) {
    $uFib-&gt;makeHashCall($frFib-&gt;getLabel("result"), $op,
      idx =&gt; $idx,
      fib =&gt; $idx &lt; 1 ? 0 : 1,
    );
  } else {
    $stateFib-&gt;{op} = $op;
    $stateFib-&gt;{idx} = $idx;

    $frFib-&gt;push($fbFibPrev1);
    $uFib-&gt;makeHashCall($lbFibCompute, $op,
      idx =&gt; $idx - 1,
    );
  }
});
$fbFibPrev1 = Triceps::FnBinding-&gt;new(
  unit =&gt; $uFib,
  name =&gt; "FibPrev1",
  on =&gt; $frFib,
  labels =&gt; [
    result =&gt; sub {
      $frFib-&gt;pop($fbFibPrev1);

      $stateFib-&gt;{prev1} = $_[1]-&gt;getRow()-&gt;get("fib");

      # must prepare before pushing new state and with it new $stateFib
      my $rop = $lbFibCompute-&gt;makeRowopHash($stateFib-&gt;{op},
        idx =&gt; $stateFib-&gt;{idx} - 2,
      );

      $frFib-&gt;push($fbFibPrev2);
      $uFib-&gt;call($rop);
    },
  ],
);
$fbFibPrev2 = Triceps::FnBinding-&gt;new(
  unit =&gt; $uFib,
  on =&gt; $frFib,
  name =&gt; "FibPrev2",
  labels =&gt; [
    result =&gt; sub {
      $frFib-&gt;pop($fbFibPrev2);

      $stateFib-&gt;{prev2} = $_[1]-&gt;getRow()-&gt;get("fib");
      $uFib-&gt;makeHashCall($frFib-&gt;getLabel("result"), $stateFib-&gt;{op},
        idx =&gt; $stateFib-&gt;{idx},
        fib =&gt; $stateFib-&gt;{prev1} + $stateFib-&gt;{prev2},
      );
    },
  ],
);

# End of streaming function
###</pre><p>
		The rest of the code stays the same, so I won't copy it here.
		</p><p>
		The computation still needs to keep the intermediate results of two
		recursive calls. With no closures, these results have to be kept in a
		global object <code class="computeroutput">$stateFib</code> (which refers to a hash that keeps multiple values).
		</p><p>
		But it can't just be a single object! The recursive calls would
		overwrite it. So it has to be built into a stack of objects, a new one
		pushed for each call and popped after it. This pushing and popping can
		be tied to the pushing and popping of the bindings on an FnReturn. When
		the FnReturn is defined, the options <span class="quote">&#8220;<span class="quote">onPush</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">onPop</span>&#8221;</span> define the custom
		Perl code to execute, which is used here for the management of the
		state stack.
		</p><p>
		The whole logic is then split into the sections around the calls:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		before the first call;
		</li><li class="listitem">
		between the first and second call;
		</li><li class="listitem">
		after the second call.
		</li></ul></div><p>
		The first section goes as a normal label and the rest are done as
		bindings.
		</p><p>
		A tricky moment is that a simple scoped AutoFnBind can't be used here.
		The pushing of the binding happens in the calling label (such as
		FibCompute) but then the result is processed in another label (such as
		FibPrev1.result). The procedural control won't return to FibCompute
		until after FibPrev1.result has been completed. But FibPrev1.result
		needs the state popped before it can do its work! So the pushing and
		popping of the binding is done explicitly in two split steps: <code class="computeroutput">push()</code>
		called in FibCompute and <code class="computeroutput">pop()</code> called in FibPrev1.result. And of
		course then after FibPrev1.result saves the result, it pushes the next
		binding, which then gets popped in FibPrev2.result.
		</p><p>
		The popping can also be done without arguments, as simply <code class="computeroutput">pop()</code>, but if it's
		given an argument, it will check that the binding popped is the same as
		its argument. This is helpful for detecting the call stack corruptions.
		</p><p>
		Now, can you guess, what depth of the unit call stack is required to
		compute and print the 2nd Fibonacci number? It's 7. If the tracing is
		enabled, it will produce this trace:
		</p><pre class="programlisting">unit 'uFib' before label 'FibCompute' op OP_DELETE {
unit 'uFib' before label 'FibCompute' op OP_DELETE {
unit 'uFib' before label 'Fib.result' op OP_DELETE {
unit 'uFib' before label 'FibPrev1.result' (chain 'Fib.result') op
    OP_DELETE {
unit 'uFib' before label 'FibCompute' op OP_DELETE {
unit 'uFib' before label 'Fib.result' op OP_DELETE {
unit 'uFib' before label 'FibPrev2.result' (chain 'Fib.result') op
    OP_DELETE {
unit 'uFib' before label 'Fib.result' op OP_DELETE {
unit 'uFib' before label 'FibCall.result' (chain 'Fib.result') op
    OP_DELETE {
unit 'uFib' after label 'FibCall.result' (chain 'Fib.result') op
    OP_DELETE }
unit 'uFib' after label 'Fib.result' op OP_DELETE }
unit 'uFib' after label 'FibPrev2.result' (chain 'Fib.result') op
    OP_DELETE }
unit 'uFib' after label 'Fib.result' op OP_DELETE }
unit 'uFib' after label 'FibCompute' op OP_DELETE }
unit 'uFib' after label 'FibPrev1.result' (chain 'Fib.result') op
    OP_DELETE }
unit 'uFib' after label 'Fib.result' op OP_DELETE }
unit 'uFib' after label 'FibCompute' op OP_DELETE }
unit 'uFib' after label 'FibCompute' op OP_DELETE }</pre><p>
		9 labels get called in a sequence, all the way from the initial call to
		the result printing. And only then the whole sequence unrolls back. 3
		of them are chained through the bindings, so they don't push the stack
		frames onto the stack, and there is always the outermost stack frame,
		with the resulting stack depth of 9-3+1 = 7.  This number grows fast. For the 6th
		number the number of labels becomes 75 and the frame count 51.
		</p><p>
		It happens because all the calls get unrolled into a single sequence,
		like what I've warned against in 
		<a class="xref" href="#sc_sched_topo_loops" title="7.7. Topological loops">Section 7.7: &#8220;Topological loops&#8221; </a>.
		The function
		return does unroll its FnReturn stack but doesn't unroll the unit call
		stack, it just goes even deeper by calling the label that processes it.
		</p><p>
		There are ways to improve it. The simplest one is to use the FnBinding
		with a tray, and call this tray after the function completely returns.
		This works out quite conveniently in two other ways too: First,
		AutoFnBind with its scoped approach can be used again. And second, it
		allows to handle the situations where a function returns not just one
		row but multiple of them. That will be the next example: 
		</p><pre class="programlisting">###
# A streaming function that computes a Fibonacci number.

# Input:
#   $lbFibCompute: request to compute the number.
# Output (by FnReturn labels):
#   "result": the computed value.
# The opcode is preserved through the computation.

my @stackFib; # stack of the function states
my $stateFib; # The current state

my $frFib = Triceps::FnReturn-&gt;new(
  name =&gt; "Fib",
  unit =&gt; $uFib,
  labels =&gt; [
    result =&gt; $rtFibRes,
  ],
  onPush =&gt; sub { push @stackFib, $stateFib; $stateFib = { }; },
  onPop =&gt; sub { $stateFib = pop @stackFib; },
);

my $lbFibResult = $frFib-&gt;getLabel("result");

# Declare the label &amp; binding variables in advance, to define them sequentially.
my ($lbFibCompute, $fbFibPrev1, $fbFibPrev2);
$lbFibCompute = $uFib-&gt;makeLabel($rtFibArg, "FibCompute", undef, sub {
  my $row = $_[1]-&gt;getRow();
  my $op = $_[1]-&gt;getOpcode();
  my $idx = $row-&gt;get("idx");

  if ($idx &lt;= 1) {
    $uFib-&gt;makeHashCall($frFib-&gt;getLabel("result"), $op,
      idx =&gt; $idx,
      fib =&gt; $idx &lt; 1 ? 0 : 1,
    );
  } else {
    $stateFib-&gt;{op} = $op;
    $stateFib-&gt;{idx} = $idx;

    {
      my $ab = Triceps::AutoFnBind-&gt;new(
        $frFib =&gt; $fbFibPrev1
      );
      $uFib-&gt;makeHashCall($lbFibCompute, $op,
        idx =&gt; $idx - 1,
      );
    }
    $fbFibPrev1-&gt;callTray();
  }
});
$fbFibPrev1 = Triceps::FnBinding-&gt;new(
  unit =&gt; $uFib,
  name =&gt; "FibPrev1",
  on =&gt; $frFib,
  withTray =&gt; 1,
  labels =&gt; [
    result =&gt; sub {
      $stateFib-&gt;{prev1} = $_[1]-&gt;getRow()-&gt;get("fib");

      # must prepare before pushing new state and with it new $stateFib
      my $rop = $lbFibCompute-&gt;makeRowopHash($stateFib-&gt;{op},
        idx =&gt; $stateFib-&gt;{idx} - 2,
      );

      {
        my $ab = Triceps::AutoFnBind-&gt;new(
          $frFib =&gt; $fbFibPrev2
        );
        $uFib-&gt;call($rop);
      }
      $fbFibPrev2-&gt;callTray();
    },
  ],
);
$fbFibPrev2 = Triceps::FnBinding-&gt;new(
  unit =&gt; $uFib,
  on =&gt; $frFib,
  name =&gt; "FibPrev2",
  withTray =&gt; 1,
  labels =&gt; [
    result =&gt; sub {
      $stateFib-&gt;{prev2} = $_[1]-&gt;getRow()-&gt;get("fib");
      $uFib-&gt;makeHashCall($frFib-&gt;getLabel("result"), $stateFib-&gt;{op},
        idx =&gt; $stateFib-&gt;{idx},
        fib =&gt; $stateFib-&gt;{prev1} + $stateFib-&gt;{prev2},
      );
    },
  ],
);

# End of streaming function
###</pre><p>
		The stack depth is now greatly reduced because the unit stack pops the
		frames before pushing more of them. For the 2nd Fibonacci number the
		trace is:
		</p><pre class="programlisting">unit 'uFib' before label 'FibCompute' op OP_DELETE {
unit 'uFib' before label 'FibCompute' op OP_DELETE {
unit 'uFib' before label 'Fib.result' op OP_DELETE {
unit 'uFib' after label 'Fib.result' op OP_DELETE }
unit 'uFib' after label 'FibCompute' op OP_DELETE }
unit 'uFib' before label 'FibPrev1.result' op OP_DELETE {
unit 'uFib' before label 'FibCompute' op OP_DELETE {
unit 'uFib' before label 'Fib.result' op OP_DELETE {
unit 'uFib' after label 'Fib.result' op OP_DELETE }
unit 'uFib' after label 'FibCompute' op OP_DELETE }
unit 'uFib' before label 'FibPrev2.result' op OP_DELETE {
unit 'uFib' before label 'Fib.result' op OP_DELETE {
unit 'uFib' before label 'FibCall.result' (chain 'Fib.result') op
    OP_DELETE {
unit 'uFib' after label 'FibCall.result' (chain 'Fib.result') op
    OP_DELETE }
unit 'uFib' after label 'Fib.result' op OP_DELETE }
unit 'uFib' after label 'FibPrev2.result' op OP_DELETE }
unit 'uFib' after label 'FibPrev1.result' op OP_DELETE }
unit 'uFib' after label 'FibCompute' op OP_DELETE }</pre><p>
		The maximal call stack depth is reduced to 5.
		For the 6th number the maximal required stack depth now gets reduced to
		only 9 instead of 51. 
		</p><a class="indexterm" name="id548426"></a><p>
		And there is also a way to run the recursive calls without even the
		need to increase the recursion depth limit. It can be left at the
		default 1, without <code class="computeroutput">setMaxRecursionDepth()</code>. The secret is to fork the
		argument rowops to the functions instead of calling them.
		</p><pre class="programlisting">###
# A streaming function that computes a Fibonacci number.

# Input:
#   $lbFibCompute: request to compute the number.
# Output (by FnReturn labels):
#   "result": the computed value.
# The opcode is preserved through the computation.

my @stackFib; # stack of the function states
my $stateFib; # The current state

my $frFib = Triceps::FnReturn-&gt;new(
  name =&gt; "Fib",
  unit =&gt; $uFib,
  labels =&gt; [
    result =&gt; $rtFibRes,
  ],
  onPush =&gt; sub { push @stackFib, $stateFib; $stateFib = { }; },
  onPop =&gt; sub { $stateFib = pop @stackFib; },
);

my $lbFibResult = $frFib-&gt;getLabel("result");

# Declare the label &amp; binding variables in advance, to define them sequentially.
my ($lbFibCompute, $fbFibPrev1, $fbFibPrev2);
$lbFibCompute = $uFib-&gt;makeLabel($rtFibArg, "FibCompute", undef, sub {
  my $row = $_[1]-&gt;getRow();
  my $op = $_[1]-&gt;getOpcode();
  my $idx = $row-&gt;get("idx");

  if ($idx &lt;= 1) {
    $uFib-&gt;fork($frFib-&gt;getLabel("result")-&gt;makeRowopHash($op,
      idx =&gt; $idx,
      fib =&gt; $idx &lt; 1 ? 0 : 1,
    ));
  } else {
    $stateFib-&gt;{op} = $op;
    $stateFib-&gt;{idx} = $idx;

    $frFib-&gt;push($fbFibPrev1);
    $uFib-&gt;fork($lbFibCompute-&gt;makeRowopHash($op,
      idx =&gt; $idx - 1,
    ));
  }
});
$fbFibPrev1 = Triceps::FnBinding-&gt;new(
  unit =&gt; $uFib,
  name =&gt; "FibPrev1",
  on =&gt; $frFib,
  labels =&gt; [
    result =&gt; sub {
      $frFib-&gt;pop($fbFibPrev1);

      $stateFib-&gt;{prev1} = $_[1]-&gt;getRow()-&gt;get("fib");

      # must prepare before pushing new state and with it new $stateFib
      my $rop = $lbFibCompute-&gt;makeRowopHash($stateFib-&gt;{op},
        idx =&gt; $stateFib-&gt;{idx} - 2,
      );

      $frFib-&gt;push($fbFibPrev2);
      $uFib-&gt;fork($rop);
    },
  ],
);
$fbFibPrev2 = Triceps::FnBinding-&gt;new(
  unit =&gt; $uFib,
  on =&gt; $frFib,
  name =&gt; "FibPrev2",
  labels =&gt; [
    result =&gt; sub {
      $frFib-&gt;pop($fbFibPrev2);

      $stateFib-&gt;{prev2} = $_[1]-&gt;getRow()-&gt;get("fib");
      $uFib-&gt;fork($frFib-&gt;getLabel("result")-&gt;makeRowopHash($stateFib-&gt;{op},
        idx =&gt; $stateFib-&gt;{idx},
        fib =&gt; $stateFib-&gt;{prev1} + $stateFib-&gt;{prev2},
      ));
    },
  ],
);

# End of streaming function
###</pre><p>
		This is a variation of the pre-previous example, with the split push and
		pop. The split is required for the fork to work: when the forked rowop
		executes, the calling label has already returned, so obviously the
		scoped approach won't work.
		</p><p>
		In this version the unit stack depth required to compute the 6th (and
		any) Fibonacci number reduces to 2: it's really only one level on top
		of the outermost frame. 
		</p><p>
		If you were to attempt taking the advantage of the techniques from
		both of the last two examples (the one with the trays
		and the one with the forks) at the same time,
		that combination won't work. They could be combined but
		the combination just doesn't work right.
		</p><p>
		The problem is that the example with trays relies on the recursive
		function being completed before the tray gets called. But if the recursive
		functions are forked, things break. Looking at why
		they break provides another insight into the works of recursion. The
		example would look approximately like this in pseudo-code:
		</p><pre class="programlisting">Compute:
  if (idx &lt;= 1) {
    call FrFib Result;
  } else {
    push FibPrev1 to FrFib;
    fork Compute for n-1;
    fork Followup1;
  }

Followup1:
  fork tray of FibPrev1;

FibPrev1.result:
  pop FibPrev1 from FrFib;
  push FibPrev2 to FrFib;
  fork Compute for n-2;
  fork Followup2;

Followup2:
  fork tray of FibPrev2;

FibPrev2.result:
  pop FibPrev2 from FrFib;
  call FrFib Result;</pre><p>
		The Followup labels are required because the trays with the intermediate
		results won't call themselves. They need to be called (or in this case,
		forked) by something else. The FnBinding has no method <code class="computeroutput">forkTray()</code>
		but it can be done manually by first swapping the tray and then
		forking the result. The result FnReturn has to be called, not forked,
		so that it would immediately deposit the result rowop into the
		bound tray.
		</p><p>
		If there were only one recursive call, it would still work because the
		execution frame after the label <code class="computeroutput">Compute(n)</code> returns would then look like this:
		</p><pre class="programlisting">Compute(n-1)
Followup1(n)</pre><p>
		The rowop <code class="computeroutput">Compute(n-1)</code> would be the argument for the recursive function
		call, and <code class="computeroutput">Followup1(n)</code> would be the follow-up rowop.
		When the execution time comes,
		the rowop <code class="computeroutput">Compute(n-1)</code> executes, places the result into the tray.
		Then the rowop <code class="computeroutput">Followup1(n)</code>
		executes and forks the tray, with the next rowop <code class="computeroutput">FibPrev1.result(n)</code> 
		then executing in order. So far so good.
		</p><p>
		Now let's trace the recursion to the depth of two. The first level starts the
		same:
		</p><pre class="programlisting">Compute(n-1)
Followup1(n)</pre><p>
		Then <code class="computeroutput">Compute(n-1)</code> executes and forks the second level of recursion,
		the frame becoming:
		</p><pre class="programlisting">Followup1(n)
Compute(n-1-1)
Followup1(n-1)</pre><p>
		Do you see what went wrong? The unit execution frames are FIFO. So the
		second level of recursion got queued after the follow-up of the first
		level. That rowop <code class="computeroutput">Followup1(n)</code> executes next, doesn't get any return 
		values, and everything goes downhill from there. 
		</p></div><div class="sect1" title="15.11. Streaming functions and unit boundaries"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_units"></a>15.11. Streaming functions and unit boundaries</h2></div></div></div><a class="indexterm" name="id548600"></a><a class="indexterm" name="id548608"></a><a class="indexterm" name="id548617"></a><a class="indexterm" name="id548625"></a><a class="indexterm" name="id548634"></a><p>
		One of the examples-as-future-standard-modules I've come up with, is TQL:
		the Triceps Trivial Query Language (or should that be TTQL?) along
		with a server to execute it. A TQL server is kind of like the
		Sybase or StreamBase CEP server in the way that it encapsulates
		the CEP logic, handles the client network connections with inputs and
		outputs, and also lets the clients define the ad-hoc queries against 
		the tables of both the one-time and streaming varieties. The ad-hoc
		capabilities of TQL are probably better than those of Sybase and
		StreamBase, at least comparing to the last time I've looked at them
		up close. TQL will be described in detail in
		<a class="xref" href="#ch_tql" title="Chapter 17. TQL, Triceps Trivial Query Language">Chapter 17: &#8220;<i>TQL, Triceps Trivial Query Language</i>&#8221; </a>
		but right now
		I want to look at only one aspect of its implementation.
		</p><p>
		When you're building the execution model of an ad-hoc query, you'd 
		obviously need to take it apart after its work is done. The easy way
		to do so is by building it in its own unit. Then this unit can
		be disposed of as, well, a unit, and guarantee that nothing will leak.
		By the way, that is the
		answer to the question of why would someone want to use multiple units
		in the same thread: for modular disposal.
		So far so good, but it means that the data sources in the 
		<span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> unit need to be connected with the processing
		labels in the units of the ad-hoc queries.
		</p><p>
		But the labels in the main unit and the query unit can't be directly
		connected. A direct connection would create the stable references, and
		the disposal won't work. That's where the streaming function interface
		comes to the rescue: it provides a temporary connection. Build the
		query unit, build a binding for it, push the binding onto the FnReturn
		of the main unit, run the query, pop the binding, dispose of the query
		unit.
		</p><p>
		And the special capacity (or if you will, superpower) of the streaming
		functions that allows all that is that the FnReturn and FnBinding don't
		have to be of the same unit. They may be of the different units and
		will still work together fine.
		</p><p>
		TQL was really developed as a showcase of this feature but it has
		gained a life of its own and I don't want to go into all details here.
		Instead lets have a high-level overview and then dive straight into the
		part that uses the streaming functions.
		</p><p>
		To start a TQL server, you build a Triceps model as usual, and then
		create an object of class Triceps::X::Tql using the endpoints of that
		model (inputs, outputs, queryable tables) as arguments. After that
		the object runs the server and handles the clients until it's asked to stop.
		</p><p>
		The TQL queries are pipelines. You read the data from a table, then
		select, project, join (in any order, and possibly repeatedly) and
		eventually print the result (that is, send it back to the client
		over the socket).
		</p><p>
		The reading from a table is done through its dump label.
		When the Tql object is created, it builds an FnReturn with the
		dump labels of all the tables given to it. When an ad-hoc query is created,
		its head of the pipeline gets a matching FnBinding that is then pushed 
		onto the FnReturn, the table gets dumped and flows through the binding
		into the query.
		</p><p>
		Now let's take a look at the code. I'll be
		skipping over the code that is less interesting, you can find the full
		version in the source code in <code class="computeroutput">lib/Triceps/X/Tql.pm</code> as
		always. The constructor is one of these things to be skipped. The
		initialization part is more interesting. I've cut out the part that
		supports the multi-threaded logic, and the remaining single-threaded
		version goes as follows:
		</p><pre class="programlisting">sub initialize # ($self)
{
  my $myname = "Triceps::X::Tql::initialize";
  my $self = shift;

  return if ($self-&gt;{initialized});

  my $owner = $self-&gt;{trieadOwner};
  if (defined $owner) {
    # ... multithreaded version ...
  } else {
    my %dispatch;
    my @labels;
    for (my $i = 0; $i &lt;= $#{$self-&gt;{tables}}; $i++) {
      my $name = $self-&gt;{tableNames}[$i];
      my $table = $self-&gt;{tables}[$i];

      confess "$myname: found a duplicate table name '$name', all names are: "
          . join(", ", @{$self-&gt;{tableNames}})
        if (exists $dispatch{$name});

      $dispatch{$name} = $table;
      push @labels, $name, $table-&gt;getDumpLabel();
    }

    $self-&gt;{dispatch} = \%dispatch;
    $self-&gt;{fret} = Triceps::FnReturn-&gt;new(
      name =&gt; $self-&gt;{name} . ".fret",
      labels =&gt; \@labels,
    );
  }

  $self-&gt;{initialized} = 1;
}</pre><p>
		It creates a dispatch hash of name-to-table and also an FnReturn that
		contains the dump labels of all the tables.
		</p><p>
		The method <code class="computeroutput">compileQuery()</code> then handles the creation of the
		separate unit with its contents (<span class="quote">&#8220;<span class="quote">facet</span>&#8221;</span> is a term from the
		multithreading support, just ignore it for now):
		</p><pre class="programlisting"># The common query compilation for the single-threaded and multi-threaded versions.
#
# The options are:
#
# qid =&gt; $id
# (optional) The query id that will be used to report any service information
# such as errors, end of dump portion and such.
# Default: ''.
#
# qname =&gt; $name
# The query name that will be used as a label name for all the
# produced data, and for the service information too.
#
# nxprefix =&gt; $name
# (optional) Prefix for the created unit name.
# Default: ''.
#
# text =&gt; $query_text
# Text of the query, in the braced format.
#
# subError =&gt; \&amp;error($id, $qname, $msg, $error_code, $error_val)
# The function that will handle the error reporting. The args are:
#   $id and $qname as received in the options
#   $msg - the full human-readable message
#   $error_code - the string identifying the error
#   $error_val - the particular value that caused the error
#
# tables =&gt; { $name =&gt; $table, ... }
# The tables list for the single-threaded version.
# Not used with the multithreaded version.
#
# fretDumps =&gt; $fnReturn
# The FnReturn object for dumps in the single-threaded version.
# Not used with the multithreaded version.
#
# faOut =&gt; $facet
# The facet used to send the data to the Tql thread.
# Not used with the single-threaded version.
#
# faRqDump =&gt; $facet
# The facet used to send the table dump requests back to the app core.
# Not used with the single-threaded version.
#
# subPrint =&gt; \&amp;print($text)
# The function that prints the text back to the socket.
# Not used with the single-threaded version.
#
# @return - undef on error, the compiled context object on success
#           (see the definition of its contents inside the function)
sub compileQuery # (@opts)
{
  my $myname = "Triceps::X::Tql::compileQuery";
  my $opts = {};
  &amp;Triceps::Opt::parse("chatSockWriteT", $opts, {
    qid =&gt; [ '', undef ],
    qname =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    nxprefix =&gt; [ '', undef ],
    text =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    subError =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory; &amp;Triceps::Opt::ck_ref(@_, "CODE"); } ],
    tables =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "HASH", "Triceps::Table"); } ],
    fretDumps =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::FnReturn"); } ],
    faOut =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::Facet"); } ],
    faRqDump =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "Triceps::Facet"); } ],
    subPrint =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "CODE"); } ],
  }, @_);

  my $q = $opts-&gt;{qname}; # the name of the query itself

  my @cmds = split_braced($opts-&gt;{text});
  if ($opts-&gt;{text} ne '') {
    &amp;{$opts-&gt;{subError}}($opts-&gt;{qid}, $q, "mismatched braces in the trailing " . $opts-&gt;{text},
      'query_syntax', $opts-&gt;{text});
    return undef;
  }

  # The context for the commands to build up an execution of a query.
  # Unlike $self, the context is created afresh for every query.
  my $ctx = {};
  $ctx-&gt;{qid} = $opts-&gt;{qid};
  $ctx-&gt;{qname} = $opts-&gt;{qname};

  $ctx-&gt;{tables} = $opts-&gt;{tables};
  $ctx-&gt;{fretDumps} = $opts-&gt;{fretDumps};
  $ctx-&gt;{actions} = []; # code that will run the pipeline

  $ctx-&gt;{faOut} = $opts-&gt;{faOut};
  $ctx-&gt;{faRqDump} = $opts-&gt;{faRqDump};
  $ctx-&gt;{subPrint} = $opts-&gt;{subPrint};
  $ctx-&gt;{requests} = []; # dump and subscribe requests that will run the pipeline
  $ctx-&gt;{copyTables} = []; # the tables created in this query
    # (have to keep references to the tables or they will disappear)

  # The query will be built in a separate unit
  $ctx-&gt;{u} = Triceps::Unit-&gt;new($opts-&gt;{nxprefix} . "${q}.unit");
  $ctx-&gt;{prev} = undef; # will contain the output of the previous command in the pipeline
  $ctx-&gt;{id} = 0; # a unique id for auto-generated objects
  # deletion of the context will cause the unit in it to clean
  $ctx-&gt;{cleaner} = $ctx-&gt;{u}-&gt;makeClearingTrigger();

  if (! eval {
    foreach my $cmd (@cmds) {
      my @args = split_braced($cmd);
      my $argv0 = bunescape(shift @args);
      # The rest of @args do not get unquoted here!
      die "No such TQL command '$argv0'\n" unless exists $tqlDispatch{$argv0};
      # do something better with the errors, show the failing command...
      $ctx-&gt;{id}++;
      &amp;{$tqlDispatch{$argv0}}($ctx, @args);
      # Each command must set its result label (even if an undef) into
      # $ctx-&gt;{next}.
      die "Internal error in the command $argv0: missing result definition\n"
        unless (exists $ctx-&gt;{next});
      $ctx-&gt;{prev} = $ctx-&gt;{next};
      delete $ctx-&gt;{next};
    }
    if (defined $ctx-&gt;{prev}) {
      # implicitly print the result of the pipeline, no options
      &amp;{$tqlDispatch{"print"}}($ctx);
    }

    1; # means that everything went OK
  }) {
    &amp;{$opts-&gt;{subError}}($opts-&gt;{qid}, $q, "query error: $@", 'bad_query', '');
    return undef;
  }

  return $ctx;
}</pre><p>
		Each TQL command is defined as its own method, all of them collected in
		the <code class="computeroutput">%tqlDispatch</code>. <code class="computeroutput">compileQuery()</code> splits the pipeline and then lets each
		command build its part of the query, connecting them through <code class="computeroutput">$ctx</code>. A
		command may also register an action to be run later. After everything
		is built, the actions run and produce the result.
		</p><a class="indexterm" name="id548818"></a><p>
		The TQL syntax uses braces for the grouping in the pipeline.
		The functions <code class="computeroutput">split_braced()</code> and <code class="computeroutput">bunescape()</code> are imported from the
		package Triceps::Braced that handles the parsing of the braced
		nested lists. They are described in detail in
		<a class="xref" href="#sc_ref_braced" title="19.16. Braced reference">Section 19.16: &#8220;Braced reference&#8221; </a>.
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">subError</span>&#8221;</span> defines a function that reports
		the errors back to the user. Since everything is returned back as
		a stream, the errors are reported as rowops on the special label
		<span class="quote">&#8220;<span class="quote">+ERROR</span>&#8221;</span>. 
		</p><p>
		And the final part of the puzzle, here is the <span class="quote">&#8220;<span class="quote">read</span>&#8221;</span> 
		command handler that creates the head of the query pipeline:
		</p><pre class="programlisting"># "read" command. Defines a table to read from and starts the command pipeline.
# Options:
# table - name of the table to read from.
sub _tqlRead # ($ctx, @args)
{
  my $ctx = shift;
  die "The read command may not be used in the middle of a pipeline.\n"
    if (defined($ctx-&gt;{prev}));
  my $opts = {};
  &amp;Triceps::Opt::parse("read", $opts, {
    table =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
  }, @_);

  my $tabname = bunescape($opts-&gt;{table});
  my $unit = $ctx-&gt;{u};

  if ($ctx-&gt;{faOut}) {
    # ... multithreaded version ...
  } else {
    my $fret = $ctx-&gt;{fretDumps};

    die ("Read found no such table '$tabname'\n")
      unless (exists $ctx-&gt;{tables}{$tabname});
    my $table = $ctx-&gt;{tables}{$tabname};
    my $lab = $unit-&gt;makeDummyLabel($table-&gt;getRowType(), "lb" . $ctx-&gt;{id} . "read");
    $ctx-&gt;{next} = $lab;

    my $code = sub {
      Triceps::FnBinding::call(
        name =&gt; "bind" . $ctx-&gt;{id} . "read",
        unit =&gt; $unit,
        on =&gt; $fret,
        labels =&gt; [
          $tabname =&gt; $lab,
        ],
        code =&gt; sub {
          $table-&gt;dumpAll();
        },
      );
    };
    push @{$ctx-&gt;{actions}}, $code;
  }
}</pre><p>
		It's the only command that registers an action, which sends data into
		the query unit. The rest of commands just add more handlers to the
		pipeline in the unit, and get the data that flows from <span class="quote">&#8220;<span class="quote">read</span>&#8221;</span>. The
		action sets up a binding and calls the table dump, to send the data
		into that binding.
		</p><p>
		The reading of the tables could have also been done without the
		bindings, and without the need to bind the units at all: just iterate
		through the table procedurally in the action. But this whole example
		has been built largely to showcase that the bindings can be used in
		this way, so naturally it uses bindings.
		</p><p>
		The bindings come more useful when the query logic has to react to the
		normal logic of the main unit, such as in the subscriptions: set up the
		query, read its initial state, and then keep reading as the state gets
		updated. But guess what, the subscriptions can't be done with the
		FnReturns as shown because the FnReturn only sends its data to the last
		binding pushed onto it. This means, if multiple subscriptions get set
		up, only the last one will be getting the data. This problem gets
		solved only in the multithreaded implementation of Tql that will
		be discussed in
		<a class="xref" href="#sc_tql_join_internals" title="17.6. Internals of a TQL join">Section 17.6: &#8220;Internals of a TQL join&#8221; </a>.
		There each client runs in its own thread,
		and each of its queries runs in its own unit;
		the inter-thread communications are used to subscribe to the
		updates.
		</p></div><div class="sect1" title="15.12. The ways to call a streaming function"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_call"></a>15.12. The ways to call a streaming function</h2></div></div></div><a class="indexterm" name="id548924"></a><p>
		The examples in this chapter have shown many ways to call
		a streaming function. Here is a recap of them all:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Manually push the FnBinding onto the FnReturn, send the argument rowops
			to the streaming function, pop the FnBinding.
			</li><li class="listitem">
			Use an AutoFnBind to handle the pushing and popping in a scoped fashion.
			A single AutoFnBind can control multiple pairs of FnBinding and FnReturn,
			so it can build in one go not only a single streaming function call but
			even a whole pipeline. In the C++ API a more low-level object
			ScopedFnBind can also be used in a similar way.
			</li><li class="listitem">
			Use <code class="computeroutput">Unit::callBound()</code> that takes care of creating both the
			AutoFnBind object and a scope around of it in a more efficient way.
			</li><li class="listitem">
			Use <code class="computeroutput">FnBinding::call()</code> to create an FnBinding object dynamically,
			do a call with it, and dispose of it.
			</li></ul></div><p>
		The most convenient way depends on the situation.
		</p></div><div class="sect1" title="15.13. The gritty details of streaming functions scheduling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_strf_scheduling"></a>15.13. The gritty details of streaming functions scheduling</h2></div></div></div><a class="indexterm" name="id548981"></a><a class="indexterm" name="id548990"></a><p>
		If you've read carefully about all the gritty details of scheduling,
		you might wonder, what exactly happens when a label in an FnBinding gets
		called through an FnReturn? The answer is, they are executed
		like the chained labels, reusing the frame of the parent label
		(that is, of the matching label on the FnReturn side). They
		even show in the traces as the chained labels.
		This lets the bound labels to easily fork a rowop to the frame of its parent.
		</p><p>
		The only exception is when the FnReturn and FnBinding are in the different units.
		Then the bound label is properly called with its own frame in the unit
		where it belongs. 
		</p><p>
		And of course the rowops collected in a tray are another exception,
		since they are not called in the binding, they are only collected.
		When the tray gets called, they get properly called with their
		own frames, just as when calling any other tray.
		</p></div></div><div class="chapter" title="Chapter 16. Multithreading"><div class="titlepage"><div><div><h2 class="title"><a name="ch_mt"></a>Chapter 16. Multithreading</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_mt_concepts">16.1. Triceps multithreading concepts</a></span></dt><dt><span class="sect1"><a href="#sc_mt_triead_life">16.2. The Triead lifecycle</a></span></dt><dt><span class="sect1"><a href="#sc_mt_pipeline">16.3. Multithreaded pipeline</a></span></dt><dt><span class="sect1"><a href="#sc_mt_objects">16.4. Object passing between threads</a></span></dt><dt><span class="sect1"><a href="#sc_mt_files">16.5. Threads and file descriptors</a></span></dt><dt><span class="sect1"><a href="#sc_mt_dynamic_server">16.6. Dynamic threads and fragments in a socket server</a></span></dt><dt><span class="sect1"><a href="#sc_mt_threaded_server">16.7. ThreadedServer implementation, and the details of thread harvesting</a></span></dt><dt><span class="sect1"><a href="#sc_mt_threaded_client">16.8. ThreadedClient, a Triceps Expect</a></span></dt><dt><span class="sect1"><a href="#sc_mt_main_timeouts">16.9. Thread main loop and timeouts in the guts of ThreadedClient</a></span></dt><dt><span class="sect1"><a href="#sc_mt_main_reorder">16.10. The threaded dreaded diamond and data reordering</a></span></dt></dl></div><div class="sect1" title="16.1. Triceps multithreading concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_concepts"></a>16.1. Triceps multithreading concepts</h2></div></div></div><a class="indexterm" name="id482745"></a><p>
		When running the CEP models, naturally the threads have to be connected
		by the queues for the data exchange. The use of queues is extremely
		popular but also notoriously bug-prone.
		</p><p>
		The idea of the multithreading support in Triceps is to make writing
		the multithreaded model easier. To make writing the good code easy and
		writing the bad code hard. But of course you don't have to use it, if 
		it feels too constraining, you can always make your own.
		</p><p>
		The diagram in
		<a class="xref" href="#fig_mt_overview" title="Figure 16.1. Triceps multithreaded application.">Figure 16.1</a>
		shows all the main elements of a multithread Triceps application.
		</p><div class="figure"><a name="fig_mt_overview"></a><div class="figure-contents"><div><img src="thread-010-over.lowres.png" width="NaN" alt="Triceps multithreaded application."></div></div><p class="title"><b>Figure 16.1. Triceps multithreaded application.</b></p></div><br class="figure-break"><a class="indexterm" name="id502342"></a><a class="indexterm" name="id462559"></a><a class="indexterm" name="id470407"></a><a class="indexterm" name="id467562"></a><a class="indexterm" name="id496659"></a><a class="indexterm" name="id487420"></a><p>
		The Triceps application is embodied in the class App. It's possible to
		have multiple Apps in one program.
		</p><p>
		Each thread has multiple parts to it. First, of course, there is the
		OS-level (or, technically, library-level, or Perl-level) thread where
		the code executes. And then there is a class that represents this
		thread and its place in the App. To reduce the naming conflict, this
		class is creatively named Triead (pronounced still <span class="quote">&#8220;<span class="quote">thread</span>&#8221;</span>). In the
		discussion I use the word <span class="quote">&#8220;<span class="quote">thread</span>&#8221;</span> for both concepts, the OS-level
		thread and the Triead, and it's usually clear from the context which
		one I mean. But sometimes it's particularly important to make the
		distinction, and then I name one or the other explicitly.
		</p><p>
		The class Triead itself is largely opaque, allowing only a few methods
		for introspection. But there is a control interface to it, called
		TrieadOwner. The Triead is visible from the outside, the TrieadOwner
		object is visible only in the OS thread that owns the Triead. The
		TrieadOwner manages the thread state and acts as the intermediary in
		the thread's communications with the App.
		</p><p>
		The data is passed between the threads through the Nexuses. A Nexus is
		unidirectional, with data going only one way, however it may have
		multiple writers and multiple readers. All the readers see the exact
		same data, with rowops going in the exact same order (well, there will
		be other policies in the future as well, but for now there is only one
		policy).
		</p><p>
		A Nexus passes through the data for multiple labels, very much like an
		FnReturn does (and indeed there is a special connection between them).
		A Nexus also allows to export the row types and table types from one
		thread to another.
		</p><p>
		A Nexus is created by one thread, and then the other threads connect to it.
		The thread that creates the Nexus determines what labels will it contain,
		and what row types and table types to export.
		</p><p>
		A Nexus gets connected to the Trieads through the Facets (in the diagram,
		the Facets are shown as flat spots on the round Nexuses). A Facet is
		a connection point between the Nexus and the Triead. Each Facet is for
		either reading or writing. And there may be only one Facet between a
		given Nexus and a given Triead, you can't make multiple connections
		between them. As a consequence, a thread can't both write and read to
		the same Nexus, it can do only one thing. This might actually be an
		overly restrictive limitation and might change in the future but that's
		how things work now.
		</p><a class="indexterm" name="id466076"></a><p>
		Each Nexus also has a direction: either direct (<span class="quote">&#8220;<span class="quote">downwards</span>&#8221;</span>) or reverse
		(<span class="quote">&#8220;<span class="quote">upwards</span>&#8221;</span>). How does it know, which direction is down and
		whih is up? It doesn't. You tell it by designating a Nexus one way or the other.
		And yes, the reverse Nexuses allow to build the models
		with loops. However the loops consisting of only the direct Nexuses are
		not allowed, nor of only reverse Nexuses. They would mess up the flow
		control. The proper loops must contain a mix of direct and reverse
		Nexuses.
		</p><p>
		The direct Nexuses have a limited queue size and stop the writers when
		the queue fills up, until the data gets consumed, thus providing the
		flow control. The reverse Nexuses have an unlimited queue size, which
		allows to avoid the circular deadlocks. The reverse Nexuses also have
		a higher priority: if a thread is reading from a direct Nexus and a
		reverse one, with both having data available, it will read the data
		from the reverse Nexus first. This is to prevent the unlimited queues
		in the reverse Nexuses from the truly unlimited growth.
		</p><p>
		Normally an App is built once and keeps running in this configuration
		until it stops. But there is a strong need to have the threads
		dynamically added and deleted too. For example, if the App running as a
		server, and clients connect to it, each client needs to have its
		thread(s) added when the client connects and then deleted when the client
		disconnects. This is handled through the concept of fragments. There is
		no Fragment class but when you create a Triead, you can specify a
		fragment name for it. Then it becomes possible to shut down and dispose
		the threads in a fragment after the fragment's work is done. 
		</p></div><div class="sect1" title="16.2. The Triead lifecycle"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_triead_life"></a>16.2. The Triead lifecycle</h2></div></div></div><a class="indexterm" name="id543473"></a><p>
		Each Triead goes through a few stages in its life:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			declared
			</li><li class="listitem">
			defined
			</li><li class="listitem">
			constructed
			</li><li class="listitem">
			ready
			</li><li class="listitem">
			waited ready
			</li><li class="listitem">
			requested dead
			</li><li class="listitem">
			dead
			</li></ul></div><p>
		Note by the way that it's the stages of the Triead object. The OS-level
		thread as such doesn't know much about them, even though these stages
		do have some connections to its state.
		</p><p>
		These stages always go in order and can not be skipped. However for
		convenience you can request a move directly to a further stage. This will just
		automatically pass through all the intermediate stages. Although, well,
		there is one exception: the <span class="quote">&#8220;<span class="quote">waited ready</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">requested dead</span>&#8221;</span> stages
		can get skipped on the way to <span class="quote">&#8220;<span class="quote">dead</span>&#8221;</span>. Other than that, there is always
		the sequence, so if you find out that a Triead is dead, you can be sure
		that it's also declared, defined, constructed and ready. The attempts
		to go to a previous stage are silently ignored.
		</p><p>
		Now, what do these stages mean?
		</p><div class="variablelist"><dl><dt><span class="term">Declared:</span></dt><dd><p>
				The App knows the name of the thread and that this thread
				will eventually exist. When an App is asked to find the resources from
				this thread (such as Nexuses, and by the way, the Nexuses are
				associated with the threads that created them) it will know to wait
				until this thread becomes constructed, and then look for the resources.
				It closes an important race condition: the code that defines the Triead
				normally runs in a new OS thread but there is no way to tell when
				exactly will it run and do its work. If you had spawned a new thread and
				then attempted to get a nexus from it before it actually runs, the App
				would tell you that there is no such thread and fail. To get around it,
				you declare the thread first and then start it. Most of the time there
				is no need to declare explicitly, the library code that wraps the
				thread creation does it for you.
				</p></dd><dt><span class="term">Defined:</span></dt><dd><p>
				The Triead object has been created and connected to the App.
				Since this is normally done from the new OS thread, it also implies
				that the thread is running and is busy about constructing the nexuses
				and whatever its own internal resources.
				</p></dd><dt><span class="term">Constructed:</span></dt><dd><p>
				The Triead had constructed and exported all the nexuses
				that it planned to. This means that now these nexuses can be imported
				by the other threads (i.e. connected to the other threads). After this
				point the thread can not construct any more nexuses. However it can
				keep importing the nexuses from the other threads. It's actually a good
				idea to do all your exports, mark the thread constructed, and only then
				start importing. This order guarantees the absence of initialization deadlocks (which
				would be detected and will cause the App to be aborted). There are some
				special cases when you need to import a nexus from a thread that is not
				fully constructed yet, and it's possible, but requires more attention
				and a special override of the <span class="quote">&#8220;<span class="quote">immediate</span>&#8221;</span> import.
				This is described in more detail in
				<a class="xref" href="#sc_ref_triead_owner" title="19.22. TrieadOwner reference">Section 19.22: &#8220;TrieadOwner reference&#8221; </a>,
				with the method <code class="computeroutput">importNexus()</code>.
				</p></dd><dt><span class="term">Ready:</span></dt><dd><p>
				The thread had imported all the nexuses it wanted and fully
				initialized all its internals (for example, if it needs to load data
				from a file, it might do that before telling that it's ready). After
				this point no more nexuses can be imported. A fine point is that the
				other threads may still be created, and they may do their exporting and
				importing, but once a thread is marked as ready, it's cast in bronze.
				And in the simple cases you don't need to worry about separating the
				constructed and ready stages, just initialize everything and mark the
				thread as ready.
				</p></dd><dt><span class="term">Waited ready:</span></dt><dd><p>
				Before proceeding further, the thread has to wait for all
				the threads in App to be ready, or it would lose data when it tries to
				communicate with them. It's essentially a barrier. Normally both the
				stages <span class="quote">&#8220;<span class="quote">ready</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">waited ready</span>&#8221;</span> are advanced to with a single call
				<code class="computeroutput">readyReady()</code>. With it the thread says <span class="quote">&#8220;<span class="quote">I'm ready, and let me continue when
				everyone is ready</span>&#8221;</span>. After that the actual work can begin. It's still
				possible to create more threads after that (normally, parts of the
				transient fragments), and until they all become ready, the App may
				temporarily become unready again, but that's a whole separate advanced
				topic that will be discussed in
				<a class="xref" href="#sc_mt_dynamic_server" title="16.6. Dynamic threads and fragments in a socket server">Section 16.6: &#8220;Dynamic threads and fragments in a socket server&#8221; </a>.
				</p></dd><dt><span class="term">Requested dead:</span></dt><dd><p>
				This is the way to request a thread to exit. Normally
				some control thread will decide that the App needs to exit and will
				request all its threads to die. The threads will get these requests,
				perform their last rites and exit. The threads don't have to get this
				request to exit, they can also always decide to exit on their own. When
				a thread is requested to die, all the data communication with it stops.
				No more data will get to it through the nexuses and any data it sends
				will be discarded. It might churn a little bit through the data in its
				input buffers but any results produced will be discarded. The good
				practice is to make sure that all the data is drained before requesting
				a thread to die. Note that the nexuses created by this thread aren't
				affected at all, they keep working as usual. It's the data connections
				between this thread and any nexuses that get broken.
				</p></dd><dt><span class="term">Dead:</span></dt><dd><a class="indexterm" name="id546596"></a><p>
				The thread had completed its execution and exited. Normally you
				don't need to mark this explicitly. When the thread's main function
				returns, the library will do it for you. Marking the thread dead also
				drives the harvesting of the OS threads: the harvesting logic will
				perform a <code class="computeroutput">join()</code> (not to be confused with SQL join) of the thread and
				thus free the OS resources. The dead Trieads are still visible in the
				App (except for some special cases with the fragments), and their
				nexuses continue working as usual (even including the special cases
				with the fragments), the other threads can keep communicating through
				them for as long as they want. 
				</p></dd></dl></div></div><div class="sect1" title="16.3. Multithreaded pipeline"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_pipeline"></a>16.3. Multithreaded pipeline</h2></div></div></div><a class="indexterm" name="id546634"></a><p>
		The multithreaded models are well suited for running the pipelines,
		so that is going to be the first example of the threads. The full text of the example
		can be found in <code class="computeroutput">t/xTrafficAggMt.t</code> in the class Traffic1.
		It's a variation of an already shown example, the traffic
		data aggregation from 
		<a class="xref" href="#sc_time_periodic" title="13.2. Periodic updates">Section 13.2: &#8220;Periodic updates&#8221; </a>.
		The short recap is that it gets
		the data for each network packet going through and keeps it for some
		time, aggregates the data by the hour and keeps it for a longer time,
		and aggregates it by the day and keeps for a longer time yet. This
		multi-stage computation naturally matches the pipeline approach.
		</p><p>
		Since this new example highlights different features than the original one,
		I've changed it logic a little: it updates both the
		hourly and daily summaries on every packet received. And I didn't
		bother to implement the part with the automatic cleaning of the old
		data, it doesn't add anything interesting to the pipeline works.
		</p><p>
		The pipeline topologies are quite convenient for working with the
		threads. The parallel computations create a possibility of things
		happening in an unpredictable order and producing unpredictable
		results. The pipeline topology allows the parallelism and at the same
		time also keeps the data in the same predictable order, with no
		possibility of rows overtaking each other.
		</p><p>
		The computation in this example is split into the following threads:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Read the input, parse and send the data into the model.
			</li><li class="listitem">
			Store the recent data and aggregate it by the hour.
			</li><li class="listitem">
			Store the hourly data and aggregate it by the day.
			</li><li class="listitem">
			Store the daily data.
			</li><li class="listitem">
			Get the data at the end of the pipeline and print it.
			</li></ul></div><p>
		The result of each aggregation gets stored in a table in the next thread,
		which then uses the same table for the next stage of aggregation.
		</p><p>
		Technically, each stage only needs the data from the previous
		stage, but to get the updates to the printing stage (since we want
		to print the original updates, daily and hourly), they all go all
		the way through.
		</p><p>
		Dumping the contents of the tables also requires some special support.
		Each table is local to its thread and can't be accessed from the other
		threads. To dump its contents, the dump request needs to be sent to its
		thread, which would extract the data and send it through. There are
		multiple ways to deal with the dump results. One is to have a special
		label for each table's dump and propagate it to the last stage to
		print. If all that is needed is text, another way is to have one label that allows to send
		strings is good enough, all the dumps can send the data converted to
		text into it, and it would go all the way through the pipeline.
		For this example I've picked the last approach.
		</p><p>
		And now is time to show some code. The main part goes like this:
		</p><pre class="programlisting">Triceps::Triead::startHere(
  app =&gt; "traffic",
  thread =&gt; "print",
  main =&gt; \&amp;printT,
);</pre><a class="indexterm" name="id546736"></a><a class="indexterm" name="id546746"></a><p>
		The <code class="computeroutput">startHere()</code> creates an App and starts a Triead in the current OS
		thread. <span class="quote">&#8220;<span class="quote">Here</span>&#8221;</span> in the method name stands for <span class="quote">&#8220;<span class="quote">in the current OS thread</span>&#8221;</span>.
		<span class="quote">&#8220;<span class="quote">traffic</span>&#8221;</span> is the app name, <span class="quote">&#8220;<span class="quote">print</span>&#8221;</span> the thread name. This thread
		will be the end of the pipeline, and it will create the rest of the
		threads. This is a convenient pattern when the results of the model
		need to be fed back to the current thread, and it works out very
		conveniently for the unit tests. <code class="computeroutput">printT()</code> is the body function of
		this printing thread:
		</p><pre class="programlisting">sub printT # (@opts)
{
  my $opts = {};
  Triceps::Opt::parse("traffic main", $opts, {@Triceps::Triead::opts}, @_);
  my $owner = $opts-&gt;{owner};
  my $unit = $owner-&gt;unit();

  Triceps::Triead::start(
    app =&gt; $opts-&gt;{app},
    thread =&gt; "read",
    main =&gt; \&amp;readerT,
  );
  Triceps::Triead::start(
    app =&gt; $opts-&gt;{app},
    thread =&gt; "raw_hour",
    main =&gt; \&amp;rawToHourlyT,
    from =&gt; "read/data",
  );
  Triceps::Triead::start(
    app =&gt; $opts-&gt;{app},
    thread =&gt; "hour_day",
    main =&gt; \&amp;hourlyToDailyT,
    from =&gt; "raw_hour/data",
  );
  Triceps::Triead::start(
    app =&gt; $opts-&gt;{app},
    thread =&gt; "day",
    main =&gt; \&amp;storeDailyT,
    from =&gt; "hour_day/data",
  );

  my $faIn = $owner-&gt;importNexus(
    from =&gt; "day/data",
    as =&gt; "input",
    import =&gt; "reader",
  );

  $faIn-&gt;getLabel("print")-&gt;makeChained("print", undef, sub {
    print($_[1]-&gt;getRow()-&gt;get("text"));
  });
  for my $tag ("packet", "hourly", "daily") {
    makePrintLabel($tag, $faIn-&gt;getLabel($tag));
  }

  $owner-&gt;readyReady();
  $owner-&gt;mainLoop(); # all driven by the reader
}</pre><p>
		<code class="computeroutput">startHere()</code> accepts a number of fixed options plus arbitrary options
		that it doesn't care about by itself but passes through to the thread's main
		function, which are then the responsibility of the main function to
		parse. To reiterate, the main function gets all the options from the
		call of <code class="computeroutput">startHere()</code>, both these that <code class="computeroutput">startHere()</code> parses and these that
		it simply passes through. <code class="computeroutput">startHere()</code> also adds one more option on its
		own: <span class="quote">&#8220;<span class="quote">owner</span>&#8221;</span> containing the TrieadOwner object that the thread uses to
		communicate with the rest of the App.
		</p><p>
		In this case <code class="computeroutput">printT()</code> doesn't have any extra options on its own,
		it's just happy to get <code class="computeroutput">startHere()</code>'s standard set that it takes all
		together from <code class="computeroutput">@Triceps::Triead::opts</code>.
		</p><a class="indexterm" name="id546860"></a><a class="indexterm" name="id546870"></a><a class="indexterm" name="id546880"></a><p>
		It gets the TrieadOwner object <code class="computeroutput">$owner</code> from the option appended by
		<code class="computeroutput">startHere()</code>. Each TrieadOwner is created with its own Unit, so the unit
		is obtained from it to create the thread's model in it. Incidentally,
		the TrieadOwner  also acts as a clearing trigger object for the Unit,
		so when the TrieadOwner is destroyed, it properly clears the Unit.
		</p><p>
		Then it goes and creates all the threads of the pipeline. The <code class="computeroutput">start()</code>
		works very much like <code class="computeroutput">startHere()</code>, only it actually creates a new thread
		and starts the main function in it. The main function can be the same
		whether it runs through <code class="computeroutput">start()</code> or <code class="computeroutput">startHere()</code>. The special catch is
		that the options to <code class="computeroutput">start()</code> must contain only the plain Perl values,
		not Triceps objects. It has to do with how Perl works with threads: it
		makes a copy of every value for the new thread, and it cant's copy the
		XS objects, so they simply become undefined in the new thread.
		</p><p>
		All but the first thread in the pipeline have the extra option <span class="quote">&#8220;<span class="quote">from</span>&#8221;</span>: it
		specifies the input nexus for this thread, and each thread creates an
		output nexus <span class="quote">&#8220;<span class="quote">data</span>&#8221;</span>. A nexus it named relatively to the
		thread that created it, so when the option <span class="quote">&#8220;<span class="quote">from</span>&#8221;</span> says <span class="quote">&#8220;<span class="quote">day/data</span>&#8221;</span>, it's
		the nexus <span class="quote">&#8220;<span class="quote">data</span>&#8221;</span> created by the thread <span class="quote">&#8220;<span class="quote">day</span>&#8221;</span>.
		</p><a class="indexterm" name="id546970"></a><a class="indexterm" name="id546980"></a><p>
		So, the pipeline gets all connected sequentially until eventually
		<code class="computeroutput">printT()</code> imports the nexus at its tail. <code class="computeroutput">importNexus()</code> returns a
		Facet, which is the thread's API to the nexus. A facet looks very much
		like an FnReturn for most purposes, with a few additions. It even has a
		real FnReturn in it, and you work with the labels of that FnReturn to get the
		data out of the nexus (or to send data into the nexus). You could potentially
		use an FnBinding with that FnReturn but the typical pattern for reading
		from a facet is different: just get its labels 
		and chain the handling labels directly to them.
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">as</span>&#8221;</span> of <code class="computeroutput">importNexus()</code> gives the name to the facet and to its
		same-named FnReturn (without it the facet would be named the same as
		the short name of the nexus, in this case <span class="quote">&#8220;<span class="quote">data</span>&#8221;</span>). The option <span class="quote">&#8220;<span class="quote">import</span>&#8221;</span>
		tells whether this thread will be reading or writing the nexus, and
		in this case it's reading.
		</p><p>
		By the time the pipeline gets to the last stage, it has a few
		labels in its facet:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">print</code> - carries the direct text lines to print in its field <code class="computeroutput">text</code>,
			and its contents gets printed.
			</li><li class="listitem"><code class="computeroutput">dumprq</code> - carries the dump requests to the tables, and the printing
			thread doesn't care about it.
			</li><li class="listitem"><code class="computeroutput">packet</code> - carries the raw data about the packets.
			</li><li class="listitem"><code class="computeroutput">hourly</code> - carries the hourly summaries.
			</li><li class="listitem"><code class="computeroutput">daily</code> - carries the daily summaries.
			</li></ul></div><p>
		The last three get also printed but this time as whole rows.
		</p><p>
		And after everything is connected, the thread both tells that it's
		ready and waits for all the other threads to become ready by calling
		<code class="computeroutput">readyReady()</code>. Then its the run time, and <code class="computeroutput">mainLoop()</code> takes care of it:
		it keeps reading data from the nexus and
		processes it until it's told to shutdown.
		The shutdown will be controlled by the file reading
		thread at the start of the pipeline. The processing is done by getting
		the rowops from the nexus and calling them on the appropriate label in
		the facet, which then calls the the labels chained from it, and that
		gets all the rest of the thread's model running.
		</p><p>
		The reader thread drives the pipeline:
		</p><pre class="programlisting">sub readerT # (@opts)
{
  my $opts = {};
  Triceps::Opt::parse("traffic main", $opts, {@Triceps::Triead::opts}, @_);
  my $owner = $opts-&gt;{owner};
  my $unit = $owner-&gt;unit();

  my $rtPacket = Triceps::RowType-&gt;new(
    time =&gt; "int64", # packet's timestamp, microseconds
    local_ip =&gt; "string", # string to make easier to read
    remote_ip =&gt; "string", # string to make easier to read
    local_port =&gt; "int32",
    remote_port =&gt; "int32",
    bytes =&gt; "int32", # size of the packet
  );

  my $rtPrint = Triceps::RowType-&gt;new(
    text =&gt; "string", # the text to print (including \n)
  );

  my $rtDumprq = Triceps::RowType-&gt;new(
    what =&gt; "string", # identifies, what to dump
  );

  my $faOut = $owner-&gt;makeNexus(
    name =&gt; "data",
    labels =&gt; [
      packet =&gt; $rtPacket,
      print =&gt; $rtPrint,
      dumprq =&gt; $rtDumprq,
    ],
    import =&gt; "writer",
  );

  my $lbPacket = $faOut-&gt;getLabel("packet");
  my $lbPrint = $faOut-&gt;getLabel("print");
  my $lbDumprq = $faOut-&gt;getLabel("dumprq");

  $owner-&gt;readyReady();

  while(&lt;STDIN&gt;) {
    chomp;
    # print the input line, as a debugging exercise
    $unit-&gt;makeArrayCall($lbPrint, "OP_INSERT", "&gt; $_\n");

    my @data = split(/,/); # starts with a command, then string opcode
    my $type = shift @data;
    if ($type eq "new") {
      $unit-&gt;makeArrayCall($lbPacket, @data);
    } elsif ($type eq "dump") {
      $unit-&gt;makeArrayCall($lbDumprq, "OP_INSERT", $data[0]);
    } else {
      $unit-&gt;makeArrayCall($lbPrint, "OP_INSERT", "Unknown command '$type'\n");
    }
    $owner-&gt;flushWriters();
  }

  {
    # drain the pipeline before shutting down
    my $ad = Triceps::AutoDrain::makeShared($owner);
    $owner-&gt;app()-&gt;shutdown();
  }
}</pre><p>
		It starts by creating the nexus with the initial set of the labels: for
		the data about the network packets, for the lines to be printed at the
		end of the pipeline and for the dump requests to the tables in the
		other threads. It gets exported for the other threads to import, and
		also imported right back into this thread, for writing. And then the
		setup is done, <code class="computeroutput">readyReady()</code> is called, and the processing starts.
		</p><p>
		It reads the CSV lines, splits them, makes a decision if it's a data
		line or dump request, and one way or the other sends it into the nexus.
		The data sent to a facet doesn't get immediately forwarded to the
		nexus. It's collected internally in a tray, and then <code class="computeroutput">flushWriters()</code>
		sends it on. The <code class="computeroutput">mainLoop()</code> shown in <code class="computeroutput">printT</code> calls <code class="computeroutput">flushWriters()</code>
		automatically after every tray it processes from the input. But when
		reading from a file you've got to do it yourself. Of course, it's more
		efficient to send through multiple rows at once, so a smarter
		implementation would check if multiple lines are available from the
		file and send them in larger bundles.
		</p><a class="indexterm" name="id547191"></a><a class="indexterm" name="id547201"></a><p>
		The last part is the shutdown. After the end of file is reached, it's
		time to shut down the application. You can't just shut down it right
		away because there still might be data in the pipeline, and if you shut
		it down, that data will be lost. The right way is to drain the pipeline
		first, and then do the shutdown when the app is drained.
		<code class="computeroutput">AutoDrain::makeShared()</code> creates a scoped drain: the drain request for
		all the threads is started when this object is created, and the object
		construction completes when the drain succeeds. When the object is
		destroyed, that releases the drain. So in this case the drain succeeds and
		then the app gets shut down.
		</p><p>
		The shutdown causes the <code class="computeroutput">mainLoop()</code> calls in all the other threads to
		return, and the threads to exit. Then <code class="computeroutput">startHere()</code> in the first thread
		has the special logic in it that joins all the started threads after
		its own main function returns and before it completes. After that the
		script continues on its way and is free to exit. 
		</p><p>
		The rest of this example might be easier to understand by looking at an
		example of a run first. The lines in bold are the copies of
		the input lines that <code class="computeroutput">readerT()</code> reads from the input and
		sends into the pipeline, and <code class="computeroutput">printT()</code> faithfully
		prints.
		</p><p>
		<code class="computeroutput">input.packet</code> are the rows that reach the <code class="computeroutput">printT</code> on the <code class="computeroutput">packet</code> label
		(remember, <span class="quote">&#8220;<span class="quote">input</span>&#8221;</span> is the name with which it imports its input nexus).
		<code class="computeroutput">input.hourly</code> is the data aggregated by the hour intervals (and also by
		the IP addresses, dropping the port information), and <code class="computeroutput">input.daily</code>
		further aggregates it per day (and again per the IP addresses). The
		timestamps in the hourly and daily rows are truncated to the start
		of the hour or day.
		</p><p>
		And the lines without any prefixes are the dumps of the table contents
		that again reach the <code class="computeroutput">printT()</code> through the <span class="quote">&#8220;<span class="quote">print</span>&#8221;</span> label:
		</p><pre class="programlisting"><span class="bold"><strong>new,OP_INSERT,1330886011000000,1.2.3.4,5.6.7.8,2000,80,100</strong></span>
input.packet OP_INSERT time="1330886011000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="100"
input.hourly OP_INSERT time="1330884000000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="100"
input.daily OP_INSERT time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="100"
<span class="bold"><strong>new,OP_INSERT,1330886012000000,1.2.3.4,5.6.7.8,2000,80,50</strong></span>
input.packet OP_INSERT time="1330886012000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="50"
input.hourly OP_DELETE time="1330884000000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="100"
input.daily OP_DELETE time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="100"
input.hourly OP_INSERT time="1330884000000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="150"
input.daily OP_INSERT time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="150"
<span class="bold"><strong>new,OP_INSERT,1330889612000000,1.2.3.4,5.6.7.8,2000,80,150</strong></span>
input.packet OP_INSERT time="1330889612000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="150"
input.hourly OP_INSERT time="1330887600000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="150"
input.daily OP_DELETE time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="150"
input.daily OP_INSERT time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="300"
<span class="bold"><strong>new,OP_INSERT,1330889811000000,1.2.3.4,5.6.7.8,2000,80,300</strong></span>
input.packet OP_INSERT time="1330889811000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" local_port="2000" remote_port="80" bytes="300"
input.hourly OP_DELETE time="1330887600000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="150"
input.daily OP_DELETE time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="300"
input.daily OP_INSERT time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="150"
input.hourly OP_INSERT time="1330887600000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="450"
input.daily OP_DELETE time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="150"
input.daily OP_INSERT time="1330819200000000" local_ip="1.2.3.4"
    remote_ip="5.6.7.8" bytes="600"
<span class="bold"><strong>new,OP_INSERT,1330972411000000,1.2.3.5,5.6.7.9,3000,80,200</strong></span>
input.packet OP_INSERT time="1330972411000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" local_port="3000" remote_port="80" bytes="200"
input.hourly OP_INSERT time="1330970400000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" bytes="200"
input.daily OP_INSERT time="1330905600000000" local_ip="1.2.3.5"
    remote_ip="5.6.7.9" bytes="200"
<span class="bold"><strong>new,OP_INSERT,1331058811000000</strong></span>
input.packet OP_INSERT time="1331058811000000"
<span class="bold"><strong>new,OP_INSERT,1331145211000000</strong></span>
input.packet OP_INSERT time="1331145211000000"
<span class="bold"><strong>dump,packets</strong></span>
time="1330886011000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="100"
time="1330886012000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="50"
time="1330889612000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="150"
time="1330889811000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    local_port="2000" remote_port="80" bytes="300"
time="1330972411000000" local_ip="1.2.3.5" remote_ip="5.6.7.9"
    local_port="3000" remote_port="80" bytes="200"
<span class="bold"><strong>dump,hourly</strong></span>
time="1330884000000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="150"
time="1330887600000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="450"
time="1330970400000000" local_ip="1.2.3.5" remote_ip="5.6.7.9"
    bytes="200"
<span class="bold"><strong>dump,daily</strong></span>
time="1330819200000000" local_ip="1.2.3.4" remote_ip="5.6.7.8"
    bytes="600"
time="1330905600000000" local_ip="1.2.3.5" remote_ip="5.6.7.9"
    bytes="200"</pre><p>
		Note that the order of the lines is completely nice and predictable,
		nothing goes out of order. Each nexus preserves the order of the rows
		put into it, and the fact that there is only one writer per nexus and
		that every thread is fed from only one nexus, avoids the races.
		</p><p>
		Let's look at the thread that performs the aggregation by the hour:
		</p><pre class="programlisting"># compute an hour-rounded timestamp (in microseconds)
sub hourStamp # (time)
{
  return $_[0]  - ($_[0] % (1000*1000*3600));
}

sub rawToHourlyT # (@opts)
{
  my $opts = {};
  Triceps::Opt::parse("traffic main", $opts, {
    @Triceps::Triead::opts,
    from =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
  }, @_);
  my $owner = $opts-&gt;{owner};
  my $unit = $owner-&gt;unit();

  # The current hour stamp that keeps being updated;
  # any aggregated data will be propagated when it is in the
  # current hour (to avoid the propagation of the aggregator clearing).
  my $currentHour;

  my $faIn = $owner-&gt;importNexus(
    from =&gt; $opts-&gt;{from},
    as =&gt; "input",
    import =&gt; "reader",
  );

  # the full stats for the recent time
  my $ttPackets = Triceps::TableType-&gt;new($faIn-&gt;getLabel("packet")-&gt;getRowType())
    -&gt;addSubIndex("byHour",
      Triceps::IndexType-&gt;newPerlSorted("byHour", undef, sub {
        return &amp;hourStamp($_[0]-&gt;get("time")) &lt;=&gt; &amp;hourStamp($_[1]-&gt;get("time"));
      })
      -&gt;addSubIndex("byIP",
        Triceps::IndexType-&gt;newHashed(key =&gt; [ "local_ip", "remote_ip" ])
        -&gt;addSubIndex("group",
          Triceps::IndexType-&gt;newFifo()
        )
      )
    )
  ;

  # type for a periodic summary, used for hourly, daily etc. updates
  my $rtSummary;

  Triceps::SimpleAggregator::make(
    tabType =&gt; $ttPackets,
    name =&gt; "hourly",
    idxPath =&gt; [ "byHour", "byIP", "group" ],
    result =&gt; [
      # time period's (here hour's) start timestamp, microseconds
      time =&gt; "int64", "last", sub {&amp;hourStamp($_[0]-&gt;get("time"));},
      local_ip =&gt; "string", "last", sub {$_[0]-&gt;get("local_ip");},
      remote_ip =&gt; "string", "last", sub {$_[0]-&gt;get("remote_ip");},
      # bytes sent in a time period, here an hour
      bytes =&gt; "int64", "sum", sub {$_[0]-&gt;get("bytes");},
    ],
    saveRowTypeTo =&gt; \$rtSummary,
  );

  $ttPackets-&gt;initialize();
  my $tPackets = $unit-&gt;makeTable($ttPackets, "tPackets");

  # Filter the aggregator output to match the current hour.
  my $lbHourlyFiltered = $unit-&gt;makeDummyLabel($rtSummary, "hourlyFiltered");
  $tPackets-&gt;getAggregatorLabel("hourly")-&gt;makeChained("hourlyFilter", undef, sub {
    if ($_[1]-&gt;getRow()-&gt;get("time") == $currentHour) {
      $unit-&gt;call($lbHourlyFiltered-&gt;adopt($_[1]));
    }
  });

  # update the notion of the current hour before the table
  $faIn-&gt;getLabel("packet")-&gt;makeChained("processPackets", undef, sub {
    my $row = $_[1]-&gt;getRow();
    $currentHour = &amp;hourStamp($row-&gt;get("time"));
    # skip the timestamp updates without data
    if (defined $row-&gt;get("bytes")) {
      $unit-&gt;call($tPackets-&gt;getInputLabel()-&gt;adopt($_[1]));
    }
  });

  # The makeNexus default option chainFront =&gt; 1 will make
  # sure that the pass-through data propagates first, before the
  # processed data.
  my $faOut = $owner-&gt;makeNexus(
    name =&gt; "data",
    labels =&gt; [
      $faIn-&gt;getFnReturn()-&gt;getLabelHash(),
      hourly =&gt; $lbHourlyFiltered,
    ],
    import =&gt; "writer",
  );

  my $lbPrint = $faOut-&gt;getLabel("print");

  # the dump request processing
  $tPackets-&gt;getDumpLabel()-&gt;makeChained("printDump", undef, sub {
    $unit-&gt;makeArrayCall($lbPrint, "OP_INSERT", $_[1]-&gt;getRow()-&gt;printP() . "\n");
  });
  $faIn-&gt;getLabel("dumprq")-&gt;makeChained("dump", undef, sub {
    if ($_[1]-&gt;getRow()-&gt;get("what") eq "packets") {
      $tPackets-&gt;dumpAll();
    }
  });

  $owner-&gt;readyReady();
  $owner-&gt;mainLoop(); # all driven by the reader
}</pre><p>
		This function inherits the options from <code class="computeroutput">Triead::start()</code> as usual and
		adds the option <span class="quote">&#8220;<span class="quote">from</span>&#8221;</span> of its own. This option's value is then used as
		the name of nexus to import for reading. The row types of the labels
		from that imported facet are then used to create the table and
		aggregation.
		</p><p>
		The table and aggregation themselves are the same as in
		<a class="xref" href="#sc_time_periodic" title="13.2. Periodic updates">Section 13.2: &#8220;Periodic updates&#8221; </a>,
		so I won't go into much detail describing them.  The only big change is
		the use of SimpleAggergator instead of a manually-built one.  The
		filter logic allows to delete the old raw data without propagation of
		the aggregation changes caused by it.
		</p><p>
		Then the output nexus is created. The creation passes through all the
		incoming data, short-circuiting the input and output, and adds the
		extra label for the aggregated output. The call
		<code class="computeroutput">$faIn-&gt;getFnReturn()-&gt;getLabelHash()</code> pulls all the labels
		and their names from the input facet, convenient for passing the
		data directly through to the output.  Just like an FnReturn,
		the Facet construction with <code class="computeroutput">makeNexus()</code> has the option
		<span class="quote">&#8220;<span class="quote">chainFront</span>&#8221;</span> set to 1 by default, and thus when it chains
		the labels from the pass-through ones, they are chained on the front.
		This works very nicely: this way the input data passes through first
		and only then the input goes to the computational labels and produces
		the results that follow it into the output facet.
		</p><p>
		The table dump is implemented after the output facet is defined because
		it needs the print label from that facet to send the results to.
		That print label ends up with two sources of datra for it. One is
		the eponymous label from the input facet, that passes the print
		requests from the previous stage of the pipeline. Another one is the
		table dump logic from this thread. Both are fine and can be mixed
		together.
		</p><p>
		And after that it's all usual <code class="computeroutput">readyReady()</code> and <code class="computeroutput">mainLoop()</code>.
		</p><p>
		The <code class="computeroutput">hourlyToDailyT()</code> is very similar, so I won't even show it here, you can
		find the full text in the sources.
		</p></div><div class="sect1" title="16.4. Object passing between threads"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_objects"></a>16.4. Object passing between threads</h2></div></div></div><a class="indexterm" name="id547553"></a><a class="indexterm" name="id547563"></a><p>
		A limitation of the Perl threads is that no variables can be shared
		between them. Well, there are the special shared variables but
		they're are very special and have great many limitations on their own.
		When a new thread gets created, it gets a copy of all the
		variables of the parent. That is, of all the plain Perl variables. With
		the XS extensions your luck may vary: the variables might get copied,
		might become undefined, or just become broken (if the XS module is not
		threads-aware). Copying the XS variables requires a quite high overhead
		at all the other times, so Triceps doesn't do it and all the Triceps
		object become undefined in the new thread.
		</p><p>
		This model of behavior for a package is marked by creating the
		method <code class="computeroutput">CLONE_SKIP</code> in it:
		</p><pre class="programlisting">sub CLONE_SKIP { 1; }</pre><p>
		All the Triceps packages define it, and it's the best practice to
		define it in your packages as well.
		</p><p>
		However the threads are useless without communication, and
		Triceps provides a way to pass around certain objects through the
		Nexuses.
		</p><a class="indexterm" name="id547606"></a><a class="indexterm" name="id547616"></a><a class="indexterm" name="id547626"></a><p>
		First, obviously, the Nexuses are intended to pass through the Rowops.
		These Rowops coming out of a nexus are not the same Rowop objects that
		went in. Rowop is a single-threaded object and can not be shared by two
		threads. Instead it gets converted to an internal form while in the
		nexus, and gets re-created when it comes out, pointing to the same Row object and to the
		correct Label in the local Facet.
		</p><p>
		Then, again obviously, the Facets get imported to the other threads
		as an interface of the Nexus, together with their row types.
		</p><a class="indexterm" name="id547648"></a><a class="indexterm" name="id547657"></a><p>
		And two more types of objects can be exported through a Nexus: the
		RowTypes and TableTypes. They get exported through the options as in
		this example:
		</p><pre class="programlisting">$fa = $owner-&gt;makeNexus(
    name =&gt; "nx1",
    labels =&gt; [
        one =&gt; $rt1,
        two =&gt; $lb,
    ],
    rowTypes =&gt; [
        one =&gt; $rt2,
        two =&gt; $rt1,
    ],
    tableTypes =&gt; [
        one =&gt; $tt1,
        two =&gt; $tt2,
    ],
    import =&gt; "writer",
);</pre><p>
		As you can see, the namespaces for the labels, row types and table
		types are completely independent, and the same names can be reused in
		each of them for different meaning. All the three sections are
		optional, so if you want, you can export only the types in the nexus,
		without any labels.
		</p><p>
		They can then be extracted from the imported facet as:
		</p><pre class="programlisting">$rt1 = $fa-&gt;impRowType("one");
$tt1 = $fa-&gt;impTableType("one");</pre><p>
		Or the whole set of name-value pairs can be obtained with:
		</p><pre class="programlisting">@rtset = $fa-&gt;impRowTypesHash();
@ttset = $fa-&gt;impTableTypesHash();</pre><p>
		The exact table types and row types (by themselves or in the table
		types or labels) in the importing thread will be copied. It's
		technically possible to share the references to the same row type
		from multiple threads in
		the C++ code but it's more efficient to make a separate copy for each
		thread, and thus the Perl API goes along the more efficient way.
		</p><p>
		The import is smart in the sense that it preserves the sameness of the
		row types: if in the exporting thread the same row type was referred
		from multiple places in the <code class="computeroutput">labels</code>, <code class="computeroutput">rowTypes</code> and <code class="computeroutput">tableTypes</code> sections,
		in the imported facet that would again be the same row type object (even
		though of course not the one that has been exported but its copy). This
		again helps with the efficiency when various objects decide if the rows
		created by this and that type are matching.
		</p><a class="indexterm" name="id547739"></a><p>
		This is all well until you want to export a table type that has an
		index with a Perl sort condition in it, or an aggregator with the Perl
		code. The Perl code objects are tricky: they get copied OK when a new
		thread is created but the attempts to import them through a nexus later
		cause a terrible memory corruption. So Triceps doesn't allow to export
		the table types with the function references in them. 
		But it provides an
		alternative solution: the code snippets can be specified as the source
		code, as described in
		<a class="xref" href="#sc_code" title="4.4. Code references and snippets">Section 4.4: &#8220;Code references and snippets&#8221; </a>. 
		They get compiled when the table type gets initialized. When a
		table type gets imported through a nexus, it brings the source code
		with it. The imported table types are always uninitialized, so at
		initialization time the source code gets compiled in the new thread and
		works.
		</p><p>
		It all works transparently: just specify a string instead of a function
		reference when creating the index, and it will be recognized and
		processed. For example:
		</p><pre class="programlisting">$it= Triceps::IndexType-&gt;newPerlSorted("b_c", undef, '
    my $res = ($_[0]-&gt;get("b") &lt;=&gt; $_[1]-&gt;get("b")
        || $_[0]-&gt;get("c") &lt;=&gt; $_[1]-&gt;get("c"));
    return $res;
    '
);</pre><p>
		Before the code gets compiled, it gets wrapped into a <code class="computeroutput">sub { ... }</code>, so
		don't write your own <code class="computeroutput">sub</code> in the code string, that would be an error.
		</p><p>
		To recap the differences between the code references and the
		source code snippets format:
		</p><p>
		When you compile a function, it carries with it the lexical context. So
		you can make the closures that refer to the <span class="quote">&#8220;<span class="quote">my</span>&#8221;</span> variables in their
		lexical scope. With the source code you can't do this. The table type
		compiles them at initialization time in the context of the main
		package, and that's all they can see. Remember also that the global
		variables are not shared between the threads, so if you refer to a
		global variable in the code snippet and rely on a value in that
		variable, it won't be present in the other threads (unless the other
		threads are direct descendants and the value was set before their
		creation).
		</p><p>
		There is also the issue of arguments that can be specified for these
		functions. Triceps is smart enough to handle the arguments that are
		one of:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">undef</code></li><li class="listitem">
			integer
			</li><li class="listitem">
			floating-point
			</li><li class="listitem">
			string
			</li><li class="listitem">
			Triceps::RowType object
			</li><li class="listitem">
			Triceps::Row object
			</li><li class="listitem">
			reference to an array or hash thereof
			</li></ul></div><p>
		It converts the data to an internal C++ representation in the nexus and
		then converts it back on import. So, if a TableType has all the code in
		it in the source form, and the arguments for this code within the
		limits of this format, it can be exported through the nexus. Otherwise
		an attempt to export it will fail.
		</p><a class="indexterm" name="id547859"></a><a class="indexterm" name="id547869"></a><p>
		The SimpleOrderedIndex uses the source code format for the
		functions it generates, so they will pass through the nexuses.
		And if you specify the aggregator functions as code snippets, you
		can export the table types with them through the nexuses too.
		</p><a class="indexterm" name="id547884"></a><p>
		However things didn't work out so well for the SimpleAggregator.
		I've found that I can't just do it within the current aggregation
		infrastructure. As mentioned in
		<a class="xref" href="#sc_aggregation_optimized" title="11.5. Optimized DELETEs">Section 11.5: &#8220;Optimized DELETEs&#8221; </a>,
		the aggregators don't have the same kind of initialization function
		as indexes (one that would run at the table type initialization
		time), and that becomes the deal-breaker. 
		</p><p>
		Fortunately, some thinking had showed that this feature is not really
		needed. There usually just isn't any need to export a table type with
		aggregators. 
		So it's a nice feature to have overall but not urgent.
		Moreover, there is a need to export the table types with
		many elements stripped. 
		</p><p>
		What is to be stripped and why?
		The most central part of the table type is its primary index. It
		defines how the data gets organized. And then the secondary indexes and
		aggregators perform the computations from the data in the table. The
		tables can not be shared between threads, and thus the way to copy a
		table between the threads is to export the table type and send the
		data, then let the other thread construct a copy of the table from that.
		But the table created in another thread really needs only the base data
		organization. If it does any computations on that data, that would be
		its own computations, different than the ones in the exporting thread.
		So all it needs to get is the basic table type with the primary index,
		very rarely some secondary indexes, and pretty much never the
		aggregators. The importing thread would then add its own secondary
		indexes and aggregators before initializing its table type and
		constructing the table from it.
		</p><p>
		The way to get such a stripped table type with only the fundamentally
		important parts is:
		</p><pre class="programlisting">$tabtype_fundamental = $tabtype-&gt;copyFundamental();</pre><p>
		That copies the row type and the primary index (the whole path to the
		first leaf index type) and leaves alone the rest. All the aggregators
		on all the indexes, even on the primary one, are not included in the
		copy. In the context of the full nexus, making it can look like:
		</p><pre class="programlisting">$facet = $owner-&gt;makeNexus(
    name =&gt; "data"
    labels =&gt; [ @labels ],
    tableTypes =&gt; [
         mytable =&gt; $mytable-&gt;getType()-&gt;copyFundamental(),
    ],
    import =&gt; "writer",
);</pre><p>
		In case if more index types need to be included, they can be specified
		by path in the arguments of <code class="computeroutput">copyFundamental()</code>:
		</p><pre class="programlisting">$tabtype_fundamental = $tabtype-&gt;copyFundamental(
    [ "byDate", "byAddress", "fifo" ],
    [ "byDate", "byPriority", "fifo" ],
);</pre><p>
		The paths may overlap, as shown here, and the matching subtrees will be
		copied correctly, still properly overlapping in the result. There is
		also a special syntax:
		</p><pre class="programlisting">$tabtype_fundamental = $tabtype-&gt;copyFundamental(
    [ "secondary", "+" ],
);</pre><p>
		The <code class="computeroutput">"+"</code> in the path means <span class="quote">&#8220;<span class="quote">do the path to the first leaf index of that
		subtree</span>&#8221;</span> and saves the necessity to write out the whole path.
		</p><p>
		Finally, what if you don't want to include the original primary index
		at all? You can use the string <code class="computeroutput">"NO_FIRST_LEAF"</code> as the first argument.
		That would skip it. You can still include it by using its explicit
		path, possibly at the other position.
		</p><p>
		For example, suppose that you have a table type with two top-level
		indexes, <span class="quote">&#8220;<span class="quote">first</span>&#8221;</span> is the primary index and <span class="quote">&#8220;<span class="quote">second</span>&#8221;</span> as secondary, and
		make a copy:
		</p><pre class="programlisting">$tabtype_fundamental = $tabtype-&gt;copyFundamental(
     "NO_FIRST_LEAF",
    [ "second", "+" ],
    [ "first", "+" ],
);</pre><p>
		In the copied table type the index <span class="quote">&#8220;<span class="quote">second</span>&#8221;</span> becomes primary and <span class="quote">&#8220;<span class="quote">first</span>&#8221;</span>
		secondary.
		</p><p>
		Another example of the table type exporting and of the table copying is
		shown in 
		<a class="xref" href="#sc_tql_join_internals" title="17.6. Internals of a TQL join">Section 17.6: &#8220;Internals of a TQL join&#8221; </a>.
		</p></div><div class="sect1" title="16.5. Threads and file descriptors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_files"></a>16.5. Threads and file descriptors</h2></div></div></div><a class="indexterm" name="id540990"></a><a class="indexterm" name="id540999"></a><a class="indexterm" name="id541009"></a><p>
		The interaction of the file descriptors (including sockets) with threads
		tends to be a somewhat thorny issue. The problems lie around the problem
		of geting a thread to  stop if it's stuck reading from a file descriptor.
		Triceps aims to be an one-stop shop for the threading solutions, so
		among other things it covers the interaction with the file descriptors.
		</p><a class="indexterm" name="id541025"></a><p>
		The overall approach is that whenever a thread opens a file, it should register
		that file with its TrieadOwner object. Then when the thread is requested
		to die, that file will be revoked, waking up the thread if it's waiting
		for that file descriptor. This is an operation that requires finesse,
		with multiple possibilities for the race conditions, but Triceps
		covers all the complexity and takes care of everything.
		</p><p>
		The registration of files with TrieadOwner is done with:
		</p><pre class="programlisting">$to-&gt;track(*FILE);
$to-&gt;track($socket);</pre><p>
		The form of the argument differs depending on whether it's a plain
		Perl file handle or if it's a file object, such as the one returned
		by the socket creation methods. The plain perl file handles have to be specified
		in a glob form, with <code class="computeroutput">*</code>.
		</p><p>
		To unregister the file and close it, use:
		</p><pre class="programlisting">$to-&gt;close(*FILE);
$to-&gt;close($socket);</pre><p>
		If you just want to unregister a file without closing it (not sure
		why would you want to do that, but why not), there is also a way:
		</p><pre class="programlisting">$to-&gt;forget(*FILE);
$to-&gt;forget($socket);</pre><p>
		And there also are the methods that do the registration with the
		plain file descriptors:
		</p><pre class="programlisting">$to-&gt;trackFd($fd);
$to-&gt;forgetFd($fd);</pre><p>
		The file descriptor methods underlie the file handle methods,
		a <code class="computeroutput">$to-&gt;trackFd(fileno(FILE));</code> is really an equivalent
		of <code class="computeroutput">$to-&gt;track(*FILE);</code>.
		</p><p>
		But wait, there is more. It's annoying to close the files manually,
		and easy to miss too (especially if the code might die within an
		<code class="computeroutput">eval</code>, with the file close sandwiched between them). 
		The scope-based file closing is much easier and more reliable: when
		you leave the scope, the file is guaranteed to get closed.
		Triceps provides the scope-based file handle management.
		Actuallly, if you use files-as-objects in Perl (in the form like
		<code class="computeroutput">$socket</code>), Perl already does the scope-based management,
		closing the file when the last reference to it disappears.
		But Triceps adds the automatic forgetting of the file in the
		TrieadOwner as well.  And it's very, very important to unregister
		the file descriptors before closing them, or the file descriptor
		corruption will result when the thread exits.
		A scope-based file is registered like this:
		</p><pre class="programlisting">$tf = $to-&gt;makeTrackedFile($file);</pre><a class="indexterm" name="id541140"></a><p>
		<code class="computeroutput">$tf</code> will contain a TrackedFile object that will control
		the life of the file tracking. <code class="computeroutput">$tf</code> contains its own reference
		to the file handle, so until <code class="computeroutput">$tf</code> is destroyed, the file
		handle will not be destroyed and thus will not be automatically closed.
		When <code class="computeroutput">$tf</code> goes out of scope and gets
		destroyed, it will unregister the file from TrieadOwner and then
		discard its reference to the file handle, letting Perl close it if all
		the references are gone. 
		To find the file handle from the TrackedFile, use:
		</p><pre class="programlisting">$file = $tf-&gt;get();</pre><p>
		It's also possible to close the file explicitly before <code class="computeroutput">$tf</code> goes
		out of scope:
		</p><pre class="programlisting">$tf-&gt;close();</pre><p>
		That will unregister the file and close it. And in this case close really
		means close: even if there are other references to the file handle, it will
		still get closed and could not be used through these other references any more
		either. After that, the final destruction of the TrackedFile object will have
		nothing to do.
		</p><a class="indexterm" name="id541209"></a><p>
		In the C++ API the file registration happens a bit differently, through a
		FileInterrupt object that keeps track of a set of file descriptors. Each
		trieadOwner object has a public field <code class="computeroutput">fileInterrupt_</code> of that
		class. There is no scoped unregistration in the C++ API yet, it should
		probably be added in the future. The Perl API actually also uses the
		FileInterrupt but with the high-level logic on top of it.
		</p><a class="indexterm" name="id541231"></a><a class="indexterm" name="id541241"></a><p>
		In case if you wonder what exactly happens with the file handle during the
		revocation, let me tell you. Overall it follows the approach described
		in my book [<a href="#Babkin10" class="biblioref" title="[Babkin10]">Babkin10</a>],
		with the system call <code class="computeroutput">dup2()</code> copying a
		descriptor of <code class="computeroutput">/dev/null</code> opened read-only over the target file descriptor.
		Perl's file handle keeps owning that file descriptor id but now
		with a different contents in it. However there is a problem with
		the plain <code class="computeroutput">dup2()</code>, it doesn't always interrupt the ongoing system call.  
		I've thought that on Linux it
		works reliably but then I've found that it works on the sockets but not
		on the pipes, and even with sockets the <code class="computeroutput">accept()</code> seems to ignore it.
		So I've found a better solution: use a <code class="computeroutput">dup2()</code> but then also
		send a signal (Triceps uses <code class="computeroutput">SIGUSR2</code>) to the target thread, which
		has a dummy handler of that signal to avoid killing the process.
		Even if <code class="computeroutput">dup2()</code> gets ignored by the
		current system call, the signal will get through and either make the ongoing system call return
		<code class="computeroutput">EINTR</code> to make the user code retry or cause a system call restart in the
		OS. In either case the new file descriptor copied by <code class="computeroutput">dup2()</code> will be
		discovered on the next attempt and cause the desired interruption. And
		unlike the signal used by itself, <code class="computeroutput">dup2()</code> closes the race window around
		the signal.
		</p><p>
		By the way, the Perl's <code class="computeroutput">threads::kill()</code> doesn't send a real signal, it
		just sets a flag for the interpreter. If you try it on your own, it
		won't interrupt the system calls, and now you know why. Instead Triceps
		gets the POSIX thread identity from the Perl thread and calls the
		honest <code class="computeroutput">ptherad_kill()</code> from the C++ code.
		</p><p>
		And another detour into the gritty details, what if the thread gets
		requested to die after the socket is opened but before it is tracked? 
		The answer is that the tracking enrollment will check whether
		the death request already happened, and if so, it will revoke the socket
		right away, before returning. So the reading loop will find the socket
		revoked right on its first iteration. It's one of these potential
		race conditions that Triceps prevents.
		</p><p>
		Now returning back to the high-level Perl API.
		As it turns out, Perl doesn't allow to pass the file descriptors between the
		threads. Well, you sort of can pass them as arguments to another thread
		but then it ends up printing the error messages like these and
		corrupting the reference counts:
		</p><pre class="programlisting">Unbalanced string table refcount: (1) for "GEN1" during global destruction.
Unbalanced string table refcount: (1) for "/usr/lib/perl5/5.10.0/Symbol.pm" during global destruction.
Scalars leaked: 1</pre><a class="indexterm" name="id541366"></a><p>
		If you try to pass a file descriptor through trheads::shared, it
		honestly won't allow you, while the thread arguments pretend that they
		can and then fail.
		</p><p>
		And it's something that is really needed, for more than one reason.
		If you write a TCP server, you typically have one thread accepting
		connections and then creating a new thread to handle each accepted
		socket. And the typical way to avoid polling on a socket is to have
		two threads handle it, one doing all the reading, another one
		doing all the writing. None of that works with Perl out of the box.
		Triceps comes to the rescue again, it gets done as follows:
		</p><pre class="programlisting"># in one thread
$to-&gt;app()-&gt;storeCloseFile($name, $socket);

#----------

# in another thread
my ($tf, $socket) = $to-&gt;trackGetFile($name, 'r+');</pre><p>
		The first thing that needs to be clarified here is that even though
		the variables <code class="computeroutput">$to</code> are named the same in both threads, they
		contain different TrieadOwner objects, each one belonging to its own thread.
		<code class="computeroutput">storeCloseFile()</code> stores a copy of the socket in the App object and
		then closes it in the local thread (the copy stays open). <code class="computeroutput">trackGetFile()</code> pulls the
		socket out of the App, registers it with the TrieadOwner and creates
		a TrackedFile scoped object for it, returning both the TrackedFile and
		the socket handle object. 
		</p><p>
		You can actually get the filehandle directly from the
		TrackedFile, as <code class="computeroutput">$tf-&gt;get()</code>, so why return the socket separately? As
		it turns out, Perl has issues with handling the Perl values stored
		inside the XS objects if they aren't referred by any Perl variables.
		Returning the file handle as a separate value prevents that.
		</p><p>
		The file opening mode still has to be specified
		as a <code class="computeroutput">trackGetFile()</code> argument because it can't be easily
		pulled out of the original file handle, and also because the other
		thread might want to use only a subset of the modes from the original.
		The mode can be specified in either of the fashions: 
		as <code class="computeroutput">r/w/a/r+/w+/a+</code> or <code class="computeroutput">&lt;/&gt;/&gt;&gt;/+&lt;/+&gt;/+&gt;&gt;</code>.
		</p><p>
		The <code class="computeroutput">$name</code> is a unique name by which
		this socket is known in the App, it has to be generated in some way
		to guarantee the uniqueness. But then the name is a plain string that
		can be passed between the threads, either as an argument at the thread
		creation time or in a Triceps Rowop going through a nexus.
		The whole procedure is easy, straightforward, and difficult to get wrong.
		</p><p>
		Let's look at more variations of the same. What if you want to pass
		a file handle to more than one thread? It's a typical case when a TCP
		server accepts a connection and wants to start the separate reader
		and writer threads on that socket.  One way is to simply pass it twice,
		with different names. For example:
		</p><pre class="programlisting"># in the acceptor thread
$to-&gt;app()-&gt;storeFile('name_r', $socket);
$to-&gt;app()-&gt;storeCloseFile('name_w', $socket);

#----------

# in the reader thread
my ($tf, $socket) = $to-&gt;trackGetFile('name_r', 'r');

#----------

# in the writer thread
my ($tf, $socket) = $to-&gt;trackGetFile('name_w', 'w');</pre><p>
		The <code class="computeroutput">storeFile()</code> in the acceptor stores a copy of the file
		descriptor but doesn't close the original. Which then gets closed after
		storing the second copy. Then two threads extract each its own copy.
		In this example each thread adds its own permission limitation on the
		extracted file handle, one reading, another one writing, even though the
		underlying socket is capable of both reading and writing.
		</p><p>
		Another way is possible if the threads are started sequentially, such as
		if the acceptor thread starts the reader thread, which in turn starts the
		writer thread. Then the reader thread can load the file handle without
		forgetting it in the App before starting the writer thread, and then
		the writer thread would get it and discard from the App:
		</p><pre class="programlisting"># in the acceptor thread
$to-&gt;app()-&gt;storeCloseFile('name', $socket);
// ... start the reader thread

#----------

# in the reader thread
my ($tf, $socket) = $to-&gt;trackDupFile('name', 'r');
// ... start the writer thread

#----------

# in the writer thread
my ($tf, $socket) = $to-&gt;trackGetFile('name', 'w');</pre><p>
		Yet another way is to store the file once and load into
		each thread without forgetting, but then have the storing thread close
		the copy stored in the App
		after all the loading threads have completed the initialization.
		For example:
		</p><pre class="programlisting"># in the acceptor thread
$to-&gt;app()-&gt;storeCloseFile('name', $socket);
// ... start the reader thread
// ... start the writer thread

$to-&gt;readyReady(); // wait for all threads to initialize
$to-&gt;app()-&gt;closeFd('name');

#----------

# in the reader thread
my ($tf, $socket) = $to-&gt;trackDupFile('name', 'r');
$to-&gt;readyReady();

#----------

# in the writer thread
my ($tf, $socket) = $to-&gt;trackDupFile('name', 'w');
$to-&gt;readyReady();</pre><p>
		In the acceptor thread, <code class="computeroutput">readyReady()</code> doesn't mark
		the acceptor thread as ready, because it already is, but simply waits
		for all other threads to become ready. And the reader and writer threads
		report that they are ready only after they have copied the file handle
		out of the App. This approach is used, for example, in Triceps::X::ThreadedClient.
		It would not be so great in a server because generally we want the
		server to accept the connections as fast as possible, without waiting
		for each connection's threads to initialize. But it's fine for a client.
		</p><p>
		The App's copy of the file is closed by <code class="computeroutput">closeFd()</code>. 
		It's an Fd and not a File because the App really stores the OS file
		descriptors, not the Perl file handles, and the File handling is
		done as wrappers on top of it. If you really want, you can deal with the
		raw file descriptors in the App, with the methods described in
		<a class="xref" href="#sc_ref_app" title="19.20. App reference">Section 19.20: &#8220;App reference&#8221; </a>
		and
		<a class="xref" href="#sc_cpp_triead_owner" title="20.37. TrieadOwner reference">Section 20.37: &#8220;TrieadOwner reference&#8221; </a>.
		But dealing directly with the Perl file handles is much more convenient.
		</p></div><div class="sect1" title="16.6. Dynamic threads and fragments in a socket server"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_dynamic_server"></a>16.6. Dynamic threads and fragments in a socket server</h2></div></div></div><a class="indexterm" name="id541575"></a><a class="indexterm" name="id541585"></a><p>
		The threads can be used to run a TCP server that
		accepts the connections and then starts the new client communication
		thread(s) for each connection.  This thread can then communicate with
		the rest of the model, feeding and receiving data, as usual, through
		the nexuses.
		</p><p>
		The challenge here is that there must be a way to create the threads
		dynamically, and later when the client closes connection, to dispose of
		them. There are two possible general approaches:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Dynamically create and delete the threads in the same App;
			</li><li class="listitem">
			Create a new App per connection and connect it to the main App.
			</li></ul></div><p>
		Both have their own advantages and difficulties, but the approach with
		the dynamic creation and deletion of threads ended up looking easier,
		and that's what Triceps has. The second approach is not particularly
		well supported yet. You can create multiple Apps in one program, and
		you can connect them by making two Triceps Trieads run in the same OS
		thread and ferry the data around. But it's extremely cumbersome. This
		will be improved in the future, but for now the first approach is the
		ticket.
		</p><a class="indexterm" name="id541626"></a><p>
		The dynamically created threads are grouped into the fragments. This is
		done by specifying the fragment name option when creating a thread. The
		threads in a fragment have a few special properties.
		</p><p>
		One, it's possible to shut down (i.e. request to die) the whole fragment in one fell swoop.
		There is no user-accessible way to shut down the individual threads,
		you can shut down either the whole App or a fragment. Shutting down
		individual threads is dangerous, since it can mess up the application
		in many non-obvious ways. But shutting down a fragment is OK, since the
		fragment serves a single logical function, such as servicing one TCP
		connection, and it's OK to shut down the whole logical function.
		</p><p>
		Two, when a thread in the fragment exits, it's really gone, and takes
		all its nexuses with it. Well, technically, the nexuses continue to
		exist and work as long as there are threads connected to them, but no new
		connections can be created after this point. Since usually the whole
		fragment will be gone together, and since the nexuses defined by the
		fragment's thread are normally used only by the other threads of the
		same fragment, a fragment shutdown cleans up its state like the
		fragment had never existed. By contrast, when a normal thread exists,
		the nexuses defined by it stay present and accessible until the App
		shuts down.
		</p><a class="indexterm" name="id541658"></a><p>
		To show how all this stuff works, I've created an example of a <span class="quote">&#8220;<span class="quote">chat
		server</span>&#8221;</span>. It's not really a human-oriented chat, it's more of a
		machine-oriented publish-subscribe, and specially tilted to work
		through the running of a socket server with threads.
		</p><p>
		In this case the core logic is absolutely empty. All there is of it, is
		a nexus that passes messages through. The clients read from this
		nexus to get the messages, and write to this nexus to send the
		messages.
		</p><p>
		When the App starts, it has only one thread, the listener thread that
		listens on a socket for the incoming connections. The listener doesn't
		even care about the common nexus and doesn't import it. When a
		connection comes in, the listener creates two threads to serve it: the
		reader reads the socket and sends to the nexus, and the writer receives
		from the nexus and writes to the socket. These two threads constitute a
		fragment for this client. They also create their own private nexus,
		allowing the reader to send control messages to the writer. That could
		also have been done through the central common nexus, but I wanted to
		show that there are different ways of doing things.
		</p><p>
		With a couple of clients connected, threads and sockets start looking
		as shown in
		<a class="xref" href="#fig_mt_chat" title="Figure 16.2. Chat server internal structure.">Figure 16.2</a>.
		And the listener thread still stays on the side.
		</p><div class="figure"><a name="fig_mt_chat"></a><div class="figure-contents"><div><img src="thread-020-chat.lowres.png" width="NaN" alt="Chat server internal structure."></div></div><p class="title"><b>Figure 16.2. Chat server internal structure.</b></p></div><br class="figure-break"><p>
		Now let's look at the code, located in <code class="computeroutput">t/xChatMt.t</code>.
		Let's start with the top-level: how the server gets started. It's
		really the last part of the code, that brings everything together.
		</p><p>
		It uses the ThreadedServer infrastructure:
		</p><pre class="programlisting">use Triceps::X::ThreadedServer qw(printOrShut);</pre><a class="indexterm" name="id541752"></a><p>
		The X subdirectory is for the examples and experimental stuff, but the
		ThreadedServer is really of production quality, I just haven't written
		a whole set of tests for it yet.
		</p><p>
		The server gets started like this:
		</p><pre class="programlisting">my ($port, $pid) = Triceps::X::ThreadedServer::startServer(
    app =&gt; "chat",
    main =&gt; \&amp;listenerT,
    port =&gt; 0,
    fork =&gt; 1,
);</pre><p>
		The port option of 0 means <span class="quote">&#8220;<span class="quote">pick any free port</span>&#8221;</span>, it will be returned as
		the result.  If you know the fixed port number in advance, use it.
		<span class="quote">&#8220;<span class="quote">chat</span>&#8221;</span> will be the name of the App, and <code class="computeroutput">listenerT</code> is the main function
		of the thread that will listen for the incoming connections and start
		the other threads. And it's also the first thread that gets started, so
		it's responsible for creating the core part of the App as well (though
		in this case there is not a whole lot of it).
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">fork</span>&#8221;</span> determines how and whether the server gets started in
		the background. The value 1 means that a new process will be forked,
		and then the threads will be created there. The returned PID can be
		used to wait for that process to complete:
		</p><pre class="programlisting">waitpid($pid, 0);</pre><p>
		Of course, if you're starting a daemon, you'd probably write this PID
		to a file and then just exit the parent process.
		</p><p>
		The fork value of 0 starts the server in the current process, and the
		current thread becomes the App's harvester thread (the one that
		joins the other threads when the App shuts down).
		</p><p>
		In this case the server doesn't return until it's done, so there is not
		much point in the returned port value, by that time the socket will be
		already closed. In this case you really need to either use a fixed port
		or write the port number to a file from your listener thread. The PID
		also doesn't make sense, and it's returned as <code class="computeroutput">undef</code>. Here is an example
		of this kind of call:
		</p><pre class="programlisting">my ($port, $pid) = Triceps::X::ThreadedServer::startServer(
    app =&gt; "chat",
    main =&gt; \&amp;listenerT,
    port =&gt; 12345,
    fork =&gt; 0,
);</pre><p>
		Finally, the server can be started in the current process, with a new
		thread created as the App's harvester thread, setting the <span class="quote">&#8220;<span class="quote">fork</span>&#8221;</span> option 
		to -1. The
		original thread can then continue and do other things in parallel. It's
		the way I use for the unit tests.
		</p><pre class="programlisting">my ($port, $thread) = Triceps::X::ThreadedServer::startServer(
    app =&gt; "chat",
    main =&gt; \&amp;listenerT,
    port =&gt; 0,
    fork =&gt; -1,
);</pre><p>
		In this case the second value returned is not a PID but the Perl thread
		object for the harvester thread. You should either detach it or
		eventually join it:
		</p><pre class="programlisting">$thread-&gt;join();</pre><a class="indexterm" name="id541877"></a><p>
		Perl propagates the errors in the threads through the <code class="computeroutput">join()</code>, so if the
		harvester thread dies, that would show only in the <code class="computeroutput">join()</code> call. And
		since Triceps propagates the errors too, any other App's thread dying will
		cause the harvester thread to die after it shuts down and joins all the App's threads. 
		So if there are any errors in the application, it will die and you will know
		it right away, and not left wondering why does the application appear to run but
		not work right. Unless, of course, you wrap the whole thing in an <code class="computeroutput">eval</code>,
		then you get the error message and the clean state, and can try running another App.
		</p><p>
		The listener thread is:
		</p><pre class="programlisting">sub listenerT
{
  my $opts = {};
  &amp;Triceps::Opt::parse("listenerT", $opts, {@Triceps::Triead::opts,
    socketName =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
  }, @_);
  undef @_;
  my $owner = $opts-&gt;{owner};

  my ($tsock, $sock) = $owner-&gt;trackGetFile($opts-&gt;{socketName}, "+&lt;");

  # a chat text message
  my $rtMsg = Triceps::RowType-&gt;new(
    topic =&gt; "string",
    msg =&gt; "string",
  );

  # a control message between the reader and writer threads
  my $rtCtl = Triceps::RowType-&gt;new(
    cmd =&gt; "string", # the command to execute
    arg =&gt; "string", # the command argument
  );

  $owner-&gt;makeNexus(
    name =&gt; "chat",
    labels =&gt; [
      msg =&gt; $rtMsg,
    ],
    rowTypes =&gt; [
      ctl =&gt; $rtCtl,
    ],
    import =&gt; "none",
  );

  $owner-&gt;readyReady();

  Triceps::X::ThreadedServer::listen(
    owner =&gt; $owner,
    socket =&gt; $sock,
    prefix =&gt; "cliconn",
    handler =&gt; \&amp;chatSockReadT,
  );
}</pre><p>
		It gets the usual options of the thread start (and as usual you can
		pass more options to the <code class="computeroutput">startServer()</code> and they will make their way to
		the listener thread. But there is also one more option added by
		<code class="computeroutput">startServer()</code>: <span class="quote">&#8220;<span class="quote">socketName</span>&#8221;</span>.
		</p><p>
		As described in
		<a class="xref" href="#sc_mt_files" title="16.5. Threads and file descriptors">Section 16.5: &#8220;Threads and file descriptors&#8221; </a>,
		since the the socket objects can't be passed directly between the
		threads, a roundabout way is taken. After <code class="computeroutput">startServer()</code> opens a socket,
		it stores the dupped file descriptor in the App with a unique name and passes that name
		through, so that it can be used to load the socket back
		into the listener thread:
		</p><pre class="programlisting">my ($tsock, $sock) = $owner-&gt;trackGetFile($opts-&gt;{socketName}, "+&lt;");</pre><p>
		This does multiple things:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Loads the file descriptor from the App by name (with a <code class="computeroutput">dup()</code>).
			</li><li class="listitem">
			Opens a Perl socket object from that file descriptor.
			</li><li class="listitem">
			Registers that file descriptor for tracking with the TrieadOwner,
			so that if the thread needs to be shut down, that descriptor will
			be revoked and any further operations with it will fail.
			</li><li class="listitem">
			Creates a TrackedFile object that will automatically unregister the
			file descriptor from TrieadOwner when the TrackedFile goes out of
			scope. This is important to avoid that races between the revocation
			and the normal close of the file.
			</li><li class="listitem">
			Makes the App close and forget its file descriptor.
			</li></ul></div><p>
		The <code class="computeroutput">$tsock</code> returned is a TrackedFile object, and <code class="computeroutput">$sock</code> is the socket
		filehandle.
		</p><p>
		The listener thread then creates the row types for the data messages
		and for the control messages between the client's reader and writer
		threads, and makes a nexus. The listener is not interested in the data,
		so it doesn't even import this nexus itself. The nexus passes the data
		only, so it has no label for the control messages, only the row type.
		</p><p>
		Then the mandatory <code class="computeroutput">readyReady()</code>, and then the control goes again to the
		library that accepts the connections and starts the client connection
		threads. The handler is the main function for the thread that gets
		started to handle the connection. The prefix is used to build the names
		for the new thread, for its fragment, and for the connection socket
		that gets also passed through by storing it in the App. The name is the
		same for all three and gets created by concatenating the prefix with a
		number that gets increased for every connection, to keep it unique. The newly created
		thread will then get the option <span class="quote">&#8220;<span class="quote">socketName</span>&#8221;</span> with the name of the socket.
		</p><p>
		How does the <code class="computeroutput">ThreadedServer::listen()</code> know when to return? It runs until the
		App gets shut down, and returns only when the thread is requested to
		die as a result of the shutdown. 
		</p><p>
		As described before, each socket gets served by two threads: one runs
		reading from the socket and forwards the data into the model and
		another one runs getting data from the model and forwards it into the
		socket. Since the same thread can't wait for both a socket descriptor
		and a thread synchronization primitive, they have to be separate.
		</p><p>
		The first thread started for a connection by the listener is the socket
		reader. Let's go through it bit by bit.
		</p><pre class="programlisting">sub chatSockReadT
{
  my $opts = {};
  &amp;Triceps::Opt::parse("chatSockReadT", $opts, {@Triceps::Triead::opts,
    socketName =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
  }, @_);
  undef @_; # avoids a leak in threads module
  my $owner = $opts-&gt;{owner};
  my $app = $owner-&gt;app();
  my $unit = $owner-&gt;unit();
  my $tname = $opts-&gt;{thread};

  # only dup the socket, the writer thread will consume it
  my ($tsock, $sock) = $owner-&gt;trackDupFile($opts-&gt;{socketName}, "&lt;");</pre><p>
		The beginning is quite usual. Then it loads the socket from the App and
		gets it tracked with the TrieadOwner. The listener passes the name
		under which it stored the socket in the App as the option
		<span class="quote">&#8220;<span class="quote">socketName</span>&#8221;</span>.
		<code class="computeroutput">trackDupSocket()</code> leaves the socket instance in the App, to be found by the
		writer-side thread.
		</p><p>
		The socket is loaded in this thread as read-only. The writing to the
		socket from all the threads has to be synchronized to avoid mixing the
		half-messages. And the easiest way to synchronize is to always write
		from one thread; if the other thread wants to write something, it
		has to pass the data to the writer thread through the control nexus.
		</p><pre class="programlisting">  # user messages will be sent here
  my $faChat = $owner-&gt;importNexus(
    from =&gt; "global/chat",
    import =&gt; "writer",
  );

  # control messages to the reader side will be sent here
  my $faCtl = $owner-&gt;makeNexus(
    name =&gt; "ctl",
    labels =&gt; [
      ctl =&gt; $faChat-&gt;impRowType("ctl"),
    ],
    reverse =&gt; 1, # gives this nexus a high priority
    import =&gt; "writer",
  );</pre><p>
		Imports the chat nexus and creates the private control nexus for
		communication with the writer side. The name of the chat nexus is
		hardcoded here, since it's pretty much a solid part of the application.
		If this were a module, the name of the chat nexus could be passed
		through the options.
		</p><a class="indexterm" name="id542133"></a><p>
		The control nexus is marked as reverse even though it really isn't. But
		the reverse option has a side effect of making this nexus
		high-priority. Even if the writer thread has a long queue of messages
		from the chat nexus, the messages from the control nexus will be read
		first. Which again isn't strictly necessary here, but I wanted to show
		how it's done.
		</p><p>
		The type of the control label is imported from the chat nexus, so it
		doesn't have to be defined from scratch.
		</p><pre class="programlisting">  $owner-&gt;markConstructed();

  Triceps::Triead::start(
    app =&gt; $opts-&gt;{app},
    thread =&gt; "$tname.rd",
    fragment =&gt; $opts-&gt;{fragment},
    main =&gt; \&amp;chatSockWriteT,
    socketName =&gt; $opts-&gt;{socketName},
    ctlFrom =&gt; "$tname/ctl",
  );

  $owner-&gt;readyReady();</pre><a class="indexterm" name="id542168"></a><a class="indexterm" name="id542178"></a><p>
		Then the construction is done and the writer thread gets started.  And
		then the thread becomes ready and waits for the writer thread to be ready
		too. The <code class="computeroutput">readyReady()</code> works in the fragments just as it does at the
		start of the App. Whenever a new thread is started, the App becomes not
		ready, and stays this way until all the threads report that they are
		ready. The rest of the App keeps working like nothing happened, at
		least sort of. Whenever a nexus is imported, the messages from this
		nexus start collecting for this thread, and if there are many of them,
		the nexus will become backed up and the threads writing to it will
		block. The new threads have to call <code class="computeroutput">readyReady()</code> as usual to
		synchronize between themselves, and then everything gets on its way.
		</p><p>
		Of course, if two connections are received in a quick succession, that
		would start two sets of threads, and <code class="computeroutput">readyReady()</code> will continue only
		after all of them are ready. This is not very good but acceptable in most cases.
		</p><pre class="programlisting">  my $lbChat = $faChat-&gt;getLabel("msg");
  my $lbCtl = $faCtl-&gt;getLabel("ctl");

  $unit-&gt;makeHashCall($lbCtl, "OP_INSERT",
    cmd =&gt; "print", arg =&gt; "!ready," . $opts-&gt;{fragment});
  $owner-&gt;flushWriters();</pre><p>
		A couple of labels get remembered for the future use, and the
		connection ready message gets sent to the writer thread through the
		control nexus. By convention of this application, the messages go in
		the CSV format, with the control messages starting with <span class="quote">&#8220;<span class="quote">!</span>&#8221;</span>. If this is
		the first client, this would send
		</p><pre class="programlisting">!ready,cliconn1</pre><p>
		to the client. It's important to call <code class="computeroutput">flushWriters()</code> every time to get
		the message(s) delivered.
		</p><pre class="programlisting">  while(&lt;$sock&gt;) {
    s/[\r\n]+$//;
    my @data = split(/,/);
    if ($data[0] eq "exit") {
      last; # a special case, handle in this thread
    } elsif ($data[0] eq "kill") {
      eval {$app-&gt;shutdownFragment($data[1]);};
      if ($@) {
        $unit-&gt;makeHashCall($lbCtl, "OP_INSERT", cmd =&gt; "print", arg =&gt; "!error,$@");
        $owner-&gt;flushWriters();
      }
    } elsif ($data[0] eq "shutdown") {
      $unit-&gt;makeHashCall($lbChat, "OP_INSERT", topic =&gt; "*", msg =&gt; "server shutting down");
      $owner-&gt;flushWriters();
      Triceps::AutoDrain::makeShared($owner);
      eval {$app-&gt;shutdown();};
    } elsif ($data[0] eq "shutdown2") { # with the guarantee of the last word
      my $drain = Triceps::AutoDrain::makeExclusive($owner);
      $unit-&gt;makeHashCall($lbChat, "OP_INSERT", topic =&gt; "*", msg =&gt; "server shutting down");
      $owner-&gt;flushWriters();
      $drain-&gt;wait();
      eval {$app-&gt;shutdown();};
    } elsif ($data[0] eq "publish") {
      $unit-&gt;makeHashCall($lbChat, "OP_INSERT", topic =&gt; $data[1], msg =&gt; $data[2]);
      $owner-&gt;flushWriters();
    } else {
      # this is not something you want to do in a real chat application
      # but it's cute for a demonstration
      $unit-&gt;makeHashCall($lbCtl, "OP_INSERT", cmd =&gt; $data[0], arg =&gt; $data[1]);
      $owner-&gt;flushWriters();
    }
  }</pre><p>
		The main loop keeps reading lines from the socket and interpreting
		them. The lines are in CSV format, and the first field is the command
		and the rest are the arguments (if any).  The commands are:
		</p><div class="variablelist"><dl><dt><span class="term">publish</span></dt><dd><p>
				Send a message with a topic to the chat nexus.
				</p></dd><dt><span class="term">exit</span></dt><dd><p>
				Close the connection.
				</p></dd><dt><span class="term">kill</span></dt><dd><p>
				Close another connection, by name.
				</p></dd><dt><span class="term">shutdown</span></dt><dd><p>
				Shut down the server.
				</p></dd><dt><span class="term">subscribe</span></dt><dd><p>
				Subscribe the client to a topic.
				</p></dd><dt><span class="term">unsibscribe</span></dt><dd><p>
				Unsubscribe the client from a topic.
				</p></dd></dl></div><p>
		The <span class="quote">&#8220;<span class="quote">exit</span>&#8221;</span> just exits the loop, since it works the same as if the socket
		just gets closed from the other side.
		</p><p>
		The <span class="quote">&#8220;<span class="quote">kill</span>&#8221;</span> shuts down by name the fragment where the threads of the other
		connection belong. This is a simple application, so it doesn't check
		any permissions, whether this fragment should allowed to be shut down.
		If there is no such fragment, the shutdown call will silently do
		nothing, so the error check and reporting is really redundant (if
		something goes grossly wrong in the thread interruption code, an error
		might still occur, but theoretically this should never happen).
		</p><p>
		The <span class="quote">&#8220;<span class="quote">shutdown</span>&#8221;</span> sends the notification to the common topic <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span> (to which
		all the clients are subscribed by default), then drains the model and
		shuts it down. The drain makes sure that all the messages in the model
		get processed (and even written to the sockets) without allowing any new
		messages to be injected. <span class="quote">&#8220;<span class="quote">Shared</span>&#8221;</span> means that there is no special
		exceptions for some threads.
		</p><p>
		<code class="computeroutput">AutoDrain::makeShared()</code> actually creates a drain object that keeps the drain
		active during its lifetime. Here this object is not assigned anywhere,
		so it gets immediately destroyed and lifts the drain. So potentially
		more messages can get squeezed in between this point and shutdown.
		Which doesn't matter a whole lot here.
		</p><p>
		The command <span class="quote">&#8220;<span class="quote">shutdown2</span>&#8221;</span> shows the implementation for
		the case when it's really important that nothing get sent after the shutdown
		notification.
		</p><p>
		It starts the drain in the exclusive mode, which means that this
		thread is excluded from the drain and allowed to send more data. When the drain is created, it
		waits for success, so when the new message is inserted, it will be
		after all the other messages. <code class="computeroutput">$drain-&gt;wait()</code> does another wait and
		makes sure that this last message propagates all the way. And then the
		app gets shut down, while the drain is still in effect, so no more
		messages can be sent for sure.
		</p><p>
		The <span class="quote">&#8220;<span class="quote">publish</span>&#8221;</span> sends the data to the chat nexus (note the <code class="computeroutput">flushWriters()</code>,
		as usual!).
		</p><p>
		And the rest of commands (that would be <span class="quote">&#8220;<span class="quote">subscribe</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">unsubscribe</span>&#8221;</span> but
		you can do any other commands like <span class="quote">&#8220;<span class="quote">print</span>&#8221;</span>) get simply forwarded to the
		reader thread for execution. Sending through the commands like this
		without testing is not a good practice for a real application but it's
		cute for a demo.
		</p><pre class="programlisting">  {
    # let the data drain through
    my $drain = Triceps::AutoDrain::makeExclusive($owner);

    # send the notification - can do it because the drain is excluding itself
    $unit-&gt;makeHashCall($lbCtl, "OP_INSERT", cmd =&gt; "print", arg =&gt; "!exiting");
    $owner-&gt;flushWriters();

    $drain-&gt;wait(); # wait for the notification to drain

    $app-&gt;shutdownFragment($opts-&gt;{fragment});
  }

  $tsock-&gt;close(); # not strictly necessary
}</pre><p>
		The last part is when the connection get closed, either by the <span class="quote">&#8220;<span class="quote">exit</span>&#8221;</span>
		command or when the socket gets closed. Remember, the socket can get
		closed asymmetrically, in one direction, so even when the reading is
		closed, the writing may still work and needs to return the responses to
		any commands received from the socket. And of course the same is true
		for the <span class="quote">&#8220;<span class="quote">exit</span>&#8221;</span> command.
		</p><a class="indexterm" name="id542504"></a><p>
		So here the full exclusive drain sequence is used, ending with the
		shutdown of this thread's own fragment, which will close the socket.
		Even though only one fragment needs to be shut down, the drain drains
		the whole model. Because of the potentially complex interdependencies,
		there is no way to reliably drain only a part, and all the drains are
		App-wide.
		</p><p>
		The last part, with <code class="computeroutput">$tsock-&gt;close()</code>, is not technically necessary since
		the shutdown of the fragment will get the socket descriptor revoked
		anyway, and then the socket will get closed when the last reference to
		it disappears. But other than that, it's a good practice that unregisters the
		socket from the TrieadOwner and then closes it. 
		</p><p>
		The socket writer thread is the last part of the puzzle:
		</p><pre class="programlisting">sub chatSockWriteT
{
  my $opts = {};
  &amp;Triceps::Opt::parse("chatSockWriteT", $opts, {@Triceps::Triead::opts,
    socketName =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    ctlFrom =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
  }, @_);
  undef @_;
  my $owner = $opts-&gt;{owner};
  my $app = $owner-&gt;app();
  my $tname = $opts-&gt;{thread};

  my ($tsock, $sock) = $owner-&gt;trackGetFile($opts-&gt;{socketName}, "&gt;");

  my $faChat = $owner-&gt;importNexus(
    from =&gt; "global/chat",
    import =&gt; "reader",
  );

  my $faCtl = $owner-&gt;importNexus(
    from =&gt; $opts-&gt;{ctlFrom},
    import =&gt; "reader",
  );</pre><p>
		The usual preamble. The <code class="computeroutput">trackGetFile()</code> consumes the socket from the
		App, and this time reopens it for writing. The previously created
		nexuses are imported.
		</p><pre class="programlisting">  my %topics; # subscribed topics for this thread

  $faChat-&gt;getLabel("msg")-&gt;makeChained("lbMsg", undef, sub {
    my $row = $_[1]-&gt;getRow();
    my $topic = $row-&gt;get("topic");
    #printOrShut($app, $opts-&gt;{fragment}, $sock, "XXX got topic '$topic'\n");
    if ($topic eq "*" || exists $topics{$topic}) {
      printOrShut($app, $opts-&gt;{fragment}, $sock, $topic, ",", $row-&gt;get("msg"), "\n");
    }
  });</pre><p>
		The logic is defined as the connected labels. The topic hash keeps the
		keys that this thread is subscribed to. When a message is received from
		the chat nexus and the topic is in the hash or is <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span>, the message gets
		sent into the socket in the CSV format:
		</p><pre class="programlisting">topic,text</pre><p>
		The function <code class="computeroutput">printOrShut()</code> is imported from Triceps::X::ThreadedServer.
		Its first 3 arguments are fixed, and the rest are passed through to
		<code class="computeroutput">print()</code>. It prints the message to the socket file handle, flushes the
		socket, and in case of any errors it shuts down the fragment specified
		in its second argument. This way if the socket gets closed from the
		other side, the threads handling it automatically shut down.
		</p><pre class="programlisting">  $faCtl-&gt;getLabel("ctl")-&gt;makeChained("lbCtl", undef, sub {
    my $row = $_[1]-&gt;getRow();
    my ($cmd, $arg) = $row-&gt;toArray();
    if ($cmd eq "print") {
      printOrShut($app, $opts-&gt;{fragment}, $sock, $arg, "\n");
    } elsif ($cmd eq "subscribe") {
      $topics{$arg} = 1;
      printOrShut($app, $opts-&gt;{fragment}, $sock, "!subscribed,$arg\n");
    } elsif ($cmd eq "unsubscribe") {
      delete $topics{$arg};
      printOrShut($app, $opts-&gt;{fragment}, $sock, "!unsubscribed,$arg\n");
    } else {
      printOrShut($app, $opts-&gt;{fragment}, $sock, "!invalid command,$cmd,$arg\n");
    }
  });</pre><p>
		The handling of the control commands is pretty straightforward.
		</p><pre class="programlisting">  $owner-&gt;readyReady();

  $owner-&gt;mainLoop();

  $tsock-&gt;close(); # not strictly necessary
}</pre><p>
		And the rest is taken care of by the <code class="computeroutput">mainLoop()</code>. The thread's main loop
		runs until the thread gets shut down, by handling the incoming
		messages. So if say <code class="computeroutput">printOrShut()</code> decides to shut down the fragment,
		the next iteration of the loop will detect it and exit. 
		</p><p>
		And now a recorded log from a run. It has been produced with the automated
		testing infrastructure described in
		<a class="xref" href="#sc_mt_threaded_client" title="16.8. ThreadedClient, a Triceps Expect">Section 16.8: &#8220;ThreadedClient, a Triceps Expect&#8221; </a>.
		</p><p>
		As usual, the lines sent from the clients to the socket server are
		shown in bold. But since there are many clients, to tell them
		apart, both the sent and received lines are prefixed by the client's
		name and a <span class="quote">&#8220;<span class="quote">|</span>&#8221;</span>. I've just picked arbitrary client names to tell them
		apart.
		</p><p>
		I've also marked the incoming connection as <span class="quote">&#8220;<span class="quote"><span class="bold"><strong>connect client_name</strong></span></span>&#8221;</span>,
		the client's close of the socket for writing as <span class="quote">&#8220;<span class="quote"><span class="bold"><strong>close WR client_name</strong></span></span>&#8221;</span>,
		and the disconnections as <span class="quote">&#8220;<span class="quote">__EOF__</span>&#8221;</span> after the client name.
		</p><p>
		So, here we go.
		</p><pre class="programlisting"><span class="bold"><strong>connect c1</strong></span>
c1|!ready,cliconn1
<span class="bold"><strong>connect c2</strong></span>
c2|!ready,cliconn2</pre><p>
		Two clients connect.
		</p><pre class="programlisting"><span class="bold"><strong>c1|publish,*,zzzzzz</strong></span>
c1|*,zzzzzz
c2|*,zzzzzz</pre><p>
		A message published to the topic <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span> gets forwarded to all the
		connected clients. In reality the messages may of course be received on
		separate sockets in any order, but I've ordered them here for the ease
		of reading.
		</p><pre class="programlisting"><span class="bold"><strong>c2|garbage,trash</strong></span>
c2|!invalid command,garbage,trash</pre><p>
		An invalid command gets detected in the writer thread and responded as
		such.
		</p><pre class="programlisting"><span class="bold"><strong>c2|subscribe,A</strong></span>
c2|!subscribed,A
<span class="bold"><strong>c1|publish,A,xxx</strong></span>
c2|A,xxx</pre><p>
		A subscription request gets acknowledged, and after that all the
		messages sent to this topic get received by the client.
		</p><pre class="programlisting"><span class="bold"><strong>c1|subscribe,A</strong></span>
c1|!subscribed,A
<span class="bold"><strong>c1|publish,A,www</strong></span>
c1|A,www
c2|A,www</pre><p>
		If more than one client is subscribed to a topic, all of them get the messages.
		</p><pre class="programlisting"><span class="bold"><strong>c2|unsubscribe,A</strong></span>
c2|!unsubscribed,A
<span class="bold"><strong>c1|publish,A,vvv</strong></span>
c1|A,vvv</pre><p>
		The unsubscription makes the client stop receiving messages from this
		topic.
		</p><pre class="programlisting"><span class="bold"><strong>connect c3</strong></span>
c3|!ready,cliconn3
<span class="bold"><strong>c3|exit</strong></span>
c3|!exiting
c3|__EOF__</pre><p>
		The third client connects, immediately requests an exit, gets the
		confirmation and gets disconnected.
		</p><pre class="programlisting"><span class="bold"><strong>connect c4</strong></span>
c4|!ready,cliconn4
<span class="bold"><strong>close WR c4</strong></span>
c4|!exiting
c4|__EOF__</pre><p>
		The fourth client connects and then closes its write side of the socket
		(that is the read side for the server). It produces the same affect as
		the exit command.
		</p><pre class="programlisting"><span class="bold"><strong>c1|shutdown</strong></span>
c1|*,server shutting down
c1|__EOF__
c2|*,server shutting down
c2|__EOF__</pre><p>
		And the shutdown command sends the notifications to all the remaining
		clients and closes the connections. 
		</p></div><div class="sect1" title="16.7. ThreadedServer implementation, and the details of thread harvesting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_threaded_server"></a>16.7. ThreadedServer implementation, and the details of thread harvesting</h2></div></div></div><a class="indexterm" name="id542886"></a><a class="indexterm" name="id542895"></a><a class="indexterm" name="id542905"></a><p>
		And now I want to show the internals of the ThreadedServer methods. It
		shows how to store the socket file handles into the App, how the
		threads are harvested, and how the connections get accepted.
		The class is defined in <code class="computeroutput">lib/Triceps/X/ThreadedServer.pm</code>.
		It's of essentially production quality but misses the detailed set of
		tests yet, and thus for now is placed in the X subdirectory.
		</p><p>
		The most important method in it is <code class="computeroutput">startServer()</code>:
		</p><pre class="programlisting">sub startServer # ($optName =&gt; $optValue, ...)
{
  my $myname = "Triceps::X::ThreadedServer::startServer";
  my $opts = {};
  my @myOpts = (
    app =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    thread =&gt; [ "global", undef ],
    main =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "CODE") } ],
    port =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    socketName =&gt; [ undef, undef ],
    fork =&gt; [ 1, undef ],
  );
  &amp;Triceps::Opt::parse($myname, $opts, {
    @myOpts,
    '*' =&gt; [],
  }, @_);

  if (!defined $opts-&gt;{socketName}) {
    $opts-&gt;{socketName} = $opts-&gt;{thread} . ".listen";
  }

  my $srvsock = IO::Socket::INET-&gt;new(
    Proto =&gt; "tcp",
    LocalPort =&gt; $opts-&gt;{port},
    Listen =&gt; 10,
  ) or confess "$myname: socket creation failed: $!";
  my $port = $srvsock-&gt;sockport() or confess "$myname: sockport failed: $!";</pre><p>
		So far it's pretty standard: get the options and open the socket for
		listening.
		A slightly special thing is that it saves the list of supported
		options in the variable <code class="computeroutput">@myOpts</code> for the future use.
		That future use will be to pass the list of unknown options to the
		user thread, so the known options in <code class="computeroutput">@myOpts</code> will be removed
		from the list before passing it.
		<span class="quote">&#8220;<span class="quote">*</span>&#8221;</span> is the pass-through: it tells <code class="computeroutput">Opt::parse</code>
		to accept any options and gets all the unknown options collected in
		<code class="computeroutput">$opts-&gt;{"*"}</code>.
		</p><pre class="programlisting">  if ($opts-&gt;{fork} &gt; 0)  {
    my $pid = fork();
    confess "$myname: fork failed: $!" unless defined $pid;
    if ($pid) {
      # parent
      $srvsock-&gt;close();
      return ($port, $pid);
    }
    # for the child, fall through
  }</pre><p>
		This handles the process forking option: if forking is requested, it
		executes and then the parent process returns the PID while the child
		process continues with the rest of the logic. By the way, your success
		with forking a process that has multiple running threads may vary. The
		resulting process usually has one running thread (continuing where the
		thread that called <code class="computeroutput">fork()</code> was) but the synchronization primitives in
		the new process can be inherited in any state, so the attempts to
		continue the threaded processing are usually not such a good idea. It's
		usually best to fork first before there are more threads.
		</p><pre class="programlisting">  # make the app explicitly, to put the socket into it first
  my $app = Triceps::App::make($opts-&gt;{app});
  $app-&gt;storeCloseFile($opts-&gt;{socketName}, $srvsock);
  Triceps::Triead::start(
    app =&gt; $opts-&gt;{app},
    thread =&gt; $opts-&gt;{thread},
    main =&gt; $opts-&gt;{main},
    socketName =&gt; $opts-&gt;{socketName},
    &amp;Triceps::Opt::drop({ @myOpts }, \@_),
  );</pre><a class="indexterm" name="id555679"></a><p>
		Then the App gets created.  Previously I've shown starting the App
		with <code class="computeroutput">startHere()</code> that created the App, the first thread,
		and did a bunch of services implicitly. Here everything will be done manually. 
		</p><p>
		Triceps keeps a global list of all its Apps in the process, and after
		an App is created, it's placed into that list and can be found by name
		from any thread. The App object will exist while there are references
		to it, including the reference from that global list. On the other
		hand, it's possible to remove the App from the list while it's still
		running but that's a bad practice because it will break any attempts
		from its threads to find it by name.
		</p><p>
		So the App is made, then the file handle gets stored.  The listening socket
		has to be stored into the App before the listener thread gets started,
		so that the listener thread can find it.
		<code class="computeroutput">storeCloseFile()</code>
		gets the file descriptor from the socket, dups it, stores into the App,
		and then closes the original file handle, as explained before. 
		</p><p>
		Then the listener thread is started, and as shown before, it's
		responsible for starting all the other threads. It gets a set of
		fixed options plus all the unknown options that the user had specified.
		It will do the same trick with passing these unknown options to
		the thread that runs the user code and handles the accepted
		connections, such as <code class="computeroutput">readerT()</code> in 
		<a class="xref" href="#sc_mt_dynamic_server" title="16.6. Dynamic threads and fragments in a socket server">Section 16.6: &#8220;Dynamic threads and fragments in a socket server&#8221; </a>.
		In the meantime, the <code class="computeroutput">startServer()</code> continues:
		</p><pre class="programlisting">  my $tharvest;
  if ($opts-&gt;{fork} &lt; 0) {
    @_ = (); # prevent the Perl object leaks
    $tharvest = threads-&gt;create(sub {
      # In case of errors, the Perl's join() will transmit the error
      # message through.
      Triceps::App::find($_[0])-&gt;harvester();
    }, $opts-&gt;{app}); # app has to be passed by name
  } else {
    $app-&gt;harvester();
  }</pre><a class="indexterm" name="id555749"></a><p>
		The harvester logic is started. Each App must have its harvester.
		<code class="computeroutput">startHere()</code> runs the harvester implicitly, unless told otherwise, but
		if the App is created manually, the harvester has to be run manually. 
		It can be run either in this
		thread or in another thread, as determined by the ThreadedServer option 
		<span class="quote">&#8220;<span class="quote">fork</span>&#8221;</span>. 
		</p><p>
		If the option <span class="quote">&#8220;<span class="quote">fork</span>&#8221;</span> is 0, the server just runs the harvester in the
		current process and thread. If the option <span class="quote">&#8220;<span class="quote">fork</span>&#8221;</span> is 1, the server
		runs in the first thread of the child process, and if the code got to this
		point, it would be running now in the child process. So these two cases
		are handled together and for them the harvester just starts in the current thread
		with <code class="computeroutput">$app-&gt;harvester();</code> and returns after the App shuts down.
		</p><p>
		If the option <span class="quote">&#8220;<span class="quote">fork</span>&#8221;</span> is -1, it requires that the harvester is to
		be started in another newly created thread.
		<code class="computeroutput">$tharvest</code> will contain that thread's
		identity. A special thing about starting threads with <code class="computeroutput">threads-&gt;create()</code>
		is that it's sensitive to anything in <code class="computeroutput">@_</code>. If <code class="computeroutput">@_</code> contains anything, it
		will be leaked (though the more recent versions of Perl should have it
		fixed). So <code class="computeroutput">@_</code> gets cleared before starting the thread.
		</p><p>
		And the harvester gets started in the new thread slightly differently.
		Since in the new thread all the XS objects become <code class="computeroutput">undef</code>s,
		the App object has to be found by name in the global list first.
		</p><p>
		One way or the other, the harvester is started. What does it do? It
		joins the App's threads as they exit. After all of them exit, it
		removes the App from the global list of Apps, which will allow to
		collect the App's memory when the last reference to it is gone, and
		then the harvester returns.
		</p><p>
		If any of the App's threads die rather than exit nicely, they cause the App to be aborted. The
		aborted App shuts down immediately and remembers the identity of the
		failed thread and its error message (only the first message is saved
		because the abort is likely to cause the other threads to die too, and
		there is no point in seeing these derivative messages). The harvester,
		in turn, collects this message from the App, and after all its
		cleaning-up work is done, also dies, propagating this message. Then if the
		harvester is running not in the first thread of the program, that message will be
		propagated further by Perl's <code class="computeroutput">join()</code>.
		</p><p>
		A catch is that the errors are not reported until the harvester
		completes. Normally all the App's threads should exit immediately on
		shutdown but if they don't, the program will be stuck without any
		indication of what happened.
		</p><p>
		It's also possible to disable this propagation of dying by using the
		option <span class="quote">&#8220;<span class="quote">die_on_abort</span>&#8221;</span>:
		</p><pre class="programlisting">$app-&gt;harvester(die_on_abort =&gt; 0);</pre><p>
		There is a way to get the error message that caused the abort directly
		from the App instead.
		</p><p>
		And finally the last part of startServer():
		</p><pre class="programlisting">  if ($opts-&gt;{fork} &gt; 0) {
    exit 0; # the forked child process
  }

  return ($port, $tharvest);
}</pre><p>
		 If this was the child process forked before, it exits at this point.
		 Otherwise the port and the harvester's thread object are returned. 
		</p><p>
		The next function of the ThreadedServer is <code class="computeroutput">listen()</code>, the function that gets
		called from the listener thread and takes care of accepting the
		connections and spawning the per-client threads.
		</p><pre class="programlisting">sub listen # ($optName =&gt; $optValue, ...)
{
  my $myname = "Triceps::X::ThreadedServer::listen";
  my $opts = {};
  my @myOpts = (
    owner =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "Triceps::TrieadOwner") } ],
    socket =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "IO::Socket") } ],
    prefix =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    handler =&gt; [ undef, sub { &amp;Triceps::Opt::ck_mandatory(@_); &amp;Triceps::Opt::ck_ref(@_, "CODE") } ],
    pass =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "ARRAY") } ],
  );
  &amp;Triceps::Opt::parse($myname, $opts, {
    @myOpts,
    '*' =&gt; [],
  }, @_);
  my $owner = $opts-&gt;{owner};
  my $app = $owner-&gt;app();
  my $prefix = $opts-&gt;{prefix};
  my $sock = $opts-&gt;{socket};</pre><p>
		The option parsing is similar to <code class="computeroutput">startServer()</code>:
		it also saves the list of supported options in the variable <code class="computeroutput">@myOpts</code>
		and accepts any unknown options with <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span>, to pass them
		through to the user thread.
		</p><pre class="programlisting">  my $clid = 0; # client id

  while(!$owner-&gt;isRqDead()) {
    my $client = $sock-&gt;accept();
    if (!defined $client) {
      my $err = "$!"; # or the text message will be reset by isRqDead()
      if ($owner-&gt;isRqDead()) {
        last;
      } elsif($!{EAGAIN} || $!{EINTR}) { # numeric codes don't get reset
        next;
      } else {
        confess "$myname: accept failed: $err";
      }
    }</pre><p>
		The accept loop starts. It runs until the thread is requested to die
		at shutdown. The shutdown would also revoke the listening socket,
		and thus if it happened in the middle of <code class="computeroutput">$sock-&gt;accept()</code>,
		<code class="computeroutput">$sock-&gt;accept()</code> would return an <code class="computeroutput">undef</code> because
		it will see the revocation as an error.
		Note that <code class="computeroutput">listen()</code> itself doesn't request to
		track the socket for revocation. The caller must do that
		before calling <code class="computeroutput">listen()</code>.
		</p><p>
		So, after <code class="computeroutput">accept()</code> the code checks for
		errors. The first thing to check for is again the <code class="computeroutput">isRdDead()</code>, because
		it's not really an error, it's an expected condition. 
		If the shutdown is found, the loop exits.  However
		the error text had to be saved before <code class="computeroutput">isRqDead()</code>, 
		because like other Triceps calls <code class="computeroutput">isRdDead()</code> will clear the error text.
		Then the check
		for the spurious interruptions is done, and for them the loop
		continues. Interestingly, the <code class="computeroutput">$!{}</code> uses the numeric part of <code class="computeroutput">$!</code> that is
		independent from its text part and doesn't get cleared by the Triceps
		calls. And on any other errors the thread confesses. The confession will unroll
		the stack, eventually will get caught by the Triceps threading code, abort
		the App, and propagate the error message to the harvester.
		</p><pre class="programlisting">    $clid++;
    my $cliname = "$prefix$clid";
    $app-&gt;storeCloseFile($cliname, $client);

    Triceps::Triead::start(
      app =&gt; $app-&gt;getName(),
      thread =&gt; $cliname,
      fragment =&gt; $cliname,
      main =&gt; $opts-&gt;{handler},
      socketName =&gt; $cliname,
      &amp;Triceps::Opt::drop({ @myOpts }, \@_),
    );

    # Doesn't wait for the new thread(s) to become ready.
  }
}</pre><p>
		If a proper connection has been received, the socket gets stored into
		the App with a unique name, for later load by the per-client thread.
		And then the per-client thread gets started.
		</p><p>
		<code class="computeroutput">Opt::drop()</code> passes through all the original options except for the ones
		handled by this thread. In retrospect, this is not the best solution
		for this case. It would be better to just use <code class="computeroutput">@{$opts-&gt;{"*"}}</code> instead.
		<code class="computeroutput">Opt::drop()</code> is convenient when not all the explicitly recognized
		options but only some of them have to be dropped.
		</p><p>
		After starting the thread, the loop doesn't call <code class="computeroutput">readyReady()</code> but goes
		for the next iteration. This is basically because it doesn't care about
		the started thread and doesn't ever send anything to it. And waiting
		for the threads to start will make the loop slower, possibly
		overflowing the socket's listening queue and dropping the incoming
		connections if they arrive very fast.
		</p><p>
		And the last part of the ThreadedServer is the function <code class="computeroutput">printOrShut()</code>:
		</p><pre class="programlisting">sub printOrShut # ($app, $fragment, $sock, @text)
{
  my $app = shift;
  my $fragment = shift;
  my $sock = shift;

  undef $!;
  print $sock @_;
  $sock-&gt;flush();

  if ($!) { # can't write, so shutdown
    Triceps::App::shutdownFragment($app, $fragment);
  }
}</pre><p>
		Nothing too complicated. Prints the text into the socket, flushes it
		and checks for errors. On errors shuts down the fragment. In this case
		there is no need for draining. After all, the socket leading to the
		client is dead and there is no way to send anything more through it, so
		there is no point in worrying about any unsent data. Just shut down as
		fast as it can, before the threads have generated more data that can't
		be sent any more. Any data queued in the nexuses for the shut down
		threads will be discarded.
		</p></div><div class="sect1" title="16.8. ThreadedClient, a Triceps Expect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_threaded_client"></a>16.8. ThreadedClient, a Triceps Expect</h2></div></div></div><a class="indexterm" name="id556102"></a><a class="indexterm" name="id556110"></a><p>
		In case if you're not familiar with it, <code class="computeroutput">expect</code> is a program that
		allows to connect to the interactive programs and pretend being an
		interactive user. Obviously, the terminal programs, not the GUI ones.
		It has originally been done as an extension for Tcl, and later ported
		as a library for Perl and other languages.
		</p><p>
		The class Triceps::X::ThreadedClient implements a variety of <code class="computeroutput">expect</code> in
		the Triceps framework. I'm using it for the unit tests of the Triceps
		servers but it can have other uses as well. Why not just use <code class="computeroutput">expect</code>?
		One reason, I don't like bringing in extra dependencies, especially
		just for tests, second, it was an interesting exercise, and third, I
		didn't realize that I was writing a simplified variety of expect until I
		had it mostly completed. The biggest simplification compared to the
		real <code class="computeroutput">expect</code> is that ThreadedClient works with the complete lines.
		</p><p>
		It gets used in the unit tests like this: first the server gets started
		in a background process or thread, and then the server's port number is used to
		create the clients. The ThreadedClient gets embedded into a Triceps
		App, so you can start other things in the same App. Well, the names of
		the ThreadedClient threads are hardcoded at the moment, so you can
		start only one copy of it per App, and there could be conflicts if you
		start your other threads and use the same names as in ThreadedClient.
		</p><p>
		But first you need to start an App. I'll show it done in yet another way this
		time:
		</p><pre class="programlisting">  Triceps::App::build "client", sub {
    my $appname = $Triceps::App::name;
    my $owner = $Triceps::App::global;

    # give the port in startClient
    my $client = Triceps::X::ThreadedClient-&gt;new(
      owner =&gt; $owner,
      totalTimeout =&gt; 5,
      debug =&gt; 0,
    );

    $owner-&gt;readyReady();

    $client-&gt;startClient("c1", $port);
    $client-&gt;expect("c1", '!ready');

    # this repetition tests the expecting to the first match
    $client-&gt;send("c1", "publish,*,zzzzzz\n");
    $client-&gt;send("c1", "publish,*,zzzzzz\n");
    $client-&gt;expect("c1", '\*,zzzzzz');
    $client-&gt;expect("c1", '\*,zzzzzz');

    $client-&gt;startClient("c2", $port);
    $client-&gt;expect("c2", '!ready,cliconn2');

    $client-&gt;send("c1", "kill,cliconn2\n");
    $client-&gt;expect("c2", '__EOF__');

    $client-&gt;send("c1", "shutdown\n");
    $client-&gt;expect("c1", '__EOF__');
  };</pre><p>
		<code class="computeroutput">Triceps::App::build()</code> is kind of like <code class="computeroutput">Triceps::Triead::startHere()</code> but
		saves the trouble of parsing the options. The app name is its first
		argument and the code for the main routine of the first thread is the
		second argument. That first Triead will run in the current Perl thread.
		After that the name of the app is placed into the global variable
		<code class="computeroutput">$Triceps::App::name</code>, the App object into <code class="computeroutput">$Triceps::App::app</code>, and the
		TrieadOwner into <code class="computeroutput">$Triceps::App::global</code>. The name of the first Triead is
		hardcoded as <span class="quote">&#8220;<span class="quote">global</span>&#8221;</span>.  After the main function exits,
		<code class="computeroutput">Triceps::App::build()</code> runs the harvester, very similar to <code class="computeroutput">startHere()</code>.
		</p><p>
		<code class="computeroutput">Triceps::X::ThreadedClient-&gt;new()</code> is used to start an instance of a
		client. A single client instance supports multiple connections, to the
		same or different servers.
		The option <span class="quote">&#8220;<span class="quote">owner</span>&#8221;</span> gives it the current TrieadOwner as a
		starting point but ThreadedClient will create its own threads starting from this
		point. 
		</p><p>
		The port number for the connection can be specified as either the option <span class="quote">&#8220;<span class="quote">port</span>&#8221;</span> or as the
		second argument of <code class="computeroutput">startClient()</code>. You can use both, and then the option
		will provide the default value while <code class="computeroutput">startClient()</code> can stil override it.
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">debug</span>&#8221;</span> is optional, with the default value of 0. In the non-debug
		mode ThreadedClient collects the trace of the run but otherwise runs silently.
		Setting the <span class="quote">&#8220;<span class="quote">debug</span>&#8221;</span> option to 1 makes it also print the trace as it gets
		collected, so if something goes not the way you expected, you can see
		what it is. Setting the debug to 1 also adds the printouts from the
		socket-facing threads, so you can also see what goes in and out the
		client socket.
		</p><p>
		The option <span class="quote">&#8220;<span class="quote">totalTimeout</span>&#8221;</span> can be used to set the time limit
		in seconds (as a floating-point number, so you can use values like 0.1 for
		a timeout of 0.1 second) for the whole exchange.
		It's very convenient for the unit tests,
		limiting the time for which the test could get stuck if something
		goes wrong. If the timeout gets exceeded, all the following calls of <code class="computeroutput">expect()</code>
		will return immediately, setting the error message in <code class="computeroutput">$@</code> and appending
		it to the trace.
		</p><p>
		There are three ways to specify the timeout. Two of them are in the <code class="computeroutput">new()</code>:
		</p><pre class="programlisting">my $client = Triceps::X::ThreadedClient-&gt;new(
  owner =&gt; $owner,
  totalTimeout =&gt; $timeout,
);

my $client = Triceps::X::ThreadedClient-&gt;new(
  owner =&gt; $owner,
  timeout =&gt; $timeout,
);</pre><p>
		The option <span class="quote">&#8220;<span class="quote">totalTimeout</span>&#8221;</span> gives a timeout for the whole run to
		complete. Once that timeout is reached, all future <code class="computeroutput">expect()</code>s just fail
		immediately. The option <span class="quote">&#8220;<span class="quote">timeout</span>&#8221;</span> gives the default timeout for each
		<code class="computeroutput">expect()</code>. It's possible to use both, and each call of <code class="computeroutput">expect()</code> will be
		limited by the shorter time limit of the two (<span class="quote">&#8220;<span class="quote">totalTimeout</span>&#8221;</span>
		starts counting since the call of <code class="computeroutput">new()</code>, <span class="bold"><strong>not</strong></span> from <code class="computeroutput">startClient()</code>,
		while <span class="quote">&#8220;<span class="quote">timeout</span>&#8221;</span> starts counting since the call of <code class="computeroutput">expect()</code>).
		</p><p>
		The third way is to use an extra argument in <code class="computeroutput">expect()</code>:
		</p><pre class="programlisting">$client-&gt;expect("c1", "expected text", $timeout);</pre><p>
		This timeout completely overrides whatever was set in <code class="computeroutput">new()</code>. The value
		of 0 disables the timeout for this call, and even 0 still overrides the timeout
		from <code class="computeroutput">new()</code>, so it can be used for the one-off calls without the
		timeout.
		</p><p>
		After the ThreadedClient object is created, the client connections get
		started with <code class="computeroutput">startClient()</code>. Its first
		argument is a symbolic name of the client that will be used in the
		further calls and also in the trace. The second optional argument is
		the port number, if you want to use a different port than specified in
		the <code class="computeroutput">new()</code>.
		</p><p>
		After that the data gets sent into the client socket with <code class="computeroutput">send()</code>, and
		the returned lines get parsed with <code class="computeroutput">expect()</code>. The usual procedure is
		that you send something, then expect some response to it. 
		</p><p>
		The second argument of <code class="computeroutput">expect()</code> is actually a regexp placed inside a
		string. So to expect a literal special character like <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span>, prefix it
		with a backslash and put the string into single quotes, like:
		</p><pre class="programlisting">$client-&gt;expect("c1", '\*,zzzzzz');</pre><p>
		<code class="computeroutput">expect()</code> keeps reading lines until it finds one matching the
		regexp. Then all the lines including that one are added to the trace
		and the call returns.  The sent
		lines are also included into the trace, with the prefix <span class="quote">&#8220;<span class="quote">&gt; </span>&#8221;</span>.
		</p><p>
		There are a couple of special lines generated by the connection status
		itself rather than coming from the socket. When the socket gets
		connected, it generates the line <span class="quote">&#8220;<span class="quote">connected <span class="emphasis"><em>name</em></span></span>&#8221;</span> in the trace
		(but not as an expectable input). When the connection gets dropped by the server,
		this generates an expectable line <span class="quote">&#8220;<span class="quote">__EOF__</span>&#8221;</span>. And each line in the
		trace gets prefixed with the client name and <span class="quote">&#8220;<span class="quote">|</span>&#8221;</span>. The example of the
		chat server run in the previous section was created by the ThreadedClient.
		</p><p>
		The socket disconnect (<span class="quote">&#8220;<span class="quote">__EOF__</span>&#8221;</span>) has another special property:
		if it's encountered by an <code class="computeroutput">expect()</code> call that doesn't expect it,
		that call and the following ones will set the
		error message in <code class="computeroutput">$@</code> and append it to the trace, then immediately return.
		This handles the situation with the unexpectedly
		dropped connection quickly, without resorting to the timeout.
		</p><p>
		The recorded trace can be extracted as <code class="computeroutput">$client-&gt;getTrace()</code>. So for unit tests
		you can check the trace match as
		</p><pre class="programlisting">ok($client-&gt;getTrace(), $expected);</pre><p>
		It's possible to get only the error messages with <code class="computeroutput">$client-&gt;getErrorTrace()</code>.
		</p><p>
		One more method not shown above allows to close the client socket 
		(in socket terms, shut it down):
		</p><pre class="programlisting">$client-&gt;sendClose("c4", "WR");</pre><p>
		The first argument is the client name. The second argument determines,
		which side of the socket gets closed: <span class="quote">&#8220;<span class="quote">WR</span>&#8221;</span> for the writing side, <span class="quote">&#8220;<span class="quote">RD</span>&#8221;</span>
		for the reading side, and <span class="quote">&#8220;<span class="quote">RDWR</span>&#8221;</span> for both. It's the same names as for
		the system call <code class="computeroutput">shutdown()</code>. 
		</p><p>
		Internally the ThreadedClient is very much like the chat server, 
		except for the support of the timeouts. The way the timeouts work is described
		below in
		<a class="xref" href="#sc_mt_main_timeouts" title="16.9. Thread main loop and timeouts in the guts of ThreadedClient">Section 16.9: &#8220;Thread main loop and timeouts in the guts of ThreadedClient&#8221; </a>.
		But there is not a whole lot of point in going over the rest of implementation
		in detail. Feel free to read it on your own, in <code class="computeroutput">lib/Triceps/X/ThreadedClient.pm</code>.
		</p></div><div class="sect1" title="16.9. Thread main loop and timeouts in the guts of ThreadedClient"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_main_timeouts"></a>16.9. Thread main loop and timeouts in the guts of ThreadedClient</h2></div></div></div><a class="indexterm" name="id556573"></a><a class="indexterm" name="id556581"></a><a class="indexterm" name="id556590"></a><a class="indexterm" name="id556598"></a><p>
		First of all, let me re-iterate: if you look for repeatability
		of computation, you should really use an external time source
		synchronized with your data.  But sometimes you really need to work
		with the real time, such as when handling the input from a socket
		and/or time-limiting the run of the tests. The repeatability doesn't
		matter much for these uses, since it's really for handling of the
		cases that Should Never Happen.
		</p><p>
		The ThreadedClient uses this kind of timeouts, so I'll use its
		implementation as an example. Let's start by stepping back and
		looking at the structure of ThreadedClient. It runs in multiple
		threads.
		</p><p>
		The collector thread is the heart of ThreadedClient. When a
		ThreadedClient object is created, the collector thread starts.
		It will be receiving data from the connections and matching it
		up with the expectations.
		</p><p>
		Whenever a client connection is created, two threads go with
		it, the reader and writer. The reader passes the data directly
		to the collector, which then buffers all the received data
		until <code class="computeroutput">expect()</code> asks for it.
		</p><p>
		Finally, there is the thread where the user's control code runs.
		When a ThreadedClient gets created in the user thread, the option <span class="quote">&#8220;<span class="quote">owner</span>&#8221;</span>
		provides the TrieadOwner of that user thread to the ThreadedClient object.
		</p><p>
		<code class="computeroutput">expect()</code> works by sending a request to the collector
		thread and waiting for the response from it. If there is a time limit
		and the response is not received within it, the wait gets interrupted,
		and a cancellation request gets sent to the collector.
		</p><p>
		<code class="computeroutput">new()</code> creates the labels for processing the replies from the
		collector:
		</p><pre class="programlisting">  $self-&gt;{faReply}-&gt;getLabel("msg")-&gt;makeChained("lbReplyExpect", undef, sub {
    my ($cmd, $client, $arg) = $_[1]-&gt;getRow()-&gt;toArray();
    if ($cmd eq "expect") {
      my $ptext = $arg;
      $ptext =~ s/^/$client|/gm;
      $self-&gt;{trace} .= $ptext;
      if ($self-&gt;{debug}) {
        print $ptext;
      }
      $self-&gt;{expectDone} = 1;
    } elsif ($cmd eq "error") {
      # save the error in trace, so that it will be easily printed.
      my $ptext = $arg . "\n";
      $ptext =~ s/^/$client|/gm;
      $self-&gt;{trace} .= $ptext;
      $self-&gt;{errorTrace} .= $ptext;
      if ($self-&gt;{debug}) {
        print $ptext;
      }

      $self-&gt;{error} = $arg;
      $self-&gt;{expectDone} = 1;
    }</pre><p>
		But of course these labels will not run until the thread reads
		the data from its input facets. Most threads read the data from the facets
		continuously with <code class="computeroutput">TrieadOwner::mainLoop()</code>. Of course, the
		user thread that owns ThreadedClient can't do that, or it would not
		be able to run the user code. But anyway, let's look at the internals
		of the <code class="computeroutput">mainLoop()</code> for the reference first. It's implemented
		in C++ literally as follows:
		</p><pre class="programlisting">void TrieadOwner::mainLoop()
{
  while (nextXtray())
    { }
}</pre><a class="indexterm" name="id556701"></a><p>
		<code class="computeroutput">nextXtray()</code> represents one step of the main loop: it reads one
		incoming tray from one of the input facets and processes it. 
		"Xtray" is a special form of the trays used to pass the data across the nexus. 
		If no tray
		is available, it waits. If more that one facet has trays available,
		the facets of the reverse nexuses get the higher priority, and then
		within the same priority it round-robins. 
		It returns <code class="computeroutput">true</code> until the thread is requested
		dead, and then it returns <code class="computeroutput">false</code>.
		<code class="computeroutput">nextXtray()</code> is
		available in the Perl API as well.
		</p><p>
		Now we're ready to look at <code class="computeroutput">expect()</code>.
		The core part of <code class="computeroutput">expect()</code>, after it computes the time limit from the
		three sources, is this:
		</p><pre class="programlisting">  $self-&gt;{error} = undef;
  $self-&gt;{expectDone} = 0;

  if ($self-&gt;{debug} &gt; 1) {
    print "expect: $pattern\n"
  }

  $owner-&gt;unit()-&gt;makeHashCall($self-&gt;{faCtl}-&gt;getLabel("msg"), "OP_INSERT",
    cmd =&gt; "expect",
    client =&gt; $client,
    arg =&gt; $pattern,
  );
  $owner-&gt;flushWriters();

  if ($limit &gt; 0.) {
    while(!$self-&gt;{expectDone} &amp;&amp; $owner-&gt;nextXtrayTimeLimit($limit)) { }
    # on timeout reset the expect and have that confirmed
    if (!$self-&gt;{expectDone}) {
      $owner-&gt;unit()-&gt;makeHashCall($self-&gt;{faCtl}-&gt;getLabel("msg"), "OP_INSERT",
        cmd =&gt; "cancel",
        client =&gt; $client,
      );
      $owner-&gt;flushWriters();
      # wait for confirmation
      while(!$self-&gt;{expectDone} &amp;&amp; $owner-&gt;nextXtray()) { }
    }
  } else {
    while(!$self-&gt;{expectDone} &amp;&amp; $owner-&gt;nextXtray()) { }
  }


  if ($app-&gt;isAborted()) {
    confess "$myname: app is aborted";
  }
  $@ = $self-&gt;{error};</pre><p>
		If there is no time limit, it keeps reading the data from the facets with
		<code class="computeroutput">$owner-&gt;nextXtray()</code> until it gets the reply from the collector
		thread. If there is a time limit, it uses a special form of <code class="computeroutput">nextXtray()</code>
		with the time limit. There are multiple of these special forms:
		</p><pre class="programlisting">$res = $owner-&gt;nextXtrayNoWait();</pre><p>
		Returns immediately if there is no data available at the moment.
		</p><pre class="programlisting">$res = $owner-&gt;nextXtrayTimeLimit($deadline);</pre><p>
		Returns if no data becomes available before the absolute deadline.
		</p><pre class="programlisting">$res = $owner-&gt;nextXtrayTimeout($timeout);</pre><p>
		Returns if no data becomes available before the timeout, starting at
		the time of the call. Just to reiterate, the difference is that the
		<code class="computeroutput">nextXtrayTimeLimit()</code> receives the absolute time since the epoch while
		<code class="computeroutput">nextXtrayTimeout()</code> receives the length of the timeout starting from the
		time of the call, both as seconds in floating-point.
		</p><p>
		All the forms that may return early on no data return <code class="computeroutput">false</code> if they
		have to do so. If you need to differentiate between these functions returning
		<code class="computeroutput">false</code> due to the lack of data and due to the thread being requested
		to shut down, you can do it with <code class="computeroutput">$owner-&gt;isRqDead()</code>.
		</p><a class="indexterm" name="id556844"></a><p>
		The absolute deadline is generally a more reliable approach than the
		relative timeout. It's not susceptible to drift over time caused
		by the slight delays between the timeout being calculated and the
		start of the time-limited call. To compute the deadline as an offset
		from the current time, you need to get the current time.
		The function <code class="computeroutput">Triceps::now()</code>
		returns the current time in seconds since epoch as a floating-point
		value, including the fractions of the seconds (which is the general
		time format of the Triceps Perl API). Then you add the timeout to
		it and get the deadline value:
		</p><pre class="programlisting">$limit = Triceps::now() + $timeout;</pre><p>
		<code class="computeroutput">Triceps::now()</code> is also convenient for finding out the performance
		of the Triceps code, and in general of the Perl code.
		</p><p>
		<code class="computeroutput">expect()</code> uses the form with the absolute deadline. If the collector
		thread finds a match, it will send a rowop back to the expect thread,
		where it will get processed in <code class="computeroutput">nextXtrayTimeLimit()</code>, calling a label that
		sets the flag <code class="computeroutput">$self-&gt;{expectDone}</code>, and then <code class="computeroutput">nextXtrayTimeLimit()</code> will
		return 1, and the loop will find the flag and exit.
		</p><p>
		If the collector thread doesn't find a match, <code class="computeroutput">nextXtrayTimeLimit()</code> will
		return 0, and the loop will again exit. But then it will fill find
		the <span class="quote">&#8220;<span class="quote">done</span>&#8221;</span> flag not set, so it knows that the timeout has expired and
		it has to tell the collector thread that the call is being cancelled.
		So it sends another rowop for the cancel, and then waits for the
		confirmation with another <code class="computeroutput">nextXtray()</code>, this time with no limit on it
		since the confirmation must arrive back quickly in any case.
		</p><p>
		It's the confirmation rowop processing that sets <code class="computeroutput">$self-&gt;{error}</code>. But
		there is always a possibility that the match will arrive just after the
		timeout has expired but just before the cancellation. It's one of these
		things that you have to deal with when multiple threads exchange
		messages. What then? Then the normal confirmation will arrive back to
		the expecting thread. And when the cancel message will arrive to the
		collector thread, it will find that this client doesn't have an
		outstanding expect requests any more, and will just ignore the cancel.
		Thus, the second <code class="computeroutput">nextXtray()</code> will receive either a confirmation of the
		cancel and set the error message, or it will receive the last-moment
		success message. Either way it will fall through and return (setting <code class="computeroutput">$@</code>
		if the cancel confirmation came back).
		</p><p>
		By the way, if the collector thread finds the socket closed, it will
		immediately return an error rowop, very similar to the confirmation of
		the cancel. Which will set both <code class="computeroutput">$self-&gt;{expectDone}</code> and <code class="computeroutput">$self-&gt;{error}</code>
		in the expect thread. 
		</p></div><div class="sect1" title="16.10. The threaded dreaded diamond and data reordering"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_mt_main_reorder"></a>16.10. The threaded dreaded diamond and data reordering</h2></div></div></div><a class="indexterm" name="id556976"></a><a class="indexterm" name="id556985"></a><p>
		The pipelined examples shown before had very conveniently preserved the
		order of the data while spreading the computational load among multiple
		threads. But it forced the computation to pass sequentially through
		every thread, increasing the latency and adding overhead. The other
		frequently used option is to farm out the work to a number of parallel
		threads and then collect the results back from them.
		This topology is colloquially known as <span class="quote">&#8220;<span class="quote">diamond</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">fork-join</span>&#8221;</span>
		(having nothing to do with the SQL joins, just that the arrows first
		fork from one box to multiple and then join back to one box).
		</p><p>
		The single-threaded use of this topology has already been discussed in
		<a class="xref" href="#sc_other_diamond" title="14.1. The dreaded diamond">Section 14.1: &#8220;The dreaded diamond&#8221; </a>,
		and its diagram can be found there in
		<a class="xref" href="#fig_other_diamond" title="Figure 14.1. The diamond topology.">Figure 14.1: &#8220;The diamond topology.&#8221; </a>.
		</p><p>
		There are multiple ways to decide, which thread gets which unit of data
		to process. One possibility that provides the natural load balancing is
		to keep a common queue of work items, and have the worker threads (B
		and C in 
		<a class="xref" href="#fig_other_diamond" title="Figure 14.1. The diamond topology.">Figure 14.1 </a>)
		read the next work item when they become free after
		processing the last item. But this way has an important limitation:
		there is no way to tell in advance, which work item will go to which
		thread, so there is no way for the worker threads to keep any state.
		All the state would have to be encapsulated into the work item (
		a work item
		would be a tray in the Triceps terms). And at the moment Triceps
		provides no way to maintain such a shared queue.
		</p><p>
		The other way is to partition the data between the worker threads based
		on the primary key. Usually it's done by using a hash of the key, which
		would distribute the data randomly and hopefully evenly. Then a worker
		thread can keep the state for its subset of keys, forming a partition
		(also known as <span class="quote">&#8220;<span class="quote">shard</span>&#8221;</span>) and process the sequential updates for this
		partition. The way to send a rowop only to the thread B or only to the
		thread C would be by having a separate designated nexus for each worker
		thread, and the thread A making the decision based on the hash of the
		primary key in the data. The processed data from all the worker threads
		can then be sent to a single nexus feeding the thread D.
		</p><p>
		But either way the data will arrive at D in an unpredictable order. The
		balance of load between the worker threads is not perfect, and there is
		no way to predict, how long will each tray take to process. A tray
		following one path may overtake a tray following another path.
		</p><a class="indexterm" name="id557058"></a><a class="indexterm" name="id557066"></a><p>
		If the order of the data is important, D must collate the data back
		into the original order before processing it further. Obviously, for
		that it must know what the original order was, so A must tag the data
		with the sequential identifiers. Since the data rows themselves may get
		multiplied, the tagging is best done at the tray level (what happens if
		the trays split in the worker threads is a separate story,
		for now the solution is simply <span class="quote">&#8220;<span class="quote">keep the tray together</span>&#8221;</span>).
		</p><a class="indexterm" name="id557085"></a><a class="indexterm" name="id557094"></a><p>
		When the data goes through a nexus, Triceps always keeps a tray as an
		indivisible bundle. It always gets read from the reading facet
		together, without being interspersed with the data from the other
		trays. As the data is sent into a writer facet, it's collected in a
		tray, and sent on only when the facet gets flushed, with the
		<code class="computeroutput">TrieadOwner::flushWriters()</code> or <code class="computeroutput">Facet::flushWriter()</code>.
		</p><p>
		There also are two special labels defined on every nexus, that tell the
		tray boundaries to the reading thread:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> is called at the start of the tray.
			</li><li class="listitem"><span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> is called at the end of the tray.
			</li></ul></div><p>
		These labels can be defined explicitly, or otherwise they become
		defined implicitly anyway. If they get defined implicitly, they get the
		empty row type (one with no fields). If you define them explicitly, you
		can use any row type you please, and this is a good place for the tray
		sequence id.
		</p><p>
		And in a writer facet you can send data to these labels. When you want
		to put a sequence id on a tray, you define the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> label with that
		sequence id field, and then call the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> label with the appropriate
		id values. Even if you don't call the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> labels, they do
		get called (not quite called but placed on the tray) automatically
		anyway, with the opcode of <code class="computeroutput">OP_INSERT</code> and all the fields NULL. The
		direct calling of these labels will also cause the facet to be flushed:
		<span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> flushes any data previously collected on the tray and then adds
		itself; <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> adds itself and then flushes the tray.
		</p><p>
		The exact rules of how the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> get called are actually
		somewhat complicated, having to deal with the optimizations for the
		case when nobody is interested in them, but they do what makes sense
		intuitively.
		</p><p>
		The case when these labels get a call with <code class="computeroutput">OP_INSERT</code> and no data, gets
		optimized out by not placing it into the actual Xtray, even if it was
		called explicitly. Then in the reader facet these implicit rowops are
		re-created but only if there is a chaining for their labels from the
		facet's FnReturn or if they are defined in the currently pushed
		FnBinding. So if you do a trace on the reading thread's unit, you will
		see these implicit rowops to be called only if they are actually used.
		</p><a class="indexterm" name="id557201"></a><p>
		Before going to the example itself, let's talk more about the general
		issues of the data partitioning.
		</p><p>
		If the data processing is stateless, it's easy: just partition by the
		primary key, and each thread can happily work on its own. If the data
		depends on the previous data with the same primary key, the
		partitioning is still easy: each thread keeps the state for its part of
		the keys and updates it with the new data.
		</p><p>
		But what if you need to join two tables with independent primary keys,
		where the matches of the keys between them are fairly arbitrary? Then
		you can partition by one table but you have to give a copy of the
		second table to each thread. Typically, if one table is larger than the
		other, you would partition by the key of the big table, and copy the
		small table everywhere. Since the data rows are referenced in Triceps,
		the actual data of the smaller table won't be copied, it would be just
		referenced from multiple threads, but each copy will still have the
		overhead of its own index.
		</p><p>
		With some luck, and having enough CPUs, you might be able to save a
		little overhead by doing a matrix: if you have one table partitioned
		into the parts A, B and C, and the other table into parts 1, 2 and 3,
		you can then do a matrix-combination into 9 threads processing the
		combinations A1, A2, A3, B1, B2, B3, C1, C2, C3. If both tables are of
		about the same size, this would create a total of 18 indexes, each
		keeping 1/3 of one original table, so the total size of indexes will be
		6 times the size of one original table (or 3 times the combined sizes
		of both tables). On the other hand, if you were to copy the first table
		to each thread and split the second table into 9 parts, creating the
		same 9 threads, the total size of indexes will be 9 times the first
		table and 1 times the second table, resulting in the 10 times the size
		of one original table (or 5 times the combined sizes of both tables).
		The 3x3 matrix is more optimal, but the catch is that the results from it
		will really have to be restored to the correct order afterwards.
		</p><p>
		The reason is that when a row in the first table changes, it might change
		its join key, matching the row from a different partition of the second table.
		Which means that the DELETE of the old value and the INSERT of the
		new value will be processed in the different threads.
		For example, it might move the processing from the thread A1 to the thread A2. 
		So the thread
		A1 would generate a DELETE for the join result, and the thread A2 would
		generate a following INSERT. With two separate threads, the resulting
		order will be unpredictable, and the INSERT coming before the DELETE
		would be bad. The post-reordering is required to ensure the correct order.
		</p><p>
		By contrast, if you just partition the first table and copy the second one
		everywhere, you get 9 threads A, B, C, D, E, F, G, H, I, and the change
		in a row will still keep it in the same thread, so the updates will
		come out of that thread strictly sequentially. If you don't care about
		the order of changes between different primary keys, you can get away
		without the post-reordering. Of course, if a key field might change and
		you care about it being processed in order, you'd still need the
		post-reordering.
		</p><p>
		The example I'm going to show is a somewhat strange mix. It's an
		adaptation of the Forex arbitration example from the 
		<a class="xref" href="#sc_joins_lookup_manual" title="12.3. The lookup join, done manually">Section 12.3: &#8220;The lookup join, done manually&#8221; </a>.
		As you can see from the name of that section,
		it's doing a self-join, and doing it twice: kind of like going through the same table three
		times.
		</p><p>
		The partitioning in this example works as follows:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			All the data is sent to all the threads. All the threads keep a
			full copy of the table and update it according to the input. 
			</li><li class="listitem">
			But then they compute the join only if the first currency name in
			the update falls into the thread's partition. 
			</li><li class="listitem">
			The partitioning is done by the first letter of the symbol, with
			interleaving: the symbols starting with A are handled by the thread
			0, with B by thread 1, and so on until the threads end, and then
			continuing again with the thread 0. A production-ready
			implementation would use a hash function instead. But the
			interleaving approach makes much easier to predict, which symbol
			goes to which thread for the demonstration.
			</li><li class="listitem">
			Naturally, all this means that the loop of 3 currencies might get
			created by a change in one pair and then very quickly disappear by
			a change to another pair.of currencies. So the post-reordering of
			the result is important to keep the things consistent.
			</li></ul></div><p>
		I've also added a tweak allowing to artificially slow down the thread
		0, making the incorrect order show up reliably, and really exercise the
		reordering code. For example, suppose the following input was
		sent quickly:
		</p><pre class="programlisting">OP_INSERT,AAA,BBB,1.30
OP_INSERT,BBB,AAA,0.74
OP_INSERT,AAA,CCC,1.98
OP_INSERT,CCC,AAA,0.49
OP_INSERT,BBB,CCC,1.28
OP_INSERT,CCC,BBB,0.78
OP_DELETE,BBB,AAA,0.74
OP_INSERT,BBB,AAA,0.64</pre><p>
		With two threads, and thread 0 working slowly, it would produce the raw
		result:
		</p><pre class="programlisting">BEGIN OP_INSERT seq="2" triead="1"
BEGIN OP_INSERT seq="5" triead="1"
BEGIN OP_INSERT seq="7" triead="1"
result OP_DELETE ccy1="AAA" ccy2="CCC" ccy3="BBB" rate1="1.98"
    rate2="0.78" rate3="0.74" looprate="1.142856"
BEGIN OP_INSERT seq="8" triead="1"
BEGIN OP_INSERT seq="1" triead="0"
BEGIN OP_INSERT seq="3" triead="0"
BEGIN OP_INSERT seq="4" triead="0"
BEGIN OP_INSERT seq="6" triead="0"
result OP_INSERT ccy1="AAA" ccy2="CCC" ccy3="BBB" rate1="1.98"
    rate2="0.78" rate3="0.74" looprate="1.142856"</pre><p>
		Here the BEGIN lines are generated by the code and show the sequence
		number of the input row and the id of the thread that did the join. 
		They represent the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> rowops of the trays that
		contain the transactions, and all the following result lines until
		the next BEGIN belong in the same tray.  The
		result lines show the arbitration opportunities produced by the join.
		Obviously, not every update produces a new opportunity, most of them don't.
		But the INSERT and DELETE in the result come in the wrong order: the
		update 7 had overtaken the update 6.
		</p><p>
		The post-reordering comes to the resque and restores the order:
		</p><pre class="programlisting">BEGIN OP_INSERT seq="1" triead="0"
BEGIN OP_INSERT seq="2" triead="1"
BEGIN OP_INSERT seq="3" triead="0"
BEGIN OP_INSERT seq="4" triead="0"
BEGIN OP_INSERT seq="5" triead="1"
BEGIN OP_INSERT seq="6" triead="0"
result OP_INSERT ccy1="AAA" ccy2="CCC" ccy3="BBB" rate1="1.98"
    rate2="0.78" rate3="0.74" looprate="1.142856"
BEGIN OP_INSERT seq="7" triead="1"
result OP_DELETE ccy1="AAA" ccy2="CCC" ccy3="BBB" rate1="1.98"
    rate2="0.78" rate3="0.74" looprate="1.142856"
BEGIN OP_INSERT seq="8" triead="1"</pre><p>
		As you can see, now the sequence numbers go in the sequential order. 
		</p><p>
		And finally the code of the example. I've written it with the simple
		approach of <span class="quote">&#8220;<span class="quote">read all stdin, process, print all to stdout</span>&#8221;</span>. 
		It's easier this way, and
		anyway to demonstrate the rowop reordering, all the input has to be
		sent quickly in one chunk. The example is found in <code class="computeroutput">t/xForkJoinMt.t</code>.
		The application starts as:
		</p><pre class="programlisting">Triceps::Triead::startHere(
  app =&gt; "ForkJoin",
  thread =&gt; "main",
  main =&gt; \&amp;mainT,
  workers =&gt; 2,
  delay =&gt; 0.02,
);</pre><p>
		The main thread is:
		</p><pre class="programlisting">sub mainT # (@opts)
{
  my $opts = {};
  &amp;Triceps::Opt::parse("mainT", $opts, {@Triceps::Triead::opts,
    workers =&gt; [ 1, undef ], # number of worker threads
    delay =&gt; [ 0, undef ], # artificial delay for the 0th thread
  }, @_);
  undef @_; # avoids a leak in threads module
  my $owner = $opts-&gt;{owner};
  my $app = $owner-&gt;app();
  my $unit = $owner-&gt;unit();</pre><p>
		So far the pretty standard boilerplate with the argument parsing.
		</p><pre class="programlisting">  my $rtRate = Triceps::RowType-&gt;new( # an exchange rate between two currencies
    ccy1 =&gt; "string", # currency code
    ccy2 =&gt; "string", # currency code
    rate =&gt; "float64", # multiplier when exchanging ccy1 to ccy2
  );

  # the resulting trade recommendations
  my $rtResult = Triceps::RowType-&gt;new(
    triead =&gt; "int32", # id of the thread that produced it
    ccy1 =&gt; "string", # currency code
    ccy2 =&gt; "string", # currency code
    ccy3 =&gt; "string", # currency code
    rate1 =&gt; "float64",
    rate2 =&gt; "float64",
    rate3 =&gt; "float64",
    looprate =&gt; "float64",
  );</pre><p>
		The row types originate from the self-join example code, unchanged.
		</p><pre class="programlisting">  # each tray gets sequentially numbered and framed
  my $rtFrame = Triceps::RowType-&gt;new(
    seq =&gt; "int64", # sequence number
    triead =&gt; "int32", # id of the thread that produced it (optional)
  );

  # the plain-text output of the result
  my $rtPrint = Triceps::RowType-&gt;new(
    text =&gt; "string",
  );</pre><p>
		Thes definitions of the service row types. The frame row type is used to send the
		information about the sequence number in the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> label. The print
		row type is used to send the text for printing back to the main thread.
		</p><pre class="programlisting">  # the input data
  my $faIn = $owner-&gt;makeNexus(
    name =&gt; "input",
    labels =&gt; [
      rate =&gt; $rtRate,
      _BEGIN_ =&gt; $rtFrame,
    ],
    import =&gt; "none",
  );

  # the raw result collected from the workers
  my $faRes = $owner-&gt;makeNexus(
    name =&gt; "result",
    labels =&gt; [
      result =&gt; $rtResult,
      _BEGIN_ =&gt; $rtFrame,
    ],
    import =&gt; "none",
  );

  my $faPrint = $owner-&gt;makeNexus(
    name =&gt; "print",
    labels =&gt; [
      raw =&gt; $rtPrint, # in raw order as received by collator
      cooked =&gt; $rtPrint, # after collation
    ],
    import =&gt; "reader",
  );</pre><p>
		The processing will go in essentially a pipeline: <span class="quote">&#8220;<span class="quote">read the input -&gt;
		process in the worker threads -&gt; collate -&gt; print in the main thread</span>&#8221;</span>.
		A nexus is defined for each connection between the stages of the pipeline.
		The worker thread stage spreads into multiple parallel threads for
		parititoned data, then joining the data paths back together in the collator.
		</p><pre class="programlisting">  Triceps::Triead::start(
    app =&gt; $app-&gt;getName(),
    thread =&gt; "reader",
    main =&gt; \&amp;readerT,
    to =&gt; $owner-&gt;getName() . "/input",
  );

  for (my $i = 0; $i &lt; $opts-&gt;{workers}; $i++) {
    Triceps::Triead::start(
      app =&gt; $app-&gt;getName(),
      thread =&gt; "worker$i",
      main =&gt; \&amp;workerT,
      from =&gt; $owner-&gt;getName() . "/input",
      to =&gt; $owner-&gt;getName() . "/result",
      delay =&gt; ($i == 0? $opts-&gt;{delay} : 0),
      workers =&gt; $opts-&gt;{workers},
      identity =&gt; $i,
    );
  }

  Triceps::Triead::start(
    app =&gt; $app-&gt;getName(),
    thread =&gt; "collator",
    main =&gt; \&amp;collatorT,
    from =&gt; $owner-&gt;getName() . "/result",
    to =&gt; $owner-&gt;getName() . "/print",
  );

  my @rawp; # the print in original order
  my @cookedp; # the print in collated order

  $faPrint-&gt;getLabel("raw")-&gt;makeChained("lbRawP", undef, sub {
    push @rawp, $_[1]-&gt;getRow()-&gt;get("text");
  });
  $faPrint-&gt;getLabel("cooked")-&gt;makeChained("lbCookedP", undef, sub {
    push @cookedp, $_[1]-&gt;getRow()-&gt;get("text");
  });

  $owner-&gt;readyReady();

  $owner-&gt;mainLoop();

  print("--- raw ---\n", join("\n", @rawp), "\n");
  print("--- cooked ---\n", join("\n", @cookedp), "\n");
}</pre><p>
		All the threads get started and instructed to connect to the appropriate nexuses.
		The collator will send the data for printing twice: first time in the
		order it was received (<span class="quote">&#8220;<span class="quote">raw</span>&#8221;</span>), second time in the order after collation
		(<span class="quote">&#8220;<span class="quote">cooked</span>&#8221;</span>).
		</p><pre class="programlisting">sub readerT # (@opts)
{
  my $opts = {};
  &amp;Triceps::Opt::parse("readerT", $opts, {@Triceps::Triead::opts,
    to =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ], # dest nexus
  }, @_);
  undef @_; # avoids a leak in threads module
  my $owner = $opts-&gt;{owner};
  my $unit = $owner-&gt;unit();

  my $faIn = $owner-&gt;importNexus(
    from =&gt; $opts-&gt;{to},
    import =&gt; "writer",
  );

  my $lbRate = $faIn-&gt;getLabel("rate");
  my $lbBegin = $faIn-&gt;getLabel("_BEGIN_");
  # _END_ is always defined, even if not defined explicitly
  my $lbEnd = $faIn-&gt;getLabel("_END_");</pre><p>
		This demonstrates that the labels <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> always get defined
		in each nexus, even if they are not defined explicitly. Here
		<span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> was defined explicitly but <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> was not, and nevertheless it
		can be found and used.
		</p><pre class="programlisting">  my $seq = 0; # the sequence

  $owner-&gt;readyReady();

  while(&lt;STDIN&gt;) {
    chomp;

    ++$seq; # starts with 1
    $unit-&gt;makeHashCall($lbBegin, "OP_INSERT", seq =&gt; $seq);
    my @data = split(/,/); # starts with a string opcode
    $unit-&gt;makeArrayCall($lbRate, @data);
    # calling _END_ is an equivalent of flushWriter()
    $unit-&gt;makeHashCall($lbEnd, "OP_INSERT");
  }

  {
    # drain the pipeline before shutting down
    my $ad = Triceps::AutoDrain::makeShared($owner);
    $owner-&gt;app()-&gt;shutdown();
  }
}</pre><p>
		Each input row is sent through in a separate transaction, or in another
		word, a separate tray. The <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> label carries the sequence number of
		the tray. The trays can as well be sent on with <code class="computeroutput">TrieadOwner::flushWriters()</code> or
		<code class="computeroutput">Facet::flushWriter()</code>, but I wanted to show that you can also flush it by
		calling the <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> label.
		</p><pre class="programlisting">sub workerT # (@opts)
{
  my $opts = {};
  &amp;Triceps::Opt::parse("workerT", $opts, {@Triceps::Triead::opts,
    from =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ], # src nexus
    to =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ], # dest nexus
    delay =&gt; [ 0, undef ], # processing delay
    workers =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ], # how many workers
    identity =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ], # which one is us
  }, @_);
  undef @_; # avoids a leak in threads module
  my $owner = $opts-&gt;{owner};
  my $unit = $owner-&gt;unit();
  my $delay = $opts-&gt;{delay};
  my $workers = $opts-&gt;{workers};
  my $identity = $opts-&gt;{identity};

  my $faIn = $owner-&gt;importNexus(
    from =&gt; $opts-&gt;{from},
    import =&gt; "reader",
  );

  my $faRes = $owner-&gt;importNexus(
    from =&gt; $opts-&gt;{to},
    import =&gt; "writer",
  );

  my $lbInRate = $faIn-&gt;getLabel("rate");
  my $lbResult = $faRes-&gt;getLabel("result");
  my $lbResBegin = $faRes-&gt;getLabel("_BEGIN_");
  my $lbResEnd = $faRes-&gt;getLabel("_END_");</pre><p>
		The worker thread starts with the pretty usual boilerplate.
		</p><pre class="programlisting">  my $seq; # sequence from the frame labels
  my $compute; # the computation is to be done by this label
  $faIn-&gt;getLabel("_BEGIN_")-&gt;makeChained("lbInBegin", undef, sub {
    $seq = $_[1]-&gt;getRow()-&gt;get("seq");
  });</pre><p>
		The processing of each transaction starts by remembering its sequence
		number from the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> label. It doesn't send a <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> to the output
		yet because it doesn't know yet if it will be producing the output.
		All the threads get the same input, to be able to update their copies of the
		table, but then only one thread produces the output. And the thread
		doesn't know whether it will be the one producing the output until it
		knows the primary key of the data. So it can start sending the
		output only after it had seen the data. This whole scheme works for this example because
		there is exactly one data row per each transaction. A more general
		approach might be to have the reader thread decide up front, which worker will
		produce the result and put this information (as either a copy of the
		primary key or the computed thread id) into the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> rowop.
		</p><pre class="programlisting">  ...

  # the table gets updated for every incoming rate
  $lbInRate-&gt;makeChained("lbIn", undef, sub {
    my $ccy1 = $_[1]-&gt;getRow()-&gt;get("ccy1");
    # decide, whether this thread is to perform the join
    $compute = ((ord(substr($ccy1, 0, 1)) - ord('A')) % $workers == $identity);

    # this relies on every Xtray containing only one rowop,
    # otherwise one Xtray will be split into multiple
    if ($compute) {
      $unit-&gt;makeHashCall($lbResBegin, "OP_INSERT", seq =&gt; $seq, triead =&gt; $identity);
      select(undef, undef, undef, $delay) if ($delay);
    }

    # even with $compute is set, this might produce some output or not,
    # but the frame still goes out every time $compute is set, because
    # _BEGIN_ forces it
    $unit-&gt;call($lbRateInput-&gt;adopt($_[1]));
  });</pre><p>
		This code makes the decision of whether this join is to be computed for
		this thread. The decisiton is remembered in the flag <code class="computeroutput">$compute</code>, and used to generate the
		<span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> rowop for the output. Then the table gets updated in any case
		(<code class="computeroutput">$lbRateInput</code> is the table's input label). I've skipped over the table
		creation code, it's unchanged from the original self-join example.
		</p><pre class="programlisting">  $tRate-&gt;getOutputLabel()-&gt;makeChained("lbCompute", undef, sub {
    return if (!$compute); # not this thread's problem

    ...
      if ($looprate &gt; 1) {
        $unit-&gt;call($result);
      }
    ...
  });
  ##################################################

  $owner-&gt;readyReady();

  $owner-&gt;mainLoop();
}</pre><p>
		Here again I've skipped over the way the result is computed because it's
		lengthy and unchanged from the original example. The
		important part is that if the <code class="computeroutput">$compute</code> flag is not set, the whole
		self-joining computation is not performed. 
		</p><p>
		The <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> label is not
		touched, the flushing of transactions is taken care of by the
		<code class="computeroutput">mainLoop()</code>. Note that the <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> label is always sent if the data is
		designated to this thread, even if no output as such is produced. This
		is done because the collator needs to get an uninterrupted sequence of
		transactions. Otherwise it would not be able to say if some transaction
		had been dropped or only delayed.
		</p><pre class="programlisting">sub collatorT # (@opts)
{
  my $opts = {};
  &amp;Triceps::Opt::parse("collatorT", $opts, {@Triceps::Triead::opts,
    from =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ], # src nexus
    to =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ], # dest nexus
  }, @_);
  undef @_; # avoids a leak in threads module
  my $owner = $opts-&gt;{owner};
  my $unit = $owner-&gt;unit();

  my $faRes = $owner-&gt;importNexus(
    from =&gt; $opts-&gt;{from},
    import =&gt; "reader",
  );

  my $faPrint = $owner-&gt;importNexus(
    from =&gt; $opts-&gt;{to},
    import =&gt; "writer",
  );

  my $lbResult = $faRes-&gt;getLabel("result");
  my $lbResBegin = $faRes-&gt;getLabel("_BEGIN_");
  my $lbResEnd = $faRes-&gt;getLabel("_END_");

  my $lbPrintRaw = $faPrint-&gt;getLabel("raw");
  my $lbPrintCooked = $faPrint-&gt;getLabel("cooked");

  my $seq = 1; # next expected sequence
  my @trays; # trays held for reordering: $trays[0] is the slot for sequence $seq
    # (only of course that slot will be always empty but the following ones may
    # contain the trays that arrived out of order)
  my $curseq; # the sequence of the current arriving tray</pre><p>
		The collator thread starts very much as usual. It has its expectation
		of the next tray in order, which gets set correctly. The trays that
		arrive out of order will be buffered in the array <code class="computeroutput">@trays</code>. Well, more
		exactly, for simplicity, all the trays get buffered there and then sent
		on if their turn has come. But it's possible to make an optimized
		version that would let the data flow through immediately if it's
		arriving in order.
		</p><pre class="programlisting">  # The processing of data after it has been "cooked", i.e. reordered.
  my $bindRes = Triceps::FnBinding-&gt;new(
    name =&gt; "bindRes",
    on =&gt; $faRes-&gt;getFnReturn(),
    unit =&gt; $unit,
    withTray =&gt; 1,
    labels =&gt; [
      "_BEGIN_" =&gt; sub {
        $unit-&gt;makeHashCall($lbPrintCooked, "OP_INSERT", text =&gt; $_[1]-&gt;printP("BEGIN"));
      },
      "result" =&gt; sub {
        $unit-&gt;makeHashCall($lbPrintCooked, "OP_INSERT", text =&gt; $_[1]-&gt;printP("result"));
      }
    ],
  );
  $faRes-&gt;getFnReturn()-&gt;push($bindRes); # will stay permanently</pre><p>
		The data gets collected into trays through a binding that gets
		permanently pushed onto the facet's FnReturn. Then when the tray's
		turn comes, it will be simply called and will produce the print calls
		for the cooked data order.
		</p><pre class="programlisting">  # manipulation of the reordering,
  # and along the way reporting of the raw sequence
  $lbResBegin-&gt;makeChained("lbBegin", undef, sub {
    $unit-&gt;makeHashCall($lbPrintRaw, "OP_INSERT", text =&gt; $_[1]-&gt;printP("BEGIN"));
    $curseq = $_[1]-&gt;getRow()-&gt;get("seq");
  });
  $lbResult-&gt;makeChained("lbResult", undef, sub {
    $unit-&gt;makeHashCall($lbPrintRaw, "OP_INSERT", text =&gt; $_[1]-&gt;printP("result"));
  });
  $lbResEnd-&gt;makeChained("lbEnd", undef, sub {
    my $tray = $bindRes-&gt;swapTray();
    if ($curseq == $seq) {
      $unit-&gt;call($tray);
      shift @trays;
      $seq++;
      while ($#trays &gt;= 0 &amp;&amp; defined($trays[0])) {
        # flush the trays that arrived misordered
        $unit-&gt;call(shift @trays);
        $seq++;
      }
    } elsif ($curseq &gt; $seq) {
      $trays[$curseq-$seq] = $tray; # remember for the future
    } else {
      # should never happen but just in case
      $unit-&gt;call($tray);
    }
  });

  $owner-&gt;readyReady();

  $owner-&gt;mainLoop();
};</pre><p>
		The input rowops are not only collected in the binding's tray but also
		chained directly to the labels that print the raw order of arrival. The
		handling of <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> also remembers its sequence number.
		</p><p>
		The handler of <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> (the <span class="quote">&#8220;<span class="quote">_END_</span>&#8221;</span> rowops get produced implicitly at the end
		of transaction) then does the heavy lifting. It looks at the sequence
		number remembered from <span class="quote">&#8220;<span class="quote">_BEGIN_</span>&#8221;</span> and makes the decision. If the received
		sequence is the next expected one, the data collected in the tray gets
		sent on immediately, and then the contents of the <code class="computeroutput">@trays</code> array 
		continues being
		sent on until it hits a blank spot of missing data. Or if the received
		sequence leaves a gap, the tray is placed into an appropriate spot in
		<code class="computeroutput">@trays</code> for later processing.
		</p><p>
		This whole logic can be encapsulated in a class but I haven't decided
		yet on the best way to do it. Maybe some time in the future. 
		</p></div></div><div class="chapter" title="Chapter 17. TQL, Triceps Trivial Query Language"><div class="titlepage"><div><div><h2 class="title"><a name="ch_tql"></a>Chapter 17. TQL, Triceps Trivial Query Language</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_tql_intro">17.1. Introduction to TQL</a></span></dt><dt><span class="sect1"><a href="#sc_tql_syntax">17.2. TQL syntax</a></span></dt><dt><span class="sect1"><a href="#sc_tql_commands">17.3. TQL commands</a></span></dt><dt><span class="sect1"><a href="#sc_tql_single">17.4. TQL in a single-threaded server</a></span></dt><dt><span class="sect1"><a href="#sc_tql_multi">17.5. TQL in a multi-threaded server</a></span></dt><dt><span class="sect1"><a href="#sc_tql_join_internals">17.6. Internals of a TQL join</a></span></dt></dl></div><div class="sect1" title="17.1. Introduction to TQL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_tql_intro"></a>17.1. Introduction to TQL</h2></div></div></div><a class="indexterm" name="id462115"></a><a class="indexterm" name="id519339"></a><a class="indexterm" name="id462445"></a><p>
		Triceps by itself is a library that can be embedded into any program
		to add the CEP functionality. But sometimes having a ready server process
		that handles the communications and queries and wraps the CEP logic
		within itself is a great convenience.  TQL, the Triceps Trivial Query 
		Language, is used in this server.
		</p><p>
		The server is useful as both a tool to play with Triceps programs
		and as an example of implementation.
		It all started with the example of simple queries in 
		<a class="xref" href="#sc_sched_mainloop_socket" title="7.9. Main loop with a socket">Section 7.9: &#8220;Main loop with a socket&#8221; </a>,
		then I've wanted to use the queries to demonstrate a feature of the
		streaming functions, then I've wanted to use it for a threaded
		logic demonstration, so it has been growing over time.
		</p><p>
		This server and the TQL are so far of only an example quality, but TQL
		is extensible and it already can do some interesting things.
		The <span class="quote">&#8220;<span class="quote">example quality</span>&#8221;</span> means that they work but
		the set of commands is limited and they
		don't have an extensive set of tests for every possibility,
		so it could happen that some corner cases don't work so well.
		</p><p>
		Why not SQL, after all, there are multiple parser building tools
		available in Perl? Partially, because I wanted to keep it trivial and
		to avoid introducing extra dependencies, especially just for the
		examples. Partially, because I don't like SQL. I think that the queries
		can be expressed much more naturally in the form of shell-like
		pipelines. At one of my past jobs I wrote a simple toolkit for querying and
		comparison of the CSV files (yeah, I didn't find the DBD::CSV module),
		I've used a pipeline semantics and it worked pretty well. It also did
		things that are quite difficult with SQL, like mass renaming and
		reordering of fields, and diffing. Although TQL is not a descendant of
		the language I've used in that query tool, it is a further development
		of the pipeline idea. As I've found later, there are other products
		that also use the pipeline approach for the queries, such as the PowerShell.
		</p></div><div class="sect1" title="17.2. TQL syntax"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_tql_syntax"></a>17.2. TQL syntax</h2></div></div></div><p>
		Syntactically, TQL is very simple: its query is represented as a
		nested list, similar to Tcl (or if you like Lisp better, you can think
		that it's similar to Lisp but with different parentheses). A list is
		surrounded by curly braces <span class="quote">&#8220;<span class="quote">{}</span>&#8221;</span>. The elements of a list are either
		other lists or words consisting of non-space characters.
		</p><pre class="programlisting">{word1 {word21 word22} word3}</pre><p>
		Unlike Tcl, there are no quotes in the TQL syntax, the quote characters
		are just the normal word characters. If you want to include spaces into
		a word, you use the curly braces instead of the quotes.
		</p><pre class="programlisting">{ this is a {brace-enquoted} string with spaces and nested braces }</pre><p>
		Note that the spaces inside a list are used as delimiters and thrown
		away but within a brace-quoted word-string they are significant. How do
		you know, which way they will be treated in a particular case? It all
		depends on what is expected in this case. If the command expects a
		string as an argument, it will treat it as a string. If the command
		expects a list as an argument, it will treat it as a list.
		</p><p>
		What if you need to include an unbalanced brace character inside a
		string? Escape it with a backslash, <span class="quote">&#8220;<span class="quote">\{</span>&#8221;</span>. The other usual Perl
		backslash sequences work too (though in the future TQL may get
		separated from Perl and then only the C sequences will work, that is to
		be seen). Any non-alphanumeric characters (including spaces) can be
		prepended with a backslash too. An important point is that when you
		build the lists, unlike shell, and like Tcl, you do the backslash
		escaping only once, when accepting a raw string. After that you can
		include the string with escapes into the lists of any depth without any
		extra escapes (and you must not add any extra escapes in the lists).
		</p><p>
		Unlike shell, you can't combine a single string out of the quoted and
		unquoted parts. Instead the quoting braces work as implicit separators.
		For example, if you specify a list as {a{b}c d}, you don't get two
		strings <span class="quote">&#8220;<span class="quote">abc</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">d</span>&#8221;</span>, you get four 
		strings <span class="quote">&#8220;<span class="quote">a</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">b</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">c</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">d</span>&#8221;</span>.
		</p><p>
		The parsing of the lists is done with the package Braced, with some more
		examples shown in 
		<a class="xref" href="#sc_ref_braced" title="19.16. Braced reference">Section 19.16: &#8220;Braced reference&#8221; </a>.
		</p><p>
		A TQL query is a list that represents a pipeline. Each element of the
		list is a command. The first command reads the data from a table, and
		the following commands perform transformations on that data. For
		example:
		</p><pre class="programlisting">{read table tWindow} {project fields {symbol price}} {print tokenized
    0}</pre><p>
		If the print command is missing at the end of the pipeline, it will be
		added implicitly, with the default arguments: <code class="computeroutput">{print}</code>.
		</p><p>
		The arguments of each TQL command are always in the option name-value
		format, very much like the Perl constructors of many Triceps objects.
		There aren't any arguments in TQL that go by themselves without an
		option name.
		</p><p>
		So for example the command <code class="computeroutput">read</code> above has an option <span class="quote">&#8220;<span class="quote">table</span>&#8221;</span> with
		value <span class="quote">&#8220;<span class="quote">tWindow</span>&#8221;</span>. The command <code class="computeroutput">project</code> has an option <span class="quote">&#8220;<span class="quote">fields</span>&#8221;</span> with a
		list value of two elements. In this case the elements are simple words
		and don't need the further bracing. But the braces around it won't hurt.
		Say, if you wanted to rename the field <span class="quote">&#8220;<span class="quote">price</span>&#8221;</span> to <span class="quote">&#8220;<span class="quote">trade_price</span>&#8221;</span>, you
		use the <code class="computeroutput">Triceps::Fields::filter()</code> syntax for it, and even though the
		format doesn't contain any spaces and can be still used just as a word,
		it looks nicer with the braces around it:
		</p><pre class="programlisting">{project fields {symbol {price/trade_price} }}</pre></div><div class="sect1" title="17.3. TQL commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_tql_commands"></a>17.3. TQL commands</h2></div></div></div><p>
		I'm sure that the list of commands and their options will expand and
		change over time. So far the supported commands are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">read</code></span></dt><dd><p>
			Defines a table to read from and starts the command pipeline.
			</p><p>
			Options:
			</p><p>
			<code class="computeroutput">table</code> - name of the table to read from. When a Triceps
			model gets wrapped in the server, it defines, what tables it has
			available.
			</p></dd><dt><span class="term"><code class="computeroutput">project</code></span></dt><dd><p>
			Projects (and possibly renames) a subset of fields in the current
			pipeline. In other words, all the files besides the specified
			ones get thrown away.
			</p><p>
			Options:
			</p><p>
			<code class="computeroutput">fields</code> - an array of field definitions in the syntax of
			<code class="computeroutput">Triceps::Fields::filter()</code> (same as in the joins), as described in
			<a class="xref" href="#sc_ref_fields" title="19.12. Fields reference">Section 19.12: &#8220;Fields reference&#8221; </a>.
			</p></dd><dt><span class="term"><code class="computeroutput">print</code></span></dt><dd><p>
			The last command of the pipeline, which prints the results. If not
			used explicitly, the query adds this command implicitly at the end
			of the pipeline, with the default options.
			</p><p>
			Options:
			</p><p>
			<code class="computeroutput">tokenized</code> (optional) - Flag: print in the name-value format, as in
			Row::printP(). Otherwise prints only the values in the CSV format.
			Default: 1.
			</p></dd><dt><span class="term"><code class="computeroutput">join</code></span></dt><dd><p>
			Joins the current pipeline with another table. This is the functionally
			similar to LookupJoin, although the options are closer to JoinTwo.
			</p><p>
			Options:
			</p><p>
			<code class="computeroutput">table</code> - name of the table to join with. The current pipeline is
			considered the <span class="quote">&#8220;<span class="quote">left side</span>&#8221;</span>, the table the <span class="quote">&#8220;<span class="quote">right side</span>&#8221;</span>. The
			duplicate key fields on the right side are always excluded from the
			result, as by the LookupJoin option <code class="computeroutput">fieldsDropRightKey =&gt; 1</code>.
			</p><p>
			<code class="computeroutput">rightIdxPath</code> (optional) - path name of the table's index on which to join.
			As usual, the path is an array of nested index type names. If this option is not
			specified, the index path will be found automatically by the join fields.
			</p><p>
			<code class="computeroutput">by</code> (semi-optional) - the join equality condition specified as pairs
			of fields. Similarly to JoinTwo, it's a single-level array with the
			fields logically paired:{leftFld1 rightFld1 leftFld2 rightFld2 ...
			}.  Options <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span> are mutually exclusive, and one of
			them must be present.
			</p><p>
			<code class="computeroutput">byLeft</code> (semi-optional) - the join equality condition specified as a
			transformation on the left-side field set in the syntax of
			<code class="computeroutput">Triceps::Fields::filter()</code>, with an implicit element <code class="computeroutput">{!.*}</code> added at
			the end. Options <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span> are mutually exclusive, and one
			of them must be present.
			</p><p>
			<code class="computeroutput">leftFields</code> (optional) - the list of patterns for the left-side
			fields to pass through and possibly rename, in the syntax of
			<code class="computeroutput">Triceps::Fields::filter()</code>. Default: pass all, with the same name.
			</p><p>
			<code class="computeroutput">rightFields</code> (optional) - the list of patterns for the right-side
			fields to pass through and possibly rename, in the syntax of
			<code class="computeroutput">Triceps::Fields::filter()</code>. The key fields get implicitly removed
			before. Default: pass all, with the same name.
			</p><p>
			<code class="computeroutput">type</code> (optional) - type of the join, <span class="quote">&#8220;<span class="quote">inner</span>&#8221;</span> or 
			<span class="quote">&#8220;<span class="quote">left</span>&#8221;</span>. Default: <span class="quote">&#8220;<span class="quote">inner</span>&#8221;</span>.
			</p></dd><dt><span class="term"><code class="computeroutput">where</code></span></dt><dd><p>
			Filters/selects the rows.
			</p><p>
			Options:
			</p><p>
			<code class="computeroutput">istrue</code> - a Perl expression, the condition for the rows to pass
			through. The particularly dangerous constructions are not allowed
			in the expression, including the loops and the general function
			calls. The fields of the row are referred to as <code class="computeroutput">$%field</code>, these
			references get translated before the expression is compiled.
			</p></dd></dl></div><p>
		Here are some examples of the Tql queries, with results produced from
		the output of the code examples that will be shown below.
		</p><pre class="programlisting"><span class="bold"><strong>query,{read table tSymbol}</strong></span>
query OP_INSERT symbol="AAA" name="Absolute Auto Analytics Inc"
    eps="0.5"
+EOD,OP_NOP,query</pre><p>
		Reads the stock symbol information table and prints it in the default
		tokenized format. The input line is CSV, containing as usual in the examples
		from
		<a class="xref" href="#sc_sched_mainloop_socket" title="7.9. Main loop with a socket">Section 7.9: &#8220;Main loop with a socket&#8221; </a>,
		the command and the data for it. Here the command <span class="quote">&#8220;<span class="quote">query</span>&#8221;</span>
		has been defined to handle the TQL queries. It's possible to define
		multiple TQL-handling commands in a server, in case if you want them
		to query different units, or different subsets of the tables.
		The parsing of the data part is
		smart enough not to break up the text of the query on the commas in it.
		</p><p>
		The tokenized result format is a bit messy for now, a mix of
		tokenized data lines and a CSV end-of-data line. 
		</p><p>
		In the simpler examples in
		<a class="xref" href="#sc_sched_mainloop_socket" title="7.9. Main loop with a socket">Section 7.9: &#8220;Main loop with a socket&#8221; </a>
		the end-of-data has been marked by either a row with opcode <code class="computeroutput">OP_NOP</code> or not
		marked at all. For the TQL queries I've decided to try out a
		different approach: send a CSV row on the pseudo-label <span class="quote">&#8220;<span class="quote">+EOD</span>&#8221;</span> with the
		value equal to the name of the command that has been completed. The
		labels with names starting with <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span> are special in this convention,
		they represent some kind of metadata.
		</p><pre class="programlisting"><span class="bold"><strong>query,{read table tWindow} {project fields {symbol price}}</strong></span>
query OP_INSERT symbol="AAA" price="20"
query OP_INSERT symbol="AAA" price="30"
+EOD,OP_NOP,query</pre><p>
		Reads the trade window rows and projects the fields <span class="quote">&#8220;<span class="quote">symbol</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">price</span>&#8221;</span> from them.
		</p><pre class="programlisting"><span class="bold"><strong>query,{read table tWindow} {project fields {symbol price}} {print
    tokenized 0}</strong></span>
query,OP_INSERT,AAA,20
query,OP_INSERT,AAA,30
+EOD,OP_NOP,query</pre><p>
		The same, only explicitly prints the data in the CSV format.
		</p><pre class="programlisting"><span class="bold"><strong>query,{read table tWindow} {where istrue {$%price == 20}}</strong></span>
query OP_INSERT id="3" symbol="AAA" price="20" size="20"
+EOD,OP_NOP,query</pre><p>
		Selects the trade window row with price equal to 20.
		</p><pre class="programlisting"><span class="bold"><strong>query,{read table tWindow} {join table tSymbol byLeft {symbol}}</strong></span>
query OP_INSERT id="3" symbol="AAA" price="20" size="20"
    name="Absolute Auto Analytics Inc" eps="0.5"
query OP_INSERT id="5" symbol="AAA" price="30" size="30"
    name="Absolute Auto Analytics Inc" eps="0.5"
+EOD,OP_NOP,query</pre><p>
		Reads the trade window and enriches it by joining with the symbol
		information.
		</p><p>
		A nice feature of TQL is that it allows to combine the operations in
		the pipeline in any order, repeated any number of times. For example,
		you can read a table, filter it, join with another table, filter again,
		join with the third table, filter again and so on. SQL in the same
		situation has to resort to specially named clauses, for example <span class="emphasis"><em>WHERE</em></span>
		filters before grouping and <span class="emphasis"><em>HAVING</em></span> filters after grouping.
		</p><p>
		Of course, a typical smart SQL compiler would determine the earliest
		application point for each <span class="emphasis"><em>WHERE</em></span> sub-expression and build a similar
		pipeline. But TQL allows to keep the compiler trivial, following the
		explicit pipelining in the query. And nothing really prevents a smart
		TQL compiler either, it could as well analyze, split and reorder the
		pipeline stages. 
		</p><p>
		As mentioned above, the TQL queries are compiled before the execution
		into the normal Triceps code. A query is built in a separate unit.
		After the query is built, the data is fed into it to produce the
		result, and then the unit gets destroyed. Potentially, TQL could
		be extended for writing the general Triceps programs as well.
		</p></div><div class="sect1" title="17.4. TQL in a single-threaded server"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_tql_single"></a>17.4. TQL in a single-threaded server</h2></div></div></div><a class="indexterm" name="id543386"></a><p>
		The TQL support may be instantiated in both the single-threaded and
		multi-threaded applications. The single-threaded support is simpler,
		so we'll look at it first. The TQL itself stays the same in both cases,
		and even the way to construct the TQL server is similar but then
		the way for the TQL queries to extract the data from the application
		is different.
		</p><p>
		The code that produced the query output examples from the previous section
		looks like this:
		</p><pre class="programlisting"># The basic table type to be used for querying.
# Represents the trades reports.
our $rtTrade = Triceps::RowType-&gt;new(
  id =&gt; "int32", # trade unique id
  symbol =&gt; "string", # symbol traded
  price =&gt; "float64",
  size =&gt; "float64", # number of shares traded
);

our $ttWindow = Triceps::TableType-&gt;new($rtTrade)
  -&gt;addSubIndex("bySymbol",
    Triceps::SimpleOrderedIndex-&gt;new(symbol =&gt; "ASC")
      -&gt;addSubIndex("last2",
        Triceps::IndexType-&gt;newFifo(limit =&gt; 2)
      )
  )
;
$ttWindow-&gt;initialize();

# Represents the static information about a company.
our $rtSymbol = Triceps::RowType-&gt;new(
  symbol =&gt; "string", # symbol name
  name =&gt; "string", # the official company name
  eps =&gt; "float64", # last quarter earnings per share
);

our $ttSymbol = Triceps::TableType-&gt;new($rtSymbol)
  -&gt;addSubIndex("bySymbol",
    Triceps::IndexType-&gt;newHashed(key =&gt; [ "symbol" ])
  )
;
$ttSymbol-&gt;initialize();

my $uTrades = Triceps::Unit-&gt;new("uTrades");
my $tWindow = $uTrades-&gt;makeTable($ttWindow, "tWindow");
my $tSymbol = $uTrades-&gt;makeTable($ttSymbol, "tSymbol");

# The information about tables, for querying.
my $tql = Triceps::X::Tql-&gt;new(
  name =&gt; "tql",
  tables =&gt; [
    $tWindow,
    $tSymbol,
  ],
);

my %dispatch;
$dispatch{$tWindow-&gt;getName()} = $tWindow-&gt;getInputLabel();
$dispatch{$tSymbol-&gt;getName()} = $tSymbol-&gt;getInputLabel();
$dispatch{"query"} = sub { $tql-&gt;query(@_); };
$dispatch{"exit"} = \&amp;Triceps::X::SimpleServer::exitFunc;

# calls Triceps::X::SimpleServer::startServer(0, \%dispatch);
Triceps::X::DumbClient::run(\%dispatch);</pre><p>
		It's very much like the example shown before in
		<a class="xref" href="#sc_sched_mainloop_socket" title="7.9. Main loop with a socket">Section 7.9: &#8220;Main loop with a socket&#8221; </a>,
		with one of the dispatch entries being a TQL query method.
		The list of tables is given to the Tql object which figures
		out all by itself how to run the queries on them.
		</p><p>
		Just as before, DumbClient is a class for both starting the server
		and running the unit tests on it, so in reality the dispatch
		table is handled in <code class="computeroutput">SimpleServer::startServer()</code>.
		</p><p>
		The dispatched labels have the CSV line received from the socket broken
		up into the fields and formed into the rowops but
		the dispatched functions receive the whole argument
		line as the client had sent it.
		The functions can then do the text parsing
		in their own way, which comes real handy for TQL. The <code class="computeroutput">Tql::query()</code>
		method splits off the name of the label to be used as the name of
		the query, and parses the rest as the query body.
		</p><p>
		There are multiple ways to create a Tql object. By default the
		option <span class="quote">&#8220;<span class="quote">tables</span>&#8221;</span> lists all the queryable tables, and their <span class="quote">&#8220;<span class="quote">natural</span>&#8221;</span>
		names will be used in the queries, as was shown above. It's possible to specify the names
		explicitly as well:
		</p><pre class="programlisting">my $tql = Triceps::X::Tql-&gt;new(
  name =&gt; "tql",
  tables =&gt; [
    $tWindow,
    $tSymbol,
    $tWindow,
    $tSymbol,
  ],
  tableNames =&gt; [
    "window",
    "symbol",
    $tWindow-&gt;getName(),
    $tSymbol-&gt;getName(),
  ],
);</pre><p>
		This version defines each table under two synonymous names. The tables
		and their names go in the parallel arrays in the same order.
		</p><p>
		It's also possible to create a Tql object without tables, and add tables to it
		later as they are created:
		</p><pre class="programlisting">my $tql = Triceps::X::Tql-&gt;new(name =&gt; "tql");
$tql-&gt;addNamedTable(
  window =&gt; $tWindow,
  symbol =&gt; $tSymbol,
);
# add 2nd time, with different names
$tql-&gt;addTable(
  $tWindow,
  $tSymbol,
);
$tql-&gt;initialize();</pre><p>
		Multiple tables can be added in one method call, as shown here.
		The tables can be added with explicit names or with <span class="quote">&#8220;<span class="quote">natural</span>&#8221;</span> names.
		After all the tables are added, the Tql object has to be initialized.
		</p><p>
		The two ways of creation are mutually exclusive: if the option <span class="quote">&#8220;<span class="quote">tables</span>&#8221;</span>
		is used, the object will be initialized right away in the constructor.
		If this option is absent, the explicit initialization has to be done later. The
		methods <code class="computeroutput">addTable()</code> and <code class="computeroutput">addNamedTable()</code> cannot be used on an
		initialized table, and <code class="computeroutput">query()</code> cannot be used on an uninitialized
		table. 
		</p></div><div class="sect1" title="17.5. TQL in a multi-threaded server"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_tql_multi"></a>17.5. TQL in a multi-threaded server</h2></div></div></div><a class="indexterm" name="id545537"></a><p>
		As the single-threaded version of TQL works
		symbiotically with the SimpleServer, the multithreaded version works
		with the ThreadedServer. The multithreaded version of TQL does all
		that the single-threaded one does, and more: it allows to define
		the dynamic queries. Some day TQL might become the language to
		define the whole Triceps models.
		</p><p>
		One thread created by the programmer contains the <span class="quote">&#8220;<span class="quote">core logic</span>&#8221;</span> of the
		model. It doesn't technically have to be all in a single thread: the
		data can be forwarded to the other threads and then the results
		forwarded back from them. But a single core logic thread is a
		convenient simplification. This thread has some input labels, to
		receive data from the outside, and some tables with the computed
		results that can be read by TQL. Of course, it's entirely realistic to
		have also just the output labels without tables, sending a stream of
		computed rowops, but again for simplicity let's leave this out for now.
		</p><p>
		This core logic thread creates a TQL instance, which listens on a
		socket, accepts the connections, forwards the input data to the core
		logic, performs queries on the tables from the core logic and sends the
		results back to the client. To this end, the TQL instance creates a few
		nexuses in the core logic thread and uses them to communicate between
		all the fragments. The input labels and tables in the core thread also
		get properly connected to these nexuses. 
		<a class="xref" href="#fig_tql_multi" title="Figure 17.1. Multithreaded TQL application structure.">Figure 17.1</a>
		shows the thread structure, I'll use it for the reference throughout
		the discussion.
		</p><div class="figure"><a name="fig_tql_multi"></a><div class="figure-contents"><div><img src="tql-010-mt-over.lowres.png" width="NaN" alt="Multithreaded TQL application structure."></div></div><p class="title"><b>Figure 17.1. Multithreaded TQL application structure.</b></p></div><br class="figure-break"><p>
		The core logic thread then goes into its main loop and performs as its
		name says, the core logic computations.
		</p><p>
		Here is a very simple example of a TQL application:
		</p><pre class="programlisting">sub appCoreT # (@opts)
{
  my $opts = {};
  &amp;Triceps::Opt::parse("appCoreT", $opts, {@Triceps::Triead::opts,
    socketName =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
  }, @_);
  undef @_; # avoids a leak in threads module
  my $owner = $opts-&gt;{owner};
  my $app = $owner-&gt;app();
  my $unit = $owner-&gt;unit();

  # build the core logic

  my $rtTrade = Triceps::RowType-&gt;new(
    id =&gt; "int32", # trade unique id
    symbol =&gt; "string", # symbol traded
    price =&gt; "float64",
    size =&gt; "float64", # number of shares traded
  );

  my $ttWindow = Triceps::TableType-&gt;new($rtTrade)
    -&gt;addSubIndex("byId",
      Triceps::SimpleOrderedIndex-&gt;new(id =&gt; "ASC")
    )
  ;
  $ttWindow-&gt;initialize();

  # Represents the static information about a company.
  my $rtSymbol = Triceps::RowType-&gt;new(
    symbol =&gt; "string", # symbol name
    name =&gt; "string", # the official company name
    eps =&gt; "float64", # last quarter earnings per share
  );

  my $ttSymbol = Triceps::TableType-&gt;new($rtSymbol)
    -&gt;addSubIndex("bySymbol",
      Triceps::SimpleOrderedIndex-&gt;new(symbol =&gt; "ASC")
    )
  ;
  $ttSymbol-&gt;initialize();

  my $tWindow = $unit-&gt;makeTable($ttWindow, "tWindow");
  my $tSymbol = $unit-&gt;makeTable($ttSymbol, "tSymbol");

  # export the endpoints for TQL (it starts the listener)
  my $tql = Triceps::X::Tql-&gt;new(
    name =&gt; "tql",
    trieadOwner =&gt; $owner,
    socketName =&gt; $opts-&gt;{socketName},
    tables =&gt; [
      $tWindow,
      $tSymbol,
    ],
    tableNames =&gt; [
      "window",
      "symbol",
    ],
    inputs =&gt; [
      $tWindow-&gt;getInputLabel(),
      $tSymbol-&gt;getInputLabel(),
    ],
    inputNames =&gt; [
      "window",
      "symbol",
    ],
  );

  $owner-&gt;readyReady();

  $owner-&gt;mainLoop();
}

{
  my ($port, $thread) = Triceps::X::ThreadedServer::startServer(
      app =&gt; "appTql",
      main =&gt; \&amp;appCoreT,
      port =&gt; 0,
      fork =&gt; -1, # create a thread, not a process
  );
}</pre><p>
		This core logic is the same as in the single-threaded example:
		all it does is create two tables and
		then send the input data into them. The server gets started in a
		background thread (<code class="computeroutput">fork =&gt; -1</code>) because this code is taken from a test
		that then goes and runs the <code class="computeroutput">expect</code> with the ThreadedClient.
		</p><p>
		The specification of tables for TQL is the same as for the 
		single-threaded version.
		The new options available only in the multi-threaded mode
		are the <span class="quote">&#8220;<span class="quote">threadOwner</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">inputs</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">inputNames</span>&#8221;</span>. The <span class="quote">&#8220;<span class="quote">threadOwner</span>&#8221;</span>
		is how TQL knows that it must run in the multithreaded mode, and it's
		used to create the nexuses for communication between the core logic and
		the rest of TQL. The <span class="quote">&#8220;<span class="quote">inputs</span>&#8221;</span> are needed because the multithreaded TQL
		parses and forwards the input data, unlike the single-threaded version
		that relies on the SimpleServer to do that according to the
		user-defined dispatch table.
		</p><p>
		The names options don't have to be used: if you name your labels and
		tables nicely and suitable for the external vieweing, the
		renaming-for-export can be skipped.
		</p><p>
		Similarly to the single-threaded version, if any of the options <span class="quote">&#8220;<span class="quote">tables</span>&#8221;</span>
		or <span class="quote">&#8220;<span class="quote">inputs</span>&#8221;</span> is used, the TQL object gets initialized automatically,
		otherwise the tables and inputs can be added piecemeal with <code class="computeroutput">addTable()</code>,
		<code class="computeroutput">addNamedTable()</code>, <code class="computeroutput">addInput()</code>, <code class="computeroutput">addNamedInput()</code>, and then the whole thing
		initialized manually.
		</p><p>
		Then the clients can establish the connections with the TQL server,
		send in the data and the queries. To jump in, here is a trace of a
		simple session that sends some data, then does some table dumps and
		subscribes, not touching the queries yet. I'll go through it fragment
		by fragment and explain the meaning. The dumps and subscribes were the
		warm-up exercises before writing the full queries, but they're useful
		in their own right, and here they serve as the warm-up exercises for
		the making of the queries!
		</p><p>
		The trace is marked with the client name <span class="quote">&#8220;<span class="quote">c1</span>&#8221;</span>, just as it is in
		<a class="xref" href="#sc_mt_dynamic_server" title="16.6. Dynamic threads and fragments in a socket server">Section 16.6: &#8220;Dynamic threads and fragments in a socket server&#8221; </a>,
		since it's also a trace from SimpleClient.
		</p><pre class="programlisting"><span class="bold"><strong>connect c1</strong></span>
c1|ready</pre><p>
		The <span class="quote">&#8220;<span class="quote">connect</span>&#8221;</span> is not an actual command send but just the indication in
		the trace that the connection was set up by the client <span class="quote">&#8220;<span class="quote">c1</span>&#8221;</span>.  The
		<span class="quote">&#8220;<span class="quote">ready</span>&#8221;</span> response is sent when the connection is opened.
		</p><pre class="programlisting"><span class="bold"><strong>c1|subscribe,s1,symbol</strong></span>
c1|subscribe,s1,symbol</pre><p>
		This is a subscription request. It means <span class="quote">&#8220;<span class="quote">I'm not interested in the
		current state of a table but send me all the updates</span>&#8221;</span>. The response is
		the mirror of the request, so that the client knows that the request
		has been processed. The format of the requests is different in the
		multi-threaded mode than in the single-threaded, it has the extra elements.
		The first element is always the command.
		<span class="quote">&#8220;<span class="quote">s1</span>&#8221;</span> is the unique identifier of the request, so
		that the client can match together the responses it received to the
		requests it sent. Keeping the uniqueness is up to the client, the
		server may refuse the requests with duplicate identifiers.
		And <span class="quote">&#8220;<span class="quote">symbol</span>&#8221;</span> is the name of the table. Once a subscription is in place,
		there is no way to unsubscribe other than by disconnecting the client
		(it's doable but adds complications, and I wanted to skip over the
		nonessential parts). Subscribing multiple times to the same table will
		send a confirmation every time but the repeated confirmations will have
		no effect: only one copy of the data will be sent anyway.
		</p><p>
		Side-tracking a bit, if a second subscription attempt is to be
		done with the same id, the error would look like:
		</p><pre class="programlisting">error,s1,Duplicate id 's1': query ids must be unique,bad_id,s1</pre><p>
		The response type field contains <span class="quote">&#8220;<span class="quote">error</span>&#8221;</span>, followed by the id of the request,
		the error message, the error name, and the data that caused the error.
		</p><p>
		Let's send the data into the model:
		</p><pre class="programlisting"><span class="bold"><strong>c1|d,symbol,OP_INSERT,ABC,ABC Corp,1.0</strong></span>
c1|d,symbol,OP_INSERT,ABC,ABC Corp,1</pre><p>
		And since it propagates through the
		subscription, the data gets sent back too. The <span class="quote">&#8220;<span class="quote">symbol</span>&#8221;</span> here means two
		different things: on the input side it's the name of the label where
		the data is sent, on the output side it's the name of the table that
		has been subscribed to.
		</p><p>
		The data lines start with the command <span class="quote">&#8220;<span class="quote">d</span>&#8221;</span> (since the data is sent much
		more frequently than the commands, I've picked a short one-letter
		command name for it), then the label/table name, opcode and the row
		fields in CSV format.
		</p><pre class="programlisting"><span class="bold"><strong>c1|confirm,cf1</strong></span>
c1|confirm,cf1,,,</pre><p>
		The <span class="quote">&#8220;<span class="quote">confirm</span>&#8221;</span> command provides a way for the client to check that the
		data it send had propagated through the model. And it doesn't have to
		subscribe back to the data and read them. Send some data lines, then
		send the <span class="quote">&#8220;<span class="quote">confirm</span>&#8221;</span> command and wait for it to come back (again, the
		unique id allows to keep multiple confirmations in flight if you
		please). This command doesn't guarantee that all the clients have seen
		the results from that data. It only guarantees that the core logic had
		seen the data, and more weakly guarantees that the data had been
		processed by the core logic, and this particular client had already
		seen all the results from it.
		</p><p>
		Why weakly? It has to do with the way it works inside, and it depends
		on the core logic. If the core logic consists of one thread, the
		guarantee is quite strong. But if the core logic farms out the work
		from the main thread to the other threads and then collects the results
		back, the guarantee breaks.
		</p><p>
		You can see in
		<a class="xref" href="#fig_tql_multi" title="Figure 17.1. Multithreaded TQL application structure.">Figure 17.1</a>
		that unlike the chat server shown 
		<a class="xref" href="#sc_mt_dynamic_server" title="16.6. Dynamic threads and fragments in a socket server">Section 16.6: &#8220;Dynamic threads and fragments in a socket server&#8221; </a>,
		TQL doesn't have any private nexuses for communication between the reader
		and writer threads of a client. Instead it relies on the same input and
		output nexuses, adding a control label to them, to forward the commands
		from the reader to the writer. The TQL object in the core logic thread
		creates a short-circuit connection between the control labels in the
		input and output nexuses, forwarding the commands. And if the core
		logic all runs in one thread, this creates a natural pipeline: the data
		comes in, gets processed, comes out, the <span class="quote">&#8220;<span class="quote">confirm</span>&#8221;</span> command comes in,
		comes out after the data. But if the core logic farms out the work to
		more threads, the confirmation can <span class="quote">&#8220;<span class="quote">jump the line</span>&#8221;</span> because its path is
		a direct short circuit.
		</p><pre class="programlisting"><span class="bold"><strong>c1|drain,dr1</strong></span>
c1|drain,dr1,,,</pre><p>
		The <span class="quote">&#8220;<span class="quote">drain</span>&#8221;</span> is an analog of <span class="quote">&#8220;<span class="quote">confirm</span>&#8221;</span> but more reliable and slower:
		the reader thread drains the whole model before sending the command on.
		This guarantees that all the processing is done, and all the output
		from it has been sent to all the clients.
		</p><pre class="programlisting"><span class="bold"><strong>c1|dump,d2,symbol</strong></span>
c1|startdump,d2,symbol
c1|d,symbol,OP_INSERT,ABC,ABC Corp,1
c1|dump,d2,symbol</pre><p>
		The <span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span> command dumps the current contents of a table. Its result
		starts with <span class="quote">&#8220;<span class="quote">startdump</span>&#8221;</span>, and the same id and table name as in the
		request, then goes the data (all with OP_INSERT), finishing with the
		completion confirmation echoing the original command. The dump is
		atomic, the contents of the table doesn't change in the middle of the
		dump. However if a subscription on this table is active, the data rows
		from that subscription may come before and after the dump.
		</p><pre class="programlisting"><span class="bold"><strong>c1|dumpsub,ds3,symbol</strong></span>
c1|startdump,ds3,symbol
c1|d,symbol,OP_INSERT,ABC,ABC Corp,1
c1|dumpsub,ds3,symbol</pre><p>
		The <span class="quote">&#8220;<span class="quote">dumpsub</span>&#8221;</span> command is a combination of a dump and subscribe: get the
		initial state and then get all the updates.  The confirmation of
		<span class="quote">&#8220;<span class="quote">dumpsub</span>&#8221;</span> marks the boundary between the original dump and the
		following updates.
		</p><pre class="programlisting"><span class="bold"><strong>c1|d,symbol,OP_INSERT,DEF,Defense Corp,2.0</strong></span>
c1|d,symbol,OP_INSERT,DEF,Defense Corp,2</pre><p>
		Send some more data, and it comes back only once, even though the
		subscription was done twice: once in <span class="quote">&#8220;<span class="quote">subscribe</span>&#8221;</span> and once in <span class="quote">&#8220;<span class="quote">dumpsub</span>&#8221;</span>.
		The repeated subscription requests simply get consumed into one
		subscription.
		</p><pre class="programlisting"><span class="bold"><strong>c1|d,window,OP_INSERT,1,ABC,101,10</strong></span></pre><p>
		This sends a row to the other table but nothing comes back because
		there is no subscription to that table.
		</p><pre class="programlisting"><span class="bold"><strong>c1|dumpsub,ds4,window</strong></span>
c1|startdump,ds4,window
c1|d,window,OP_INSERT,1,ABC,101,10
c1|dumpsub,ds4,window
<span class="bold"><strong>c1|d,window,OP_INSERT,2,ABC,102,12</strong></span>
c1|d,window,OP_INSERT,2,ABC,102,12</pre><p>
		This demonstrates the pure dump-and-subscribe without any interventions.
		</p><pre class="programlisting"><span class="bold"><strong>c1|shutdown</strong></span>
c1|shutdown,,,,
c1|__EOF__</pre><p>
		And the shutdown command works the same as in the chat server, draning
		and then shutting down the whole server.
		</p><p>
		Now on to the queries.
		</p><pre class="programlisting"><span class="bold"><strong>connect c1</strong></span>
c1|ready
<span class="bold"><strong>c1|d,symbol,OP_INSERT,ABC,ABC Corp,1.0</strong></span></pre><p>
		Starts a client connection and sends some data.
		</p><pre class="programlisting"><span class="bold"><strong>c1|querysub,q1,query1,{read table symbol}{print tokenized 0}</strong></span>
c1|d,query1,OP_INSERT,ABC,ABC Corp,1
c1|querysub,q1,query1</pre><p>
		The <span class="quote">&#8220;<span class="quote">querysub</span>&#8221;</span> command does the <span class="quote">&#8220;<span class="quote">query-and-subscribe</span>&#8221;</span>: reads the
		initial state of the table, processed through the query, and then
		subscribes to any future updates. The single-threaded variety of TQL
		doesn't do this, it does just the one-time queries. The multithreaded
		TQL could potentially do the one-time queries, and also just the subscribes
		without the initial state, but so far I've been cutting corners
		and the only thing that's actually available is the combination
		of two, the <span class="quote">&#8220;<span class="quote">querysub</span>&#8221;</span>.
		</p><p>
		Similarly to the other commands, <span class="quote">&#8220;<span class="quote">q1</span>&#8221;</span> is the command identifier. The next
		field <span class="quote">&#8220;<span class="quote">query1</span>&#8221;</span> is the name for the query, it's the name that will be
		shown for the data lines coming out of the query. And then goes the
		query in the brace-quoted format, same as in the single-threaded TQL (and
		there is no further splitting by commas, so the commas can be used
		freely in the query).
		</p><p>
		The identifier and the name of the query sound kind of redundant. But
		the client may generate them in different ways and need both. The name
		has the more symbolic character. The identifier can be generated as a
		sequence of numbers, so that the client can keep track of its progress
		more easily. And the error reports include the identifier but not the
		query name in them.
		</p><p>
		For the query, there is no special line coming out before the initial
		dump. Supposedly, there would not be more than one query in flight with
		the same name, so they could be easily told apart based on the name in
		the data lines. There is also an underlying consideration that when the
		query involves a join, in the future the initial dump might be
		happening in multiple chunks, requiring to either surround every chunk
		with the start-end lines or just let them go without the extra
		notifications, as they are now.
		</p><p>
		And the initial dump ends as usual with getting the echo of the command
		(without the query part) back.
		</p><p>
		This particular query is very simple and equivalent to a <span class="quote">&#8220;<span class="quote">dumpsub</span>&#8221;</span>.
		</p><pre class="programlisting"><span class="bold"><strong>c1|d,symbol,OP_INSERT,DEF,Defense Corp,2.0</strong></span>
c1|d,query1,OP_INSERT,DEF,Defense Corp,2</pre><p>
		Send more data and it will come out of the query.
		</p><pre class="programlisting"><span class="bold"><strong>c1|querysub,q2,query2,{read table symbol}{where istrue {$%symbol =~
    /^A/}}{project fields {symbol eps}}</strong></span>
c1|t,query2,query2 OP_INSERT symbol="ABC" eps="1"
c1|querysub,q2,query2</pre><p>
		This query is more complicated, doing a selection (the <span class="quote">&#8220;<span class="quote">where</span>&#8221;</span> query
		command) and projection. It also prints the results in the tokenized
		format (the <span class="quote">&#8220;<span class="quote">print</span>&#8221;</span> command gets added automatically if it wasn't used
		explicitly, and the default options for it enable the tokenized
		format).
		</p><p>
		The tokenized lines come out with the command <span class="quote">&#8220;<span class="quote">t</span>&#8221;</span>, query name and then
		the contents of the row. The query name happens to be sent twice, and
		I'm not sure yet if it's a feature or a bug.
		</p><pre class="programlisting"><span class="bold"><strong>c1|d,symbol,OP_INSERT,AAA,Absolute Auto Analytics Inc,3.0</strong></span>
c1|d,query1,OP_INSERT,AAA,Absolute Auto Analytics Inc,3
c1|t,query2,query2 OP_INSERT symbol="AAA" eps="3"
<span class="bold"><strong>c1|d,symbol,OP_DELETE,DEF,Defense Corp,2.0</strong></span>
c1|d,query1,OP_DELETE,DEF,Defense Corp,2</pre><p>
		More examples of the data sent, getting processed by both queries.  In
		the second case the <span class="quote">&#8220;<span class="quote">where</span>&#8221;</span> filters out the row from query2, so only
		query1 produces the result.
		</p><pre class="programlisting"><span class="bold"><strong>c1|shutdown</strong></span>
c1|shutdown,,,,
c1|__EOF__</pre><p>
		And the shutdown as usual.
		</p><p>
		Now the <span class="emphasis"><em>piece de resistance</em></span>: queries with joins.
		</p><pre class="programlisting"><span class="bold"><strong>connect c1</strong></span>
c1|ready
<span class="bold"><strong>c1|d,symbol,OP_INSERT,ABC,ABC Corp,2.0</strong></span>
<span class="bold"><strong>c1|d,symbol,OP_INSERT,DEF,Defense Corp,2.0</strong></span>
<span class="bold"><strong>c1|d,symbol,OP_INSERT,AAA,Absolute Auto Analytics Inc,3.0</strong></span>
<span class="bold"><strong>c1|d,window,OP_INSERT,1,AAA,12,100</strong></span></pre><p>
		Connect and send some starting data.
		</p><pre class="programlisting"><span class="bold"><strong>c1|querysub,q1,query1,{read table window}{join table symbol byLeft
    {symbol} type left}</strong></span>
c1|t,query1,query1 OP_INSERT id="1" symbol="AAA" price="12" size="100"
    name="Absolute Auto Analytics Inc" eps="3"
c1|querysub,q1,query1</pre><p>
		A left join of the tables <span class="quote">&#8220;<span class="quote">window</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">symbol</span>&#8221;</span>, by the field <span class="quote">&#8220;<span class="quote">symbol</span>&#8221;</span>
		as join condition.
		</p><p>
		The TQL joins, even in the multithreaded mode, are still implemented
		internally as LookupJoin, driven only by the main flow of the query. So
		the changes to the joined dimension tables will not update the query
		results, and will be visible only when a change on the main flow picks
		them up, potentially creating inconsistencies in the output. This is
		wrong, but fixing it presents complexities that I've left alone until
		some later time.
		</p><pre class="programlisting"><span class="bold"><strong>c1|d,window,OP_INSERT,2,ABC,13,100</strong></span>
c1|t,query1,query1 OP_INSERT id="2" symbol="ABC" price="13" size="100"
    name="ABC Corp" eps="2"
<span class="bold"><strong>c1|d,window,OP_INSERT,3,AAA,11,200</strong></span>
c1|t,query1,query1 OP_INSERT id="3" symbol="AAA" price="11" size="200"
    name="Absolute Auto Analytics Inc" eps="3"</pre><p>
		Sending the data updates the results of the query.
		</p><pre class="programlisting"><span class="bold"><strong>c1|d,symbol,OP_DELETE,AAA,Absolute Auto Analytics Inc,3.0</strong></span>
<span class="bold"><strong>c1|d,symbol,OP_INSERT,AAA,Alcoholic Abstract Aliens,3.0</strong></span></pre><p>
		As described above, the modifications of the dimension table are not
		visible in the query directly.
		</p><pre class="programlisting"><span class="bold"><strong>c1|d,window,OP_DELETE,1</strong></span>
c1|t,query1,query1 OP_DELETE id="1" symbol="AAA" price="12" size="100"
    name="Alcoholic Abstract Aliens" eps="3"</pre><p>
		But an update on the main flow brings them up (an in this case
		inconsistently, the row getting deleted is not exactly the same as the
		row inserted before).
		</p><pre class="programlisting"><span class="bold"><strong>c1|querysub,q2,query2,{read table window}{join table symbol byLeft
    {symbol} type left}{join table symbol byLeft {eps} type left
    rightFields {symbol/symbol2}}</strong></span>
c1|t,query2,query2 OP_INSERT id="2" symbol="ABC" price="13" size="100"
    name="ABC Corp" eps="2" symbol2="ABC"
c1|t,query2,query2 OP_INSERT id="2" symbol="ABC" price="13" size="100"
    name="ABC Corp" eps="2" symbol2="DEF"
c1|t,query2,query2 OP_INSERT id="3" symbol="AAA" price="11" size="200"
    name="Alcoholic Abstract Aliens" eps="3" symbol2="AAA"
c1|querysub,q2,query2</pre><p>
		This is a more complicated query, involving two joins, with the same
		dimension table <span class="quote">&#8220;<span class="quote">symbol</span>&#8221;</span>. The second join by <span class="quote">&#8220;<span class="quote">eps</span>&#8221;</span> makes no real-world
		sense whatsoever but it's interesting from the technical perspective:
		if you check the table type of this table at the start of the section,
		you'll find that it has no index on the field <span class="quote">&#8220;<span class="quote">eps</span>&#8221;</span>. The join adds this
		index on demand!
		</p><p>
		The way it works, all the dimension tables are copied into the client's
		writer thread, created from the table types exported by the core logic
		throuhg the output nexus. (And if a table is used in the same query
		twice, it's currently also copied twice). This provides a nice
		opportunity to amend the table type by adding any necessary secondary
		index before creating the table, and TQL makes a good use of it.
		</p></div><div class="sect1" title="17.6. Internals of a TQL join"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_tql_join_internals"></a>17.6. Internals of a TQL join</h2></div></div></div><p>
		The TQL implementation provides interesting examples of the
		sophisticated Triceps usage. Remember, it isn't somehow special
		or monolothic with the rest of Triceps. It uses the normal triceps
		API and anyone can write a similar language layer from scratch.
		The code is located in <code class="computeroutput">perl/Triceps/lib/Triceps/X/DumbClient.pm</code>.
		</p><p>
		The most complex operation implemented in TQL is the join in the
		multi-threaded server. It requires copying of multiple tables
		from the core logic thread to the client thread that executes
		the join, and rebuilding them in the new thread, possibly with
		the automatically added indexes.
		</p><p>
		It all starts in the Tql initialization method. In the multithreaded
		mode it builds the nexuses for communication. I'll skip the input nexus
		(it's straightforward) and show the building of only the output and
		request-dump nexuses:
		</p><pre class="programlisting">  # row type for dump requests and responses
  my $rtRequest = Triceps::RowType-&gt;new(
    client =&gt; "string", #requesting client
    id =&gt; "string", # request id
    name =&gt; "string", # the table name, for convenience of requestor
    cmd =&gt; "string", # for convenience of requestor, the command that it is executing
  );</pre><p>
		The request row type is used by the client writer thread to request the
		table dumps from the core logic, and to get back the notifications
		about the dumps.
		</p><pre class="programlisting">  # build the output side
  for (my $i = 0; $i &lt;= $#{$self-&gt;{tables}}; $i++) {
    my $name = $self-&gt;{tableNames}[$i];
    my $table = $self-&gt;{tables}[$i];

    push @tabtypes, $name, $table-&gt;getType()-&gt;copyFundamental();
    push @labels, "t.out." . $name, $table-&gt;getOutputLabel();
    push @labels, "t.dump." . $name, $table-&gt;getDumpLabel();
  }
  push @labels, "control", $rtControl; # pass-through from in to out
  push @labels, "beginDump", $rtRequest; # framing for the table dumps
  push @labels, "endDump", $rtRequest;

  $self-&gt;{faOut} = $owner-&gt;makeNexus(
    name =&gt; $self-&gt;{nxprefix} . "out",
    labels =&gt; [ @labels ],
    tableTypes =&gt; [ @tabtypes ],
    import =&gt; "writer",
  );
  $self-&gt;{beginDump} = $self-&gt;{faOut}-&gt;getLabel("beginDump");
  $self-&gt;{endDump} = $self-&gt;{faOut}-&gt;getLabel("endDump");</pre><p>
		On the output side each table is represented by 3 elements:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			its fundamental table type (stripped down to the primary index);
			</li><li class="listitem">
			its output label for normal updates;
			</li><li class="listitem">
			its dump label for the responses to the dump requests.
			</li></ul></div><p>
		There also are the <span class="quote">&#8220;<span class="quote">beginDump</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">endDump</span>&#8221;</span> labels that frame each
		response to a dump request.
		</p><p>
		The row type <code class="computeroutput">$rtControl</code> and label <span class="quote">&#8220;<span class="quote">control</span>&#8221;</span> are used to pass the
		commands from the client reader to client writer, but its exact
		contents is not important here.
		All the magic happens in the client writer thread. The
		reader thread just passes the commands to the writer thread, and then
		the writer thread controls the parsing and processing of the commands.
		</p><p>
		The dump request nexus is built in a similar way:
		</p><pre class="programlisting">  # build the dump requests, will be coming from below
  undef @labels;
  for (my $i = 0; $i &lt;= $#{$self-&gt;{tables}}; $i++) {
    my $name = $self-&gt;{tableNames}[$i];
    my $table = $self-&gt;{tables}[$i];

    push @labels, "t.rqdump." . $name, $rtRequest;
  }
  $self-&gt;{faRqDump} = $owner-&gt;makeNexus(
    name =&gt; $self-&gt;{nxprefix} . "rqdump",
    labels =&gt; [ @labels ],
    reverse =&gt; 1, # avoids making a loop, and gives priority
    import =&gt; "reader",
  );
  # tie together the labels
  for (my $i = 0; $i &lt;= $#{$self-&gt;{tables}}; $i++) {
    my $name = $self-&gt;{tableNames}[$i];
    my $table = $self-&gt;{tables}[$i];

    $self-&gt;{faRqDump}-&gt;getLabel("t.rqdump." . $name)-&gt;makeChained(
      $self-&gt;{nxprefix} . "rqdump." . $name, undef,
      \&amp;_dumpTable, $self, $table
    );
  }</pre><p>
		Each table has a label created for requesting its contents.
		The dumps are executed in the function _dumpTable:
		</p><pre class="programlisting">sub _dumpTable # ($label, $rowop, $self, $table)
{
  my ($label, $rop, $self, $table) = @_;
  my $unit = $label-&gt;getUnit();
  # pass through the client id to the dump
  $unit-&gt;call($self-&gt;{beginDump}-&gt;adopt($rop));
  $table-&gt;dumpAll();
  $unit-&gt;call($self-&gt;{endDump}-&gt;adopt($rop));
  $self-&gt;{faOut}-&gt;flushWriter();
}</pre><p>
		The data gets framed around by the 
		copies of the original request sent to the labels
		<span class="quote">&#8220;<span class="quote">beginDump</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">endDump</span>&#8221;</span>.
		This helps the client
		writer thread keep track of its current spot. The flushing of the
		writer is not strictly needed. Just in case if multiple dump requests
		are received in a single tray, the flush breaks up the responses into a
		separate tray for each dump, keeping the size of the trays lower. Not
		that this situation could actually happen yet.
		</p><p>
		This part taken care of, let's jump around and see how the client
		writer thread processes a <span class="quote">&#8220;<span class="quote">querysub</span>&#8221;</span> command:
		</p><pre class="programlisting">    } elsif ($cmd eq "querysub") {
      if ($id eq "" || exists $queries{$id}) {
        printOrShut($app, $fragment, $sock,
          "error,$id,Duplicate id '$id': query ids must be unique,bad_id,$id\n");
        next;
      }
      my $ctx = compileQuery(
        qid =&gt; $id,
        qname =&gt; $args[0],
        text =&gt; $args[1],
        subError =&gt; sub {
          chomp $_[2];
          $_[2] =~ s/\n/\\n/g; # no real newlines in the output
          $_[2] =~ s/,/;/g; # no confusing commas in the output
          printOrShut($app, $fragment, $sock, "error,", join(',', @_), "\n");
        },
        faOut =&gt; $faOut,
        faRqDump =&gt; $faRqDump,
        subPrint =&gt; sub {
          printOrShut($app, $fragment, $sock, @_);
        },
      );
      if ($ctx) { # otherwise the error is already reported
        $queries{$id} = $ctx;
        &amp;$runNextRequest($ctx);
      }
    }</pre><p>
		The query id is used to keep track of the outstanding queries, so the
		code makes sure that it's unique. This is the origin of the
		duplicate id error that was shown before.
		</p><p>
		The bulk of the work is done in the method
		<code class="computeroutput">compileQuery()</code>. Its arguments supply the details of the query and
		also provide the closures for the functionality that differs between
		the single-threaded and multi-threaded versions. The option <span class="quote">&#8220;<span class="quote">subError</span>&#8221;</span>
		is used to send the errors to the client, and <span class="quote">&#8220;<span class="quote">subPrint</span>&#8221;</span> is used to
		send the output to the client, it gets used for building the labels in
		the <span class="quote">&#8220;<span class="quote">print</span>&#8221;</span> command of the query.
		</p><p>
		<code class="computeroutput">compileQuery()</code> returns the query context, which contains a compiled
		sub-model that executes the query and a set of requests that tell the
		writer how to connect the query to the incoming data. Or on error it
		reports the error using the closure from the option <span class="quote">&#8220;<span class="quote">subError</span>&#8221;</span>
		and returns an <code class="computeroutput">undef</code>. If the
		compilation succeeded, the writer thread remembers the query and starts the
		asynchronous execution of the requests. The requests are the 
		data dump requests to be sent back to the application core thread.
		More about the requests later,
		now let's look at the query compilation and context.
		</p><p>
		The context is created in <code class="computeroutput">compileQuery()</code> thusly:
		</p><pre class="programlisting">  my $ctx = {};
  $ctx-&gt;{qid} = $opts-&gt;{qid};
  $ctx-&gt;{qname} = $opts-&gt;{qname};

  # .. skipped the parts related to single-threadde TQL

  $ctx-&gt;{faOut} = $opts-&gt;{faOut};
  $ctx-&gt;{faRqDump} = $opts-&gt;{faRqDump};
  $ctx-&gt;{subPrint} = $opts-&gt;{subPrint};
  $ctx-&gt;{requests} = []; # dump and subscribe requests that will run the pipeline
  $ctx-&gt;{copyTables} = []; # the tables created in this query
    # (have to keep references to the tables or they will disappear)

  # The query will be built in a separate unit
  $ctx-&gt;{u} = Triceps::Unit-&gt;new($opts-&gt;{nxprefix} . "${q}.unit");
  $ctx-&gt;{prev} = undef; # will contain the output of the previous command in the pipeline
  $ctx-&gt;{id} = 0; # a unique id for auto-generated objects
  # deletion of the context will cause the unit in it to clean
  $ctx-&gt;{cleaner} = $ctx-&gt;{u}-&gt;makeClearingTrigger();</pre><p>
		It has some parts common and some parts differing for the single- and
		multi-threaded varieties, here I've skipped over the single-threaded
		parts.
		</p><p>
		One element that is left undefined here is <code class="computeroutput">$ctx-&gt;{prev}</code>. It's the label
		created as the output of the previous stage of the query pipeline. As
		each command in the pipeline builds its piece of processing, it chains
		its logic from <code class="computeroutput">$ctx-&gt;{prev}</code> and leaves its result label in
		<code class="computeroutput">$ctx-&gt;{next}</code>. Then <code class="computeroutput">compileQuery()</code> moves <code class="computeroutput">next</code> to <code class="computeroutput">prev</code> and calls the
		compilation of the next command in the pipeline. The only command that
		accepts an undefined <code class="computeroutput">prev</code> (and it must be undefined for it) is
		<span class="quote">&#8220;<span class="quote">read</span>&#8221;</span> which reads the table at the start of the pipeline.
		</p><p>
		<code class="computeroutput">$ctx-&gt;{copyTables}</code> also has an important point behind it. When you
		create a label, it's OK to discard the original reference after you
		chain the label into the logic, that chaining will keep a reference, and
		the label will stay alive. Not so with a table: if you create a table,
		then chain its input label and drop the reference to a table, the table
		will be discarded. When the input label would try to send any data
		to the table, it will die.
		So it's important to keep the direct table references, and
		that's what this array is for.
		</p><p>
		<code class="computeroutput">$ctx-&gt;{id}</code> is used to generate the unique names for the objects built
		in this context.
		</p><p>
		Each query is built in its own unit. This is convenient, after the
		query is done or the compilation encounters an error, the unit with its
		whole contents can be easily discarded. The clearing trigger placed in
		the context makes sure that the unit gets properly cleared and
		discarded.
		</p><p>
		Next goes the compilation of the join query command, I'll go through it
		in chunks.
		</p><pre class="programlisting">sub _tqlJoin # ($ctx, @args)
{
  my $ctx = shift;
  die "The join command may not be used at the start of a pipeline.\n"
    unless (defined($ctx-&gt;{prev}));
  my $opts = {};
  &amp;Triceps::Opt::parse("join", $opts, {
    table =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    rightIdxPath =&gt; [ undef, undef ],
    by =&gt; [ undef, undef ],
    byLeft =&gt; [ undef, undef ],
    leftFields =&gt; [ undef, undef ],
    rightFields =&gt; [ undef, undef ],
    type =&gt; [ "inner", undef ],
  }, @_);

  my $tabname = bunescape($opts-&gt;{table});
  my $unit = $ctx-&gt;{u};
  my $table;

  &amp;Triceps::Opt::checkMutuallyExclusive("join", 1, "by", $opts-&gt;{by}, "byLeft", $opts-&gt;{byLeft});
  my $by = split_braced_final($opts-&gt;{by});
  my $byLeft = split_braced_final($opts-&gt;{byLeft});

  my $rightIdxPath;
  if (defined $opts-&gt;{rightIdxPath}) { # propagate the undef
    $rightIdxPath = split_braced_final($opts-&gt;{rightIdxPath});
  }</pre><p>
		It starts by parsing the options and converting them to the internal
		representation, removing the braced quotes.
		</p><pre class="programlisting">  # If we were to use a JoinTwo (which is more correct), the data
  # incoming through the query would have to be put into a table too.
  # And that requires finding the primary key for the data.
  # I suppose, after the sequence ids for the rows would get worked
  # out, that would provide the easy default primary key.
  if ($ctx-&gt;{faOut}) {
    # Potentially, the tables might be reused between multiple joins
    # in the query if the required keys match. But for now keep things
    # simpler by creating a new table from scratch each time.

    my $tt = eval {
      # copy to avoid adding an index to the original type
      $ctx-&gt;{faOut}-&gt;impTableType($tabname)-&gt;copy();
    };
    die ("Join found no such table '$tabname'\n") unless ($tt);

    if (!defined $rightIdxPath) {
      # determine or add the index automatically
      my @workby;
      if (defined $byLeft) { # need to translate
        my @leftfld = $ctx-&gt;{prev}-&gt;getRowType()-&gt;getFieldNames();
        @workby = &amp;Triceps::Fields::filterToPairs("Join option 'byLeft'",
          \@leftfld, [ @$byLeft, "!.*" ]);
      } else {
        @workby = @$by;
      }

      my @idxkeys; # extract the keys for the right side table
      for (my $i = 1; $i &lt;= $#workby; $i+= 2) {
        push @idxkeys, $workby[$i];
      }
      $rightIdxPath = [ $tt-&gt;findOrAddIndex(@idxkeys) ];
    }

    # build the table from the type
    $tt-&gt;initialize();
    $table = $ctx-&gt;{u}-&gt;makeTable($tt, "tab" . $ctx-&gt;{id} . $tabname);
    push @{$ctx-&gt;{copyTables}}, $table;

    # build the request that fills the table with data and then
    # keeps it up to date;
    # the table has to be filled before the query's main flow starts,
    # so put the request at the front
    &amp;_makeQdumpsub($ctx, $tabname, 1, $table-&gt;getInputLabel());
  } else {
    die ("Join found no such table '$tabname'\n")
      unless (exists $ctx-&gt;{tables}{$tabname});
    $table = $ctx-&gt;{tables}{$tabname};
  }</pre><p>
		The presence of <code class="computeroutput">$ctx-&gt;{faOut}</code> means that the query is compiled in the
		multithreaded context.
		</p><p>
		The command handlers, including the join command handler,
		may freely die, and the error messages will be
		caught by <code class="computeroutput">compileQuery()</code> and nicely (at least, sort-of) reported back
		to the user.
		</p><p>
		If an explicit <span class="quote">&#8220;<span class="quote">rightIdxPath</span>&#8221;</span> option was not requested, it gets found or added
		automatically. On the way there the index fields need to be determined.
		Which can be specified either as the explicit field pairs in the option <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> or
		as the name translation syntax in the option <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span>. If we've got
		a <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span>, first it gets translated to the same format as <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span>, and
		then the right-side fields are extracted from the format of <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span>. After
		that <code class="computeroutput">$tt-&gt;findOrAddIndex()</code> takes care of all the heavy lifting. It
		either finds a matching index type in the table type or creates a new
		one from the specified fields, and either way returns the index path
		(an invalid field will make it confess).
		</p><p>
		You might wonder, how come the explicit <span class="quote">&#8220;<span class="quote">rightIdxPath</span>&#8221;</span> option is not checked in
		any way? It will be checked later by <code class="computeroutput">LookupJoin()</code>, so not much point in
		doing the check twice.
		</p><p>
		After that the table is created in a straightforward way, and
		rememebered in <code class="computeroutput">$ctx-&gt;{copyTables}</code>. And the requests list gets prepended with a
		request to dump and subscribe to this table in <code class="computeroutput">_makeQdumpsub()</code>. I'll get back to that, for
		now let's finish up with <code class="computeroutput">_tqlJoin()</code>.
		</p><pre class="programlisting">  my $isLeft = 0; # default for inner join
  my $type = $opts-&gt;{type};
  if ($type eq "inner") {
    # already default
  } elsif ($type eq "left") {
    $isLeft = 1;
  } else {
    die "Unsupported value '$type' of option 'type'.\n"
  }

  my $leftFields = split_braced_final($opts-&gt;{leftFields});
  my $rightFields = split_braced_final($opts-&gt;{rightFields});

  my $join = Triceps::LookupJoin-&gt;new(
    name =&gt; "join" . $ctx-&gt;{id},
    unit =&gt; $unit,
    leftFromLabel =&gt; $ctx-&gt;{prev},
    rightTable =&gt; $table,
    rightIdxPath =&gt; $rightIdxPath,
    leftFields =&gt; $leftFields,
    rightFields =&gt; $rightFields,
    by =&gt; $by,
    byLeft =&gt; $byLeft,
    isLeft =&gt; $isLeft,
    fieldsDropRightKey =&gt; 1,
  );

  $ctx-&gt;{next} = $join-&gt;getOutputLabel();
}</pre><p>
		The rest of the options get parsed, and then all the collected data
		gets forwarded to the LookupJoin constructor. Finally the <code class="computeroutput">next</code> label
		is assigned from the join's result.
		</p><p>
		Now jumping to the <code class="computeroutput">_makeQdumpsub()</code>. It's used by both the <span class="quote">&#8220;<span class="quote">read</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">join</span>&#8221;</span> query commands to initiate the joins and subscriptions.
		</p><pre class="programlisting">sub _makeQdumpsub # ($ctx, $tabname, [$front, $lbNext])
{
  my $ctx = shift;
  my $tabname = shift;
  my $front = shift;
  my $lbNext = shift;

  my $unit = $ctx-&gt;{u};

  my $lbrq = eval {
    $ctx-&gt;{faRqDump}-&gt;getLabel("t.rqdump.$tabname");
  };
  my $lbsrc = eval {
    $ctx-&gt;{faOut}-&gt;getLabel("t.out.$tabname");
  };
  die ("Found no such table '$tabname'\n") unless ($lbrq &amp;&amp; $lbsrc);

  # compute the binding for the data dumps, that would be a cross-unit
  # binding to the original faOut but it's OK
  my $fretOut = $ctx-&gt;{faOut}-&gt;getFnReturn();
  my $dumpname = "t.dump.$tabname";
  # the dump and following subscription data will merge on this label
  if (!defined $lbNext) {
    $lbNext = $unit-&gt;makeDummyLabel(
      $lbsrc-&gt;getRowType(), "lb" . $ctx-&gt;{id} . "out_$tabname");
  }

  my $bindDump = Triceps::FnBinding-&gt;new(
    on =&gt; $fretOut,
    name =&gt; "bind" . $ctx-&gt;{id} . "dump",
    labels =&gt; [ $dumpname =&gt; $lbNext ],
  );</pre><p>
		First it finds all the proper labels. The label <code class="computeroutput">$lbNext</code> will accept the
		merged dump contents and the following subscription, and it might be
		either auto-generated or received as an argument. A join will pass it as an
		argument, set to <code class="computeroutput">$table-&gt;getInputLabel()</code>, so all the data goes to the copied
		table.
		</p><p>
		The binding is used to receive the dump. It's a bit of an optimization.
		Remember, the dump responses are sent to all the clients. Whenever
		any client requests a dump, all the clients will get the response. A
		client finds that the incoming dump is destined for it by processing
		the <span class="quote">&#8220;<span class="quote">beginDump</span>&#8221;</span> label. If it contains this client's name, the dump is
		destined here, and the client reacts by pushing the appropriate binding
		onto the facet's FnReturn, and the data flows. The matching <span class="quote">&#8220;<span class="quote">endDump</span>&#8221;</span>
		label then pops the binding and the data stops flowing. The binding
		allows to avoid checking every rowop for whether it's supposed to be
		accepted and if yes then where exactly (rememeber, the same table may
		be dumped independently multiple times by multiple queries). Just check
		once at the start of the bundle and then let the data flow in bulk.
		</p><pre class="programlisting">  # qdumpsub:
  #   * label where to send the dump request to
  #   * source output label, from which a subscription will be set up
  #     at the end of the dump
  #   * target label in the query that will be tied to the source label
  #   * binding to be used during the dump, which also directs the data
  #     to the same target label
  my $request = [ "qdumpsub", $lbrq, $lbsrc, $lbNext, $bindDump ];
  if ($front) {
    unshift @{$ctx-&gt;{requests}}, $request;
  } else {
    push @{$ctx-&gt;{requests}}, $request;
  }
  return $lbNext;
}</pre><p>
		Finally, the created bits and pieces get packaged into a request and
		added to the list of requests in the query context. The last tricky
		part is that the request can be added at the back or the front of the
		list. The <span class="quote">&#8220;<span class="quote">normal</span>&#8221;</span> way is to add at the back, however the dimension
		tables for the joins have to be populated before the main data flow of
		the query starts. So for them the argument <code class="computeroutput">$front</code> is set to 1, and they
		get added at the front.
		</p><p>
		Now jumping back to the writer thread logic, after it called
		<code class="computeroutput">compileQuery()</code>, it starts the query execution by calling
		<code class="computeroutput">&amp;$runNextRequest()</code>. Which is a closure function defined inside the
		client writer thread function, and knows how to send the dump requests we've
		just seen created to the core logic.
		</p><pre class="programlisting"># The requests from a query context get sent one by one, and
# after one is done, the next is sent until they all are done.
my $runNextRequest = sub { # ($ctx)
  my $ctx = shift;
  my $requests = $ctx-&gt;{requests};
  undef $ctx-&gt;{curRequest}; # clear the info of the previous request
  my $r = shift @$requests;
  if (!defined $r) {
    # all done, now just need to pump the data through
    printOrShut($app, $fragment, $sock,
      "querysub,$ctx-&gt;{qid},$ctx-&gt;{qname}\n");
    return;
  }</pre><p>
		First it clears the information about the previous request, if any.
		This function will be called after each request, to send the next
		one, so on all its calls except the first one of a query it will have
		something to clear.
		</p><p>
		Then it checks if all the requests are already done. If so, it sends
		the query confirmation to the client socket and returns. The subscription part
		of the query will continue running on its own.
		</p><pre class="programlisting">  $ctx-&gt;{curRequest} = $r; # remember until completed
  my $cmd = $$r[0];
  if ($cmd eq "qdumpsub") {
    # qdumpsub:
    #   * label where to send the dump request to
    #   * source output label, from which a subscription will be set up
    #     at the end of the dump
    #   * target label in the query that will be tied to the source label
    #   * binding to be used during the dump, which also directs the data
    #     to the same target label
    my $lbrq = $$r[1];
    # this code very specifically ignores %dump, doing its requests
    # independently for each query, and showing off another way to
    # do things
    # print "DBG next request {" . $ctx-&gt;{qname} . "} qdumpsub " . $lbrq-&gt;getName() . "\n";
    $unit-&gt;makeHashCall($lbrq, "OP_INSERT",
      client =&gt; $fragment, id =&gt; $ctx-&gt;{qid}, name =&gt; $ctx-&gt;{qname}, cmd =&gt; $cmd);
  } else {
    printOrShut($app, $fragment, $sock,
      "error,", $ctx-&gt;{qid}, ",Internal error: unknown request '$cmd',internal,", $cmd, "\n");
    $ctx-&gt;{requests} = [];
    undef $ctx-&gt;{curRequest};
    # and this will leave the query partially initialized,
    # but it should never happen
    return;
  }
};</pre><p>
		The request data might vary by the command. If the command is <span class="quote">&#8220;<span class="quote">qdumpsub</span>&#8221;</span>,
		the request gets translated to a rowop sent through the nexus to the dump
		request label in the core logic.
		</p><p>
		And a catch-all just in case if the query compiler ever decides to
		produce an invalid request.
		</p><p>
		Next goes the handling of the dump labels (again, this gets set up
		during the build of the client reader threads, and then the nature is
		left to run its course, reacting to the rowops as they come in).
		It gets set up in the writer thread function:
		</p><pre class="programlisting">  $faOut-&gt;getLabel("beginDump")-&gt;makeChained("lbBeginDump", undef, sub {
    my $row = $_[1]-&gt;getRow();
    my ($client, $id, $name, $cmd) = $row-&gt;toArray();
    return unless ($client eq $fragment);
    if ($cmd eq "qdumpsub") {
      return unless(exists $queries{$id});
      my $ctx = $queries{$id};
      $fretOut-&gt;push($ctx-&gt;{curRequest}[4]); # the binding for the dump
    } else {
      return unless (exists $dumps{$name});
      printOrShut($app, $fragment, $sock,
        "startdump,$id,$name\n");
      $fretOut-&gt;push($bindDump);
    }
  });</pre><p>
		As described before, it checks if this is the destination client, and if there
		is an active request with this id, then it pushes the appropriate
		binding.
		</p><p>
		The handling of the end of transaction also gets set up in the writer
		thread function:
		</p><pre class="programlisting">  $faOut-&gt;getLabel("endDump")-&gt;makeChained("lbEndDump", undef, sub {
    my $row = $_[1]-&gt;getRow();
    my ($client, $id, $name, $cmd) = $row-&gt;toArray();
    return unless ($client eq $fragment);

    if ($cmd eq "qdumpsub") {
      return unless(exists $queries{$id});
      my $ctx = $queries{$id};
      $fretOut-&gt;pop($ctx-&gt;{curRequest}[4]); # the binding for the dump
      # and chain together all the following updates
      $ctx-&gt;{curRequest}[2]-&gt;makeChained(
        "qsub$id." . $ctx-&gt;{curRequest}[3]-&gt;getName(), undef,
        sub {
          # a cross-unit call
          $_[2]-&gt;call($_[3]-&gt;adopt($_[1]));
        },
        $ctx-&gt;{u}, $ctx-&gt;{curRequest}[3]
      );

      &amp;$runNextRequest($ctx);
    } else {
      # .. skipped the handling of dump/dumpsub
    }
  });</pre><p>
		Same as the <span class="quote">&#8220;<span class="quote">beginDump</span>&#8221;</span>, it checks if this is the right client, and
		if it has an outstanding dump request, then pops the binding. After the
		dump is completed, the subscription has to be set up, so it sets up a
		label that forwards the normal output of this table to the label
		specified in the request. Since each query is defined in its own unit,
		this forwarding is done as a cross-unit call.
		</p><p>
		And then the next request of this query can be started until they all are done.
		And that's it, the end of the example. 
		</p></div></div><div class="chapter" title="Chapter 18. Performance"><div class="titlepage"><div><div><h2 class="title"><a name="ch_perf"></a>Chapter 18. Performance</h2></div></div></div><a class="indexterm" name="id478388"></a><p>
		Obviously, the performance depends on the machine on which Triceps runs.
		One of the Perl unit tests, <code class="computeroutput">t/Perf.t</code> allows you to measure the Triceps performace
		on your own machine.  By default it runs only one thousand iterations,
		to be fast and not delay the run of the full tests suite. But the
		number can be increased by setting an environment variable, such as:
		</p><pre class="programlisting">$ TRICEPS_PERF_COUNT=100000 perl t/Perf.t
Performance test, 100000 iterations, real time.
Empty Perl loop 0.006801 s, 14702927.05 per second.
Empty Perl function of 5 args 0.031918 s, 3133046.99 per second.
Empty Perl function of 10 args 0.027418 s, 3647284.30 per second.
Row creation from array and destruction 0.277232 s, 360708.19 per second.
Row creation from hash and destruction 0.498189 s, 200727.04 per second.
Rowop creation and destruction 0.155996 s, 641043.69 per second.
Calling a dummy label 0.098480 s, 1015437.21 per second.
Calling a chained dummy label 0.110546 s, 904601.83 per second.
  Pure chained call 0.012066 s, 8287664.25 per second.
Calling a Perl label 0.512559 s, 195099.61 per second.
Row handle creation and destruction 0.195778 s, 510781.66 per second.
Repeated table insert (single hashed idx, direct) 0.772934 s, 129377.12 per second.
Repeated table insert (single hashed idx, direct &amp; Perl construct) 1.109781 s, 90107.89 per second.
  RowHandle creation overhead in Perl 0.336847 s, 296871.05 per second.
Repeated table insert (single sorted idx, direct) 2.122350 s, 47117.59 per second.
Repeated table insert (single hashed idx, call) 0.867846 s, 115227.88 per second.
Table insert makeRowArray (single hashed idx, direct) 1.224588 s, 81660.14 per second.
  Excluding makeRowArray 0.947355 s, 105557.02 per second.
Table insert makeRowArray (double hashed idx, direct) 1.443053 s, 69297.51 per second.
  Excluding makeRowArray 1.165821 s, 85776.47 per second.
  Overhead of second index 0.218466 s, 457738.04 per second.
Table insert makeRowArray (single sorted idx, direct) 29.880962 s, 3346.61 per second.
  Excluding makeRowArray 29.603730 s, 3377.95 per second.
Table lookup (single hashed idx) 0.287407 s, 347938.44 per second.
Table lookup (single sorted idx) 9.160540 s, 10916.39 per second.
Lookup join (single hashed idx) 3.940388 s, 25378.21 per second.
Nexus pass (1 row/flush) 0.578993 s, 172713.78 per second.
Nexus pass (10 rows/flush) 2.266709 s, 441168.31 per row per second.
  Overhead of each row 0.187524 s, 533265.07 per second.
  Overhead of flush 0.391469 s, 255448.33 per second.</pre><p>
		An important caveat, the test is of the Perl interface, so it includes
		all the overhead of constructing the Perl objects. I've tried to
		structure it so that some of the underlying performance can be deduced,
		but it's still approximate. I haven't done the performance testing of
		just the underlying C++ implementation yet, it will be better.
		</p><p>
		The computations are done with the real elapsed time, so if the machine
		is not idle, the time of the other processes will get still counted
		against the tests, and the results will show slower than they really
		are.
		</p><p>
		The numbers above are from my old-ish laptop (dual-CPU Intel
		Core2 T9900 3GHz). The time in seconds printed for each
		value is for the whole test loop of 100K iterations. The <span class="quote">&#8220;<span class="quote">per second</span>&#8221;</span>
		number shows the opposite, how many loop iterations were done per second.
		</p><p>
		I've had an opportunity to run the performance tests on a few more
		laptops. Al of the same Core2 generation, but with the different CPU
		frequencies. The 2GHz version showed expectedly an about 30% lower
		performance proportionally. A 2.2GHz CPU also showed an about proportional
		change, except for the inter-thread communication through the
		nexus, it went down more than proportional.
		I'm not sure, what was up with the 2.2GHz CPU, maybe
		the timing worked out just wrong to add more overhead.
		</p><p>
		Here is the row-by-row description of the measurements:
		</p><pre class="programlisting">Performance test, 100000 iterations, real time.</pre><p>
		The first thing it prints is the iteration count, to set the
		expectations for the run length and precision. The shorter
		runs tend to include more randomness.
		</p><pre class="programlisting">Empty Perl loop 0.006801 s, 14702927.05 per second.
Empty Perl function of 5 args 0.031918 s, 3133046.99 per second.
Empty Perl function of 10 args 0.027418 s, 3647284.30 per second.</pre><p>
		A calibration to see, how much overhead is added by the execution of
		the loop itself. As it turns out, not much. The Perl function
		calls add more but still don't dominate the numbers.
		</p><pre class="programlisting">Row creation from array and destruction 0.277232 s, 360708.19 per second.</pre><p>
		The <code class="computeroutput">makeRowArray()</code> for a row of 5 fields. Each created row gets
		destroyed before the next one gets created.
		</p><pre class="programlisting">Row creation from hash and destruction 0.498189 s, 200727.04 per second.</pre><p>
		The <code class="computeroutput">makeRowHash()</code> for a row of 5 fields.
		</p><pre class="programlisting">Rowop creation and destruction 0.155996 s, 641043.69 per second.</pre><p>
		The <code class="computeroutput">makeRowop()</code> from an existing row. Same thing, each rowop gets
		destroyed before constructing the next one.
		</p><pre class="programlisting">Calling a dummy label 0.098480 s, 1015437.21 per second.</pre><p>
		Repeated calls of a dummy label with the same rowop object.
		This can be thought of as the basic overhead of a C++
		label call, with a limited amount (25-30% or so) of the Perl overhead mixed in.
		</p><pre class="programlisting">Calling a chained dummy label 0.110546 s, 904601.83 per second.
  Pure chained call 0.012066 s, 8287664.25 per second.</pre><p>
		Repeated calls of a dummy label that has another dummy label chained to
		it. The <span class="quote">&#8220;<span class="quote">pure</span>&#8221;</span> part is the difference from the previous case that gets
		added by appending another chained dummy label.
		</p><pre class="programlisting">Calling a Perl label 0.512559 s, 195099.61 per second.</pre><p>
		Repeated calls of a Perl label with the same rowop object. The Perl
		label has an empty <code class="computeroutput">sub</code> but that empty <code class="computeroutput">sub</code> still gets executed, along
		with all the support functionality.
		</p><pre class="programlisting">Row handle creation and destruction 0.195778 s, 510781.66 per second.</pre><p>
		The creation of a table's row handle from a single row, including the
		creation of the Perl wrapper for the row handle object.
		</p><pre class="programlisting">Repeated table insert (single hashed idx, direct) 0.772934 s, 129377.12 per second.</pre><p>
		Insert of the same row into a table. Since the row is the same, it
		keeps replacing the previous one, and the table size stays at 1 row.
		The code is <code class="computeroutput">$tSingleHashed-&gt;insert($row1)</code>.
		Even though the row is the same, a new row handle gets constructed for
		it every time by the table. 
		<span class="quote">&#8220;<span class="quote">Single hashed idx</span>&#8221;</span> means that the table has a single Hashed index, on
		an <code class="computeroutput">int32</code> field. <span class="quote">&#8220;<span class="quote">Direct</span>&#8221;</span> means the direct <code class="computeroutput">insert()</code> call, as opposed to
		using the table's input label.
		</p><pre class="programlisting">Repeated table insert (single hashed idx, direct &amp; Perl construct) 1.109781 s, 90107.89 per second.
  RowHandle creation overhead in Perl 0.336847 s, 296871.05 per second.</pre><p>
		The same, only the row handles are constructed in Perl before inserting
		them: <code class="computeroutput">$tSingleHashed-&gt;insert($tSingleHashed-&gt;makeRowHandle($row1))</code>. And
		the second line shows that the overhead of wrapping the row handles for
		Perl is pretty noticeable (it's the difference from the previous test
		case).
		</p><pre class="programlisting">Repeated table insert (single sorted idx, direct) 2.122350 s, 47117.59 per second.</pre><p>
		The same thing, only for a table that uses a Sorted index that executes
		a Perl comparison on the same <code class="computeroutput">int32</code> field. As you can see, it gets 
		almost 3 times slower.
		</p><pre class="programlisting">Repeated table insert (single hashed idx, call) 0.867846 s, 115227.88 per second.</pre><p>
		The same thing, again the table with a single Hashed index, but this
		time by sending the rowops to its input label.
		</p><pre class="programlisting">Table insert makeRowArray (single hashed idx, direct) 1.224588 s, 81660.14 per second.
  Excluding makeRowArray 0.947355 s, 105557.02 per second.</pre><p>
		Now the different rows get inserted into the table, each row having a
		different key. At the end of this test the table contains 100K rows (or
		however many were requested by the environment variable). Naturally,
		this is slower than the repeated insertions of the same row, since the
		tree of the table's index becomes deeper and requires more comparisons
		and rebalancing. This performance will be lower in the tests with more
		rows, since the index will become deeper and will create more overhead.
		Since the rows are all different, they are created on the fly, so this
		row creation overhead needs to be excluded to get the actual Table's
		performance.
		</p><pre class="programlisting">Table insert makeRowArray (double hashed idx, direct) 1.443053 s, 69297.51 per second.
  Excluding makeRowArray 1.165821 s, 85776.47 per second.
  Overhead of second index 0.218466 s, 457738.04 per second.</pre><p>
		Similar to previous one but on a table that has two Hashed indexes (both on
		the same <code class="computeroutput">int32</code> field). The details here also compute the overhead
		contributed by the second index.
		</p><pre class="programlisting">Table insert makeRowArray (single sorted idx, direct) 29.880962 s, 3346.61 per second.
  Excluding makeRowArray 29.603730 s, 3377.95 per second.</pre><p>
		Similar but for a table with a Sorted index with a Perl expression. As
		you can see, with the makeRowArray overhead excluded it's about 30 times
		slower (and it gets even worse for the larger row sets).
		</p><pre class="programlisting">Table lookup (single hashed idx) 0.287407 s, 347938.44 per second.</pre><p>
		Finding a row in a table of 100K (or however many iterations
		requested) rows by a hashed index.
		</p><pre class="programlisting">Table lookup (single sorted idx) 9.160540 s, 10916.39 per second.</pre><p>
		Finding a row in a table of 100K (or however many iterations
		requested) rows by a Perl sorted index. Just like row insertion,
		it's 30-odd times slower than a hashed index.
		</p><pre class="programlisting">Lookup join (single hashed idx) 3.940388 s, 25378.21 per second.</pre><p>
		Joins in the LookupJoin template (and the performance of the JoinTwo
		template will be the same, since it consists of two LookupJoins).
		It performs essentially the same table lookup, only with the added
		overhead of constructing the new combined rows, and the general
		overhead of the extra Perl label calls.
		</p><pre class="programlisting">Nexus pass (1 row/flush) 0.578993 s, 172713.78 per second.
Nexus pass (10 rows/flush) 2.266709 s, 441168.31 per row per second.
  Overhead of each row 0.187524 s, 533265.07 per second.
  Overhead of flush 0.391469 s, 255448.33 per second.</pre><p>
		The passing of the rows between threads through a Nexus.
		The time also includes the draining and stopping of the app, so
		it's a little pessimistic, and gets more pessimistic for the short runs.
		Both cases pass 100K of transactions, so the second one passes
		10 times more rows.
		The difference in performance of different transaction sizes allows
		to compute the overhead of the transaction passing (i.e. flushes)
		versus the overhead of adding extra rows to transactions.
		</p></div><div class="chapter" title="Chapter 19. Triceps Perl API Reference"><div class="titlepage"><div><div><h2 class="title"><a name="ch_ref"></a>Chapter 19. Triceps Perl API Reference</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_ref_toplevel">19.1. Top-level functions reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_code">19.2. Code helpers reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_unit">19.3. Unit and FrameMark reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_table_type">19.4. TableType reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_index_type">19.5. IndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_agg_type">19.6. AggregatorType reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_simple_agg">19.7. SimpleAggregator reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_table">19.8. Table reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_rowhandle">19.9. RowHandle reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_aggcontext">19.10. AggregatorContext reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_opt">19.11. Opt reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_fields">19.12. Fields reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_lookupjoin">19.13. LookupJoin reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_jointwo">19.14. JoinTwo reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_collapse">19.15. Collapse reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_braced">19.16. Braced reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_fnreturn">19.17. FnReturn reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_fnbinding">19.18. FnBinding reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_autofnbind">19.19. AutoFnBind reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_app">19.20. App reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sc_ref_app_inst_management">19.20.1. App instance management</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_resolution">19.20.2. App resolution</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_introspection">19.20.3. App introspection</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_harvester">19.20.4. App harvester control</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_state">19.20.5. App state management</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_drain">19.20.6. App drain control</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_start_timeout">19.20.7. App start timeout</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_fd">19.20.8. File descriptor transfer through an App</a></span></dt><dt><span class="sect2"><a href="#sc_ref_app_build">19.20.9. App build</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sc_ref_triead">19.21. Triead reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_triead_owner">19.22. TrieadOwner reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sc_ref_triead_owner_construct">19.22.1. TrieadOwner construction</a></span></dt><dt><span class="sect2"><a href="#sc_ref_triead_owner_general">19.22.2. TrieadOwner general methods</a></span></dt><dt><span class="sect2"><a href="#sc_ref_triead_owner_drains">19.22.3. TrieadOwner drains</a></span></dt><dt><span class="sect2"><a href="#sc_ref_triead_owner_interrupt">19.22.4. TrieadOwner file interrruption</a></span></dt><dt><span class="sect2"><a href="#sc_ref_triead_owner_tracked_file">19.22.5. TrackedFile</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sc_ref_nexus">19.23. Nexus reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_facet">19.24. Facet reference</a></span></dt><dt><span class="sect1"><a href="#sc_ref_autodrain">19.25. AutoDrain reference</a></span></dt></dl></div><p>
		There are two distinct ways to descibe something, a <span class="quote">&#8220;<span class="quote">guide</span>&#8221;</span> and
		a <span class="quote">&#8220;<span class="quote">reference</span>&#8221;</span>. Most of this manual is a guide: it goes
		by describing things by examples, together with the idioms of their
		usage, and with the explanation of the internal structure and
		underlying reasons. However if you already know how things work
		and need to look up the trivia, a reference with its short
		and dry descriptions comes handy. Besides, some methods of the classes
		essentially are the trivia, and there is no point in making
		elaborate examples about them. The reference for the whole
		Perl API is collected here, organized by classes.
		Eventually it should be placed into the man pages as well, but
		so far I haven't got around to do it.
		</p><p>
		Some of the classes are so fundamental that the guide sections
		about them were essentially of the reference type, with the
		use being shown in all the examples of the manual. In such cases
		I'm not copying them here, instead please refer to the relevant
		chapters:
		</p><p>
		Simple field types in
		<a class="xref" href="#sc_SimpleTypes" title="5.1. Simple types">Section 5.1: &#8220;Simple types&#8221; </a>.
		</p><p>
		RowType in 
		<a class="xref" href="#sc_RowTypes" title="5.2. Row types">Section 5.2: &#8220;Row types&#8221; </a>.
		</p><p>
		Row in 
		<a class="xref" href="#sc_Rows" title="5.4. Rows">Section 5.4: &#8220;Rows&#8221; </a>.
		</p><p>
		Label in 
		<a class="xref" href="#ch_LabelsRowops" title="Chapter 6. Labels and Row Operations">Chapter 6: &#8220;<i>Labels and Row Operations</i>&#8221; </a>.
		</p><p>
		Rowop in 
		<a class="xref" href="#sc_Rowop" title="6.4. Row operations">Section 6.4: &#8220;Row operations&#8221; </a>.
		</p><div class="sect1" title="19.1. Top-level functions reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_toplevel"></a>19.1. Top-level functions reference</h2></div></div></div><a class="indexterm" name="id554792"></a><p>
		The function <code class="computeroutput">Triceps::now()</code> is similar to
		Perl <code class="computeroutput">time()</code> but returns the current time as a floating point
		number, with the fractional seconds:
		</p><pre class="programlisting">$time = &amp;Triceps:now();</pre><p>
		This time format is used by a few Triceps methods, mostly in the
		multithreading support.
		</p><a class="indexterm" name="id596125"></a><p>
		The function <code class="computeroutput">Triceps::wrapfess()</code> takes care of wrapping the
		confessions in the templates. It's very much like the try/catch, only it has the
		hardcoded catch logic that adds the extra error information and then
		re-throws the exception.
		</p><pre class="programlisting">Triceps::wrapfess($message, $code);</pre><p>
		<code class="computeroutput">$code</code> is the code to execute in an <code class="computeroutput">eval</code>, the <span class="emphasis"><em>try</em></span> part. <code class="computeroutput">$message</code>
		is the message that is prepended to the error if the code confesses. The original
		message will be indented to create the nice-looking messages when the errors
		propagate up a chain of nested <code class="computeroutput">wrapfess()</code>. The stack trace doesn't
		get indented or duplicated, it's preserved as-is during the propagation.
		</p><p>
		The goal of <code class="computeroutput">wrapfess()</code> is to make the errors reported from the
		Triceps templates more user-friendly. When some part of the template's code
		generation fails, the error message that talks about the low-level details
		may be difficult to connect to the error in teh template arguments.
		The wrapping allows to prepend the high-level message about what template
		arguments were wrong.
		</p><p>
		<code class="computeroutput">$message</code> may be either a string or a code reference, or a reference
		to a scalar variable containing either. If it's
		a code reference, it will be evaluated, and its result will be used as a string.
		The code as message can be useful if the message is expensive to generate,
		and thus it would be generated only if an error is encountered. The reference to a scalar
		can be used to wrap the code into a single <code class="computeroutput">wrapfess</code> but then replace the
		actual value to print as needed. This might be too flexible, and it's not
		clear yet if the reference message is a good idea.
		</p><p>
		Examples of usage:
		</p><pre class="programlisting">my $result_rt = Triceps::wrapfess
  "$myname: Invalid result row type specification:",
  sub { Triceps::RowType-&gt;new(@rowdef); };

my $result_rt = Triceps::wrapfess sub {
    "$myname: Invalid result row type specification:"
  },
  sub { Triceps::RowType-&gt;new(@rowdef); };

my $eref;
return Triceps::wrapfess \$eref,
  sub {
    $eref = "Bad argument foo";
    buildTemplateFromFoo();
    $eref = sub {
      my $bardump = $argbar-&gt;dump();
      $bardump =~ s/^/    /mg;
      return "Bad argument bar:\n  bar value is:\n$bardump";
    };
    buildTemplateFromBar();
    ...
   };</pre><p>
		An example of produced error message:
		</p><pre class="programlisting">Triceps::Fields::makeTranslation: Invalid result row type specification:
  Triceps::RowType::new: incorrect specification:
    duplicate field name 'f1' for fields 3 and 2
    duplicate field name 'f2' for fields 4 and 1
  Triceps::RowType::new: The specification was: {
    f2 =&gt; int32[]
    f1 =&gt; string
    f1 =&gt; string
    f2 =&gt; float64[]
  } at blib/lib/Triceps/Fields.pm line 209.
  Triceps::Fields::__ANON__ called at blib/lib/Triceps.pm line 192
  Triceps::wrapfess('Triceps::Fields::makeTranslation: Invalid result row type spe...', 'CODE(0x1c531e0)') called at blib/lib/Triceps/Fields.pm line 209
  Triceps::Fields::makeTranslation('rowTypes', 'ARRAY(0x1c533d8)', 'filterPairs', 'ARRAY(0x1c53468)') called at t/Fields.t line 186
  eval {...} called at t/Fields.t line 185</pre><p>
		The nested error lines are differentiated from the stack trace lines
		by assuming that the stack trace lines always start with a tab character.
		Thus the lines in the errors caught by <code class="computeroutput">wrapfess()</code> that start
		with a tab character don't get indented, and the resf ot them get indented
		by two spaces.
		</p><p>
		Note also that even though <code class="computeroutput">wrapfess()</code> uses <code class="computeroutput">eval()</code>, there is no <code class="computeroutput">eval</code>
		above it in the stack trace. That's the other part of the magic: since
		that <code class="computeroutput">eval</code> is not meaningful, it gets cut from the stack trace, and
		<code class="computeroutput">wrapfess()</code> also uses it to find its own place in the stack trace, the
		point from which a simple re-confession would dump the duplicate of the
		stack. So it cuts the <code class="computeroutput">eval</code> and everything under it in the original
		stack trace, and then does its own confession, inserting the stack
		trace again. This works very well for the traces thrown by the XS code,
		which actually doesn't write anything below that <code class="computeroutput">eval</code>; <code class="computeroutput">wrapfess()</code> then
		adds the missing part of the stack.
		</p><a class="indexterm" name="id582289"></a><p>
		Internally, <code class="computeroutput">wrapfess()</code> uses the function <code class="computeroutput">Triceps::nestfess()</code> to
		re-throw the error. <code class="computeroutput">Nestfess()</code> can also be used directly:
		</p><pre class="programlisting">Triceps::nestfess($message, $nested_message);</pre><p>
		<code class="computeroutput">$message</code> is the high level message to prepend to the low-level message,
		same as in <code class="computeroutput">wrapfess()</code>. <code class="computeroutput">$nested_message</code> is the low-level message to be wrapped.
		<code class="computeroutput">Nestfess()</code> is responsible for all the smart processing of the indenting
		and stack traces, <code class="computeroutput">wrapfess()</code> is really just a bit of syntactic sugar on
		top of it.
		</p><p>
		The typical usage is:
		</p><pre class="programlisting">eval {
  buildTemplatePart();
};
if ($@) {
  Triceps::nestfess("High-level error message", $@);
}</pre></div><div class="sect1" title="19.2. Code helpers reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_code"></a>19.2. Code helpers reference</h2></div></div></div><a class="indexterm" name="id573290"></a><a class="indexterm" name="id467635"></a><p>
		As described in
		<a class="xref" href="#sc_code" title="4.4. Code references and snippets">Section 4.4: &#8220;Code references and snippets&#8221; </a>,
		many Triceps method accept the code references or source code snippets
		as arguments. The user-defined templates are encouraged to do the same.
		These code snippets can be compiled with the helper function:
		</p><pre class="programlisting">$code = Triceps::Code::compile($code_ref_or_source);
$code = Triceps::Code::compile($code_ref_or_source, $description);</pre><p>
		It takes either a code reference or a source code string as an argument
		and returns the reference to the compiled code. If the argument was a
		code reference, it just passes through unchanged. If it was a source
		code snippet, it gets compiled (the text
		gets the <code class="computeroutput">sub { ... }</code> wrapper added around it implicitly).
		</p><p>
		If the argument was an <code class="computeroutput">undef</code>, it also passes through unchanged. This is
		convenient in case if the code is optional. But if it isn't then the
		caller should check for <code class="computeroutput">undef</code>.
		</p><p>
		If the compilation fails, the method confesses, and includes the error
		and the source code into the message, in the same way as the XS methods
		do.
		</p><p>
		The optional second argument can be used to provide information
		about the meaning of the code for the error messages. If it's undefined
		then the default is <span class="quote">&#8220;<span class="quote">Code snippet</span>&#8221;</span>.
		</p><a class="indexterm" name="id549662"></a><p>
		The error messages reported by <code class="computeroutput">compile()</code> include the
		printout of the code with the line numbering. This printout
		can also be produced directly with the method <code class="computeroutput">Triceps::Code::numalign()</code>:
		</p><pre class="programlisting">$formatted_text = Triceps::Code::numalign($source_text, $indent);
$formatted_text = Triceps::Code::numalign($source_text, $indent, $tabrepl);</pre><p>
		<code class="computeroutput">$source_text</code> is the source code to be formatted. <code class="computeroutput">$indent</code> is the indentation
		to be prepended to each line of the formatted code (before the line numbers,
		and since the line numbers are printed as 4 characters, this might add
		a bit extra visual indentation). The tab characters are replaced with
		two spaces by default, or <code class="computeroutput">$tabrepl</code> can be used to specify any other replacement
		for them.
		</p><p>
		The code is also beautified a bit to make it more readable. The following
		is done to it:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			The empty lines at the front will be removed. <code class="computeroutput">numalign()</code> is smart
			enough to take the removed lines into account and show the numbers
			as they were in the original code snippet.
			You can also get the number of the removed
			lines afterwards, from the global variable
			<code class="computeroutput">$Triceps::Code::align_removed_lines</code>.
			</li><li class="listitem">
			The <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span> at the end of the snippet will be chomped. But only one, the
			rest of the empty lines at the end will be left alone.
			</li><li class="listitem">
			Then the <span class="quote">&#8220;<span class="quote">baseline</span>&#8221;</span> indenting of the code will be determined by
			looking at the first three and last two lines. The shortest
			non-empty indenting will be taken as the baseline. If some lines
			examined start with spaces and some start with tabs, the lines
			starting with tabs will be preferred as the baseline indenting.
			</li><li class="listitem">
			The baseline indenting will be removed from the front of all lines.
			If some lines in the middle of the code have a shorter indenting,
			they will be left unchanged.
			</li><li class="listitem">
			The tabs will be replaced by either the third argument or two spaces.
			</li><li class="listitem">
			The line numbers will be prepended to the lines.
			</li><li class="listitem">
			The indenting from the second argument of the function will be
			prepended to the lines.
			</li></ul></div><p>
		Here is an example of use:
		</p><pre class="programlisting">confess "$myname: error in compilation of the generated function:\n  $@function text:\n"
. Triceps::Code::numalign($gencode, "  ") . "\n";</pre><p>
		It can produce an error message like this (with a deliberately introduced syntax error):
		</p><pre class="programlisting">Triceps::Fields::makeTranslation: error in compilation of the generated function:
  syntax error at (eval 27) line 13, near "})
"
function text:
     2 sub { # (@rows)
     3   use strict;
     4   use Carp;
     5   confess "template internal error in Triceps::Fields::makeTranslation: result translation expected 1 row args, received " . ($#_+1)
     6     unless ($#_ == 0);
     7   # $result_rt comes at compile time from Triceps::Fields::makeTranslation
     8   return $result_rt-&gt;makeRowArray(
     9     $_[0]-&gt;get("one"),
    10     $_[0]-&gt;get("two"),
    11   );
    12 })
 at /home/babkin/w/triceps/trunk/perl/Triceps/blib/lib/Triceps/Fields.pm line 219
    Triceps::Fields::makeTranslation('rowTypes', 'ARRAY(0x2943cb0)', 'filterPairs', 'ARRAY(0x2943b30)', '_simulateCodeError', 1) called at t/Fields.t line 205
    eval {...} called at t/Fields.t line 204</pre><a class="indexterm" name="id491071"></a><p>
		The method <code class="computeroutput">Triceps::Code::alignsrc()</code> is just like <code class="computeroutput">numalign()</code>,
		except that it doesn't prepend the line numbers but only improves the
		alignment of the code lines:
		</p><pre class="programlisting">$formatted_text = Triceps::Code::alignsrc($source_text, $indent);
$formatted_text = Triceps::Code::alignsrc($source_text, $indent, $tabrepl);</pre></div><div class="sect1" title="19.3. Unit and FrameMark reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_unit"></a>19.3. Unit and FrameMark reference</h2></div></div></div><p>
		The Unit class represents an execution unit and
		keeps the state of the Triceps execution for one
		thread. Each thread running Triceps must have its own execution unit.
		</p><p>
		It's perfectly possible to have multiple execution units in the
		same thread. This is typically done when there is some permanent
		model plus some small intermittent sub-models created on demand to handle
		the user requests. These small sub-models would be created in the
		separate units, to be destroyed when their work is done.
		</p><a class="indexterm" name="id546181"></a><p>
		A unit is created as:
		</p><pre class="programlisting">$myUnit = Triceps::Unit-&gt;new($name);</pre><p>
		The <code class="computeroutput">$name</code> argument will be used in the error messages, making easier
		to find, which exact part of the model is having troubles.
		By convention the name should be the same as the name of the unit variable
		(<span class="quote">&#8220;<span class="quote">myUnit</span>&#8221;</span> in this case). When a Unit is created as a part of
		Triead (a Triceps thread object), it will be given the same name as
		the Triead.
		</p><p>
		The name can be read back:
		</p><pre class="programlisting">$name = $myUnit-&gt;getName();</pre><p>
		Also, as usual, the variable <code class="computeroutput">$myUnit</code> here contains a reference to the
		actual unit object, and two references can be compared for whether they
		refer to the same object:
		</p><pre class="programlisting">$result = $unit1-&gt;same($unit2);</pre><p>
		A unit also keeps an empty row type (one with no fields), primarily for the
		creation of the clearing labels (discussed in
		<a class="xref" href="#sc_memory_labels" title="8.2. Clearing of the labels">Section 8.2: &#8220;Clearing of the labels&#8221; </a>
		and
		<a class="xref" href="#sc_Label_construction" title="6.2. Label construction">Section 6.2: &#8220;Label construction&#8221; </a>),
		but you can use it for any other purposes
		too. You can get it with the method:
		</p><pre class="programlisting">$rt = $unit-&gt;getEmptyRowType();</pre><p>
		Each unit has its own instance of an empty row type that can be used
		to create the objects that don't process any data (for which
		just the fact of a rowop passing through is important). The
		creation of an empty row type in each unit instead of having
		a single global one is purely for the conveniece of memory management
		in the threads, they are all equivalent. You could also create
		your own empty row type.
		</p><p>
		The rowops are enqueued with the calls:
		</p><pre class="programlisting">$unit-&gt;call(@rowops_or_trays);
$unit-&gt;fork(@rowops_or_trays);
$unit-&gt;schedule(@rowops_or_trays);</pre><a class="indexterm" name="id582444"></a><p>
		<span class="quote">&#8220;<span class="quote">Enqueued</span>&#8221;</span> is an ugly word but since I've already used the
		word <span class="quote">&#8220;<span class="quote">schedule</span>&#8221;</span> for a specific purpose, I needed another word to name
		all these operations together. Hence <span class="quote">&#8220;<span class="quote">enqueue</span>&#8221;</span>.
		</p><p>
		<code class="computeroutput">Call()</code> executes the rowop immediately, <code class="computeroutput">fork()</code> puts it onto the current
		stack frame to be executed after the current label returns, and <code class="computeroutput">schedule()</code> 
		puts the rowop onto the outermost frame, to be executed when the model
		becomes idle.
		</p><p>
		Calling these functions with multiple arguments produces the same
		result as doing multiple calls with one argument at a time. The
		rowop and tray arguments may be mixed arbitrarily.
		</p><p>
		Also there is a call that selects the enqueueing mode by argument:
		</p><pre class="programlisting">$unit-&gt;enqueque($mode, @rowops_or_trays);</pre><p>
		The calling rules are exactly the same for the other enqueueing methods,
		may have multiple rowops or trays as arguments, no need to check the result.
		The <code class="computeroutput">$mode</code> argument is one of:
		</p><a class="indexterm" name="id585004"></a><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">&amp;Triceps::EM_CALL</code> or <code class="computeroutput">"EM_CALL"</code></li><li class="listitem"><code class="computeroutput">&amp;Triceps::EM_FORK</code> or <code class="computeroutput">"EM_FORK"</code></li><li class="listitem"><code class="computeroutput">&amp;Triceps::EM_SCHEDULE</code> or <code class="computeroutput">"EM_SCHEDULE"</code></li><li class="listitem"><code class="computeroutput">&amp;Triceps::EM_IGNORE</code> or <code class="computeroutput">"EM_IGNORE"</code></li></ul></div><p>
		The <code class="computeroutput">EM_IGNORE</code> is a <span class="quote">&#8220;<span class="quote">no-op</span>&#8221;</span> among the enqueueing
		methods. It means that the rowop will be simply ignored and not executed at all. 
		It is very rarely used in practice.
		</p><p>
		As usual, there are calls to convert between the integer constant and
		string representations:
		</p><pre class="programlisting">$string = &amp;Triceps::emString($value);
$value = &amp;Triceps::stringEm($string);
$string = &amp;Triceps::emStringSafe($value);
$value = &amp;Triceps::stringEmSafe($string);</pre><p>
		And as usual, if the value can not be translated, the functions
		with <code class="computeroutput">Safe</code> return <code class="computeroutput">undef</code>, the functions without
		it confess.
		</p><p>
		The frame marks for looping are created as their own class:
		</p><a class="indexterm" name="id555362"></a><pre class="programlisting">$mark = Triceps::FrameMark-&gt;new($name);</pre><p>
		The name can be obtained back from the mark:
		</p><pre class="programlisting">$name = $mark-&gt;getName();</pre><p>
		Other than that, the frame marks are completely opaque, and can be used
		only for the loop scheduling. Not even the <code class="computeroutput">same()</code> method is supported
		for them at the moment, though it probably will be in the future. The
		mark gets set and used as:
		</p><pre class="programlisting">$unit-&gt;setMark($mark);
$unit-&gt;loopAt($mark, @rowops_or_trays);</pre><p>
		<code class="computeroutput">setMark</code> must be called in the first label of the loop,
		normally before doing anything else. <code class="computeroutput">loopAt()</code> is called
		in any label inside the loop that wants to send a rowop back to the
		start of the loop.
		The rowop or tray arguments of the <code class="computeroutput">loopAt()</code> are the same as for the
		other enqueueing functions.
		</p><p>
		The examples of the <code class="computeroutput">loopAt()</code> operation are presented in
		<a class="xref" href="#sc_sched_topo_loops" title="7.7. Topological loops">Section 7.7: &#8220;Topological loops&#8221; </a>,
		and the details of its internal works are in 
		<a class="xref" href="#sc_sched_loop" title="7.12. The gritty details of Triceps loop scheduling">Section 7.12: &#8220;The gritty details of Triceps loop scheduling&#8221; </a>.
		</p><p>
		There also are the convenience methods that create the rowops
		from the field values and immediately enqueue them:
		</p><pre class="programlisting">$unit-&gt;makeHashCall($label, $opcode,
  $fieldName =&gt; $fieldValue, ...);
$unit-&gt;makeArrayCall($label, $opcode, @fieldValues);

$unit-&gt;makeHashSchedule($label, $opcode,
  $fieldName =&gt; $fieldValue, ...);
$unit-&gt;makeArraySchedule($label, $opcode, @fieldValues);

$unit-&gt;makeHashLoopAt($mark, $label, $opcode,
  $fieldName =&gt; $fieldValue, ...);
$unit-&gt;makeArrayLoopAt($mark, $label, $opcode, @fieldValues);</pre><p>
		These are essentially the shorter ways to make the rowops and enqueue
		them without the three-deep calls. Only the methods for the most 
		frequently used enqueueing modes are provided, not for all of them.
		</p><p>
		The Unit also serves as a factory for creation of the objects
		associated with it:
		</p><pre class="programlisting">$label = $unit-&gt;makeDummyLabel($rowType, "name");

$label = $unit-&gt;makeLabel($rowType, "name", $clearSub, $execSub, @args);

$label = $unit-&gt;makeClearingLabel("name", @args);

$table = $unit-&gt;makeTable($tableType, "name");

$tray = $unit-&gt;makeTray(@rowops);</pre><a class="indexterm" name="id544918"></a><a class="indexterm" name="id584357"></a><a class="indexterm" name="id578510"></a><a class="indexterm" name="id598613"></a><p>
		A special thing about the labels is that when a unit creates
		a label, it keeps a reference to it, for clearing. A label keeps a pointer
		back to the unit but not a reference (if you call <code class="computeroutput">getUnit()</code>
		on a label, the returned value becomes a reference). For a table
		or a tray, the unit doesn't keep a reference to them. Instead,
		they keep a reference to the unit. 
		The references are at the C++ level, not Perl level.
		</p><p>
		With the tables, the references can get
		pretty involved: A table has labels associated with it.
		When a table is created, it also creates these labels.
		The unit keeps references of these labels. The table also
		keeps references of these labels. The table keeps a reference
		of the unit. The labels 
		have pointers to the unit and the
		table but not references, to avoid the reference cycles.
		</p><p>
		See more on the memory management and label clearing in the
		<a class="xref" href="#ch_memory" title="Chapter 8. Memory Management">Chapter 8: &#8220;<i>Memory Management</i>&#8221; </a>.
		</p><p>
		The convenience methods to create the whole front part of the 
		topological loop are:
		</p><a class="indexterm" name="id581479"></a><a class="indexterm" name="id590979"></a><pre class="programlisting">($label, $frameMark) = $unit-&gt;makeLoopHead(
  $rowType, $name, $clearSub, $execSub, @args);

($label, $frameMark) = $unit-&gt;makeLoopAround(
  $name, $labelFirst);</pre><p>
		You don't have to use them, you can create the loops manually. These
		methods merely make it more convenient. Remember also that a procedural
		loop is usually much easier to write, debug, and read later than a
		topological one.
		</p><p>
		<code class="computeroutput">makeLoopHead()</code> creates the front part of the loop that starts
		with a Perl label. It gets the arguments for that label and
		creates it among the other things. <code class="computeroutput">makeLoopAround()</code> creates
		the front part of the loop around an existing label that
		will be the first one executed in the loop. <code class="computeroutput">makeLoopHead()</code> 
		is really redundant and can be replaced with a combination
		of <code class="computeroutput">makeLabel()</code> and <code class="computeroutput">makeLoopAround()</code>,
		but as-is it's slightly more efficient.
		</p><p>
		They both return the same results, a pair:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
		The label that will be the real start of the loop, where you
		send a rowop to both initiate the loop and to do the next iteration of the
		loop with <code class="computeroutput">loopAt</code>.
		</li><li class="listitem">
		The frame mark that you use in <code class="computeroutput">loopAt()</code>. You don't need to
		set the frame mark, it will be set for you in the wrapper logic.
		</li></ul></div><p>
		The name argument will become the name of the created label. The FrameMark
		object also has a name, useful for diagnostics, that gets created by adding
		a suffix to the argument: <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>name</em></span>.mark</span>&#8221;</span>.
		</p><p>
		<code class="computeroutput">makeLoopAround()</code> takes the row type for its wrpper label
		from <code class="computeroutput">$labelFirst</code>.
		</p><p>
		The unit can be checked for the emptiness of its queues:
		</p><pre class="programlisting">$result = $unit-&gt;empty();</pre><p>
		Check whether all the frames are empty.
		</p><pre class="programlisting">$res = $unit-&gt;isFrameEmpty();</pre><a class="indexterm" name="id604863"></a><p>
		Check whether the current inner frame is empty.  This
		method is useful if you run multiple units in the same thread, with
		some potentially complicated cross-unit scheduling. It's what
		<code class="computeroutput">TrieadOwner::nextXtray()</code> does with a multi-unit Triead, repeatedly calling
		<code class="computeroutput">drainFrame()</code> for all the units that are found not empty. In this
		situation the simple <code class="computeroutput">empty()</code> cannot be used because the current inner
		frame might not be the outer frame, and draining the inner frame can be
		repeated forever while the outer frame will still contain rowops. The
		more precise check of <code class="computeroutput">isFrameEmpty()</code> prevents the possibility of such
		endless loops.
		</p><pre class="programlisting">$res = $unit-&gt;isInOuterFrame();</pre><p>
		Check whether the unit's current inner frame is the same as its outer
		frame, which means that the unit is not in the middle of a call.
		</p><p>
		The functions for execution from the queues are:
		</p><pre class="programlisting">$unit-&gt;callNext();
$unit-&gt;drainFrame();</pre><p>
		<code class="computeroutput">callNext()</code> takes one label from the top (innermost) stack frame queue and calls it.
		If the inner frame happens to be empty, it does nothing. 
		<code class="computeroutput">drainFrame()</code> calls the rowops from the top stack frame until it becomes
		empty. This includes any rowops that may be created and enqueued as
		part of the execution of the previous rowops. But it doesn't pop the
		frame from the stack.  And of course the method
		<code class="computeroutput">call()</code> causes the argument rowops to be executed immediately, without
		even being technically enqueued.
		</p><p>
		The recursive calls may be enabled per-unit with the methods:
		</p><pre class="programlisting">$unit-&gt;setMaxStackDepth($n);
$unit-&gt;setMaxRecursionDepth($n);</pre><p>
		<code class="computeroutput">setMaxStackDepth()</code> sets the limit on the total depth of the
		unit's call stack. That's the maximal length of the call chain, whether
		it goes straight or in loops.
		</p><p>
		<code class="computeroutput">setMaxRecursionDepth()</code> sets the limit on the 
		number of times each particular label may appear on
		the call stack. So if you have a recursive code fragment 
		(a simple-minded loop or a recursive streaming function), this
		is the limit on its recursive reentrances.
		</p><p>
		You can change them at any time, even when the unit is running (but
		they will be enforced only on the next attempt to execute a rowop).
		Both these limits accept the 0 and negative values to mean <span class="quote">&#8220;<span class="quote">unlimited</span>&#8221;</span>.
		The default is: unlimited stack depth, recursion
		depth of 1.
		</p><p>
		You can read the current limits with:
		</p><pre class="programlisting">$n = $unit-&gt;maxStackDepth();
$n = $unit-&gt;maxRecursionDepth();</pre><p>
		Also the current depth of the call stack (the number of the
		stack frames on the queue) can be found with:
		</p><pre class="programlisting">$result = $unit-&gt;getStackDepth();</pre><p>
		It isn't of any use for the model logic as such but comes handy
		for debugging, to check in the loops that you haven't accidentally
		created a stack growing with iterations. When the unit is not
		running, the stack depth is 1, since the outermost frame always
		stays on the stack. When a rowop is being executed, the stack
		depth is at least 2.
		</p><pre class="programlisting">$unit-&gt;clearLabels();</pre><a class="indexterm" name="id580957"></a><a class="indexterm" name="id607149"></a><p>
		Clear all the labels in the unit, then drop the references from unit to them.
		Normally should be called only when the unit is about to be destroyed,
		and is called automatically when the unit gets destroyed. However
		in case of cyclic references to the unit, it may need to be called
		manually or through a UnitClearingTrigger object to break these
		cycles. For more information, see
		<a class="xref" href="#sc_ref_cycles" title="8.1. Reference cycles">Section 8.1: &#8220;Reference cycles&#8221; </a>.
		</p><p>
		In case if any errors are found during the clearing of the labels
		(such as a bug in the user code in the label clearing routine),
		they get printed to stderr. The reason for that is that the
		clearing is normally called from the object destructors, and
		there just isn't any proper way to report an error from a destructor.
		The only thing that can be done is printing them.
		</p><pre class="programlisting">$trigger = $unit-&gt;makeClearingTrigger();</pre><p>
		Create a unit clearing trigger object. When this object gets destroyed
		(at exiting the block, or when its encompassing object gets destroyed)
		it will cause the clearing of the unit.
		</p><pre class="programlisting">$unit-&gt;setTracer($tracer);
$oldTracer = $unit-&gt;getTracer();</pre><p>
		Set and read back a tracer object that will be called before and after
		each rowop executes in the unit. An <code class="computeroutput">undef</code> means <span class="quote">&#8220;<span class="quote">no tracer</span>&#8221;</span>. 
		See more information in
		<a class="xref" href="#sc_sched_tracing" title="7.10. Tracing the execution">Section 7.10: &#8220;Tracing the execution&#8221; </a>.
		</p><pre class="programlisting">$unit-&gt;callBound($rowop_or_tray, $fnreturn =&gt; $fnbinding, ...);
$unit-&gt;callBound([@rowops], $fnreturn =&gt; $fnbinding, ...);</pre><a class="indexterm" name="id600197"></a><p>
		An encapsulation of a streaming function call.
		The first argument is a rowop or a tray or a reference to an array of rowops 
		(but the trays are not allowed in the array). The rest are the pairs
		of FnReturns and FnBindings. The bindings are pushed onto the FnReturns,
		then the rowops are called, then the bindings are popped. It replaces
		a whole block that would contain an AutoFnBind (described in
		<a class="xref" href="#sc_ref_autofnbind" title="19.19. AutoFnBind reference">Section 19.19: &#8220;AutoFnBind reference&#8221; </a>)
		and the call:
		</p><pre class="programlisting">{
  my $ab = Triceps::AutoFnBind-&gt;new(
    $fnreturn =&gt; $fnbinding, ...
  );
  $unit-&gt;call($rowop_or_tray);
}</pre><p>
		Only <code class="computeroutput">callBound()</code> does its work in C++, so it's more efficient
		than a Perl block, and it's shorter to write too.
		</p></div><div class="sect1" title="19.4. TableType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_table_type"></a>19.4. TableType reference</h2></div></div></div><a class="indexterm" name="id602966"></a><p>
		The TableType is the information about the structure of a Table.
		It can be used to create multiple Tables in the same mold.
		</p><pre class="programlisting">$tt = Triceps::TableType-&gt;new($rowType);</pre><p>
		Constructs the TableType. The TableType is anonymous, it has no string name.
		After that it can be configured by adding the index types. Eventually
		it has to be initialized and that freezes the table type and makes it
		immutable. All the steps up to and including the initialization must be
		done from a single thread, after initialization a table type may be
		shared between multiple threads.
		</p><pre class="programlisting">$tt-&gt;addSubIndex("indexName", $indexType);</pre><p>
		Adds an index type, naming it within the scope of the table type.  
		The result is the same table type (unless it's an
		<code class="computeroutput">undef</code> signifying an error), so the index type additions can be
		chained with each other and with the construction:
		</p><pre class="programlisting">$tt = Triceps::TableType-&gt;new($rowType)
  -&gt;addSubIndex("indexName1", $indexType1)
  -&gt;addSubIndex("indexName2", $indexType2)
;</pre><p>
		The table type initialization freezes not only the table type
		itself but also all the index types in it. Also, the index types
		become permanently tied to this one table type.  That would make things
		difficult if the same index type is added to two table types. To avoid
		these issues, <code class="computeroutput">addSubIndex()</code> adds not the actual argument index type but
		first creates a fresh uninitialized deep copy of it, and then adds it.
		</p><pre class="programlisting">$tt-&gt;initialize();</pre><p>
		Initializes the table type.
		The index types check most of their arguments at the initialization
		time, so that's where most of the errors will be reported. Calling
		<code class="computeroutput">initialize()</code> repeatedly will have no effect and just return the same
		result again and again. 
		</p><pre class="programlisting">$result = $tt-&gt;isInitialized();</pre><p>
		Checks whether the table type has been initialized.
		</p><pre class="programlisting">$rowType = $tt-&gt;rowType();
$rowType = $tt-&gt;getRowType();</pre><p>
		Returns the row type. One method name is historic, the other has been added
		for consistency.
		</p><pre class="programlisting">$indexType = $tt-&gt;findSubIndex("indexName");
$indexType = $tt-&gt;findSubIndexSafe("indexName");</pre><p>
		Finds an index type by name.
		This is symmetric with <code class="computeroutput">addSubIndex()</code>, so it works only for the
		top-level index types. To get the nested ones, repeat the same call on
		the found index types or see the following methods.
		The <code class="computeroutput">Safe</code> version returns <code class="computeroutput">undef</code> if the index is not
		found, instead of confessing.
		</p><pre class="programlisting">$indexType = $tt-&gt;findIndexPath( ["indexName", "nestedIndexName"] );</pre><p>
		Finds an index type by the path of names leading to it in the index type tree.
		If the path is not found, the function would confess.
		An empty path is also illegal and would cause the same result.
		The argument is not an array but a reference to array of names.
		</p><pre class="programlisting">($indexType, @keys) = $tt-&gt;findIndexKeyPath( ["indexName", "nestedIndexName"] );</pre><p>
		Finds by path an index type that allows the direct look-up by key
		fields. It requires that every index type in the path returns a
		non-empty array of fields in <code class="computeroutput">getKey()</code>. In practice it means that every
		index in the path must be a Hashed index. Otherwise the method
		confesses. When the Sorted and maybe other index types will support
		<code class="computeroutput">getKey()</code>, they will be usable with this method too.
		The argument is not an array but a reference to array of names.
		</p><p>
		Besides checking that each index type in the path works by keys, this
		method builds and returns the list of all the key fields required for a
		look-up in this index. Note that <code class="computeroutput">@keys</code> is an actual array and not a
		reference to array. The return protocol of this method is a little
		weird: it returns an array of values, with the first value being the
		reference to the index type, and the rest of them the names of the key
		fields.
		</p><pre class="programlisting">@idxPath = $tt-&gt;findIndexPathForKeys(@keyFields);</pre><p>
		Finds an index path that matches the set of key fields.
		It returns the array that represents the path.
		And then having the path you can find the
		index type as such. The index type and all the types in the path
		have to be of the Hashed variety (returning their set of keys
		with the method <code class="computeroutput">getKey()</code>). If the correct index cannot
		be found, an empty array is returned. If you specify the fields that
		aren't present in the row type in the first place, this is simply
		treated the same as being unable to find an index for these fields.
		If more that one index would match, the first one found in the direct
		order of the index tree walk is returned.
		</p><pre class="programlisting">$indexType = $tt-findSubIndexById($indexTypeId);</pre><p>
		Finds the first top-level index type of a particular kind. The <code class="computeroutput">$indexTypeId</code>
		is one of the <code class="computeroutput">IT_*</code> constants in integer or string form.
		</p><pre class="programlisting">$indexType = $tt-&gt;getFirstLeaf();</pre><p>
		Returns the first leaf index type (the one used for the default
		look-ups and iteration on the tables of this type).
		</p><pre class="programlisting">@indexTypes = $tt-&gt;getSubIndexes();
%indexTypes = $tt-&gt;getSubIndexes();</pre><p>
		Returns all the top-level index types.  The resulting array contains
		the pairs of names and index types. If the order is not important but
		you want to perform the look-ups by name, the result can be stored
		directly into a hash. However if you plan to use the data to add index
		types to another table type, don't use the hash because the order of
		indexes is important and the hash loses it.
		</p><pre class="programlisting">$result = $tt1-&gt;same($tt2);
$result = $tt1-&gt;equals($tt2);
$result = $tt1-&gt;match($tt2);</pre><p>
		The usual reference comparison methods.
		</p><p>
		Two table types are considered equal when they have the equal row types,
		and exactly the same set of index types, with the same names.
		</p><p>
		Two table types are considered matching when they have the matching row types,
		and matching set of index types, although the names of the index types
		may be different.
		</p><pre class="programlisting">$res = $tt-&gt;print();</pre><p>
		Presents the content of a table type as a human-readable description.
		Accepts the usual <code class="computeroutput">print()</code> arguments.
		</p><pre class="programlisting">$newtt = $tt-&gt;copy();</pre><p>
		Copy the table type, along with copying all the index types in
		it, since each table type must have its own instances of the index
		types. The copied table type is always uninitialized and thus can
		be further extended by defining more indexes and aggregators.
		</p><p>
		In case if the table type collected errors, the errors aren't copied,
		and in general you should not copy such a table type. The errors
		will be detected again when you try to initialize the copy.
		</p><pre class="programlisting">$newtt = $tt-&gt;copyFundamental();
$newtt = $tt-&gt;copyFundamental(@idx_type_paths);
$newtt = $tt-&gt;copyFundamental("NO_FIRST_LEAF", @idx_type_paths);</pre><p>
		Copy only the fundamental data organization of the table type:
		the row type and the primary index (the whole path to the
		first leaf index type), and leave alone the rest. All the aggregators
		on all the indexes, even on the primary one, are not included in the
		copy. This is a convenient way to create another table, usually
		in a different thread, that would add its own secondary indexes
		and aggregators. See
		<a class="xref" href="#sc_mt_objects" title="16.4. Object passing between threads">Section 16.4: &#8220;Object passing between threads&#8221; </a>
		for more detail.
		</p><p>
		The optional index type paths can be used to include the secondary
		indexes into the copy. Each path is a reference to an array of index names,
		such as <code class="computeroutput">[ "byDate", "byAddress", "fifo" ]</code>. The path must
		lead all the way to a leaf index. A special path element <code class="computeroutput">"+"</code>
		can be used last with the meaning <span class="quote">&#8220;<span class="quote">the first leaf index from this point</span>&#8221;</span>.
		Multiple paths may overlap, their overlapping parts will be copied only once.
		A special string <code class="computeroutput">"NO_FIRST_LEAF"</code> used as the first argument
		excludes the first leaf index
		from the copy, then only the explicitly specified index paths will be copied.
		</p></div><div class="sect1" title="19.5. IndexType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_index_type"></a>19.5. IndexType reference</h2></div></div></div><a class="indexterm" name="id596462"></a><p>
		The IndexType is a part of TableType and defines the structuring
		of rows in the table. It provides the order of rows and optionally
		a way to find them quickly by the key. The configuration of the
		index type defines the parameters for each index instance, i.e.
		each row group in an index of this type, not for the whole table.
		The difference between indexes and index types is explained in the
		<a class="xref" href="#sc_table_indextree" title="9.10. The index tree">Section 9.10</a>.
		The index types are connected in a table type to form a tree.
		</p><p>
		The index types in Triceps are available in the following kinds:
		</p><div class="variablelist"><dl><dt><span class="term">Hashed</span></dt><dd>
			Provides quick random access based on the key formed from the
			fields of the row in the table. May be leaf or non-leaf. The order
			of the rows in the index will be repeatable between the runs of the
			same program on the same machine architecture, but not easily
			predictable. Internally the rows are stored in a tree but the
			comparisons of the rows are accelerated by pre-calculating a hash
			value from the key fields and keeping it in the row handle.
			</dd><dt><span class="term">FIFO</span></dt><dd>
			Keeps the rows in the order they were received. There is no
			efficient way to find a particular row in this index, the search in
			it works by going through all the rows sequentially and comparing
			the rows for exact equality. It provides the expiration policies
			based on the row count. It may only be a leaf.
			</dd><dt><span class="term">PerlSorted</span></dt><dd>
			Provides random access based on the key field comparison, expressed
			as a Perl function. This results in a predictable order of rows but
			the execution of the Perl code makes it slower than the Hashed
			index. May be leaf or non-leaf. Often also called simply <span class="quote">&#8220;<span class="quote">Sorted</span>&#8221;</span>.
			</dd><dt><span class="term">SimpleOrdered</span></dt><dd>
			A Perl template on top of the PerlSorted index,
			that allows to specify the keys in a more convenient way. 
			Often also called simply <span class="quote">&#8220;<span class="quote">Ordered</span>&#8221;</span>.
			</dd></dl></div><pre class="programlisting">$it = Triceps::IndexType-&gt;newHashed($optionName =&gt; $optionValue, ...);</pre><p>
		Creates a Hashed index type.  The only available and mandatory option is:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">key =&gt; [ @fields ]</code></span></dt><dd>
			The argument is a reference to an array of strings
			that specify the names of the key fields (<code class="computeroutput">key =&gt; ["f1", "f2"]</code>).
			</dd></dl></div><pre class="programlisting">$it = Triceps::IndexType-&gt;newFifo($optionName =&gt; $optionValue, ...);</pre><p>
		Creates a FIFO index type.  The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">limit =&gt; $limit</code></span></dt><dd>
			Sets the limit value for the replacement policy. Once the number of
			rows attempts to grow beyond this value, the older records get
			removed. Setting it to 0 disables the replacement policy.
			Don't try to set it to negative values, they will be
			treated as unsigned, and thus become some very large positive
			ones. Optional. Default: 0.
			</dd><dt><span class="term"><code class="computeroutput">jumping =&gt; 0/1</code></span></dt><dd>
			Determines the variation of the replacement policy in effect. If
			set to 0, implements the sliding window policy, removing
			the older rows one by one. If non-0, implements the jumping window
			policy, removing all the older rows when a new row causes the limit
			overflow. Optional. Default: 0.
			</dd><dt><span class="term"><code class="computeroutput">reverse =&gt; 0/1</code></span></dt><dd>
			Defines the iteration order. If non-0, the iteration on this index
			goes in the reverse order. However the expiration policy still
			works in the direct order! Optional. Default: 0.
			</dd></dl></div><pre class="programlisting">$it = Triceps::IndexType-&gt;newPerlSorted($sortName, $initFunc,
  $compareFunc, @args...);</pre><p>
		Creates a PerlSorted index type. The arguments are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">$sortName</code></span></dt><dd>
			a string describing the sorting order, used in <code class="computeroutput">print()</code>
			and error messages. 
			</dd><dt><span class="term"><code class="computeroutput">$initFunc</code></span></dt><dd>
			a function reference that can be used
			to generate the comparison function dynamically at the table type
			initialization time (or use <code class="computeroutput">undef</code> with a fixed comparison
			function). 
			A source code string may be used instead of the function reference, see
			<a class="xref" href="#sc_code" title="4.4. Code references and snippets">Section 4.4: &#8220;Code references and snippets&#8221; </a>. 
			</dd><dt><span class="term"><code class="computeroutput">$compareFunc</code></span></dt><dd>
			a function reference to the fixed comparison function, if preferred
			(or use <code class="computeroutput">undef</code> if it will be generated dynamically by the init
			function). 
			A source code string may be used instead of the function reference, see
			<a class="xref" href="#sc_code" title="4.4. Code references and snippets">Section 4.4: &#8220;Code references and snippets&#8221; </a>. 
			</dd><dt><span class="term"><code class="computeroutput">@args</code></span></dt><dd>
			optional extra arguments for the
			initialization and/or comparison function.
			</dd></dl></div><p>
		See the details in
		<a class="xref" href="#sc_table_sorted" title="9.8. Sorted index">Section 9.8: &#8220;Sorted index&#8221; </a>.
		</p><p>
		The handling of the fatal errors (as in <code class="computeroutput">die()</code>) in the initialization 
		and especially comparison functions is an interesting subject.
		The errors propagate properly through the table,
		and the table operations confess with the Perl handler's error message.
		But since an error in the comparison function means that things are going
		very, very wrong, after that the table becomes inoperative and will die
		on all the subsequent operations as well. You need to be very careful
		in writing these functions.
		</p><pre class="programlisting">$it = Triceps::SimpleOrderedIndex-&gt;new($fieldName =&gt; $order, ...);</pre><p>
		Creates a SimpleOrdered index type.
		The arguments are the key fields. <code class="computeroutput">$order</code> is one of
		the constants <code class="computeroutput">"ASC"</code> for ascending or <code class="computeroutput">"DESC"</code> for
		descending.
		</p><pre class="programlisting">$indexType2-&gt;addSubIndex("indexName", $indexType1);</pre><p>
		Attaches the nested <code class="computeroutput">$indexType1</code> under <code class="computeroutput">$indexType2</code>.
		More exactly, attaches an uninitialized deep copy of <code class="computeroutput">$indexType1</code>,
		the same as when adding an index type under a table type.
		It returns the reference to the same <code class="computeroutput">$indexType2</code>, so these calls can be
		conveniently chained, to add multiple sub-indexes under it. If
		<code class="computeroutput">$indexType2</code> can not be non-leaf, the call will fail.
		</p><pre class="programlisting">$itSub = $it-&gt;findSubIndex("indexName");
$itSub = $it-&gt;findSubIndexSafe("indexName");
$itSub = $it-&gt;findSubIndexById($indexTypeId);

@itSubs = $it-&gt;getSubIndexes();
$itSub = $it-&gt;getFirstLeaf();</pre><p>
		Perform the same actions as the same-named methods in the TableType.
		If the index type is already a leaf, <code class="computeroutput">getFirstLeaf()</code> will return itself.
		</p><pre class="programlisting">$it-&gt;setAggregator($aggType);</pre><p>
		Sets an aggregator type on an index type.  It will create aggregators that run on the
		rows stored withing the indexes of this type.
		The value returned is the same index type reference <code class="computeroutput">$it</code>, allowing the
		chaining calls, along with the <code class="computeroutput">addSubIndex()</code>. Only one aggregator type
		is allowed on an index type. Calling <code class="computeroutput">setAggregator()</code> repeatedly will
		replace the aggregator type. 
		</p><pre class="programlisting">$aggType = $it-&gt;getAggregator();</pre><p>
		Returns the aggregator type set on this index type.
		The returned value may be <code class="computeroutput">undef</code> if no
		aggregator type has been set.
		</p><pre class="programlisting">$result = $it-&gt;isInitialized();</pre><p>
		Returns, whether this type has been initialized.
		The index type gets initialized when the table type where it belongs
		gets initialized. After an index type has been initialized, it can not
		be changed any more, and any methods that change it will return an
		error.
		</p><pre class="programlisting">$itCopy = $it-&gt;copy();</pre><p>
		Creates a copy of the index type.
		The copy reverts to the un-initialized state. It's always a deep copy,
		with all the nested index and aggregator types copied. All of these
		copies are un-initialized.
		</p><pre class="programlisting">$itCopy = $it-&gt;flatCopy();</pre><p>
		Creates a copy of the index type object 
		itself, without any connected object hierarchies such as the nested
		indexes or aggregators.
		</p><pre class="programlisting">$tabType = $it-&gt;getTabtype();
$tabType = $it-&gt;getTabtypeSafe();</pre><p>
		Returns the table type, to which this index type is tied.
		When an index type becomes initialized, it becomes tied to a particular table type.
		If the index type is not initialized yet,
		<code class="computeroutput">getTabtype()</code> would confess while <code class="computeroutput">getTabtypeSafe()</code> would 
		return an <code class="computeroutput">undef</code>.
		Which method to use, depends on the circumstances: if this situation
		is valid and you're ready to check for it and handle it, use
		<code class="computeroutput">getTabtypeSafe()</code>, otherwise use <code class="computeroutput">getTabtype()</code>.
		</p><pre class="programlisting">$result = $it1-&gt;same($it2);
$result = $it1-&gt;equals($it2);
$result = $it1-&gt;match($it2);
$result = $it-&gt;print();</pre><p>
		The usual sameness comparisons and print methods.
		</p><p>
		Two index types are considered equal when they are of the same kind
		(type id), their type-specific parameters are equal, they have the
		same number of sub-indexes, with the same names, and equal pair-wise.
		They must also have the equal aggregators.
		</p><p>
		Two index types are considered matching when they are of the same kind,
		have matching type-specific parameters, they have the same number of
		sub-indexes, which are matching pair-wise, and the matching aggregators.
		The names of the sub-indexes may differ.
		As far as the type-specific parameters are concerned, it depends on the
		kind of the index type. The FIFO type considers any parameters matching.
		For a Hashed index the key fields must be the same. For a Sorted index
		the sorted condition must also be the same, and by extension this
		means the same condition for the Ordered index.
		</p><pre class="programlisting">$result = $it-&gt;isLeaf();</pre><p>
		Returns 1 if the index type is a leaf, 0 if not.
		</p><pre class="programlisting">@keys = $it-&gt;getKey();</pre><p>
		Returns the array of field names forming the key of this index. 
		Currently works only on the Hashed index types. On the other index
		types it returns an empty array, though probably a better support would
		be available for the PerlSorted/SimpleOrdered indexes in the future.
		</p><pre class="programlisting">$it-&gt;setComparator($compareFunc, @args...);</pre><p>
		A special method that works only on the PerlSorted index types.
		Sets an auto-generated comparator function and its optional
		arguments from an initializer function at the table initialization
		time. On success it returns 1. For all other index types this method
		confesses.
		A source code string may be used instead of the function reference, see
		<a class="xref" href="#sc_code" title="4.4. Code references and snippets">Section 4.4: &#8220;Code references and snippets&#8221; </a>. 
		</p></div><div class="sect1" title="19.6. AggregatorType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_agg_type"></a>19.6. AggregatorType reference</h2></div></div></div><a class="indexterm" name="id602593"></a><p>
		The aggregator type describes an aggregation. It gets connected
		to an index type which defines the grouping for the aggregator.
		Whenever the aggregation is performed, the code from the
		aggregator type receives the group context as its argument.
		</p><pre class="programlisting">$at = Triceps::AggregatorType-&gt;new($resultRowType, "aggName", $initFunc,
  $handlerFunc, @args);</pre><p>
		Creates an aggregator type.
		The rows created by the aggregator will be of <code class="computeroutput">$resultRowType</code>. The
		aggregator name is used to name the aggregator result label in the
		table, <span class="quote">&#8220;<span class="quote">tableName.aggName</span>&#8221;</span>. It is also used to get the reference of
		that label from the table.
		</p><p>
		<code class="computeroutput">$initFunc</code> and <code class="computeroutput">$handlerFunc</code> provide either references or
		source code strings for the init and handler functions (as usual, if the format
		is the source code, the <code class="computeroutput">sub { ... }</code> wrapper will be added implicitly, see
		<a class="xref" href="#sc_code" title="4.4. Code references and snippets">Section 4.4: &#8220;Code references and snippets&#8221; </a>). 
		The init function is
		called when the row group (contained in an index of the type, on which
		this aggregator type is set) is created. It initializes the group's
		aggregation state. The handler function gets called on the
		changes to the group.  See the details in
		<a class="xref" href="#sc_aggregation_optimized" title="11.5. Optimized DELETEs">Section 11.5: &#8220;Optimized DELETEs&#8221; </a>,
		<a class="xref" href="#sc_aggregation_additive" title="11.6. Additive aggregation">Section 11.6: &#8220;Additive aggregation&#8221; </a>
		and
		<a class="xref" href="#sc_aggregation_args" title="11.7. Computation function arguments">Section 11.7: &#8220;Computation function arguments&#8221; </a>.
		The optional <code class="computeroutput">@args</code> are passed to both the init and handler functions.
		</p><p>
		If any fatal errors (as in <code class="computeroutput">die()</code>) occur in the 
		aggregator functions, they propagate properly through the table,
		and the table operations confess with the Perl handler's error message.
		But since an error in the aggregator function means that things are going
		very, very wrong, after that the table becomes inoperative and will die
		on all the subsequent operations as well. You need to be very careful
		in writing these functions.
		</p><pre class="programlisting">$result = $at1-&gt;same($at2);
$result = $at1-&gt;equals($at2);
$result = $at1-&gt;match($at2);
$result = $at-&gt;print();
$atCopy = $at-&gt;copy();</pre><p>
		The methods for comparison, printing and copying work similarly to the index types.
		</p><a class="indexterm" name="id574939"></a><p>
		The equal aggregator types have the equal result row types, same names,
		same initialization and handler function references, same arguments.
		</p><a class="indexterm" name="id567791"></a><p>
		The matching aggregator types may differ in the aggregator name and in
		the field names of the result row type. However the function references
		and their arguments must still be the same.
		</p><pre class="programlisting">$rt = $at-&gt;getRowType();</pre><p>
		Get back the result row type.
		</p></div><div class="sect1" title="19.7. SimpleAggregator reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_simple_agg"></a>19.7. SimpleAggregator reference</h2></div></div></div><a class="indexterm" name="id574867"></a><p>
		SimpleAggregator provides an easier way to describe aggregations with
		the SQL-like aggregation functions. It also supports the user-defined
		aggregation functions.
		</p><p>
		The table types with SimpleAggregator cannot be currently exported
		between threads through a nexus, see
		<a class="xref" href="#sc_mt_objects" title="16.4. Object passing between threads">Section 16.4: &#8220;Object passing between threads&#8221; </a>
		for more detail.
		</p><pre class="programlisting">$tabType = Triceps::SimpleAggregator::make($optName =&gt; $optValue, ...);</pre><p>
		Creates an aggregator type from the high-level description and
		sets it on an index type in the table type. Returns back the
		table type passed as an option argument. Confesses on errors.
		This is <span class="bold"><strong>not</strong></span> a class constructor. It creates a common
		AggregatorType with the automatically generated code for the
		initialization and handler functions.
		</p><p>
		Most of the options are mandatory, unless noted otherwise.
		The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">name =&gt; $name</code></span></dt><dd>
			The aggregator type name.
			</dd><dt><span class="term"><code class="computeroutput">tabType =&gt; $tabType</code></span></dt><dd>
			Table type to put the aggregator on. It must be un-initialized yet.
			</dd><dt><span class="term"><code class="computeroutput">idxPath =&gt; [ @path ]</code></span></dt><dd>
			A reference to an array of index names, forming the path to the
			index where the aggregator type will be set. For example,
			<code class="computeroutput">["index", "subIndex"]</code>.
			</dd><dt><span class="term"><code class="computeroutput">result =&gt; [ [fieldName =&gt; $type, $funcName, $argFunc], ... ]</code></span></dt><dd><p>
			A reference to an array defining the result of the aggregation.
			It consists of the repeating groups of four elements:
			</p><pre class="programlisting">fieldName =&gt; $type, $funcName, $argFunc,</pre><p>
			Here <code class="computeroutput">$type</code> is the field type name, <code class="computeroutput">$funcName</code> is the name of the
			aggregtion function (case-sensitive, see the list in
			<a class="xref" href="#sc_aggregation_simple" title="11.9. SimpleAggregator">Section 11.9: &#8220;SimpleAggregator&#8221; </a>),
			and 
			<code class="computeroutput">$argFunc</code> is the code reference that computes the argument of the aggregation function.
			It's a function that receives the current row being aggregated
			as <code class="computeroutput">$_[0]</code> and computes a value from its fields. These values
			from all the rows in the group then get fed to the aggregation function.
			If the aggregation function requires no argument, <code class="computeroutput">argFunc</code> must be
			<code class="computeroutput">undef</code>.
			For example:
			</p><pre class="programlisting">  result =&gt; [
    symbol =&gt; "string", "last", sub {$_[0]-&gt;get("symbol");},
    count =&gt; "int32", "count_star", undef,
    cost =&gt; "float64", "sum", sub {$_[0]-&gt;get("size") * $_[0]-&gt;get("price")];},
    vwap =&gt; "float64", "nth_simple", sub { [1, $_[0]-&gt;get("price")];},
  ],</pre></dd><dt><span class="term"><code class="computeroutput">saveRowTypeTo =&gt; \$rt</code></span></dt><dd>
			Optional. A reference to a scalar where to save the result row type. It will be
			available when <code class="computeroutput">Triceps::SimpleAggregator::make()</code> returns.
			Later when a table with this aggregator type gets constructed,
			its result row type may also be found with
			<code class="computeroutput">$table-&gt;getAggregatorLabel("aggName")-&gt;getRowType()</code>.
			</dd><dt><span class="term"><code class="computeroutput">saveInitTo =&gt; \$code</code></span></dt><dd>
			Optional. A reference to a scalar where to save the auto-generated source
			code of the initialization function for diagnostics.
			</dd><dt><span class="term"><code class="computeroutput">saveComputeTo =&gt; \$code</code></span></dt><dd>
			Optional. A reference to a scalar where to save the auto-generated source
			code of the handler function for diagnostics.
			</dd><dt><span class="term"><code class="computeroutput">functions =&gt; { %definitions }</code></span></dt><dd>
			Optional. The additional user-defined aggregation functions. See
			the description of their structure in 
			<a class="xref" href="#sc_aggregation_simple" title="11.9. SimpleAggregator">Section 11.9: &#8220;SimpleAggregator&#8221; </a>.
			</dd></dl></div><p>
		The aggregator types produced by the SimpleAggregator would be equal
		and matching only if they have been produced by copying (you can
		also copy a table type or index type with an AggregatorType in it).
		</p></div><div class="sect1" title="19.8. Table reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_table"></a>19.8. Table reference</h2></div></div></div><a class="indexterm" name="id605219"></a><p>
		The Table provides the structured data storage in Triceps.
		</p><pre class="programlisting">$t = $unit-&gt;makeTable($tabType, "tableName");</pre><p>
		Creates a table of a given table type.
		The table type must be initialized before it can be used to create
		tables. The tables are strictly single-threaded.
		</p><p>
		The table name is used for the error messages and as a base for the names of
		the table labels.
		</p><a class="indexterm" name="id577836"></a><p>
		A word needs to be said about the handling of the fatal errors (as in <code class="computeroutput">die()</code>)
		in the custom Perl functions provided in the user elements of the table,
		such as the PerlSortedIndex and aggregators.
		The errors propagate properly through the table,
		and the table operations confess with the Perl handler's error message.
		But since an error in these functions means that things are going
		very, very wrong, after that the table becomes inoperative and will die
		on all the subsequent operations as well.
		This is known as a <span class="quote">&#8220;<span class="quote">sticky error</span>&#8221;</span>.  You need to be very careful
		in writing these functions.
		</p><pre class="programlisting">$result = $t1-&gt;same($t2);</pre><p>
		The usual comparison for sameness. (There is no comparison for equality
		and mathicng, use the table type for that; nor printing, use the table
		name and/or table type for that).
		</p><pre class="programlisting">$lb = $t-&gt;getInputLabel();
$lb = $t-&gt;getPreLabel();
$lb = $t-&gt;getOutputLabel();
$lb = $t-&gt;getDumpLabel();
$lb = $t-&gt;getAggregatorLabel("aggName");</pre><p>
		Get the labels that are creates as a part of the table. With an invalid
		name for an argument, <code class="computeroutput">getAggregatorLabel()</code> returns an <code class="computeroutput">undef</code>.
		</p><pre class="programlisting">$tt = $t-&gt;getType();
$u = $t-&gt;getUnit();
$rt = $t-&gt;getRowType();
$name = $t-&gt;getName();</pre><p>
		Get back the information about the table configuration.
		</p><pre class="programlisting">$result = $t-&gt;size();</pre><p>
		Returns the number of rows in the table.
		</p><pre class="programlisting">$rh = $t-&gt;makeRowHandle($row);
$rh = $t-&gt;makeNullRowHandle();</pre><p>
		Create the row handles.  The row must be of a matching type, and it will
		be cast to the table's row type: when read back from the row handle,
		the row will have the table's row type as its type. The casting does
		not involve any copying or modification of the row, it's still shared
		by reference counting. And the original row as it was would still
		return the same type. Basically, the row itself is untyped, its type
		is determined by the container where it is stored. The requirement
		for the matching types ensures that when a row is passed between the
		containers, they have a compatible notion of the row type.
		</p><p>
		A NULL row
		handle is a handle without a row in it. It can not be placed into a
		table but this kind of row handle gets returned by table operations to
		indicate things not found. In case if you want to fool some of your
		code by slipping it a NULL handle, <code class="computeroutput">makeNullRowHandle()</code> provides a way
		to do it. The row handles belong to a particular table and can not be
		mixed between them, even if the tables are of the same type.
		</p><p>
		The table operations can be done by either sending the rowops to the
		table's input label or by calling the operations directly.
		</p><pre class="programlisting">$result = $t-&gt;insert($row_or_rh);</pre><p>
		Inserts a row or row handle into the table. The row handle must
		not be in the table before the call, it may be either freshly created
		or previously removed from the table. If a row is used as an argument,
		it is internally wrapped in a fresh row handle, and then that row
		handle inserted. An insert may trigger the replacement policy in the
		table's indexes and have some rows removed before the insert is done.
		Returns 1 on success, 0 if the insert can not be done (the row handle is already in
		the table or NULL).
		</p><pre class="programlisting">$result = $t-&gt;remove($rh);</pre><p>
		Removes a row handle from the table. The row handle must be previously
		inserted in the table, and either found in it or a reference to it
		remembered from before. An attempt to remove a newly created row handle
		will have no effect. 
		The result is 1 on success (even if the row handle was not in the table).
		</p><pre class="programlisting">$result= $t-&gt;deleteRow($row);</pre><p>
		Finds the handle of the matching row by the table's first leaf index
		and removes it. Returns 1 on success, 0 if the row was not found.
		Unlike <code class="computeroutput">insert()</code>, the
		deletion methods for a row handle and a row are named differently to
		emphasize their difference. The method <code class="computeroutput">remove()</code> must get a reference to
		the exactly same row handle that was previously inserted. The method
		<code class="computeroutput">deleteRow()</code> does not have to get the same row as was previously
		inserted, instead it will find a row handle of the row that has the
		same key as the argument, according to the first leaf index.
		<code class="computeroutput">deleteRow()</code> never deletes more than one row. If the index contains
		multiple matching rows (for example, if the first leaf is a FIFO
		index), only one of them will be removed, usually the first one (the
		exact choice depends on what row gets found by the index).
		</p><pre class="programlisting">$rh = $t-&gt;find($row_or_rh);
$rh = $t-&gt;findIdx($idxType, $row_or_rh);</pre><p>
		Find the row handle the table by indexes.  If the row is not found,
		return a NULL row handle. If the row is of an incorrect type or the
		index type is incorrect, confesses. The index type must be exactly
		the one belonging to the type of this table (not its copy nor the
		original from which it was copied into the table's type), so the
		only way to get it is to find it in the table's type after it
		has been constructed.
		The default <code class="computeroutput">find()</code> works
		using the first leaf index type, i.e. the following two are equivalent:
		</p><pre class="programlisting">$t-&gt;find($r);
$t-&gt;findIdx($t-&gt;getType()-&gt;getFirstLeaf(), $r);</pre><p>
		but the <code class="computeroutput">find()</code> version is slightly more efficient because it handles
		the index types inside the C++ code and does not create the Perl
		wrappers for them.
		</p><p>
		The <code class="computeroutput">find()</code> operation is also used internally by <code class="computeroutput">deleteRow()</code> and to
		process the rowops received at the table's input label.
		</p><p>
		If a row is used as an argument for <code class="computeroutput">find</code>, a temporary row handle is
		internally created for it, and then the find is performed on it. Note
		that if you have a row handle that is already in the table, there is
		generally no use calling <code class="computeroutput">find</code> on it, you will just get the same row
		handle back (well, except for the case of multi-valued indexes, then
		you will get back some matching row handle, usually the first one,
		which may be the same or not). 
		</p><p>
		A <code class="computeroutput">findIdx()</code> with a non-leaf index argument is a special case: it
		returns the first row handle of the group that has the key matching the
		argument. The order of <span class="quote">&#8220;<span class="quote">first</span>&#8221;</span> in this case is defined according to
		that index'es first leaf sub-index.
		</p><pre class="programlisting">$rh = $t-&gt;findBy("fieldName" =&gt; $fieldValue, ...);
$rh = $t-&gt;findIdxBy($idxType, "fieldName" =&gt; $fieldValue, ...);</pre><p>
		Convenience methods that construct a row from the field arguments and then find it.
		They confess on incorrect arguments.
		</p><pre class="programlisting">$rh = $t-&gt;begin();
$rh = $t-&gt;next($rh);
$rh = $t-&gt;beginIdx($idxType);
$rh = $t-&gt;nextIdx($idxType, $rh);</pre><p>
		Iteration on the table. The methods <code class="computeroutput">next()</code> and <code class="computeroutput">nextIdx()</code> are equivalent
		to the same methods of the row handle.
		As usual, the versions without an explicit index type use the first
		leaf index type. The <code class="computeroutput">begin</code> methods return the first row handle
		according to an index'es order, the <code class="computeroutput">next</code> methods advance to the next
		row handle. When the end of the table is reached, these methods return
		a NULL row handle. The <code class="computeroutput">next</code> methods also return a NULL row handle if their
		argument row handle is a NULL or not in the table. So, if you iterate
		and remove the row handles, make sure to advance the iterator first and
		only then remove the current row handle.
		</p><p>
		If the index argument is non-leaf, it's equivalent to its first leaf. 
		</p><pre class="programlisting">$endrh = $t-&gt;nextGroupIdx($subIdxType, $rh_in_group);</pre><p>
		Finds the first row handle of the next group, where <code class="computeroutput">$subIdxType</code> is the
		first index inside the group (not its parent index!).  Confesses on errors.
		The result also works as the end marker handle of the current group. 
		</p><p>
		To iterate through only a group, use <code class="computeroutput">findIdx()</code> on the parent index type
		of the group to find the first row of the group. Then things become
		tricky: take the first index type one level below it to determine the
		iteration order (a group may have multiple indexes in it, defining
		different iteration orders, the first one will give the group's default
		order).  Use that index type with <code class="computeroutput">nextGroupIdx()</code> to find the
		first row handle past the end of the group, and with the usual
		<code class="computeroutput">nextIdx()</code> to advance the iterator. 
		However the end of the group will not be signaled by a NULL row handle. 
		It will be signaled by <code class="computeroutput">nextIdx()</code> returning the same row
		handle as previously returned by <code class="computeroutput">nextGroupIdx()</code>
		(compare them with <code class="computeroutput">$endrh-&gt;same($itrh)</code>).
		</p><p>
		The value returned by <code class="computeroutput">nextGroupIdx()</code> is actually the first row handle of the next group, so
		it can also be used to jump quickly to the next group, and essentially
		iterate by groups. After the last group, <code class="computeroutput">nextGroupIdx()</code> will return a
		NULL row handle. Which is OK for iteration, because at the end of the
		last group <code class="computeroutput">nextIdx()</code> will also return a NULL row handle.
		</p><p>
		What if a group has a whole sub-tree of indexes in it, and you want to
		iterate it by the order of not the first sub-index? Still use <code class="computeroutput">findIdx()</code>
		in the same way to find a row handle in the desired group. But then
		convert it to the first row handle in the desired order:
		</p><pre class="programlisting">$beginrh = $t-&gt;firstOfGroupIdx($subIdxType, $rh);</pre><p>
		The <code class="computeroutput">$subIdxType</code> is the same as used in <code class="computeroutput">nextGroupIdx()</code>.
		After that proceed as before: get the end marker with <code class="computeroutput">nextGroupIdx()</code> on
		the same sub-index, and iterate with <code class="computeroutput">nextIdx()</code> on it.
		</p><p>
		This group iteration is somewhat messy and tricky, and maybe something
		better can be done with it in the future. If you look closely, you can
		also see that it doesn't allow to iterate the groups in every possible
		order. For example, if you have an index type hierarchy
		</p><pre class="programlisting">A
+-B
| +-D
| | +-G
| | +-H
| +-E
+-C</pre><p>
		and you want to iterate on the group inside B, you can go in the order
		of D or G (which is the same as D, since G is the first leaf of D) or
		of E, but you can not go in the order of H. But for most of the
		practical purposes it should be good enough.
		</p><pre class="programlisting">$size = $table-&gt;groupSizeIdx($idxType, $row_or_rh);</pre><p>
		Finds the size of a group without iteration on it. <code class="computeroutput">$idxType</code>
		is the parent index of the group (the same as would be used with
		<code class="computeroutput">findIdx()</code>).  Naturally, it must be a non-leaf index. (Using
		a non-leaf index type is not an error but it always returns 0, because
		there are no groups under it).  Confesses on errors. The argument may
		be a row or row handle that identifies any row in the group.  If the
		argument is a row, it gets handled similarly to <code class="computeroutput">findIdx()</code>: a
		temporary row handle gets created, used to find the result, and then
		destroyed.  If there is no such group in the table, the result will be
		0.  If the argument is a row handle, that handle may be in the table or
		not in the table, either will be handled transparently (though calling
		it for a row handle that is in the table is more efficient because the
		group would not need to be found first). 
		</p><pre class="programlisting">$table-&gt;clear();
$table-&gt;clear($limit);</pre><p>
		Deletes the rows from the table.
		If <code class="computeroutput">$limit</code> is absent or 0, the whole table gets cleared. If it's greater
		than 0, no more than this number of rows will be deleted. A negative
		limit is an error. The deletion happens in the usual order of the first
		leaf index, and the rowops are sent to the table's output label as
		usual. It's really the same thing as running a loop over all the row
		handles and removing them, only with a C++ imnplementation it's more
		efficient than in Perl. There is no return value, the errors cause a
		confession.
		</p><pre class="programlisting">$fret = $table-&gt;fnReturn();</pre><p>
		Returns an FnReturn object connected to the output of this table.
		The FnReturn contains the labels <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span>, 
		<span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span> (used with <code class="computeroutput">dumpAll</code> methods) and the named labels for
		all aggregators.  The FnReturn object is created on the first call of
		this method and is kept in the table.  All the following calls return
		the same object. 
		This has some interesting consequences for the <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span>
		label: the rowop for the <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> label doesn't get created at all if
		there is nothing chained from that label. But when the FnReturn gets
		created, one of its labels gets chained from the <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> label. Which
		means that once you call <code class="computeroutput">$table-&gt;fnReturn()</code> for the first time, you
		will see that table's <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> label called in all the traces. It's not a
		huge extra overhead, but still something to keep in mind and not be
		surprised when calling <code class="computeroutput">fnReturn()</code> changes all your traces.
		See more detail in
		<a class="xref" href="#sc_strf_tables" title="15.7. Streaming functions and tables">Section 15.7: &#8220;Streaming functions and tables&#8221; </a>.
		</p><pre class="programlisting">$table-&gt;dumpAll();
$table-&gt;dumpAll($opcode);</pre><p>
		Sends all the table's rows in their default order to the label <span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span>.
		The opcode for the created rowops is OP_INSERT by default, or can be specified
		explicitly as an argument. The typical usage is to push a binding on the table's
		FnReturn to process these dumped rowops.
		</p><pre class="programlisting">$table-&gt;dumpAllIdx($indexType);
$table-&gt;dumpAllIdx($indexType, $opcode);</pre><p>
		Similar to <code class="computeroutput">dumpAll()</code>, only allows to send the rows in an order
		specified by another index type.
		As usual, the index type must belong to the exact type of this table.
		</p></div><div class="sect1" title="19.9. RowHandle reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_rowhandle"></a>19.9. RowHandle reference</h2></div></div></div><a class="indexterm" name="id607430"></a><p>
		A RowHandle is essentially the glue that keeps a row in the table. A
		row's handle keeps the position of the row in the table and allows to
		navigate from it in the direction of every index. It also keeps the
		helper information for the indexes. For example, the Hashed index
		calculates the has value for the row's fields once and remembers it in
		the handle. The table operates always on the handles, never directly on
		the rows. The table methods that accept rows as arguments, implicitly
		wrap them into handles before doing any operations.
		</p><p>
		A row handle always belongs to a particular table, and can not be mixed
		between the tables, even if the tables are of the same type. Even
		before a row handle has been inserted into the table and after it has
		been removed, it still belongs to that table and can not be inserted
		into any other one.
		</p><p>
		Just as the tables are single-threaded, the row handles are
		single-threaded.
		</p><pre class="programlisting">$rh = $table-&gt;makeRowHandle($row);</pre><p>
		Creates the RowHandle.  The newly created row handle is not inserted in
		the table. The type of the argument row must be matching the table's
		row type.
		</p><pre class="programlisting">$result = $rh-&gt;isInTable();</pre><p>
		Finds out, whether the row handle is inserted in the table. If the
		row handle is NULL, it will quietly return 0.
		</p><pre class="programlisting">$result = $rh-&gt;isNull();</pre><p>
		Finds out if the RowHandle is NULL.  A RowHandle may be NULL
		to indicate the special conditions. It pretty much means that there is only the Perl wrapper
		layer of RowHandle but no actual RowHandle under it. This happens to be
		much more convenient than dealing with undefined values at Perl level.
		The NULL row handles are returned by the certain table calls to
		indicate that the requested data was not found in the table.
		</p><pre class="programlisting">$rh = $table-&gt;makeNullRowHandle();</pre><p>
		Creates a NULL RowHandle.
		</p><pre class="programlisting">$result = $rh1-&gt;same($rh2);</pre><p>
		The usual comparison for sameness.
		</p><pre class="programlisting">$row = $rh-&gt;getRow();
$row = $rh-&gt;getRowSafe();</pre><p>
		Extracts the row from the handle. The row will have the type of the
		table's row type. A row can not be extracted from a NULL row handle,
		in this situation <code class="computeroutput">getRow()</code> will confess and <code class="computeroutput">getRowSafe()</code>
		will return <code class="computeroutput">undef</code>.
		</p><pre class="programlisting">$rh = $rh-&gt;next();
$rh = $rh-&gt;nextIdx($idxType);
$rh = $rh-&gt;firstOfGroupIdx($idxType);
$rh = $rh-&gt;nextGroupIdx($idxType);</pre><p>
		These methods work exactly the same as the same-named table methods.
		They are essentially syntactic sugar over
		the table methods.
		</p></div><div class="sect1" title="19.10. AggregatorContext reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_aggcontext"></a>19.10. AggregatorContext reference</h2></div></div></div><a class="indexterm" name="id602017"></a><p>
		AggregatorContext is one of the arguments passed to the aggregator
		computation function. It encapsulates the iteration through the
		aggregation group, in the order of the index on which the aggregator is
		defined. After the computation function returns, the context becomes
		invalidated and stops working, so there is no point in saving it
		between the calls. There is no way to construct the aggregator context
		directly.
		</p><p>
		All the methods of the AggregatorContext confess on errors.
		</p><p>
		An aggregator must never change the table. Any attempt to change the
		table is a fatal error.
		</p><pre class="programlisting">$result = $ctx-&gt;groupSize();</pre><p>
		Returns the number of rows in the group.
		</p><pre class="programlisting">$rowType = $ctx-&gt;resultType();</pre><p>
		Returns the row type of the aggregation result.
		</p><pre class="programlisting">$rh = $ctx-&gt;begin();</pre><p>
		Returns the first row handle of the iteration. In case of an empty
		group it would return a NULL handle.
		</p><pre class="programlisting">$rh = $ctx-&gt;next($rh);</pre><p>
		Returns the next row handle in order. If the argument handle was the last row
		in the group, returns a NULL handle. So the iteration through the group
		with a context is similar to iteration through the whole table: it ends
		when <code class="computeroutput">begin()</code> or <code class="computeroutput">next()</code> returns a NULL handle. 
		</p><pre class="programlisting">$rh = $ctx-&gt;last();</pre><p>
		Returns the last row handle of the group. In case of an empty
		group it would return a NULL handle.
		</p><pre class="programlisting">$rh = $ctx-&gt;beginIdx($idxType);</pre><p>
		Returns the first row in the group, according to a specific index type's order.
		The index type must belong to the group, otherwise the result is
		undefined. If the group is empty, will return the same value as
		<code class="computeroutput">endIdx()</code>. If <code class="computeroutput">$idxType</code> is non-leaf, the effect is the same as if its
		first leaf were used. 
		</p><pre class="programlisting">$rh = $ctx-&gt;endIdx($idxType);</pre><p>
		Returns the handle past the last row in the group, according to a specific
		index type's order. The index type must belong to the group, otherwise
		the result is undefined and might even result in an endless iteration
		loop.  If <code class="computeroutput">$idxType</code> is non-leaf, the effect is the same as if its first
		leaf were used. This kind of iteration uses the table's
		<code class="computeroutput">$t-&gt;nextIdx($idxType, $rh)</code> or <code class="computeroutput">$rh-&gt;next($idxType)</code> to advance the
		position. 
		Unlike the general group iteration described in
		<a class="xref" href="#sc_ref_table" title="19.8. Table reference">Section 19.8: &#8220;Table reference&#8221; </a>, 
		the aggregator context does allow the iteration by every index in the group.
		You can pick any index in the group and iterate in its order.
		And aggregation is where this ability counts the most.
		</p><p>
		If the group happens to be the last group of this index type (not of
		<code class="computeroutput">$idxType</code> but of the index on which the aggregator is defined) in the
		table, <code class="computeroutput">endIdx()</code> would return a NULL row handle. If it's also
		empty, <code class="computeroutput">beginIdx()</code> would also return a NULL handle, and in general, for
		an empty group <code class="computeroutput">beginIdx()</code> would return the same value as <code class="computeroutput">endIdx()</code>. If
		the group is not the last one, <code class="computeroutput">endIdx()</code> returns the handle of the first
		row in the next group.
		</p><pre class="programlisting">$rh = $ctx-&gt;lastIdx($idxType);</pre><p>
		Returns the last row in the group according to a particular index
		type's order. The index type must belong to the group, otherwise the
		result is undefined. If the group is empty, returns a NULL handle.
		</p><pre class="programlisting">$ctx-&gt;send($opcode, $row);</pre><p>
		Constructs a result rowop for the aggregator and arranges for it to be
		sent to the aggregator's output label. The actual sending is
		delayed: it will be done only after all the aggregators run.
		The runs before and after the table modifications are separate.
		The aggregator's
		output label is not directly visible in the computation function, so the rowop
		can not be constructed directly. Instead <code class="computeroutput">send()</code> takes care of it. The
		row must be of a type matching the aggregator's result type
		(and of course the normal practice is to use the aggregator's result
		type to construct the row). On success returns 1, on error returns
		<code class="computeroutput">undef</code> and the error message.
		</p><pre class="programlisting">$ctx-&gt;makeHashSend($opcode, $fieldName =&gt; $fieldValue, ...);</pre><p>
		A convenience method that produces the row from pairs of field names
		and values and sends it. A combination of <code class="computeroutput">makeRowHash()</code> and <code class="computeroutput">send()</code>.
		</p><pre class="programlisting">$ctx-&gt;makeArraySend($opcode, @fields);</pre><p>
		A convenience function that produces the row from the array of field
		values and sends it. A combination of <code class="computeroutput">makeRowArray()</code> and <code class="computeroutput">send()</code>.
		</p></div><div class="sect1" title="19.11. Opt reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_opt"></a>19.11. Opt reference</h2></div></div></div><a class="indexterm" name="id554032"></a><p>
		Triceps::Opt is not a class but a package with a set of functions that
		help with processing the arguments to the class constructors and other
		functions when these arguments are represented as options.
		</p><pre class="programlisting">&amp;Triceps::Opt::parse($class, \%instance, \%optdescr, @opts);</pre><p>
		Checks the options and copies their values into a class instance (or generally
		into a hash). Usually used with the class constructors, so the semantics of
		the arguments is oriented towards this usage. Confesses on errors.
		<code class="computeroutput">$class</code> is the calling class name, for the error messages. <code class="computeroutput">\%instance</code>
		is the reference to the object instance where to copy the options to.
		<code class="computeroutput">\%optdescr</code> is the reference to a hash describing the valid options.
		<code class="computeroutput">@opts</code> (all the remaining arguments) are the option name-value pairs passed through
		from the class constructor.
		</p><p>
		The entries in <code class="computeroutput">\%optdescr</code> are references to arrays, each of them describing
		an option. They are usually written in the form:
		</p><pre class="programlisting">optionName =&gt; [ $defaultValue, \&amp;checkFunc ],</pre><p>
		If there is no default value, it can be set to <code class="computeroutput">undef</code>. <code class="computeroutput">\&amp;checkFunc</code>
		is a reference to a function that is used to check the option value. If the value is
		correct, the function returns, if incorrect, it confesses with a descriptive message.
		The default value is filled in for the missing options before the check function
		is called.  If no checking is needed, the function reference may be <code class="computeroutput">undef</code>.
		The check function is called as:
		</p><pre class="programlisting">&amp;$checkFunc($optionValue, $optionName, $class, $instance);</pre><p>
		The class and instance are passed through from the arguments of <code class="computeroutput">parse()</code>.
		</p><p>
		A user-defined anonymous function can be used to combine multiple checking functions,
		for example:
		</p><pre class="programlisting">table =&gt; [ undef, sub {
  &amp;Triceps::Opt::ck_mandatory(@_);
  &amp;Triceps::Opt::ck_ref(@_, "Triceps::Table");
} ],</pre><p>
		A number of ready checking function is provided. When these functions require extra
		arguments, by convention they go after the common arguments, as shown for
		<code class="computeroutput">ck_ref()</code> above.
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">Triceps::Opt::ck_mandatory</code> checks that the value is defined.
		</li><li class="listitem"><code class="computeroutput">Triceps::Opt::ck_ref</code> checks that the value is a reference to a
		particular class, or a class derived from it. Just give the class name as the extra argument. Or,
		to check that the reference is to array or hash, make the argument
		<code class="computeroutput">"ARRAY"</code> or <code class="computeroutput">"HASH"</code>. Or an empty string <code class="computeroutput">""</code> to check that it's not a
		reference at all. For the arrays and hashes it can also check the
		values contained in them for being references to the correct types: give that
		type as the second extra argument. But it doesn't go deeper than that,
		just one nesting level. It might be extended later, but for now one nesting
		level has been enough.
		</li><li class="listitem"><code class="computeroutput">Triceps::Opt::ck_refscalar</code> checks that the value is a reference to a
		scalar. This is designed to check the arguments which are used to
		return data back to the caller, and it would accept any previous value
		in that scalar: an actual scalar value, an <code class="computeroutput">undef</code> or a reference,
		since it's about to be overwritten anyway.
		</li></ul></div><p>
		The <code class="computeroutput">ck_ref()</code> and <code class="computeroutput">ck_refscalar()</code> allow the value to be undefined, so they
		can safely be used on the truly optional options. When I come up with more of
		the useful check functions, I'll add them.
		</p><p>
		A special case is the passing through of the options:
		you can accept the arbitrary options, typically if your function is a
		wrapper to another function, and you just want to process a few options
		and let the others through. The <code class="computeroutput">Triead::start()</code> is a good example,
		passing the options through to the main function of the thread.
		</p><p>
		The acceptance of the arbitrary options is specified by using an option
		named <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span> in the <code class="computeroutput">Opt::parse()</code> arguments. For example:
		</p><pre class="programlisting">  &amp;Triceps::Opt::parse($myname, $opts, {
    app =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    thread =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    fragment =&gt; [ "", undef ],
    main =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "CODE") } ],
    '*' =&gt; [],
  }, @_);</pre><p>
		The specification array for <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span> is empty. The unknown options will be
		collected in the array referred to from <code class="computeroutput">$opts-&gt;{'*'}</code>, that is
		<code class="computeroutput">@{$opts-&gt;{'*'}}</code>.
		</p><p>
		From there on the wrapper has the choice of either passing through all
		the options to the wrapped function, using <code class="computeroutput">@_</code>, or explicitly specifying
		a few options and  passing through the  rest from <code class="computeroutput">@{$opts-&gt;{'*'}}</code>.
		</p><p>
		There is also the third possibility: filter out only some of the
		incoming options. This can be done with <code class="computeroutput">Opt::drop()</code>. 
		It lets through only the options that are not present in the description:
		</p><pre class="programlisting">@filteredOpts = &amp;Triceps::Opt::drop(\%optdescr, @opts);
@filteredOpts = &amp;Triceps::Opt::dropExcept(\%optdescr, @opts);</pre><p>
		The <code class="computeroutput">Opt::drop()</code> takes the specification of the options to drop as a
		hash reference, the same as <code class="computeroutput">Opt::parse()</code>. The values in the hash are
		not important in this case, only the keys are used. But it's simpler to
		store the same specification of the options and reuse it for both
		<code class="computeroutput">parse()</code> and <code class="computeroutput">drop()</code> than to write it twice.
		</p><p>
		There is also an opposite function, <code class="computeroutput">Opt::dropExcept()</code>. It passes
		through only the listed options and drops the rest. It can come handy
		if your wrapper wants to pass different subsets of its incoming options
		to multiple functions.
		</p><p>
		The functions <code class="computeroutput">drop()</code> and <code class="computeroutput">dropExcept()</code> can really be used on any
		name-value arrays, not just the options as such. And the same goes for
		the <code class="computeroutput">Fields::filter()</code> and friends. So you can use them interchangeably:
		you can use <code class="computeroutput">Opt::drop()</code> on the row type specifications and
		<code class="computeroutput">Fields::filter()</code> on the options if you feel that it makes your code
		simpler. 
		</p><p>
		For an example of <code class="computeroutput">drop()</code>, <code class="computeroutput">Triead::startHere()</code> works like this:
		</p><pre class="programlisting"># The options for start(). Keeping them in a variable allows the individual
# thread main functions to copy and reuse their definition instead of
# reinventing it.
our @startOpts = (
  app =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
  thread =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
  fragment =&gt; [ "", undef ],
  main =&gt; [ undef, sub { &amp;Triceps::Opt::ck_ref(@_, "CODE") } ],
);

sub startHere # (@opts)
{
  my $myname = "Triceps::Triead::start";
  my $opts = {};
  my @myOpts = ( # options that don't propagate through
    harvest =&gt; [ 1, undef ],
    makeApp =&gt; [ 1, undef ],
  );

  &amp;Triceps::Opt::parse($myname, $opts, {
    @startOpts,
    @myOpts,
    '*' =&gt; [],
  }, @_);

  my @args = &amp;Triceps::Opt::drop({
    @myOpts
  }, \@_);
  @_ = (); # workaround for threads leaking objects

  # no need to declare the Triead, since all the code executes synchronously anyway
  my $app;
  if ($opts-&gt;{makeApp}) {
    $app = &amp;Triceps::App::make($opts-&gt;{app});
  } else {
    $app = &amp;Triceps::App::resolve($opts-&gt;{app});
  }
  my $owner = Triceps::TrieadOwner-&gt;new(undef, undef, $app, $opts-&gt;{thread}, $opts-&gt;{fragment});
  push(@args, "owner", $owner);
  eval { &amp;{$opts-&gt;{main}}(@args) };
  $owner-&gt;abort($@) if ($@);
  # In case if the thread just wrote some rows outside of nextXtray()
  # and exited, flush to get the rows through. Otherwise things might
  # get stuck in a somewhat surprising way.
  eval { $owner-&gt;flushWriters(); };
  $owner-&gt;markDead();
  if ($opts-&gt;{harvest}) {
    $app-&gt;harvester();
  }
}</pre><p>
		The <code class="computeroutput">@startOpts</code> are both used by the <code class="computeroutput">startHere()</code> and passed through. The
		<code class="computeroutput">@myOpts</code> are only used in <code class="computeroutput">startHere()</code> and do not pass through. And the
		rest of the options pass through without being used in <code class="computeroutput">startHere()</code>. So
		the options from <code class="computeroutput">@myOpts</code> get dropped from <code class="computeroutput">@_</code>, and the result goes to
		the main thread.
		</p><p>
		The Opts package also provides the helper methods for processing the sets of options.
		</p><pre class="programlisting">&amp;Triceps::Opt::handleUnitTypeLabel($caller,
  $nameUnit, \$refUnit,
  $nameRowType, \$refRowType,
  $nameLabel, \$refLabel);</pre><p>
		A special post-processing that takes care of sorting out the compatibility of the
		options for the unit, input row type and the input label. Usually called after
		<code class="computeroutput">parse()</code>. Confesses on errors. 
		</p><p>
		<code class="computeroutput">$caller</code> is the description of the caller,
		for the error messages. The rest are the pairs of the option names and the references
		to the option values in the instance hash. 
		</p><p>
		Treats the options for input row type and 
		input label as mutually exclusive but with exactly one of them required. If the
		input row type is used then the unit option is also required. If the input label
		is used, the unit is optional, but if it's specified anyway, the unit in the
		option must match the unit of the input label. If the input label is used, the
		values for the input row type and the unit are extracted from the input label
		and set into the references.
		</p><pre class="programlisting">$which = &amp;Triceps::Opt::checkMutuallyExclusive(
  $caller, $mandatory, $optName1, optValue1, ...);</pre><p>
		Checks a set of mutually exclusive options. Usually called after
		<code class="computeroutput">parse()</code>. Confesses on errors, returns the name of the only
		defined option on success. If no options are defined, returns
		<code class="computeroutput">undef</code>.  
		</p><p>
		<code class="computeroutput">$caller</code> is the
		description of the caller, for the error messages.
		<code class="computeroutput">$mandatory</code> is a flag telling that exactly one of the
		options must be defined; or the check will confess. The rest are the
		option name-value pairs (unlike <code class="computeroutput">handleUnitTypeLabel()</code>, these
		are values, not references to them).
		</p></div><div class="sect1" title="19.12. Fields reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_fields"></a>19.12. Fields reference</h2></div></div></div><a class="indexterm" name="id554835"></a><p>
		Triceps::Fields is a package with a set of functions that
		help with handling the variable sets of fields in the templates.
		</p><pre class="programlisting">@fields = &amp;Triceps::Fields::filter(
  $caller, \@inFields, \@translation);</pre><p>
		Filters and renames the incoming set of fields from <code class="computeroutput">\@inFields</code> (usually
		coming from some row type) according to <code class="computeroutput">\@translation</code>. Returns the array 
		of filtered names, positionally matching the names in the original
		array. When some field gets thrown away by filtering, its entry in the
		array will be <code class="computeroutput">undef</code>. Confesses on errors. <code class="computeroutput">$caller</code> is the
		caller's description for the error messages.
		</p><p>
		See the description of the translation format in
		<a class="xref" href="#sc_template_result" title="10.7. Result projection in the templates">Section 10.7: &#8220;Result projection in the templates&#8221; </a>.
		</p><p>
		The option-processing functions <code class="computeroutput">Opt::drop()</code> and <code class="computeroutput">Opt::dropExcept()</code>
		can also be used to filter the field lists.
		</p><pre class="programlisting">@pairs = &amp;Triceps::Fields::filterToPairs(
  $caller, \@inFields, \@translation);</pre><p>
		Performs the same actions as <code class="computeroutput">filter()</code> but returns the result in a different format:
		an array of pairs of field names, where the old field name is paired with the
		new one. The field names that gets thrown away by filtering do not appear in
		the result array.
		</p><pre class="programlisting">($rowType, $projectFunc) = &amp;Triceps::Fields::makeTranslation(
  $optName =&gt; $optValue, ...);</pre><p>
		Generates and compiles a function that performs the filtering of rows and
		creates the rows of the filtered type (a <span class="quote">&#8220;<span class="quote">projection</span>&#8221;</span> in SQL terms). 
		It accepts multiple input row types, each with its own translation specification,
		and creates the result row type by combining them all.
		Returns two elements: the result row type and the reference to the compiled
		function. The function can then be called to perform the projection and
		combining of the original rows:
		</p><pre class="programlisting">$resultRow = &amp;$projectFunc($origRow1, $origRow2, ..., $origRowN);</pre><p>
		If some of the original rows are not available, they may be passed as
		<code class="computeroutput">undef</code>.  The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">rowTypes =&gt; [ @rts ]</code></span></dt><dd>
			Reference to an array of row types for the original rows.
			</dd><dt><span class="term"><code class="computeroutput">filterPairs =&gt; [ @pairs ]</code></span></dt><dd>
			Reference to an array of arrays returned by <code class="computeroutput">filterPairs()</code> for the
			original rows. Obviously, each of the original rows requires
			its own filter. The sizes of <span class="quote">&#8220;<span class="quote">rowTypes</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">filterPairs</span>&#8221;</span> arrays
			must match.  The field names in the results must not have
			any duplicates.
			</dd><dt><span class="term"><code class="computeroutput">saveCodeTo =&gt; \$code</code></span></dt><dd>
			Optional. Reference to a scalar where to save the auto-generated source
			code of the projection function, for debugging.
			</dd></dl></div><pre class="programlisting">$result = &amp;Triceps::Fields::isArrayType($typeName);</pre><p>
		Checks whether a simple type is represented in Perl as an array.
		Since <code class="computeroutput">uint8[]</code> is represented as a string, it will return 0.
		</p><pre class="programlisting">$result = &amp;Triceps::Fields::isStringType($typeName);</pre><p>
		Checks whether a simple type is represented in Perl as a string.
		<code class="computeroutput">string</code>, <code class="computeroutput">uint8</code> and <code class="computeroutput">uint8[]</code> 
		will return 1.
		</p></div><div class="sect1" title="19.13. LookupJoin reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_lookupjoin"></a>19.13. LookupJoin reference</h2></div></div></div><a class="indexterm" name="id571035"></a><p>
		LookupJoin receives the incoming rows and looks up the matches for them
		from a table, producing the joined rows.
		</p><pre class="programlisting">$joiner = Triceps::LookupJoin-&gt;new(optionName =&gt; optionValue, ...);</pre><p>
		Constructs the LookupJoin template. Confesses on any errors.
		The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">unit =&gt; $unit</code></span></dt><dd>
			Scheduling unit object where this template belongs. 
			May be skipped if <span class="quote">&#8220;<span class="quote">leftFromLabel</span>&#8221;</span> is used.
			</dd><dt><span class="term"><code class="computeroutput">name =&gt; $name</code></span></dt><dd>
			Name of this LookupJoin object. Will be used as a prefix to create
			the names of internal objects. The input label will be named
			<span class="quote">&#8220;<span class="quote">name.in</span>&#8221;</span> and the output label <span class="quote">&#8220;<span class="quote">name.out</span>&#8221;</span>.
			</dd><dt><span class="term"><code class="computeroutput">leftRowType =&gt; $rt</code></span></dt><dd>
			Type of the rows that will be coming in at the left side of the
			join, and will be used for lookup.  Mutually exclusive with
			<span class="quote">&#8220;<span class="quote">leftFromLabel</span>&#8221;</span>, one must be present.
			</dd><dt><span class="term"><code class="computeroutput">leftFromLabel =&gt; $label</code></span></dt><dd>
			Source of rows for the left side of the join; implies their type
			and the scheduling unit where this object belongs.  Mutually
			exclusive with <span class="quote">&#8220;<span class="quote">leftRowType</span>&#8221;</span>, one must be present.
			</dd><dt><span class="term"><code class="computeroutput">rightTable =&gt; $table</code></span></dt><dd>
			Table object where to do the look-ups.
			</dd><dt><span class="term"><code class="computeroutput">rightIdxPath =&gt; [ @path ]</code></span></dt><dd>
			Array reference containing the path name of index type in table
			used for the look-up. 
			The index absolutely must be a Hash (leaf or non-leaf), not of any
			other kind. Optional.
			Default: automatically found by the set of key fields. Whether
			explicitly specified or automatically found, the index must be available
			in the table.
			</dd><dt><span class="term"><code class="computeroutput">leftFields =&gt; [ @patterns ]</code></span></dt><dd>
			Reference to an array of patterns for the left-side fields to pass
			through. Syntax as described in <code class="computeroutput">Triceps::Fields::filter()</code>. 
			Optional. If not defined then pass everything.
			</dd><dt><span class="term"><code class="computeroutput">rightFields =&gt; [ @patterns ]</code></span></dt><dd>
			Reference to an array of patterns for the right-side fields to pass
			through. Syntax as described in <code class="computeroutput">Triceps::Fields::filter()</code>. Optional.
			If not defined then pass everything (which is probably a bad idea since it
			would include the second copy of the key fields, so better
			override at least one of the <span class="quote">&#8220;<span class="quote">leftFields</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">rightFields</span>&#8221;</span>).
			</dd><dt><span class="term"><code class="computeroutput">fieldsLeftFirst =&gt; 0/1</code></span></dt><dd>
			Flag: in the resulting rows put the fields from the left side
			first, then from right side. If 0, then opposite. 
			Optional. Default: 1.
			</dd><dt><span class="term"><code class="computeroutput">fieldsMirrorKey =&gt; 0/1</code></span></dt><dd>
			Flag: even if the join is an outer join and the row on one side is
			absent, when generating the result row, the key fields in it will
			still be present by mirroring them from the other side. Used by
			JoinTwo. Optional. Default: 0.
			</dd><dt><span class="term"><code class="computeroutput">fieldsDropRightKey =&gt; 0/1</code></span></dt><dd>
			Flag: remove the key fields on the right side from the result.
			Convenient to avoid their duplication, especially if the key
			fields are named the same on both sides.
			Optional. Default: 0.
			</dd><dt><span class="term"><code class="computeroutput">by =&gt; [ @fields ]</code></span></dt><dd>
			Reference to an array containing pairs of field names used for
			look-up, <code class="computeroutput">[leftFld1, rightFld1, leftFld2, rightFld2, ...]</code>.
			The set of right-side fields must match the keys of the index path
			from the option <span class="quote">&#8220;<span class="quote">rightIdxPath</span>&#8221;</span>, though possibly in a different order.
			Mutually exclusive with <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span>, one must be present.
			</dd><dt><span class="term"><code class="computeroutput">byLeft =&gt; [ @patterns ]</code></span></dt><dd>
			Reference to an array containing the patterns in the syntax of
			<code class="computeroutput">Triceps::Fields::filter()</code>. It gets applied to the left-side fields,
			the fields that pass through become the key fields, and their
			translations are the names of the matching fields on the right
			side. The set of right-side fields must match the keys of the index
			path from  the option <code class="computeroutput">rightIdxPath</code>, though possibly in a different
			order.
			Mutually exclusive with <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span>, one must be present.
			</dd><dt><span class="term"><code class="computeroutput">isLeft =&gt; 0/1</code></span></dt><dd>
			Flag: 1 for left outer join, 0 for inner join. Optional. Default: 1.
			</dd><dt><span class="term"><code class="computeroutput">limitOne =&gt; 0/1</code></span></dt><dd>
			Flag: 1 to return no more than one row even
			if multiple rows have been found by the look-up, 0 to return all
			the found matches. 
			Optional. Default: 0 for the non-leaf right index, 1 for
			leaf right index. If the right index is leaf, this option will be
			always automatically set to 1, even if the user specified
			otherwise, since there is no way to look up more than one matching
			row in it.
			</dd><dt><span class="term"><code class="computeroutput">automatic =&gt; 0/1</code></span></dt><dd>
			Flag: 1 means that the manual <code class="computeroutput">lookup()</code> method will never be called.
			This allows to optimize the label handler code and always
			take the opcode into account when processing the rows. 0 means that
			<code class="computeroutput">lookup()</code> will be used. Optional. Default: 1.
			</dd><dt><span class="term"><code class="computeroutput">oppositeOuter =&gt; 0/1</code></span></dt><dd>
			Flag: 1 for the right outer join, 0 for inner join. If both options
			<span class="quote">&#8220;<span class="quote">isLeft</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">oppositeOuter</span>&#8221;</span> are set to 1, then this is a full outer
			join. If set to 1, each update that finds a match in the right
			table, may produce a DELETE-INSERT sequence that keeps the state of
			the right or full outer join consistent. The full outer or right
			outer join logic makes sense only if this LookupJoin is one of a
			pair in a bigger JoinTwo object. Each of these LookupJoins thinks
			of itself as <span class="quote">&#8220;<span class="quote">left</span>&#8221;</span> and of the other one as <span class="quote">&#8220;<span class="quote">right</span>&#8221;</span>, 
			while JoinTwo presents a consistent whole picture to the user.
			Used by JoinTwo.  May be used only when <span class="quote">&#8220;<span class="quote">automatic</span>&#8221;</span> is 1. 
			Optional. Default: 0.
			</dd><dt><span class="term"><code class="computeroutput">groupSizeCode =&gt; $func</code></span></dt><dd><p>
			Reference to a function that would compute the group size for this
			side's table.  Optional, used only when <span class="quote">&#8220;<span class="quote">oppositeOuter</span>&#8221;</span> is 1.
			</p><p>
			The group size together with the opcode is then used
			to decide if a DELETE-INSERT sequence needs to be produced instead
			of a plain INSERT or DELETE. It is needed when this side's index
			(not visible here in LookupJoin but visible in the JoinTwo that
			envelopes it) is non-leaf, so multiple rows on this side
			may match each row on the other side. The DELETE-INSERT pair
			needs to be generated only if the current rowop was a deletion of
			the last matching row or insertion of the first matching row
			on this side. If <span class="quote">&#8220;<span class="quote">groupSizeCode</span>&#8221;</span> is not defined, the
			DELETE-INSERT pair is always generated (which is appropriate if
			this side's index is leaf, and every row is the last or first
			one). If <span class="quote">&#8220;<span class="quote">groupSizeCode</span>&#8221;</span> is defined, it should return the group
			size in the left table by the left index for the input row. If
			the operation is INSERT, the size of 1 would mean that
			the DELETE-INSERT pair needs to be generated. If the operation
			is DELETE, the size of 0  would mean that the DELETE-INSERT
			pair needs to be generated. Called as:
			</p><pre class="programlisting">&amp;$groupSizeCode($opcode, $leftRow)</pre><p>
			The default undefined <span class="quote">&#8220;<span class="quote">groupSizeCode</span>&#8221;</span> is equivalent to
			</p><pre class="programlisting">sub { &amp;Triceps::isInsert($_[0]); }</pre><p>
			but leaving it undefined is more efficient since allows to hardcode
			this logic at compile time instead of calling the function for
			every rowop.
			</p></dd><dt><span class="term"><code class="computeroutput">saveJoinerTo =&gt; \$code</code></span></dt><dd>
			Reference to a scalar where to save a copy of the joiner function
			source code.  Optional.
			</dd></dl></div><pre class="programlisting">@rows = $joiner-&gt;lookup($leftRow);</pre><p>
		Looks up the matches for the <code class="computeroutput">$leftRow</code> and return the array of the result
		rows. If the option <span class="quote">&#8220;<span class="quote">isLeft</span>&#8221;</span> is 0, the array may be empty. If the
		option <span class="quote">&#8220;<span class="quote">limitOne</span>&#8221;</span> is 1, the array will contain no more than one row,
		and may be assigned directly to a scalar. May be used only when the option
		<span class="quote">&#8220;<span class="quote">automatic</span>&#8221;</span> is 0.
		</p><p>
		This method has become largely obsolete since addition of <code class="computeroutput">fnReturn()</code>
		as described in
		<a class="xref" href="#sc_strf_templates" title="15.8. Streaming functions and template results">Section 15.8: &#8220;Streaming functions and template results&#8221; </a>
		but is still present in case if it comes useful.
		</p><pre class="programlisting">$rt = $joiner-&gt;getResultRowType();</pre><p>
		Returns the row type of the join result.
		</p><pre class="programlisting">$lb = $joiner-&gt;getInputLabel();</pre><p>
		Returns the input label of the joiner. The rowops sent there will be
		processed as coming on the left side of the join. The result will be
		produced on the output label.
		</p><pre class="programlisting">$lb = $joiner-&gt;getOutputLabel();</pre><p>
		Returns the output label of the joiner. The results from processing of the
		input rowops come out here. Note that the results of the <code class="computeroutput">lookup()</code> calls
		do not come out at the output label, they are only returned to the
		caller.
		</p><pre class="programlisting">$fret = $joiner-&gt;fnReturn();</pre><p>
		Returns an FnReturn object connected to the output of this joiner.
		The FnReturn contains one label <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span>.
		The FnReturn is created on the first call of
		this method and is kept in the joiner object.  All the following calls return
		the same object. 
		See more detail in
		<a class="xref" href="#sc_strf_templates" title="15.8. Streaming functions and template results">Section 15.8: &#8220;Streaming functions and template results&#8221; </a>.
		</p><pre class="programlisting">$res = $joiner-&gt;getUnit();
$res = $joiner-&gt;getName();
$res = $joiner-&gt;getLeftRowType();
$res = $joiner-&gt;getRightTable();
$res = $joiner-&gt;getRightIdxPath();
$res = $joiner-&gt;getLeftFields();
$res = $joiner-&gt;getRightFields();
$res = $joiner-&gt;getFieldsLeftFirst();
$res = $joiner-&gt;getFieldsMirrorKey();
$res = $joiner-&gt;getBy();
$res = $joiner-&gt;getByLeft();
$res = $joiner-&gt;getIsLeft();
$res = $joiner-&gt;getLimitOne();
$res = $joiner-&gt;getAutomatic();
$res = $joiner-&gt;getOppositeOuter();
$res = $joiner-&gt;getGroupSizeCode();</pre><p>
		Get back the values of the options use to construct the object. 
		If such an option was not set,
		returns the default value, or the automatically calculated value.
		Sometimes an automatically calculated value may even override the
		user-specified value. There is no way to get back <span class="quote">&#8220;<span class="quote">leftFromLabel</span>&#8221;</span>, it
		is discarded after the LookupJoin is constructed and chained.
		</p></div><div class="sect1" title="19.14. JoinTwo reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_jointwo"></a>19.14. JoinTwo reference</h2></div></div></div><a class="indexterm" name="id582277"></a><p>
		JoinTwo is a template that joins two tables. As the tables are modified,
		the updates propagate through the join. The join itself keeps no state
		(other than the state of its input tables), so if it needs to be kept,
		it has to be saved into another table. There is no requirement of a
		primary key on either the input tables nor the join result. However if
		the result is saved into a table, that table would have to have a primary
		key, so by extension the join would have to produce the result with
		a primary key, or the table contents will become incorrect.
		The JoinTwo is internally implemented as a pair of LookupJoins.
		</p><pre class="programlisting">$joiner = Triceps::JoinTwo-&gt;new(optionName =&gt; optionValue, ...);</pre><p>
		Creates the JoinTwo object. Confesses on any errors.
		The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">name =&gt; $name</code></span></dt><dd>
			Name of this object. Will be used to create the names of internal objects.
			</dd><dt><span class="term"><code class="computeroutput">leftTable =&gt; $table</code></span></dt><dd>
			Table object to join, for the left side. Both tables must be of the same unit.
			</dd><dt><span class="term"><code class="computeroutput">rightTable =&gt; $table</code></span></dt><dd>
			Table object to join, for the right side. Both tables must be of the same unit.
			</dd><dt><span class="term"><code class="computeroutput">leftFromLabel =&gt; $label</code></span></dt><dd><p>
			The label from which to receive the rows on
			the left side. 
			Optional. Default: the Output label of <span class="quote">&#8220;<span class="quote">leftTable</span>&#8221;</span> unless it's
			a self-join; for a self-join the Pre label of <span class="quote">&#8220;<span class="quote">leftTable</span>&#8221;</span>. 
			</p><p>
			Can be used to introduce a label that would filter out some of the input. THIS IS
			DANGEROUS! To preserve consistency, always filter by the key
			field(s) only, and apply the same condition on the left and right.
			</p></dd><dt><span class="term"><code class="computeroutput">rightFromLabel =&gt; $label</code></span></dt><dd><p>
			The label from which to receive the rows on the right side. 
			Optional. Default: the Output label of <span class="quote">&#8220;<span class="quote">rightTable</span>&#8221;</span>.
			</p><p>
			Can be used to introduce a label that would filter out some of the input. THIS IS
			DANGEROUS! To preserve consistency, always filter by the key
			field(s) only, and apply the same condition on the left and right.
			</p></dd><dt><span class="term"><code class="computeroutput">leftIdxPath =&gt; [ @path ]</code></span></dt><dd>
			An array reference containing the path name of an index type in the
			left table used for look-up. The index absolutely must be a Hash
			(leaf or not), not of any other kind. The number and order of key
			fields in the left and right indexes must match, since indexes define
			the fields used for the join. The types of key fields have to
			match exactly unless the auto-casting is allowed by the option 
			<span class="quote">&#8220;<span class="quote">overrideKeyTypes</span>&#8221;</span> being set to 1.
			</dd><dt><span class="term"><code class="computeroutput">rightIdxPath =&gt; [ @path ]</code></span></dt><dd>
			An array reference containing the path name of an index type in the
			right table used for look-up. The index absolutely must be a Hash
			(leaf or not), not of any other kind. The number and order of key
			fields in the left and right indexes must match, since indexes define
			the fields used for the join. The types of key fields have to
			match exactly unless the auto-casting is allowed by the option 
			<span class="quote">&#8220;<span class="quote">overrideKeyTypes</span>&#8221;</span> being set to 1.
			</dd><dt><span class="term"><code class="computeroutput">leftFields =&gt; [ @patterns ]</code></span></dt><dd>
			Reference to an array of patterns for the left-side fields to pass
			through to the result rows, with the syntax of
			<code class="computeroutput">Triceps::Fields::filter()</code>. Optional. If not defined then pass everything.
			</dd><dt><span class="term"><code class="computeroutput">rightFields =&gt; [ @patterns ]</code></span></dt><dd>
			Reference to an array of patterns for the right-side fields to pass
			through to the result rows, with the syntax of
			<code class="computeroutput">Triceps::Fields::filter()</code>. Optional. If not defined then pass everything.
			</dd><dt><span class="term"><code class="computeroutput">fieldsLeftFirst =&gt; 0/1</code></span></dt><dd>
			Flag: if 1, in the result rows put the fields from the left side
			first, then from the right side; if 0, then in the opposite order.
			Optional. Default: 1.
			</dd><dt><span class="term"><code class="computeroutput">fieldsUniqKey =&gt; $enum</code></span></dt><dd><p>
			Controls the logic that prevents the duplication of the key fields
			in the result rows (since by definition their originals are present
			in both the left and right tables). Optional.
			</p><p>
			This is done by setting the
			option <span class="quote">&#8220;<span class="quote">fieldsMirrorKey</span>&#8221;</span> of the underlying LookupJoins to 1 and by
			manipulating the left/rightFields options: one side is
			left unchanged, and thus lets the user pass the key fields as
			usual, while the other side gets <code class="computeroutput">'!key'</code> specs prepended to the
			front of it for each key field, thus blocking these fields
			and removing the duplication.
			</p><p>
			The enumerated values of this option are one of: 
			</p><div class="variablelist"><dl><dt><span class="term"><span class="quote">&#8220;<span class="quote">none</span>&#8221;</span></span></dt><dd>
				Do not change either of the <span class="quote">&#8220;<span class="quote">left/rightFields</span>&#8221;</span>,
				and do not enable the key mirroring at all.
				</dd><dt><span class="term"><span class="quote">&#8220;<span class="quote">manual</span>&#8221;</span></span></dt><dd>
				Enable the key mirroring; do not change either of the
				<span class="quote">&#8220;<span class="quote">left/rightFields</span>&#8221;</span>, leaving the full control to
				the user.
				</dd><dt><span class="term"><span class="quote">&#8220;<span class="quote">left</span>&#8221;</span></span></dt><dd>
				Enable the key mirroring; do not change <span class="quote">&#8220;<span class="quote">leftFields</span>&#8221;</span> (and thus
				pass the key fields in there), block the keys from
				<span class="quote">&#8220;<span class="quote">rightFields</span>&#8221;</span>.
				</dd><dt><span class="term"><span class="quote">&#8220;<span class="quote">right</span>&#8221;</span></span></dt><dd>
				Enable the key mirroring; do not change <span class="quote">&#8220;<span class="quote">rightFields</span>&#8221;</span> (and thus
				pass the key fields in there), block the keys from
				<span class="quote">&#8220;<span class="quote">leftFields</span>&#8221;</span>.
				</dd><dt><span class="term"><span class="quote">&#8220;<span class="quote">first</span>&#8221;</span></span></dt><dd>
				The default value. Enable the key mirroring; do not change
				whatever side goes first according to the option
				<span class="quote">&#8220;<span class="quote">fieldsLeftFirst</span>&#8221;</span> (and thus pass the key in there), block the
				keys from the other side.
				</dd></dl></div></dd><dt><span class="term"><code class="computeroutput">by =&gt; [ @fields ]</code></span></dt><dd>
			Reference to an array containing pairs of field names
			used for look-up, <code class="computeroutput">[leftFld1, rightFld1, leftFld2, rightFld2, ...]</code>. 
			Optional.
			The options <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span> are mutually exclusive. If none of
			them is used, by default the field lists are taken from the
			index type keys, matched up in the order they appear in the
			indexes. But if a different order is desired, this option can be
			used to override it. The fields must still be the same, just
			the order may change. 
			</dd><dt><span class="term"><code class="computeroutput">byLeft =&gt; [ @patterns ]</code></span></dt><dd>
			Reference to an array containing the patterns in the syntax of
			<code class="computeroutput">Triceps::Fields::filter()</code>. It gets applied to the left-side fields,
			the fields that pass through  become the key fields, and their
			translations are the names of the  matching fields on the right
			side.
			Optional.
			The options <span class="quote">&#8220;<span class="quote">by</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">byLeft</span>&#8221;</span> are mutually exclusive. If none of
			them is used, by default the field lists are taken from the
			index type keys, matched up in the order they appear in the
			indexes. But if a different order is desired, this option can be
			used to override it. The fields must still be the same, just
			the order may change. 
			</dd><dt><span class="term"><code class="computeroutput">type =&gt; $enum</code></span></dt><dd>
			The type of join from the inner/outer classification, one of:
			<span class="quote">&#8220;<span class="quote">inner</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">left</span>&#8221;</span> for left outer, 
			<span class="quote">&#8220;<span class="quote">right</span>&#8221;</span> for right outer, <span class="quote">&#8220;<span class="quote">outer</span>&#8221;</span>
			for full outer. Optional. Default: <span class="quote">&#8220;<span class="quote">inner</span>&#8221;</span>.
			</dd><dt><span class="term"><code class="computeroutput">leftSaveJoinerTo =&gt; \$code</code></span></dt><dd>
			Reference to a scalar where to save a copy of the joiner
			function source code for the left side. Optional.
			</dd><dt><span class="term"><code class="computeroutput">rightSaveJoinerTo =&gt; \$code</code></span></dt><dd>
			Reference to a scalar where to save a copy of the joiner
			function source code for the right side. Optional.
			</dd><dt><span class="term"><code class="computeroutput">overrideSimpleMinded =&gt; 0/1</code></span></dt><dd>
			Flag: if 1, do not try to create the correct DELETE-INSERT sequence
			for the updates, just produce the rows with the same opcode as the
			incoming ones. The only possible usage of this option might be to
			simulate the CEP systems that do not support the opcodes and treat
			averything as an INSERT. The data produced is outright garbage. It
			can also be used for the entertainment value, to show, why it's
			garbage. Optional. Default: 0.
			</dd><dt><span class="term"><code class="computeroutput">overrideKeyTypes =&gt; 0/1</code></span></dt><dd>
			Flag: if 1, allow the key field types to be not exactly the same.
			Optional. Default: 0.
			</dd></dl></div><pre class="programlisting">$rt = $joiner-&gt;getResultRowType();</pre><p>
		Returns the row type of the join result.
		</p><pre class="programlisting">$lb = $joiner-&gt;getOutputLabel();</pre><p>
		Returns the output label of the joiner. The results from processing of
		the  input rowops come out here. Note that there is no input label, the
		join is fed by connecting to the tables (with the possible override
		with the options <span class="quote">&#8220;<span class="quote">left/rightFromLabel</span>&#8221;</span>).
		</p><pre class="programlisting">$fret = $joiner-&gt;fnReturn();</pre><p>
		Returns an FnReturn object connected to the output of this joiner.
		The FnReturn contains one label <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span>.
		The FnReturn is created on the first call of
		this method and is kept in the joiner object.  All the following calls return
		the same object. 
		See more detail in
		<a class="xref" href="#sc_strf_templates" title="15.8. Streaming functions and template results">Section 15.8: &#8220;Streaming functions and template results&#8221; </a>.
		</p><pre class="programlisting">$res = $joiner-&gt;getUnit();
$res = $joiner-&gt;getName();
$res = $joiner-&gt;getLeftTable();
$res = $joiner-&gt;getRightTable();
$res = $joiner-&gt;getLeftIdxPath();
$res = $joiner-&gt;getRightIdxPath();
$res = $joiner-&gt;getLeftFields();
$res = $joiner-&gt;getRightFields();
$res = $joiner-&gt;getFieldsLeftFirst();
$res = $joiner-&gt;getFieldsUniqKey();
$res = $joiner-&gt;getBy();
$res = $joiner-&gt;getByLeft();
$res = $joiner-&gt;getType();
$res = $joiner-&gt;getOverrideSimpleMinded();
$res = $joiner-&gt;getOverrideKeyTypes();</pre><p>
		Get back the values of the options use to construct the object. 
		If such an option was not set,
		returns the default value, or the automatically calculated value.
		Sometimes an automatically calculated value may even override the
		user-specified value. There is no way to get back
		<span class="quote">&#8220;<span class="quote">left/rightFromLabel</span>&#8221;</span>, they are discarded after the JoinTwo is
		constructed and chained.
		</p></div><div class="sect1" title="19.15. Collapse reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_collapse"></a>19.15. Collapse reference</h2></div></div></div><a class="indexterm" name="id604255"></a><p>
		The Collapse template collapses multiple sequential modifications
		per primary key into one. On flush it sends out that single modification.
		</p><pre class="programlisting">$collapse = Triceps::Collapse-&gt;new($optName =&gt; $optValue, ...);</pre><p>
		Creates a new Collapse object. The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">name</code></span></dt><dd>
			Name of this object. Will be used to create the names of internal objects.
			</dd><dt><span class="term"><code class="computeroutput">unit</code></span></dt><dd>
			The unit where this object belongs.
			</dd><dt><span class="term"><code class="computeroutput">data</code></span></dt><dd>
			The data set description. Each data set has an input label and an
			output label, and collapses one stream of modifications. Currently
			only one data set is supported, the options have been structured
			like this to allow for the future extension. This option's value
			is a reference to an array (not a hash!) that is itself structured
			as the nested option-value pairs.
			</dd></dl></div><p>
		The nested options in <span class="quote">&#8220;<span class="quote">data</span>&#8221;</span> are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">name</code></span></dt><dd>
			The name of the data set. Used for the error messages. Put it
			first, this would let the constructor report nicely the errors
			in the other data set options.
			</dd><dt><span class="term"><code class="computeroutput">rowType</code></span></dt><dd>
			The row type of the data in this set. 
			Mutually exclusive with <span class="quote">&#8220;<span class="quote">fromLabel</span>&#8221;</span>, one must
			be used.
			</dd><dt><span class="term"><code class="computeroutput">fromLabel</code></span></dt><dd>
			The source label for the data set, its input will be chained
			to this label.
			Mutually exclusive with <span class="quote">&#8220;<span class="quote">rowType</span>&#8221;</span>, one must
			be used.
			</dd><dt><span class="term"><code class="computeroutput">key</code></span></dt><dd>
			The primary key of the data. A reference to an array of strings
			with field names, same as for the Hash index type.
			</dd></dl></div><pre class="programlisting">$collapse-&gt;flush();</pre><p>
		Sends out the collected modifications to the output label(s)
		and clears the state of the collapse.
		</p><pre class="programlisting">$lb = $collapse-&gt;getInputLabel($setName);</pre><p>
		Returns the input label of a data set. Confesses if there is no
		data set with this name.
		</p><pre class="programlisting">$lb = $collapse-&gt;getOutputLabel($setName);</pre><p>
		Returns the output label of a data set. Confesses if there is no
		data set with this name.
		</p><pre class="programlisting">@setNames = $collapse-&gt;getDatasets();</pre><p>
		Returns the names of all the data sets (though since currently only one
		data set is supported, only one name will be returned).
		</p><pre class="programlisting">$fret = $collapse-&gt;fnReturn();</pre><p>
		Returns an FnReturn object connected to the output of this collapser.
		The FnReturn contains a label for each data set, named accordingly.
		The order of the labels matches the specified order of data sets.
		The FnReturn is created on the first call of
		this method and is kept in the collapser object.  All the following calls return
		the same object. 
		See more detail in
		<a class="xref" href="#sc_strf_templates" title="15.8. Streaming functions and template results">Section 15.8: &#8220;Streaming functions and template results&#8221; </a>.
		</p></div><div class="sect1" title="19.16. Braced reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_braced"></a>19.16. Braced reference</h2></div></div></div><a class="indexterm" name="id577888"></a><a class="indexterm" name="id569166"></a><p>
		The package Braced is designed to parse the Tcl-like nested lists where
		the elements are separated by whitespace, and braces are used to
		enquote the elements with spaces in them.  These lists are used to write the
		pipelines that form the Tql queries. For example:
		</p><pre class="programlisting">{read table tWindow} {project fields {symbol price}} {print tokenized 0}</pre><p>
		These lists can then be parsed into elements, and the elements might
		be also lists that could be parsed into elements and so on. 
		The spaces between the braces are optional, braces also serve as separators. 
		For example, the following lines are equivalent:
		</p><pre class="programlisting">a b c
{a} {b} {c}
{a}{b}{c}
{a}b{c}</pre><p>
		In case if a brace character needs to be included into one of the strings,
		they can be escaped by backslashes, for example:
		</p><pre class="programlisting">{a\{} b\}c</pre><p>
		Any other Perl backslash escapes, such as <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span> 
		or <span class="quote">&#8220;<span class="quote">\x20</span>&#8221;</span>, work too. The quote characters have no
		special meaning, they don't need to be escaped and they don't group
		the words. For example, the following two are equivalent:
		</p><pre class="programlisting">"a b c"
{"a} {b} {c"}</pre><p>
		Escaping the spaces (<span class="quote">&#8220;<span class="quote">\ </span>&#8221;</span>) provides another way
		to combine the words into one element. The following two
		are equivalent:
		</p><pre class="programlisting">{a b c}
a\ b\ c</pre><p>
		There is no need for the nested escaping.  The characters need
		to be escaped only once, and then the resulting strings can be
		wrapped into any number of brace levels.
		</p><p>
		All the methods in this module are static, there are no objects.
		</p><pre class="programlisting">$string = $data;
@elements = Triceps::Braced::raw_split_braced($string)
confess "Unbalanced braces around '$string'" if $string;</pre><p>
		Split the string into the braced elements. If any of the elements
		were enclosed into their own braces, these braces are left in place,
		the element string will still contain them. For example, <span class="quote">&#8220;<span class="quote">a {b} {c d}</span>&#8221;</span>
		will be split into <span class="quote">&#8220;<span class="quote">a</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">{b}</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">{c d}</span>&#8221;</span>.
		No unescaping is done, the escaped characters are passed through as-is.
		This method of splitting is rarely used, it's present as a baseline.
		</p><p>
		The original string argument will be fully consumed. If anything is left
		unconsumed, this is an indication of a syntax error, with unbalanced
		braces. The argument may not be a constant because it gets modified.
		</p><pre class="programlisting">$string = $data;
@elements = Triceps::Braced::split_braced($string)
confess "Unbalanced braces around '$string'" if $string;</pre><p>
		Split the string into the braced elements. If any of the elements
		were enclosed into their own braces, these braces will be removed from the
		results.  For example, <span class="quote">&#8220;<span class="quote">a {b} {c d}</span>&#8221;</span>
		will be split into <span class="quote">&#8220;<span class="quote">a</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">b</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">c d</span>&#8221;</span>.
		No unescaping is done, the escaped characters are passed through as-is.
		This is the normal method of splitting, it allows the elements
		to be split further recursively.
		</p><p>
		The original string argument will be fully consumed. If anything is left
		unconsumed, this is an indication of a syntax error, with unbalanced
		braces. The argument may not be a constant because it gets modified.
		</p><pre class="programlisting">$result = Triceps::Braced::bunescape($string);</pre><p>
		Un-escape a string by processing all the escape characters in it.
		This step is normally done last, after all the splitting is done.
		The result will become unsuitable for the future splitting because
		the escaped characters will lose their special meaning. If any
		literal braces are present in the argument, they will pass through
		to the result as literals. For example, <span class="quote">&#8220;<span class="quote">{a \{b }</span>&#8221;</span>
		will become <span class="quote">&#8220;<span class="quote">{a {b }</span>&#8221;</span>.
		</p><pre class="programlisting">@results = Triceps::Braced::bunescape_all(@strings);</pre><p>
		Perform the un-escaping on a whole array of strings. The result
		array will contain the same number of elements as the argument.
		</p><pre class="programlisting">$ref_results = Triceps::Braced::split_braced_final($string);
confess "Unbalanced braces around '$string'" if $string;</pre><p>
		The combined functionality of splitting a string and un-escaping
		the result elements. That's why it's final: no further splits must be
		done after un-escaping.  <span class="bold"><strong>The return value is different from the
		other split methods.</strong></span> It is a reference to the array of result
		strings. The difference has been introduced to propagate the <code class="computeroutput">undef</code>
		from the argument to the result: if the argument string is <code class="computeroutput">undef</code>,
		the result will be also <code class="computeroutput">undef</code>, <span class="bold"><strong>not</strong></span> a reference to an
		empty array. The string gets consumed in the same way as for the
		other split methods, and anything left in it indicates an unbalanced
		brace.
		</p></div><div class="sect1" title="19.17. FnReturn reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_fnreturn"></a>19.17. FnReturn reference</h2></div></div></div><a class="indexterm" name="id596053"></a><p>
		The FnReturn represents the return value of a streaming function.
		The return value consists of a stream of rowops, and gets processed
		by sending them to the labels through a binding.
		</p><pre class="programlisting">$fret = Triceps::FnReturn-&gt;new($optName =&gt; $optValue, ...);</pre><p>
		Construct an FnReturn object. The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">name =&gt; $name</code></span></dt><dd>
			Name of this object. Will be used to create the names of the labels in it.
			</dd><dt><span class="term"><code class="computeroutput">unit =&gt; $unit</code></span></dt><dd>
			The unit where this object belongs.
			</dd><dt><span class="term"><code class="computeroutput">labels =&gt; [ @definitions ]</code></span></dt><dd><p>
			Definition of the labels in the FnReturn, where the results of the
			streaming function will be sent.
			The full names of these labels will be
			<span class="quote">&#8220;<span class="quote">return_name.label_name</span>&#8221;</span>. The label names within a 
			return must be unique.
			The value for this option is an array
			reference, with the labels defined as name-value pairs in the array, in
			one of two forms:
			</p><pre class="programlisting">labels =&gt; [
  $name1 =&gt; $rowType1,
  $name2 =&gt; $fromLabel2,
  ...
]</pre><p>
			If the second element in the pair is a row type, a label of that row type
			will be created in the FnReturn.
			</p><p>
			If the second element in the pair is a label, its row type will be used
			to create a label in FnReturn and that new label will also be automatically
			chained off the specified one. This is convenient if you already have
			the logic of the function defined and just want to forward the result
			data from an existing label into the FnReturn. The chaining is normally
			done with <code class="computeroutput">chainFront()</code>, unless the option <code class="computeroutput">chainFront =&gt; 0</code>
			tells otherwise. 
			The front chaining is convenient if you want to pass both
			the original request and the result into the return. Usually you
			would define the result computation and then define the return.
			With the chaining at the back, this would lead to the computation
			chained off the input label first and the return going after it.
			This would lead to the result coming out before the argument,
			and special contortions would be needed to avoid it. With chaining
			at the front, the return will go in the chain before the computation,
			even if the return was defined last.
			</p></dd><dt><span class="term"><code class="computeroutput">chainFront =&gt; 0/1</code></span></dt><dd>
			Flag: Determines whether the FnReturn labels built by chaining off the other
			labels will be chained at the back (if 0) or at the front (if 1).
			Optional. Default: 1.
			</dd><dt><span class="term"><code class="computeroutput">onPush =&gt; $code</code></span></dt><dd>
			The code to execute whenever an FnBinding is pushed onto this FnReturn.
			This is useful to maintain the extended call contexts for the streaming
			function.
			Its argument can be specified in one of two forms: either just a code
			reference, or a reference to an array containing the code reference and
			the extra arguments for it. I.e. either <code class="computeroutput">onPush =&gt; $code</code> or
			<code class="computeroutput">onPush =&gt; [ $code, @args ]</code>. The first argument of the function
			will always be the FnReturn object itself, with extra arguments going
			after it: <code class="computeroutput">&amp;$code($thisFnReturn, @optional_args)</code>.
			As usual, a source code string may be used instead of the function reference.
			Optional.
			</dd><dt><span class="term"><code class="computeroutput">onPop =&gt; $code</code></span></dt><dd>
			The code to execute whenever an FnBinding is popped from this FnReturn.
			This is useful to maintain the extended call contexts for the streaming
			function.
			Its argument can be specified in one of two forms: either just a code
			reference, or a reference to an array containing the code reference and
			the extra arguments for it. I.e. either <code class="computeroutput">onPop =&gt; $code</code> or
			<code class="computeroutput">onPop =&gt; [ $code, @args ]</code>. The first argument of the function
			will always be the FnReturn object itself, with extra arguments going
			after it: <code class="computeroutput">&amp;$code($thisFnReturn, @optional_args)</code>.
			As usual, a source code string may be used instead of the function reference.
			Optional.
			</dd></dl></div><p>
		The FnReturn has a concept of clearing: and once any of the labels owned
		by the FnReturn gets cleared, the FnReturn is also cleared. The
		clearing drops the onPush and onPop handlers, thus breaking any
		reference cycles they might be engaged in.
		</p><p>
		Also, when an FnReturn gets destroyed, it clears and disconnects from 
		the Unit all the labels defined in that FnReturn. The reason for that
		is that the labels in FnReturn cannot work without the FnReturn object
		anyway, and cannot hold a reference to it either (to avoid the
		cyclical references).
		</p><pre class="programlisting">$name = $fret-&gt;getName();</pre><p>
		Get back the object's name.
		</p><pre class="programlisting">$res = $fret-&gt;size();</pre><p>
		Get the number of labels in the return.
		</p><pre class="programlisting">@names = $fret-&gt;getLabelNames();</pre><p>
		Get an array of label names, in the same order as they were defined
		(the order of the label definitions is important).
		</p><pre class="programlisting">@labels = $fret-&gt;getLabels();</pre><p>
		Get an array of references to the FnReturn's internal labels, in the
		same order as they were defined.
		</p><pre class="programlisting">%labels = $fret-&gt;getLabelHash();</pre><p>
		Get the interspersed list of label names and references, suitable
		to initialize a hash.
		</p><pre class="programlisting">%namemap = $fret-&gt;getLabelMapping();</pre><p>
		Get the interspersed list of label names and their indexes in order
		starting from 0, suitable to initialize a hash.
		</p><pre class="programlisting">$label = $fret-&gt;getLabel($name);</pre><p>
		Get a label by name. Will confess if this name was not defined.
		</p><pre class="programlisting">$label = $fret-&gt;getLabelAt($idx);</pre><p>
		Get a label by index, starting from 0. Will confess if the index is out of range.
		</p><pre class="programlisting">$idx = $fret-&gt;findLabel($name);</pre><p>
		Translate a label name to index. Will confess if this name was not defined.
		</p><pre class="programlisting">%rts = $fret-&gt;getRowTypeHash();</pre><p>
		Get the interspersed list of label names and references to their row types, suitable
		to initialize a hash. In Perl, this is the closest thing to the C++ API's
		RowSetType.
		</p><pre class="programlisting">$res = $fret-&gt;equals($fret2);
$res = $fret-&gt;equals($fbind2);
$res = $fret-&gt;match($fret2);
$res = $fret-&gt;match($fbind2);</pre><p>
		Compare the equality or match of types with an FnReturn or FnBinding.
		Since their type objects are not directly visible in the Perl API,
		the comparison has to be done on the FnReturns and FnBindings themselves.
		The types are considered equal if they contain the equal row
		types with equal names going in the same order. They are considered
		matching if they contain matching row types going in the same order,
		with any names. If the match condition seems surprising to you, think
		of it as <span class="quote">&#8220;<span class="quote">nothing will break if one type is substituted for another at
		execution time</span>&#8221;</span>.
		</p><pre class="programlisting">$res = $fret-&gt;same($fret2);</pre><p>
		The usual check for two references referring to the same FnReturn object.
		</p><pre class="programlisting">$fret-&gt;push($fbind);</pre><p>
		Push a binding on the return stack. The binding must be of a matching type.
		The reference to the binding will be kept in the FnReturn until it's popped.
		</p><pre class="programlisting">$fret-&gt;pop($fbind);
$fret-&gt;pop();</pre><p>
		Pop a binding from the return stack. The binding argument specifies,
		which binding is expected to be popped. Without argument, pops any
		binding. The call with argument is recommended since it
		allows to catch any mess-ups with the return stack early. If the stack
		is empty or the top binding is not the same as the argument, will confess.
		</p><pre class="programlisting">$res = $fret-&gt;bindingStackSize();</pre><p>
		Get the current size of the return stack (AKA the stack of bindings). Useful
		for debugging.
		</p><pre class="programlisting">@names = $fret-&gt;bindingStackNames();</pre><p>
		Get the names of all the bindings on the return stack. Useful for debugging.
		The top of stack is on the right.
		</p><pre class="programlisting">$res = fret-&gt;isFaceted();</pre><a class="indexterm" name="id601842"></a><p>
		Returns 1 if this FnReturn object is a part of a Facet.
		</p></div><div class="sect1" title="19.18. FnBinding reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_fnbinding"></a>19.18. FnBinding reference</h2></div></div></div><a class="indexterm" name="id565491"></a><p>
		An FnBinding represents a single call of a streaming function.
		It forwards the stream of rowops coming out of an FnReturn to the
		logic in the caller.
		</p><pre class="programlisting">$fbind = Triceps::FnBinding-&gt;new($optName =&gt; $optValue, ...);</pre><p>
		Construct an FnBinding object. The object may be reused for multiple
		calls. It's very much like a function call in a procedural language:
		present once in the program text but can be executed many times.
		The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">name =&gt; $name</code></span></dt><dd>
			Name of this object. Will be used to create the names of the labels in it.
			</dd><dt><span class="term"><code class="computeroutput">unit =&gt; $unit</code></span></dt><dd>
			The unit where the labels specified as Perl inline code will be created.
			If no labels are specified in this format, this option is not required.
			</dd><dt><span class="term"><code class="computeroutput">on =&gt; $fret</code></span></dt><dd>
			The FnReturn on which this binding is defined. It determines what labels
			are available for binding. The created FnBinding may be used not only with that
			particular FnReturn but also with any FnReturn of a matching type.
			If that other FnReturn has not an equal but only a matching type, the 
			labels will be connected by the order in which they were defined in their
			respective FnReturns.
			It's a bit tricky: when an FnBinding is created, the labels in it get
			connected to the FnReturn on which it's defined by name. But at this
			point each of them gets assigned a number, in order the labels went
			in that original FnReturn. After that only this number matters: if
			this FnBinding gets connected to another matching FnReturn, it will get
			the data from the FnReturn's label with the same number, not the same
			name.
			</dd><dt><span class="term"><code class="computeroutput">labels =&gt; [ @definitions ]</code></span></dt><dd><p>
			Definition of the labels in the FnBinding, that will be connected to the
			labels in FnReturn when the FnBinding is pushed on the FnReturn.
			The label names within an
			FnBinding must match the names from FnReturn. They may go in any order
			but internally will be reordered to match the label order from FnReturn.
			The value for this option is an array
			reference, with the labels defined as name-value pairs in the array, in
			one of two forms:
			</p><pre class="programlisting">labels =&gt; [
  $name1 =&gt; $label1,
  $name2 =&gt; sub { ... },
  ...
]</pre><p>
			If the second element in the pair is a function reference
			or a source code snippet in a string, a label will be automatically created using the unit from the
			option <span class="quote">&#8220;<span class="quote">unit</span>&#8221;</span>, the row type from the matching label in
			FnReturn, and the provided function as the label's code. It's a 
			convenient way to make your code shorter.  The full names of these created
			labels will be <span class="quote">&#8220;<span class="quote">binding_name.label_name</span>&#8221;</span>. 
			</p><a class="indexterm" name="id550360"></a><p>
			The labels in an FnBinding may belong to a different unit than
			the labels of the FnReturn. The FnReturn-FnBinding pair is an official
			way to connect two units.
			</p><p>
			It's also possible to include labels from multiple units into a single
			FnBinding. It's not particularly recommended but it happens to work.
			It creates complications when dealing with trays.
			</p><p>
			The details of the label execution in a binding are described in
			<a class="xref" href="#sc_strf_scheduling" title="15.13. The gritty details of streaming functions scheduling">Section 15.13: &#8220;The gritty details of streaming functions scheduling&#8221; </a>.
			</p></dd><dt><span class="term"><code class="computeroutput">withTray =&gt; 0/1</code></span></dt><dd>
			Flag: Determines, whether the rowops coming into the FnBinding will be executed
			immediately (<code class="computeroutput">withTray =&gt; 0</code>) or collected in a tray
			(<code class="computeroutput">withTray =&gt; 1</code>). Optional, 0 by default.
			</dd><dt><span class="term"><code class="computeroutput">clearLabels =&gt; 0/1</code></span></dt><dd><p>
			Flag: Determines whether the labels in FnBinding will be automatically cleared
			and forgotten in their unit when the FnBinding gets destroyed. This allows
			to create the temporary FnBindings dynamically and destroy them after the use,
			without leaking the labels. This option applies only to the labels specified
			as the label objects. The labels created by the FnBinding from the code
			references are always cleared and forgotten.
			</p><p>
			Unlike the C++ API, there is no way to set this option separately for
			each label, it's all or none. But normally all the labels need the same
			treatment anyway, so it just makes things easier.
			</p><p>
			Optional, 0 by default. Even for the dynamically created and destroyed
			FnBindings, this option is usually best left at 0, since usually the Label objects
			given to it will not be dynamically created, they would stay fixed between
			their uses. The only exception is if you create the labels along with the
			FnBinding and destroy them together as well. If you're doing that, probably
			you'd be better off having FnBinding create the labels for you from the
			code snippets, and those are always cleared and forgotten after the FnBinding
			destruction, no matter what this option is set to.
			</p></dd></dl></div><a class="indexterm" name="id544514"></a><pre class="programlisting">Triceps::FnBinding::call($optName =&gt; $optValue, ...);</pre><p>
		A convenience function to create an FnBinding dynamically, do a single streaming
		function call with it, and destroy the FnBinding. This is not the most efficient
		way, since the FnBinding objects and its labels are constructed and destoryed
		on every call, but easy to use.
		</p><p>
		The options largely match the FnBinding constructor, with the addition of
		the options that do the streaming function call.
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">name =&gt; $name</code></span></dt><dd>
			Name of the FnBinding object that will be constructed and destoryed for
			this call. Will be used to create the names of the labels in it.
			</dd><dt><span class="term"><code class="computeroutput">unit =&gt; $unit</code></span></dt><dd>
			The unit where the labels specified as Perl inline code will be created.
			If no labels are specified in this format, this option is not required.
			</dd><dt><span class="term"><code class="computeroutput">on =&gt; $fret</code></span></dt><dd>
			The FnReturn on which this binding is defined (see mode details on
			that in the description of FnBinding constructor) and also the FnReturn
			on which the call will be performed.
			</dd><dt><span class="term"><code class="computeroutput">labels =&gt; [ @definitions ]</code></span></dt><dd><p>
			Definition of the labels in the FnBinding, that will be connected to the
			labels in FnReturn when the FnBinding is pushed on the FnReturn.
			The format and meaning is the same as in the FnBinding constructor:
			</p><pre class="programlisting">labels =&gt; [
  $name1 =&gt; $label1,
  $name2 =&gt; sub { ... },
  ...
]</pre></dd><dt><span class="term"><code class="computeroutput">delayed =&gt; 0/1</code></span></dt><dd>
			Flag: An analog of option <span class="quote">&#8220;<span class="quote">withTray</span>&#8221;</span> of the FnBinding constructor.
			Determines, whether the rowops coming into the FnBinding will be executed
			immediately (<code class="computeroutput">delayed =&gt; 0</code>) or collected in a tray and the
			tray executed after the FnBinding is popped from FnReturn (but before FnBinding
			is destroyed). Since the FnBinding
			is created and destroyed inside the call, there is no way to get the tray
			out of it, instead the tray gets automatically executed.
			Optional, 0 by default.
			</dd><dt><span class="term"><code class="computeroutput">clearLabels =&gt; 0/1</code></span></dt><dd>
			Flag: Determines whether the labels in FnBinding will be automatically cleared
			and forgotten in their unit when the FnBinding gets destroyed. The details
			are described with the constructor.
			Optional, 0 by default, and highly unlikely to be used.
			</dd><dt><span class="term"><code class="computeroutput">rowop =&gt; $rowop</code></span></dt><dd>
			A reference to rowop to execute as the argument to the streaming function.
			Exactly one of options <span class="quote">&#8220;<span class="quote">rowop</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">rowops</span>&#8221;</span>,
			<span class="quote">&#8220;<span class="quote">tray</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">code</span>&#8221;</span> must be used.
			</dd><dt><span class="term"><code class="computeroutput">rowops =&gt; [ @rowops ]</code></span></dt><dd>
			A reference to an array of rowops (<code class="computeroutput">rowops =&gt; [ @rowops ]</code>) to execute as the argument to the
			streaming function. This is just a convenient way to inline multiple
			rowops without constructing a Tray.
			Exactly one of options <span class="quote">&#8220;<span class="quote">rowop</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">rowops</span>&#8221;</span>,
			<span class="quote">&#8220;<span class="quote">tray</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">code</span>&#8221;</span> must be used.
			</dd><dt><span class="term"><code class="computeroutput">tray =&gt; $tray</code></span></dt><dd>
			A reference to tray to execute as the argument to the streaming function.
			Exactly one of options <span class="quote">&#8220;<span class="quote">rowop</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">rowops</span>&#8221;</span>,
			<span class="quote">&#8220;<span class="quote">tray</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">code</span>&#8221;</span> must be used.
			</dd><dt><span class="term"><code class="computeroutput">code =&gt; $code</code></span></dt><dd></dd><dt><span class="term"><code class="computeroutput">code =&gt; [ $code, @args ]</code></span></dt><dd>
			A code reference or snippet to execute that sends the arguments to the streaming function.
			The source code snippet in a string also works. This option may also specify
			a function reference (or, again, its source code) together with its arguments.
			In this case the value would be an array reference: <code class="computeroutput">code =&gt; [ $code, @args ]</code>.
			Exactly one of options <span class="quote">&#8220;<span class="quote">rowop</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">rowops</span>&#8221;</span>,
			<span class="quote">&#8220;<span class="quote">tray</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">code</span>&#8221;</span> must be used.
			</dd></dl></div><pre class="programlisting">$res = $fbind-&gt;same($fbind2);</pre><p>
		The usual check for two references referring to the same FnBinding object.
		</p><pre class="programlisting">$res = $fbind-&gt;equals($fret2);
$res = $fbind-&gt;equals($fbind2);
$res = $fbind-&gt;match($fret2);
$res = $fbind-&gt;match($fbind2);</pre><p>
		Compare the equality or match of types with an FnReturn or FnBinding.
		Since their type objects are not directly visible in the Perl API,
		the comparison has to be done on the FnReturns and FnBindings themselves.
		The types are considered equal if they contain the equal row
		types with equal names going in the same order. They are considered
		matching if they contain matching row types going in the same order,
		with any names. If the match condition seems surprising to you, think
		of it as <span class="quote">&#8220;<span class="quote">nothing will break if one type is substituted for another at
		execution time</span>&#8221;</span>.
		</p><pre class="programlisting">$name = $fbind-&gt;getName();</pre><p>
		Get back the name of the binding.
		</p><pre class="programlisting">$res = $fbind-&gt;size();</pre><p>
		Get the number of labels in the underlying FnReturn. That is, not just of the
		labels actually used in the binding but of all the labels that could be
		potentially used in it.
		</p><pre class="programlisting">@names = $fbind-&gt;getLabelNames();</pre><p>
		Get an array of label names, in the same order as they were defined in 
		the underlying FnReturn.  This will include all the possible labels from
		the FnReturn, even those that were not used in FnBinding.
		</p><pre class="programlisting">@names = $fbind-&gt;getDefinedLabelNames();</pre><p>
		Get an array of label names that are actually used in the FnBinding.
		The order is still the same as they were defined in FnReturn, only
		the ones not mentioned in FnBinding are skipped.
		</p><pre class="programlisting">@labels = $fret-&gt;getLabels();</pre><p>
		Get an array of references to the FnBinding's labels, in the
		order they were defined in the FnReturn. 
		If some label name was defined
		in FnReturn but not used in FnBinding, that position will contain an
		<code class="computeroutput">undef</code>.
		</p><pre class="programlisting">%labels = $fret-&gt;getLabelHash();</pre><p>
		Get the interspersed list of label names and references, suitable
		to initialize a hash.  If some label name was defined
		in FnReturn but not used in FnBinding,  the reference for it will
		be <code class="computeroutput">undef</code>.
		</p><pre class="programlisting">%namemap = $fret-&gt;getLabelMapping();</pre><p>
		Get the interspersed list of label names and their indexes in order
		starting from 0, suitable to initialize a hash. 
		This includes all the labels from FnReturn.
		</p><pre class="programlisting">$label = $fret-&gt;getLabel($name);</pre><p>
		Get a label by name. Will confess if this name was not defined in FnReturn.
		If a label was defined in FnReturn but not used in FnBinding, returns
		an <code class="computeroutput">undef</code>.
		</p><pre class="programlisting">$label = $fret-&gt;getLabelAt($idx);</pre><p>
		Get a label by index, starting from 0. The index range is as defined in the
		underlying FnReturn.  Will confess if the index is out of range.
		If a label was defined in FnReturn but not used in FnBinding, returns
		an <code class="computeroutput">undef</code>.
		</p><pre class="programlisting">$idx = $fret-&gt;findLabel($name);</pre><p>
		Translate a label name to index. Will confess if this name was not defined.
		</p><pre class="programlisting">%rts = $fret-&gt;getRowTypeHash();</pre><p>
		Get the interspersed list of label names and references to their row types, suitable
		to initialize a hash.  This includes all the label names from FnReturn, even if
		they weren't used in the FnBinding.
		In Perl, this is the closest thing to the C++ API's RowSetType.
		</p><pre class="programlisting">$res = $fbind-&gt;withTray();
$res = $fbind-&gt;withTray($on);</pre><p>
		Get back or change the value of <span class="quote">&#8220;<span class="quote">withTray</span>&#8221;</span> option. If the argument
		<code class="computeroutput">$on</code> is used, it sets the new value.  The change
		can be done at any time. Either form returns the previous value of the option.
		Disabling the tray mode discards the current tray.
		</p><pre class="programlisting">$res = $fbind-&gt;traySize();</pre><p>
		Get the size of the currently collected tray. If the tray is disabled, returns 0.
		</p><pre class="programlisting">$res = $fbind-&gt;trayEmpty();</pre><p>
		Check whether the tray is currently empty. Also returns 1 is the tray is disabled.
		</p><pre class="programlisting">$tray = $fbind-&gt;swapTray();</pre><p>
		Get the current tray out of the FnBinding, and replace it with an empty tray.
		If the tray contains a mix of rowops for different units (which might happen
		if the FnBinding refers to labels from different units), it will be detected
		at this point and the metod will confess. The Perl API doesn't support dealing
		with such mixed trays. It's still possible to deal with this situation in Perl
		by using <code class="computeroutput">callTray()</code>. This method will also detect and confess if
		any of the rowops in the tray are destined for the cleared labels. Normally
		such rowops are simply ignored but this is a special case. It reduces the
		surprise if you accidentally clear the labels and then wonder why is the
		binding not working right.
		</p><pre class="programlisting">$res = $fbind-&gt;traySize();</pre><p>
		Get the size of the currently collected tray. If the tray is disabled, returns 0.
		</p><pre class="programlisting">$fbind-&gt;callTray();</pre><p>
		Logically, a combination of <code class="computeroutput">swapTray()</code> and the call of that returned tray.
		However this method also does the correct handling of the trays that contain
		a mix of rowops for different units. Each rowop will be called in its proper unit.
		</p></div><div class="sect1" title="19.19. AutoFnBind reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_autofnbind"></a>19.19. AutoFnBind reference</h2></div></div></div><a class="indexterm" name="id565082"></a><p>
		AutoFnBind provides a scoped way of pushing and popping of the
		FnBindings on the FnReturns. The pushing happens when an AutoFnBind
		object is constructed, the popping when it is destroyed (or on an
		explicit clearing).
		</p><pre class="programlisting">$ab = AutoFnBind-&gt;new($ret1 =&gt; $binding1, ...);</pre><p>
		Create an AutoFnBind object. The arguments consist of pairs of FnReturns 
		and FnBindings to push on them. The pushing will happen in the constructor
		in the order specified, the popping in the destructor or <code class="computeroutput">clear()</code>
		method in the opposite order.
		</p><p>
		If any corruption of the call stack is detected at the popping time 
		(i.e. the binding on the top of the stack is not the one that was
		pushed on it), this error will be detected. However since there is
		no way to report an error from a Perl destructor, this error message will
		be printed on stderr and the whole program will exit with the code 1.
		If you care about the ability to catch this error, use the method
		<code class="computeroutput">clear()</code> before destroying the AutoFnBind object.
		</p><pre class="programlisting">$ab-&gt;clear();</pre><p>
		Pop the bindings, just as during the destruction, and discard the
		references to the FnReturn and FnBinding objects.  After the clearing is
		done once, the destructor will not pop anything any more, and the repeated
		clearings will have no effect.
		</p><p>
		Any detected stack corruptions make this method confess. The popping
		will always go through the whole list of bindings, collecting the
		error reports along the way.  At the end of
		the run it will make sure that it doesn't have any references to
		anything any more, and only then confess if any errors were found.
		This cleans up the things as much as possible and as
		much as can be handled, but the end result will still not be
		particularly clean: the returns that got their stacks corrupted will
		still have their stacks corrupted, and some very serious
		application-level cleaning will be needed to continue. Probably a
		better choice would be to destroy everything and restart from scratch.
		But at least it allows to get safely to this point of restarting from
		scratch.
		</p><pre class="programlisting">$res = $ab-&gt;same($ab2);</pre><p>
		The usual check for two references referring to the same object.
		</p></div><div class="sect1" title="19.20. App reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_app"></a>19.20. App reference</h2></div></div></div><a class="indexterm" name="id582320"></a><p>
		An App represents a complete multithreaded Triceps application.
		There may be multiple applications running in the same process.
		</p><div class="sect2" title="19.20.1. App instance management"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_inst_management"></a>19.20.1. App instance management</h3></div></div></div><p>
		The first part of the App API keeps track of all the
		App instances in the program, and allows to list and find them.
		It's global by necessity.
		</p><pre class="programlisting">@apps = Triceps::App::listApps();</pre><p>
		Returns the array of name-value pairs, values containing the App
		references, listing all the Apps in the program (more exactly, in this
		Triceps library, if you compile multiple Triceps libraries together by
		renaming them, each of them will have its own Apps list). The returned
		array can be placed into a hash.
		</p><pre class="programlisting">$app = Triceps::App::find($name);</pre><p>
		Find an App by name. If an App with such a name does not exist, it will
		confess.
		</p><pre class="programlisting">$app = Triceps::App:make($name);</pre><p>
		Create a new App, give it the specified name, and put it on the list.
		The names must not be duplicate with the other existing Apps, or the
		method will confess.
		</p><pre class="programlisting">Triceps::App::drop($app);
Triceps::App::drop($appName);</pre><p>
		Drop the app, by reference or by name, from the list. The App is as
		usual reference-counted and will exist while there are references to
		it. The global list provides one of these references, so an App is
		guaranteed to exist while it's still on the list. When dropped, it will
		still be accessible through the existing references, but obviously will
		not be listed any more and could not be found by name.
		</p><p>
		Moreover, a new App with the same name can be added to the list.
		Because of this, dropping an App by name requires some care in case if
		there could be a new App created again with the same name: it creates a
		potential for a race, and you might end up dropping the new App instead
		of the old one. Of course, if it's the same thread that drops the old
		one and creates the new one, then there is no race. Dropping an
		application by name that doesn't exist at the moment is an error and
		will confess.
		</p><p>
		Dropping the App by reference theoretically allows to avoid the race: a
		specific object gets dropped, and if it already has been dropped, the
		call has no effect. Theoretically. However in practice Perl has a
		limitation on passing the object values between threads, and thus
		whenever each thread starts, first thing it does is finding its App by
		name. It's a very similar kind of race and is absolutely unavoidable
		except by making sure that all the App's threads have exited and joined
		(i.e. harvesting them). So make sure to complete the App's thread
		harvesting before dropping the App in the harvester thread, and by then
		it doesn't matter a whole lot if the App is dropped by name or by
		reference.
		</p></div><div class="sect2" title="19.20.2. App resolution"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_resolution"></a>19.20.2. App resolution</h3></div></div></div><p>
		Many (but not all) of the App methods allow to specify the App either
		by reference or by name, and they automatically sort it out, doing the
		internal look-up by name if necessary. So the same method could be used
		as either of:
		</p><pre class="programlisting">$app-&gt;method(...);
Triceps::App::method($app, ...);
Triceps::App::method($appName, ...);</pre><p>
		Obviously, you cannot use the <span class="quote">&#8220;<span class="quote"><code class="computeroutput">-&gt;</code></span>&#8221;</span> syntax with a name, and obviously
		if the name is not in the app list, the method will confess. Below I'll
		show the calls that allow the dual formats as
		<code class="computeroutput">Triceps::App::method($appOrName, ...)</code> but keep in mind that you can use
		the <span class="quote">&#8220;<span class="quote"><code class="computeroutput">-&gt;</code></span>&#8221;</span> form of them too with a reference.
		</p><pre class="programlisting">$app = Triceps::App::resolve($appOrName);</pre><p>
		Do just the
		automatically-sorting-out part: gets a reference or name and returns a
		reference either way. A newly created reference is returned in either
		case (not the argument reference). You can use this resolver before the
		methods that accept only a reference.
		</p></div><div class="sect2" title="19.20.3. App introspection"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_introspection"></a>19.20.3. App introspection</h3></div></div></div><pre class="programlisting">$result = $app-&gt;same($app2);</pre><p>
		Check if two references are for the same App object. Here they both
		must be references and not names.
		</p><pre class="programlisting">$name = $app-&gt;getName();</pre><p>
		Get the name of the App, from a reference.
		</p><pre class="programlisting">Triceps::App::declareTriead($appOrName, $trieadName);</pre><p>
		Declare a Triead (Triceps thread) in advance. Any attempts to look up
		the nexuses in that thread will then wait for the thread to become
		ready. (Attempts to look up in an undeclared and undefined thread are
		errors). This is necessary to prevent a race at the thread creation
		time.  For the most part, the method <code class="computeroutput">Triead::start()</code> just does the
		right thing by calling this method automatically and you don't need the
		use it manually, except in some very special circumstances.
		Declaring a thread with the same name more than once or declaring an already
		defined thread is perfectly all right.
		</p><pre class="programlisting">%trieads = Triceps::App::getTrieads($appOrName);</pre><p>
		Get the list of currently defined Trieads in the App, as name-value pairs. Keep in
		mind that the other threads may be modifying the list of Trieads, so if
		you do this call multiple times, you may get different results. However
		the Trieads are returned as references, so they are guaranteed to stay
		alive and readable even if they get removed from the App, or even if
		the App gets dropped.
		</p></div><div class="sect2" title="19.20.4. App harvester control"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_harvester"></a>19.20.4. App harvester control</h3></div></div></div><p>
		The harvester logic is a necessary part of an App. It manages the
		collection of the Trieads that died and allows the rest of the
		program find out when the App terminates. It runs in a designated
		thread (an OS/Perl thread, not a Triead, though in some special
		cases it may use a thread left over from a Triead).
		</p><p>
		Normally the harvester thread runs in parallel with the rest of the
		App logic. To wait for the App's exit, wait for the harvester's thread
		to exit. In case of the small programs (such as the unit tests),
		the App's <span class="quote">&#8220;<span class="quote">main Triead</span>&#8221;</span> may share the thread with the
		harvester: first the main Triead method would run, and after it
		returns, the harvester. This obviously means that the threads that
		have exited will be sitting in the zombie state during the life
		of the App, until the harvester has a chance to run.
		</p><p>
		The harvesting is an absolutely necessary part of the App life cycle,
		however in most of the usage patterns (such as with <code class="computeroutput">Triead::startHere()</code>
		or <code class="computeroutput">App::build()</code>) the harvester is called implicitly from the wrapping
		library functions, so you don't need to care about it.
		</p><pre class="programlisting">$app-&gt;harvester(@options);</pre><p>
		Run the harvester in the current thread. The harvester gets
		notifications from the threads when they are about to exit, and joins
		them.  After all the threads have been joined, it automatically drops
		the App, and returns.
		</p><p>
		Note that if you're running the harvester manually, you must call
		it only after the first thread has been defined or at least declared.
		Otherwise it will find no threads in the App, consider it dead and
		immediately drop it.
		</p><p>
		If the App was aborted, the harvester will normally confess after if
		had joined all the threads and disposed of the App, unless the option
		<span class="quote">&#8220;<span class="quote">die_on_abort</span>&#8221;</span> (see below) has been set to 0. This propagates the error
		to the caller. However there is a catch: if some of the threads don't
		react properly by exiting on an abort indication, the program will be
		stuck and you will see no error message until these threads get
		unstuck, possibly forever.
		</p><p>
		Options:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">die_on_abort =&gt; 0/1</code></span></dt><dd>
			Flag: If the App was aborted, the harvester will normally
			confess after if had joined all the threads and disposed of the
			App.  Setting this option to 0 will make the aborts silently
			ignored. This option does not affect the errors in joining the
			threads: if any of those are detected, harvester will still confess
			after it had disposed of the app. Optional. Default: 1.
			</dd></dl></div><pre class="programlisting">$dead = $app-&gt;harvestOnce();</pre><p>
		Do one run of the harvesting.  Joins all the threads that have exited
		since its last call. If no threads have exited since then, returns
		immediately. Returns 1 if all the threads have exited (and thus the App
		is dead), 0 otherwise.  If a thread join fails, immediately confesses
		(if multiple threads were ready for joining, the ones queued after the
		failed one won't be joined, call <code class="computeroutput">harvestOnce()</code> once more to join them).
		</p><pre class="programlisting">$app-&gt;waitNeedHarvest();</pre><p>
		Wait for at least one thread to become ready for harvesting. If the App
		is already dead (i.e. all its threads have exited), returns
		immediately.
		</p><p>
		These two methods allow to write the custom harvesters if you're not
		happy with the default one. The basic harvester logic can be written
		as:
		</p><pre class="programlisting">do {
  $app-&gt;waitNeedHarvest()
} while(!$app-&gt;harvestOnce());
$app-&gt;drop();</pre><p>
		However the real harvester also does some smarter things around the
		error handling. You can look it up in the source code in
		<code class="computeroutput">cpp/app/App.cpp</code>.
		</p></div><div class="sect2" title="19.20.5. App state management"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_state"></a>19.20.5. App state management</h3></div></div></div><pre class="programlisting">$res = Triceps::App::isDead($appOrName);</pre><p>
		Returns 1 if the App is dead (i.e. it has no alive Trieads, all the
		defined and declared threads have exited). Right after the App is
		created, before the first Triead is created, the App is also considered
		dead, and becomes alive when the first Triead is declared or defined.
		If an App becomes dead later, when all the Trieads exit, it can still
		be brought back alive by creating more Trieads. But this is considered
		bad practice, and will cause a race with the harvester (if you want to
		do this, you have to make your own custom harvester).
		</p><p>
		Calling this method with a name for the argument is probably a bad
		idea, since the App may be dropped quickly quickly after it
		becomes dead, and you may end up with this method confessing when it
		could not find the dropped App.
		</p><pre class="programlisting">$res = Triceps::App::isShutdown($appOrName);</pre><p>
		Returns 1 if the App has been requested to shut down, either normally
		or by being aborted.  The Trieads might
		still run for some time, until they properly detect and process the
		shutdown, and exit. So this condition is not equivalent to Dead,
		althouh they are connected. If any new Trieads get started, they will
		be shut down right away and won't run.
		</p><p>
		To reiterate: if all the Trieads just exit by themselves, the App
		becomes dead but not shut down. You could still start more Trieads and
		bring the App back alive. If the App had been shut down, it won't
		become immediately dead, but it will send the shutdown indication to
		all the Trieads, and after all of them eventually exit, the App will
		become dead too. And after shutdown there is no way to bring the App
		back alive, since any new Trieads will be shut down right away.
		There might be a short period until they detect the shutdown, so the
		App could spike as alive for a short time, but then will become dead
		again.
		</p><pre class="programlisting">$res = Triceps::App::isAborted($appOrName);</pre><p>
		Returns 1 if the App has been aborted. The App may be aborted
		explicitly by calling the method <code class="computeroutput">abortBy()</code>, or the thread wrapper logic
		automatically converts any unexpected deaths in the App's threads to
		the aborts. If any thread dies, this aborts the App, which in turn
		requests the other threads to die on their next thread-related call.
		Eventually the harvester collects them all and confesses, normally
		making the whole program die with an error.
		</p><pre class="programlisting">($tname, $message) = Triceps::App::getAborted($appOrName);</pre><p>
		Get the App abort information: name of the thread that caused the
		abort, and its error message.
		</p><pre class="programlisting">Triceps::App::abortBy($appOrName, $tname, $msg);</pre><p>
		Abort the application. The thread name and message will be remembered,
		and returned later by <code class="computeroutput">getAborted()</code> or in the harvester. If <code class="computeroutput">abortBy()</code> is
		called multiple times, only the first pair of thread name and message
		gets remembered. The reason is that on abort all the threads get
		interrupted in a fairly rough manner (all their ongoing and following
		calls to the threading API die), which typically causes them to call
		<code class="computeroutput">abortBy()</code> as well, and there is no point in collecting these spurious
		messages.
		</p><p>
		The thread name here doesn't have to be the name of the actual thread
		that reports the issue. For example, if the thread creation as such
		fails (maybe because of the OS limit on the thread count) that gets
		detected by the parent thread but reported in the name of the thread
		whose creation has failed. And in general you can pass just any string
		as the thread name, App itself doesn't care, just make it something
		that makes sense to you.
		</p><pre class="programlisting">Triceps::App::waitDead($appOrName);</pre><p>
		Will wait for the App to become dead and return after that. Make sure
		to not call <code class="computeroutput">waitDead()</code> from any of App's Trieads: that would cause a
		deadlock.
		</p><pre class="programlisting">Triceps::App::shutdown($appOrName);</pre><p>
		Shut down the App. The shutdown state is sticky, so any repeated calls
		will have no effect. The call returns immediately and doesn't wait for
		the App to die. If you want to wait, call <code class="computeroutput">waitDead()</code> afterwards. Make
		sure to not call <code class="computeroutput">waitDead()</code> from a Triead: that would cause a deadlock.
		</p><pre class="programlisting">Triceps::App::shutdownFragment($appOrName, $fragName);</pre><p>
		Shut down a named fragment. This does not shut down the whole App, it
		just selectively shuts down the Trieads belonging to this fragment.
		See the explanation of the fragments in
		<a class="xref" href="#sc_mt_dynamic_server" title="16.6. Dynamic threads and fragments in a socket server">Section 16.6: &#8220;Dynamic threads and fragments in a socket server&#8221; </a>.
		The fragment shutdown is not sticky: after a fragment has been shut
		down, it's possible to create another fragment with the same name. To
		avoid races, a fragment may be shut down only after all its Trieads are
		ready. So the caller Triead must call <code class="computeroutput">readyReady()</code> before it calls
		<code class="computeroutput">shutdownFragment()</code>. If any of the fragment's Trieads are not ready, the
		call will confess.
		</p></div><div class="sect2" title="19.20.6. App drain control"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_drain"></a>19.20.6. App drain control</h3></div></div></div><p>
		The next few methods have to do with the drains. Generally, using the
		AutoDrain class to automatically limit the scope of the drains is a
		better idea. But if the automatic scoping is not desired, the App
		methods can be used directly.
		</p><pre class="programlisting">Triceps::App::requestDrain($appOrName);</pre><p>
		Request a shared drain. Does not wait for the drain to complete. This
		method may be called repeatedly, potentially from multiple threads,
		which will keep the drain active and increase the recursion count. The
		drain will be released when <code class="computeroutput">undrain()</code> is called the matching number of
		times.
		</p><p>
		If an exclusive drain by another thread is active when <code class="computeroutput">requestDrain()</code>
		is called, the call will be stuck until the exclusive drain becomes
		released (and potentially more exclusive drains might be queued up
		before the shared drain, using the POSIX read-write-lock
		implementation). Otherwise the call will set the appropriate state and
		return immediately.
		</p><p>
		If this thread has requested an exclusive drain previously (and didn't
		release it yet), an attempt to get a shared drain in the same thread
		will likely deadlock. The same applies in the opposite order as well.
		</p><p>
		Once the shared drain is requested, the input-only threads will be
		blocked from sending more data (any their attempts to flush their write
		facets will get stuck until release), and the rest of the threads will
		continue churning through the data buffered in the nexuses until all
		the nexuses are empty and there is no more data to process (yes, these
		threads will continue writing to their write facets).
		</p><p>
		It is important to not request a shared drain from an input-only thread
		and then try to write more data into an output facet, that would
		deadlock. The whole concept is doable, but an exclusive drain must be
		used instead (<span class="quote">&#8220;<span class="quote">exclusive</span>&#8221;</span> means that a designated input-only thread is
		excluded from blocking).
		</p><p>
		If the new Trieads are
		created while a drain is active, these Trieads will be notified of the
		drain. This means that the input-only Trieads won't be able to send any
		data until the drain is released. However the Trieads in the middle of
		the model will follow the normal protocol for such threads: the drain
		will become incomplete after the Triead is marked as ready and until it
		blocks on the following <code class="computeroutput">TrieadOwner::nextXtray()</code>. Normally this should be a very
		short amount of time. However such Trieads should take care to 
		check <code class="computeroutput">TrieadOwner::isRdDrain()</code> and never
		send any rowops on their own before reading from <code class="computeroutput">nextXtray()</code> if they
		find that <code class="computeroutput">isRdDrain()</code> returns true. Otherwise they may
		introduce the data into the model at a very inconvenient moment, when
		some logic expects that no data is changing, and cause a corruption.
		This is the same caveat as for using <code class="computeroutput">nextXtray()</code> varieties with the
		timeouts: if you want to send data on a timeout, always check
		<code class="computeroutput">isRqDrain()</code>, and never send any data on timeouts if <code class="computeroutput">isRqDrain()</code> returns
		true.
		</p><pre class="programlisting">Triceps::App::waitDrain($appOrName);</pre><p>
		Wait for the requested shared drain to complete. This means that all
		the queues in all the nexuses have become empty.
		</p><p>
		The effect of <code class="computeroutput">waitDrain()</code> without a preceding <code class="computeroutput">requestDrain()</code> is
		undefined. If you definitely know that some other thread has requested
		a drain and didn't release yet, it will work as normal, so you can have
		any number of threads wait for drain in parallel. (And the semantics,
		shared or exclusive, will match that currently active request). If no
		thread requested a drain, it might either return immediately
		irrespective of the state of the nexuses or might wait for some other
		thread to request a drain and succeed.
		</p><p>
		This call may also be used with an exclusive (or shared) drain
		requested through a TrieadOwner or any drain requested through an
		AutoDrain (though a better style is to use the same object as used for
		requesting the drain).
		</p><pre class="programlisting">Triceps::App::drain($appOrName);</pre><p>
		A combination of <code class="computeroutput">requestDrain()</code> and <code class="computeroutput">waitDrain()</code> in one call.
		</p><pre class="programlisting">Triceps::App::undrain($appOrName);</pre><p>
		Release the drain and let the normal processing continue. Make sure to
		call it exactly the same number of times as the <code class="computeroutput">requestDrain()</code>.
		</p><p>
		This call may also be used with a drain requested through a TrieadOwner
		(though a better style is to use the same object as used for requesting
		the drain).
		</p><pre class="programlisting">$result = Triceps::App::isDrained($appOrName);</pre><p>
		Check whether the App is currently drained (i.e. all the nexuses are
		empty), without waiting for it. Returns 1 if drained, 0 if not. If no
		drain is active during this call, the result is undefined, not even in
		the <span class="quote">&#8220;<span class="quote">best effort</span>&#8221;</span> sense: it may return 1 even if there are millions of
		records queued up. The only reliable way is to request a drain first.
		</p><p>
		This call may also be used with a drain requested through a TrieadOwner
		or through an AutoDrain.
		</p></div><div class="sect2" title="19.20.7. App start timeout"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_start_timeout"></a>19.20.7. App start timeout</h3></div></div></div><p>
		Even though Triceps is quite eager in
		watching for deadlocks in the threads topology, it's still possible to
		get some threads, and with them the whole program, stuck during
		initialization. For example, if you declare a thread and then never
		define it. These situations are very unpleasant because you start the
		program and expect it to work but it doesn't, without any indication to
		why. So Triceps imposes an initialization timeout. The App (and thus
		all its threads) must become ready within the timeout after the
		definition or declaration of the last Triead. If not, the App will be
		aborted (and the error message will tell, which thread did not
		initialize in time). The same applies to the creation of Trieads
		(usually in the fragments) after the App is already running: all the
		threads must become ready within the timeout since the last thread has
		been defined or declared.
		</p><pre class="programlisting">Triceps::App::setTimeout($appOrName, $main_to_sec);
Triceps::App::setTimeout($appOrName, $main_to_sec, $frag_to_sec);</pre><p>
		Set the readiness timeout.
		</p><p>
		The default timeout is 30 seconds, or symbolically
		</p><pre class="programlisting">&amp;Triceps::App::DEFAULT_TIMEOUT</pre><p>
		(subject to possible changes of the exact value in the future).
		</p><p>
		But the timeout can be changed. Technically, there are two timeouts:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			one starts when the App is created
			</li><li class="listitem">
			one restarts when any Triead is defined or declared
			</li></ul></div><p>
		For the App to be aborted, both timeouts must expire. By default they
		are set to the same length, so only the second timeout really matters,
		since it will always be the last one to start and last one to end. But
		if you set the first timeout to be longer, you can allow for a longer
		initialization period at the App start (<span class="quote">&#8220;<span class="quote">main timeout</span>&#8221;</span>) than later when
		more threads are added to a running App (<span class="quote">&#8220;<span class="quote">fragment timeout</span>&#8221;</span>, since the
		threads added later are typically the threads in fragments).
		</p><p>
		The one-argument form of <code class="computeroutput">setTimeout()</code> sets both timeouts to the same
		value, the two-argument form sets these timeouts separately.
		</p><p>
		The timeouts may be set only before the first thread has been created.
		This is largely due to the historical reasons of implementation, with
		the current implementation it should actually be safe to allow changing
		the timeouts at a later point as well, and this limitation may be
		removed in the future.
		</p><p>
		The timeout values are represented as integer whole seconds.
		</p><p>
		Note that it's still possible to get the initialization stuck without
		any indication if it gets stuck in the other libraries. The reason is
		that the harvester waits for all the threads to be joined before it
		propagates the error, so if a thread doesn't get aborted properly
		and doesn't get joined, the harvester
		will be stuck. For example, if you open a file on NFS as a part of
		Triead initialization, and the NFS server doesn't respond, this thread
		will be stuck for a long time if not forever. The App will detect a
		timeout and try to interrupt the threads but the NFS operations are
		often not interruptable, so the harvester will wait for this thread to
		complete this operation and exit before it propagates the error, and
		thus the whole program will be silently stuck forever (and to avoid
		this, the NFS mounts should be done in the <span class="quote">&#8220;<span class="quote">soft</span>&#8221;</span> mode but it's a
		separate story). This will likely be improved in the future but it
		needs more thinking about how to do it right.
		</p><pre class="programlisting">Triceps::App::setDeadline($appOrName, $deadline_sec);</pre><p>
		Set the <span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> timeout in the form of an absolute deadline. This is
		actually closer to the way it works internally: the limit is expressed
		as a deadline, and <code class="computeroutput">setTimeout()</code> just adds the timeout value to the
		current time to compute the deadline, while <code class="computeroutput">setDeadline()</code> sets it
		straight. Like <code class="computeroutput">setTimeout()</code>, this may be called only before any Trieads
		were created.
		</p><a class="indexterm" name="id580707"></a><p>
		The time is represented as floating-point seconds since epoch.
		<code class="computeroutput">Triceps::now()</code> can be used to get the current time with the fractional
		seconds (or if you don't care about the fractional seconds, you can
		always use the stock <code class="computeroutput">time()</code>).
		</p><pre class="programlisting">Triceps::App::refreshDeadline($appOrName);</pre><p>
		Restart the <span class="quote">&#8220;<span class="quote">fragment</span>&#8221;</span> timeout. Same as when a Triead is defined or
		declared, only without involving a Triead. 
		This method can be called at any time.
		</p></div><div class="sect2" title="19.20.8. File descriptor transfer through an App"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_fd"></a>19.20.8. File descriptor transfer through an App</h3></div></div></div><p>
		Perl doesn't allow the sharing or transfers of the file handles
		between the threads. So Triceps works around this limitation
		by passing the underlying file descriptors through the App.
		After that the receiving Triead may construct a new file
		handle from the descriptor.
		</p><p>
		The concepts are described in detail in
		<a class="xref" href="#sc_mt_files" title="16.5. Threads and file descriptors">Section 16.5: &#8220;Threads and file descriptors&#8221; </a>,
		this is just a short reference. This API works under the hood
		of <code class="computeroutput">TrieadOwner::trackGetFile()</code> and friends
		but can also be used directly.
		</p><pre class="programlisting">Triceps::App::storeFd($appOrName, $name, $fd, $fileClassName);</pre><p>
		Store a file descriptor in the App object, allowing to load it into
		other threads, and thus pass it around between the threads. $name is
		the name for this descriptor that will later be used to get the file
		descriptor back (generally, you want to generate a unique name for each
		file descriptor stored to avoid confusion, and then pass this name to
		the target thread). <code class="computeroutput">$fd</code> is the file descriptor, an integer number,
		normally received from <code class="computeroutput">fileno()</code>. The file descriptor is dupped before
		it gets stored, so the original will continue to exist, and if you have
		no other use for it, you should close it. 
		</p><p>
		The <code class="computeroutput">$fileClassName</code> allows to pass through the information
		about the class of the Perl file handle (such as IO::Handle or
		IO::Socket::INET) that owned this descriptor originally, and re-create
		the correct object later when loading the descriptor back. It's a plain
		string, and an empty string can be used for the plain files.
		</p><p>
		If a file descriptor with this name already exists in the App, this
		call will confess.
		</p><pre class="programlisting">($fd, $fileClassName) = Triceps::App::loadFd($appOrName, $name);</pre><p>
		Load back the file descriptor that was previously stored. The file handle
		class name is loaded back along with it.  If no
		descriptor with such a name is stored in the App, it will confess. The
		descriptor will keep existing in the App, so to keep things consistent,
		there are two options:
		</p><p>
		One is to let your code take over the ownership of the file descriptor,
		and tell the App to forget about it with <code class="computeroutput">forgetFd()</code>.
		</p><p>
		The other one is to never close the received descriptor in your code (a
		good example would be to dup it right away for the future use and then
		leave the original alone), and let App keep its ownership.
		</p><pre class="programlisting">($fd, $fileClassName) = Triceps::App::loadDupFd($appOrName, $name);</pre><p>
		Very much the same as <code class="computeroutput">loadFd()</code>, only does the dupping for you and
		returns the dupped descriptor. In this case your code is responsible
		for closing that descriptor. Which method is more suitable, <code class="computeroutput">loadFd()</code> or
		<code class="computeroutput">loadDupFd()</code>, depends on the nature of the code that will use the file
		descriptor and whether you want to leave the descriptor in the App for
		more threads to load.
		</p><pre class="programlisting">Triceps::App::forgetFd($appOrName, $name);</pre><p>
		Forget the file descriptor in the App. It doesn't get closed, so
		closing it becomes your responsibility, or it will leak. If no
		descriptor with this name exists, the call will confess.
		</p><pre class="programlisting">Triceps::App::closeFd($appOrName, $name);</pre><p>
		Close and forget the file descriptor in the App. If no descriptor with
		this name exists, the call will confess.
		</p><pre class="programlisting">Triceps::App::storeFile($appOrName, $name, FILE);</pre><p>
		A convenience wrapper for <code class="computeroutput">closeFd()</code>, calls <code class="computeroutput">fileno()</code> on the file and
		stores the resulting file descriptor. The name of the class of the
		file handle is stored along with the descriptor.
		</p><pre class="programlisting">Triceps::App::storeCloseFile($appOrName, $name, FILE);</pre><p>
		Stores the file descriptor extracted from the file, and closes the
		original file (since the file descriptor gets dupped on store, that
		copy continues to exist in the App).
		</p><pre class="programlisting">$file = Triceps::App::loadDupFile($appOrName, $name, $mode);</pre><p>
		Load a file descriptor and build a file handle object from it,
		using the stored file handle class name.
		The mode string may be specified in either the <code class="computeroutput">open()</code> format
		(<code class="computeroutput">&lt;/&gt;/&gt;&gt;/+&lt;/+&gt;/+&gt;&gt;</code>) or the C stdio format (<code class="computeroutput">r/w/a/r+/w+/a+</code>). Note that
		the mode must match or be a subset of the mode used to originally open
		the file descriptor. If you open a file read-only, store its
		descriptor, and load back as a write-only file, you will have a bad
		time.
		</p><p>
		There is no corresponding <code class="computeroutput">loadFile()</code>, since <code class="computeroutput">loadFd()</code> is a more
		dangerous method that is useful for the low-level operations but
		doesn't make much sense for the higher level.
		</p><pre class="programlisting">$file = Triceps::App::loadDupFileClass($appOrName, $name, $mode, $fileClassName);</pre><p>
		Load a file descriptor and build an arbitrary handle object from it,
		overriding the stored class name. The
		class (specified by its name) should normally be a subclass of
		IO::Handle, or at the very least must implement the method
		<code class="computeroutput">new_from_fd()</code> similar to IO::Handle.
		</p></div><div class="sect2" title="19.20.9. App build"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_app_build"></a>19.20.9. App build</h3></div></div></div><p>
		There are multiple ways to build an App:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Create the App manually with <code class="computeroutput">App::make()</code>, then manually
			create its Trieads and start the harvester. To wait for the app
			completion, wait for the harvester thread to exit.
			</li><li class="listitem">
			Create the App with <code class="computeroutput">App::build()</code>, as described below.
			The Trieads get constructed from the function that is passed as an
			argument to <code class="computeroutput">build()</code>. After running the thread construction,
			<code class="computeroutput">build()</code> runs the harvester automatically, and returns after the harvester
			exits. 
			</li><li class="listitem">
			Create the App with <code class="computeroutput">Triead::startHere()</code>. It's very much like
			<code class="computeroutput">App::build()</code>, except that the code started from it is an
			actual Triead, running in the context of the current thread. This is
			convenient for running the short-lived Apps that get started, run for 
			a short time and then need to return the results back to the calling
			thread. The harvester also runs automatically by <code class="computeroutput">Triead::startHere()</code>
			but only after the the <span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> Triead exits.
			</li></ul></div><pre class="programlisting">Triceps::App::build($name, $builder);</pre><p>
		Build an App instance. It creates the App instance, then the builder
		function is called to create the App's nexuses and threads, then the
		harvester is executed, that eventually destroys the App object after
		collecting all its threads. For a very basic example:
		</p><pre class="programlisting">Triceps::App::build "a1", sub {
  Triceps::App::globalNexus(
    name =&gt; "types",
    rowTypes =&gt; [
      rt1 =&gt; $rt1,
    ],
  );
  Triceps::Triead::start(
    app =&gt; $Triceps::App::name,
    thread =&gt; "t1",
    main =&gt; sub {
      my $opts = {};
      &amp;Triceps::Opt::parse("t1 main", $opts, {@Triceps::Triead::opts}, @_);
      my $to = $opts-&gt;{owner};
      $to-&gt;importNexus(
        from =&gt; "global/types",
        import =&gt; "writer", # if importing just for the types, use "writer"!
      );
      $to-&gt;readyReady();
    },
  );
};</pre><p>
		The builder function runs in the current Perl thread, however from the
		logical standpoint it runs in the App's first Triead named <span class="quote">&#8220;<span class="quote">global</span>&#8221;</span>
		(this Triead name is hardcoded in <code class="computeroutput">build()</code>). This frees you from the
		worry about the App being technically dead until the first Triead is
		created: by the time the builder function is called, the first Triead
		is already created. However it also means that you can't change the
		readiness timeouts. After the builder function returns, the global
		Triead exits, and the harvester starts in the same current Perl thread.
		</p><p>
		The builder has access to a few global variables:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">$Triceps::App::name</code> is the App name, from the <code class="computeroutput">build()</code> first argument.
			</li><li class="listitem"><code class="computeroutput">$Triceps::App::app</code> is the reference to the App object.
			</li><li class="listitem"><code class="computeroutput">$Triceps::App::global</code> is the reference to the TrieadOwner object of the global Triead.
			</li></ul></div><p>
		After the builder function exits, these variables become undefined.
		</p><pre class="programlisting">Triceps::App::globalNexus(@nexusOptions);</pre><p>
		Creates a nexus with the import mode of <span class="quote">&#8220;<span class="quote">none</span>&#8221;</span>, on the global Triead.
		The arguments are the same options as for the normal nexus creation.
		This is a simple convenience wrapper for the nexus creation. Since the
		global thread is supposed to exit immediately, there is no point in
		importing this nexus into it.
		</p><p>
		The global thread is found by this function from <code class="computeroutput">$Triceps::App::global</code>,
		so this method can only be used from inside the builder function of
		<code class="computeroutput">build()</code>. 
		</p></div></div><div class="sect1" title="19.21. Triead reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_triead"></a>19.21. Triead reference</h2></div></div></div><a class="indexterm" name="id606518"></a><p>
		The Triead class is the public interface of a Triceps thread, i.e. what
		of it is visible to the other threads. It's intended pretty much for
		introspection only, and all its method are only for reading the state.
		They are all synchronized, but of course the thread may change its state
		at any moment. The Triead objects can be obtained by calling
		<code class="computeroutput">App::getTrieads()</code>.
		</p><p>
		The class also contains some static methods that are used to construct
		the Trieads.
		</p><pre class="programlisting">$result = $t-&gt;same($t2);</pre><p>
		Check that two Triead references point to the same Triead object.
		</p><pre class="programlisting">$name = $t-&gt;getName();</pre><p>
		Get the Triead's name.
		</p><pre class="programlisting">$fragment = $t-&gt;fragment();</pre><p>
		Get the name of the Triead's fragment. If the Triead doesn't belong to
		a fragment, returns an empty string <span class="quote">&#8220;<span class="quote"></span>&#8221;</span>.
		</p><pre class="programlisting">$result = $t-&gt;isConstructed();</pre><p>
		Check whether the Triead has been constructed. For the explanation of
		the Triead lifecycle states, see
		<a class="xref" href="#sc_mt_triead_life" title="16.2. The Triead lifecycle">Section 16.2: &#8220;The Triead lifecycle&#8221; </a>.
		</p><pre class="programlisting">$result = $t-&gt;isReady();</pre><p>
		Check whether the Triead is ready.
		</p><pre class="programlisting">$result = $t-&gt;isDead();</pre><p>
		Check whether the Triead is dead.
		</p><pre class="programlisting">$result = $t-&gt;isInputOnly();</pre><p>
		Check whether the Triead is input-only, that is, it has no reader nexuses
		imported into it. When the Triead is created, this flag starts its life
		as <code class="computeroutput">false</code> (0 for Perl), and then its correct value is computed when the
		Triead becomes ready. So, to check this flag correctly, you must first
		check that the Triead is ready.
		</p><pre class="programlisting">@nexuses = $t-&gt;exports();</pre><p>
		Get the list of nexuses exported from this Triead, as name-value
		pairs, suitable to be assigned into a hash. The values are the
		references to nexus objects.
		</p><pre class="programlisting">@nexuses = $t-&gt;imports();
@nexuses = $t-&gt;readerImports();
@nexuses = $t-&gt;writerImports();</pre><p>
		Get the list of nexuses imported into this Triead, as name-value pairs.
		The <code class="computeroutput">imports()</code> returns the full list, without the ability to tell, which
		nexuses are imported for reading and which for writing, while
		<code class="computeroutput">readImports()</code> and <code class="computeroutput">writeImports()</code> return these subsets separately.
		</p><p>
		The names here are the <span class="quote">&#8220;<span class="quote">as-names</span>&#8221;</span> used for the import (the full names
		of the Nexuses can be obtained from the Nexus objects). The values are
		the references to nexus objects.
		</p><p>
		The next part of the API is the static construction methods. They
		really are wrappers of the TrieadOwner methods but Triead is a shorter
		name, and thus more convenient.
		</p><pre class="programlisting">Triceps::Triead::start(@options);</pre><p>
		Start a new Triead in a new Perl thread. The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">app =&gt; $appname</code></span></dt><dd>
			Name of the App that owns the new Triead. The App object will be
			looked up by name for the actual construction.
			</dd><dt><span class="term"><code class="computeroutput">thread =&gt; $threadname</code></span></dt><dd>
			Name of the new Triead.
			</dd><dt><span class="term"><code class="computeroutput">fragment =&gt; $fragname</code></span></dt><dd>
			Name of the new Triead's fragment. Optional. Default: <span class="quote">&#8220;<span class="quote"></span>&#8221;</span>, which means no
			fragment.
			</dd><dt><span class="term"><code class="computeroutput">immed =&gt; 0/1</code></span></dt><dd>
			Flag: when the new thread imports its nexuses, it should import
			them in the immediate mode. This flag is purely advisory, and the
			thread's main function is free to use or ignore it depending on its
			logic. It's provided as a convenience, since it's a typical concern
			for the helper threads. Optional. Default: 0.
			</dd><dt><span class="term"><code class="computeroutput">main =&gt; $code</code></span></dt><dd><p>
			The main function of the thread that will be called with all the
			options of <code class="computeroutput">start()</code> plus some more:
			</p><pre class="programlisting">&amp;$func(@opts, owner =&gt; $ownerObj)</pre><p>
			The extra option of the main is:
			</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">owner =&gt; $ownerObj</code></span></dt><dd>
				The TrieadOwner object constructed for this thread, through which
				its state can be controlled.
				</dd></dl></div><p>
			Also, any other options may be added, and they will be forwarded to the
			main function without parsing. The main function is then free to parse
			them by itself, and if it finds any unknown options, it will fail.
			</p><p>
			For the convenience of writing the main functions, the set of
			<span class="quote">&#8220;<span class="quote">standard</span>&#8221;</span> options is provided in the global variable
			</p><pre class="programlisting">@Triceps::Triead::opts</pre><p>
			The main function then uses this variable as a preamble for any of
			its own options, for example:
			</p><pre class="programlisting">sub listenerT
{
    my $opts = {};
    &amp;Triceps::Opt::parse("listenerT", $opts, {@Triceps::Triead::opts,
        socketName =&gt; [ undef, \&amp;Triceps::Opt::ck_mandatory ],
    }, @_);
    ...
}</pre></dd></dl></div><p>
		Another convenience method is:
		</p><pre class="programlisting">Triceps::Triead::startHere(@options);</pre><p>
		It's very much the same as <code class="computeroutput">start()</code> but starts the Triead in the current
		Perl thread. It's intended for the short-lived Apps that perform some
		computation and then have to return the result into the original
		thread. The unit tests are a good example of such apps.
		</p><p>
		And because of the typical usage, this method has some extra
		functionality compared to the plain <code class="computeroutput">start()</code>: unless told otherwise, it
		will first create the App (with the name specified by the option
		<span class="quote">&#8220;<span class="quote">app</span>&#8221;</span>), then construct and run it, and after the main function of this
		thread exits, run the harvester and drop the App. So it just does the
		whole package, similar to <code class="computeroutput">App::build()</code>, only typically the Triead
		started here runs as a normal real Triead, collects the results of
		computations and places them into some variables (global or referenced
		by the user-specific options of the main function).
		</p><p>
		This extra functionality can be disabled by the additional options
		(disable by setting them to 0):
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">harvest =&gt; 0/1</code></span></dt><dd>
			After the main function exits, automatically run the harvesrer. If
			you set it to 0, don't forget to call the harvester after this
			function returns. Optional. Default: 1.
			</dd><dt><span class="term"><code class="computeroutput">makeApp =&gt; 0/1</code></span></dt><dd>
			Before doing anything, create the App.  Obviously, this App must
			not exist yet. Optional. Default: 1.
			</dd></dl></div><p>
		These options are not passed through to the main function, unlike all
		the others. 
		</p></div><div class="sect1" title="19.22. TrieadOwner reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_triead_owner"></a>19.22. TrieadOwner reference</h2></div></div></div><a class="indexterm" name="id554940"></a><a class="indexterm" name="id607552"></a><p>
		TrieadOwner is the thread's private interface used to control its state
		and interact with the App (the App uses the thread's identity to detect
		the deadlocks in these interactions). Whenever a Triead is constructed,
		its OS/Perl thread receives the TrieadOwner object for it.
		</p><div class="sect2" title="19.22.1. TrieadOwner construction"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_triead_owner_construct"></a>19.22.1. TrieadOwner construction</h3></div></div></div><p>
		Normally the TrieadOwner object is constructed inside <code class="computeroutput">Triead::start()</code>
		or <code class="computeroutput">Triead::startHere()</code> and passed to the thread's main function. The
		following constructor is used inside <code class="computeroutput">start()</code>, and it's pretty much a
		private method. The only reason to use it would be if you want to do
		something very unusual, and even then you probably should write a
		wrapper method for your unusual thing and then call that wrapper
		method. The constructor constructs both Triead and TrieadOwner as a two
		sides of the same item, and registers the thread with the App.
		</p><pre class="programlisting">$to = Triceps::TrieadOwner::new($tid, $handle, $appOrName, $tname, $fragname);</pre><p>
		Here <code class="computeroutput">$tid</code> is the Perl thread id where this TrieadOwner belongs (it can
		be obtained with <code class="computeroutput">$thr-&gt;tid()</code>). <code class="computeroutput">$handle</code> is the Perl thread's low-level
		handle (as in <code class="computeroutput">$thr-&gt;handle_()</code>), it's the underlying POSIX thread
		handle, used to interrupt the thread on shutdown (the long story is
		that in the Perl threads the <code class="computeroutput">kill()</code> call doesn't actually send a signal
		to another thread but just sets a flag; to interrupt a sleeping system
		call a real signal has to be delivered through the POSIX API). <code class="computeroutput">$handle</code>
		is a dangerous argument, and passing a wrong value there may cause a
		crash.
		</p><p>
		Both <code class="computeroutput">$tid</code> and <code class="computeroutput">$handle</code> may be undef. If <code class="computeroutput">$tid</code> is undef, the thread won't
		be joined by the harvester and you can either detach it or join it
		yourself. If either <code class="computeroutput">$tid</code> or <code class="computeroutput">$handle</code> is undef, the thread won't be
		interrupted on shutdown.
		</p><p>
		The signal used for interruption is <code class="computeroutput">SIGUSR2</code>. Triceps sets its default
		handler that does nothing on this signal. This is done in
		the method <code class="computeroutput">Triceps::sigusr2_setup()</code>, and it gets called
		during the Triceps module loading. Internally it translates to the C++
		method <code class="computeroutput">Sigusr2::setup()</code> that sets the dummy handler on the first call.
		The reason why it has to be done in C++ is that Perl 5.19 crashes on SIGUSR2
		if the handler is set in Perl.
		If you're interested in the details, see
		<a class="ulink" href="https://rt.perl.org/rt3//Public/Bug/Display.html?id=118929" target="_top">https://rt.perl.org/rt3//Public/Bug/Display.html?id=118929</a>.
		</p><p>
		<code class="computeroutput">$appOrName</code> is the App object or its name that would be automatically
		looked up (or will confess if not found). <code class="computeroutput">$tname</code> is the name for the
		thread, that must be unique within the App (though
		it might be declared before). <code class="computeroutput">$fragname</code> is the name of the fragment
		where the thread belongs, use <span class="quote">&#8220;<span class="quote"></span>&#8221;</span> for no fragment.
		</p></div><div class="sect2" title="19.22.2. TrieadOwner general methods"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_triead_owner_general"></a>19.22.2. TrieadOwner general methods</h3></div></div></div><pre class="programlisting">$app = $to-&gt;app();</pre><p>
		Get the App where this Triead belongs.
		</p><pre class="programlisting">$unit = $to-&gt;unit();</pre><p>
		Whenever a Triead is constructed, a Unit is automatically  created to
		execute its logic. This call returns that unit. When the Triead is
		destroyed, the unit will be cleaned and unreferenced.
		</p><p>
		The unit is named the same as the thread.
		</p><pre class="programlisting">$to-&gt;addUnit($moreUnit);</pre><p>
		It's possible to split the Triead's logic into multiple units, all
		running in the same Perl thread. This call puts an extra unit under
		Triead's control, and has two effects: First, the unit will be
		referenced for the life of the Triead, and cleaned and unreferenced
		when the Triead is destroyed. Second, when the Triead's main loop runs,
		after each incoming rowop it will check all the controlled units for
		any rowops scheduled in them, and will run them until all such rowops
		are processed.
		</p><p>
		The names of the units are not checked in any way, it's your
		responsibility to name them sensibly and probably differently from each
		other.
		</p><p>
		The repeated calls with the same unit will have no effect.
		</p><pre class="programlisting">$to-&gt;forgetUnit($moreUnit);</pre><p>
		Pull a unit out of Triead's control. After that the cleaning of the
		unit becomes your responsibility. The thread's main unit cannot be
		forgotten, the attempts to forget it will be simply ignored. The same
		goes for the units that aren't under the Triead's control in the first
		place, these calls are ignored.
		</p><pre class="programlisting">@units = $to-&gt;listUnits();</pre><p>
		Get the list of units under Triead's control. The main unit (the same
		as returned with <code class="computeroutput">$to-&gt;unit()</code>) will always be the first in the list. The
		list contains only the unit references, <span class="bold"><strong>not</strong></span> the name-value pairs (and
		you can always get the names from the unit objects themselves).
		</p><pre class="programlisting">$triead = $to-&gt;get();</pre><p>
		Get the public API of this Triead.
		</p><pre class="programlisting">$name = $to-&gt;getName();</pre><p>
		Get this Triead's name.
		</p><pre class="programlisting">$frag = $to-&gt;fragment();</pre><p>
		Get the name of this Triead's fragment (<span class="quote">&#8220;<span class="quote"></span>&#8221;</span> if not in a fragment).
		</p><pre class="programlisting">$to-&gt;markConstructed();</pre><a class="indexterm" name="id584264"></a><p>
		Advance the Triead to the Constructed state. After that point no more
		nexuses may be exported in the Triead. Any look-ups by other Trieads
		for the Nexuses of this Triead will proceed at this point, either
		succeeding or failing (if the requested nexus is not exported).
		</p><p>
		In all the <code class="computeroutput">mark*()</code> methods, the state advance is cumulative:
		it brings the thread through all the intermediate states.
		</p><p>
		If the Triead is already in the Constructed or later state, this call
		has no effect.
		</p><pre class="programlisting">$to-&gt;markReady();</pre><p>
		Advance the Triead to the Ready (fully initialized) state. After that
		point no more nexuses may be imported into this Triead.
		</p><p>
		In all the <code class="computeroutput">mark*()</code> methods, the state advance is cumulative:
		it brings the thread through all the intermediate states.
		</p><p>
		If the App has been already shut down, this Triead will be immediately
		requested to die.
		</p><p>
		If this is the last Triead in the App to become ready, this method will invoke the
		check for the topological correctness of the App. If the check finds an
		error (a loop of nexuses of the same direction), it will abort the App
		and confess with a message describing the nature of the error.
		</p><p>
		If the Triead is already in the Ready or later state, this call has no
		effect.
		</p><pre class="programlisting">$to-&gt;readyReady();</pre><p>
		Mark this Triead as Ready and wait for all the App's Trieads to become
		Ready. There is no method that just waits for readiness because that
		would be likely causing a deadlock. When the thread waits for
		readiness, it must be ready itself, so this call does both. All the
		error checks of <code class="computeroutput">markReady()</code> apply.
		</p><p>
		It is possible and reasonable to call this method repeatedly: more
		Trieads may be added to the App later, and it's a good idea to call
		<code class="computeroutput">readyReady()</code> again before communicating with these new threads.
		Otherwise any rowops sent before these threads become ready will never
		arrive to these threads.
		</p><pre class="programlisting">$to-&gt;markDead();</pre><p>
		Mark this Triead as Dead. A dead thread will not receive any more
		input, and any output from it will be thrown away. This notifies the
		harvester that it needs to join the Perl thread, so there should not be
		too much of a delay between making this call and exiting the Perl
		thread. The repeated calls have no effect.
		</p><p>
		Normally the <code class="computeroutput">Triead::start()</code> and <code class="computeroutput">startHere()</code> call <code class="computeroutput">markDead()</code>
		automatically in their wrapper logic, and there is no need for a manual
		call. However if you decide to bypass them, you must call <code class="computeroutput">markDead()</code>
		manually before exiting the thread, or the harvester will be stuck
		forever waiting for this thread to die.
		</p><p>
		In all the <code class="computeroutput">mark*()</code> methods, the state advance is cumulative:
		it brings the thread through all the intermediate states.
		But with <code class="computeroutput">markDead()</code> there is an even more interesting twist.
		Suppose there is an application with an incorrect topology, and all the
		Trieads in it but one are ready. That last Triead then experiences an
		error, and proceeds directly to call <code class="computeroutput">markDead()</code> and then exit. This
		<code class="computeroutput">markDead()</code> will involve an intermediate step marking the Triead as
		ready. Since it's the last Triead to be ready, it will trigger the
		topology check, and since the topology is incorrect, it will fail. If
		it happened in <code class="computeroutput">markReady()</code>, the method would confess. But in <code class="computeroutput">markDead()</code>
		confessing doesn't make a whole lot of sense: after all, the thread is
		about to exit anyway. So <code class="computeroutput">markDead()</code> will catch all these confessions
		and throw them away, it will never fail. However the failed check will
		still abort the App, and the rest of the threads will wake up and fail
		as usual.
		</p><p>
		<code class="computeroutput">markDead()</code> also clears and unreferences all
		the TrieadOwner's registered units, not waiting for the TrieadOwner
		object to be destroyed. This unravels any potential cyclic references
		where the code in a label might be referring back to the TrieadOwner.
		</p><pre class="programlisting">$to-&gt;abort($msg);</pre><p>
		Abort the App with a message. This is a convenience wrapper that
		translates to <code class="computeroutput">App::abortBy()</code>.
		</p><pre class="programlisting">$result = $to-&gt;isRqDead();</pre><p>
		Check whether the thread was requested to die. For most threads,
		<code class="computeroutput">mainLoop()</code> does this check automatically, and <code class="computeroutput">nextXtray()</code> also returns
		the same value. However in the special cases, such as doing some long
		processing in response to a rowop, or doing some timeouts, it's best to
		do a manual check of <code class="computeroutput">isRqDead()</code> periodically and abort the long
		operation if the thread has been requested to die, since any output
		will be thrown away anyway.
		</p><p>
		When a thread is requested to die, it gets immediately disconnected
		from the nexuses. It will not get any more input (though it might
		still go through the buffers in its input facets), and any output
		from it will be discarded.
		</p><p>
		Note that even when the Triead has been requested to die, it still must
		call <code class="computeroutput">markDead()</code> when it actually dies (normally the <code class="computeroutput">Triead::start()</code> or
		<code class="computeroutput">startHere()</code> takes care of it in its wrapper).
		</p><pre class="programlisting">$result = $to-&gt;isConstructed();
$result = $to-&gt;isReady();
$result = $to-&gt;isDead();
$result = $to-&gt;isInputOnly();</pre><p>
		Check the state of the Triead, the same as Triead methods.
		</p><pre class="programlisting">$facet = $to-&gt;makeNexus(@options);</pre><p>
		Create, export and (optionally) import a nexus. The result is an imported
		Facet of this Nexus, except when the options specify the no-import mode
		(then the result will be <code class="computeroutput">undef</code>). Confesses on errors.
		</p><p>
		The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">name =&gt; $name</code></span></dt><dd><p>
			Name of the nexus, it will be used both as the export name and the
			local imported <span class="quote">&#8220;<span class="quote">as-name</span>&#8221;</span> of the facet.
			</p></dd><dt><span class="term"><code class="computeroutput">labels =&gt; [ @definitions ]</code></span></dt><dd><p>
			Defines the labels similarly to FnReturn in a referenced array. The
			array contains the pairs of <code class="computeroutput">(label_name, label_definition)</code>,
			with definitions in one of two forms: 
			</p><pre class="programlisting">labels =&gt; [
  name1 =&gt; $rowType1,
  name2 =&gt; $fromLabel2,
  ...
]</pre><p>
			The definition may be either a RowType, and then a label of this row
			type will be created, or a Label, and then a label of the same row
			type will be created and chained from that original label. The
			created label objects can be later found from Facets, and used like
			normal labels, by chaining them or sending rowops to them
			(chaining from them is probably not the best idea, although it works
			anyway).
			</p><p>
			Optional, or may be an empty array; the implicit labels <code class="computeroutput">_BEGIN_</code> and
			<code class="computeroutput">_END_</code> will allways be added automatically if not explicitly
			defined.
			</p><p>
			The labels are used to construct an implicit FnReturn in the
			current Triead's main unit, and this is the FnReturn that will be
			visible in the Facet that gets imported back. If the import mode is
			<span class="quote">&#8220;<span class="quote">none</span>&#8221;</span>, the FnReturn will still be  constructed and then abandoned
			(and freed by the reference count going to 0, as usual). The labels
			used as <code class="computeroutput">$fromLabel</code> above must always belong to the Triead's main unit.
			</p></dd><dt><span class="term"><code class="computeroutput">rowTypes =&gt; [ @definitions ]</code></span></dt><dd><p>
			Defines the row types exported in this Nexus as a referenced array
			of name-value pairs:
			</p><pre class="programlisting">rowTypes =&gt; [
  name =&gt; $rowType,
  ...
]</pre><p>
			The types imported back into this Triead's
			facet will be references to the exact same type objects. Optional,
			or may be empty.
			</p></dd><dt><span class="term"><code class="computeroutput">tableTypes =&gt; [ @definitions ]</code></span></dt><dd><p>
			Defines the table types exported in this Nexus as a referenced
			array of name-value pairs:
			</p><pre class="programlisting">tableTypes =&gt; [
  name =&gt; $tableType,
  ...
]</pre><p>
			The types imported back into this
			Triead's facet will be references to the exact same type objects.
			Optional, or may be empty.
			</p></dd><dt><span class="term"><code class="computeroutput">reverse =&gt; 0/1</code></span></dt><dd><p>
			Flag: this Nexus goes in the reverse direction. The reverse nexuses
			are used to break up the topological loops, to prevent the
			deadlocks on the queueing. They have no limit on the queue size,
			and the data is read from them at a higher priority than from the
			direct nexuses. Default: 0.
			</p></dd><dt><span class="term"><code class="computeroutput">chainFront =&gt; 0/1</code></span></dt><dd><p>
			Flag: when the labels are specified as <code class="computeroutput">$fromLabel</code>, chain them at
			the front of the original labels.  Default: 1. 
			</p><p>
			The default is this
			way because chaining at the front is what is typically needed. The
			reasons are described at length in 
			<a class="xref" href="#sc_mt_pipeline" title="16.3. Multithreaded pipeline">Section 16.3: &#8220;Multithreaded pipeline&#8221; </a>,
			but the short gist is that you might want to send the rows from both the
			inputs, intermediate points, and the end of processing into an
			output nexus. It's most convenient to create the nexus in one go,
			after the whole thread's computation is defined. But the rowops
			from the earlier stages of computations have to come to the nexus
			before the rowops from the later stage. Chaining at the front
			ensures that each such label will send the rowop into the nexus
			first, and only then to the next stage of the computation.
			</p></dd><dt><span class="term"><code class="computeroutput">queueLimit =&gt; $number</code></span></dt><dd><p>
			Defines the size limit after which the writes to the queue of this
			Nexus block. In reality because of the double-buffering the queue
			may contain up to twice that many trays before the future writes
			block. This option has no effect on the  reverse nexuses. Default:
			<code class="computeroutput">&amp;Facet::DEFAULT_QUEUE_LIMIT</code>, 500 or so.
			</p></dd><dt><span class="term"><code class="computeroutput">import =&gt; $importType</code></span></dt><dd><p>
			A string value, essentially an enum, determining how this Nexus gets
			immediately imported back into this Triead. The supported values are:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">reader</code> (or anything starting from <span class="quote">&#8220;<span class="quote">read</span>&#8221;</span>) - import for reading
				</li><li class="listitem"><code class="computeroutput">writer</code> (or anything starting from <span class="quote">&#8220;<span class="quote">write</span>&#8221;</span>) - import for writing
				</li><li class="listitem"><code class="computeroutput">none</code> (or anything starting from <span class="quote">&#8220;<span class="quote">no</span>&#8221;</span>) - do not import
				</li></ul></div><p>
			Case-insensitive. The use of the canonical strings is recommended.
			</p></dd></dl></div><pre class="programlisting">$facet = $to-&gt;importNexus(@options);</pre><p>
		Import a nexus into this Triead. Returns the imported Facet. The
		repeated attempts to import the same Nexus will return references to
		the same Facet object. Confesses on errors. An attempt to import the
		same nexus for both reading and writing is an error.
		</p><p>
		The options are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">from =&gt; "$thread_name/$nexus_name"</code></span></dt><dd><p>
			Identifier of the nexus to import, consisting of two parts
			separated by a slash.
			</p><p>
			The nexus name will also be used as the name of the local facet,
			unless overridden by the option <span class="quote">&#8220;<span class="quote">as</span>&#8221;</span>. The reason for slash
			separator is that normally both the thread name and the nexus name
			parts may contain further components separated by dots, and a
			different separator allows to find the boundary between them. If a
			dot were used, in <span class="quote">&#8220;<span class="quote">a.b.c</span>&#8221;</span> it would be impossible to say, does it
			mean the thread <span class="quote">&#8220;<span class="quote">a</span>&#8221;</span> and nexus <span class="quote">&#8220;<span class="quote">b.c</span>&#8221;</span> in it, or thread <span class="quote">&#8220;<span class="quote">a.b</span>&#8221;</span> and
			nexus <span class="quote">&#8220;<span class="quote">c</span>&#8221;</span>? However <span class="quote">&#8220;<span class="quote">a/b.c</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">a.b/c</span>&#8221;</span> have no such ambiguity.
			Mutually exclusive with options <span class="quote">&#8220;<span class="quote">fromTriead</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">fromNexus</span>&#8221;</span>.
			</p></dd><dt><span class="term"><code class="computeroutput">fromTriead =&gt; $t</code></span></dt><dd></dd><dt><span class="term"><code class="computeroutput">fromNexus =&gt; $n</code></span></dt><dd><p>
			The alternative way to specify the source thread and nexus as
			separate options. Both options must be present or absent at the
			same time. Mutually exclusive with <span class="quote">&#8220;<span class="quote">from</span>&#8221;</span>.
			</p></dd><dt><span class="term"><code class="computeroutput">as =&gt; $name</code></span></dt><dd><p>
			Specifies an override name for the local facet (and thus also for
			the FnReturn created in the facet). Logically similar to the SQL
			clause <span class="emphasis"><em>AS</em></span>. Default is to reuse the nexus name.
			</p></dd><dt><span class="term"><code class="computeroutput">import =&gt; $importType</code></span></dt><dd><p>
			A string value, essentially an enum, determining how this Nexus
			gets imported. The supported values are the same as for <code class="computeroutput">makeNexus()</code>,
			except <span class="quote">&#8220;<span class="quote">none</span>&#8221;</span>, since there is no point in a no-op import:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">reader</code> (or anything starting from <span class="quote">&#8220;<span class="quote">read</span>&#8221;</span>) - import for reading;
				</li><li class="listitem"><code class="computeroutput">writer</code> (or anything starting from <span class="quote">&#8220;<span class="quote">write</span>&#8221;</span>) - import for writing.
				</li></ul></div><p>
			Case-insensitive. The use of the canonical strings is recommended.
			</p></dd><dt><span class="term"><code class="computeroutput">immed =&gt; 0/1</code></span></dt><dd><p>
			Flag: do not wait for the thread that exported the nexus to be
			fully constructed. Waiting synchronizes with the exporter and
			prevents a race of an import attempt trying to find a nexus before
			it is made and failing. However if two threads are waiting for each
			other, it becomes a deadlock that gets caught and aborts the App.
			The immediate import allows to avoid such deadlocks for the
			circular topologies with helper threads.
			</p><p>
			The helper threads are the <span class="quote">&#8220;<span class="quote">blind alleys</span>&#8221;</span> in the topology: the
			<span class="quote">&#8220;<span class="quote">main thread</span>&#8221;</span> outsources some computation to a <span class="quote">&#8220;<span class="quote">helper thread</span>&#8221;</span>,
			sending it the arguments, then later receiving the results and
			continuing with its logic.
			</p><p>
			With the helper threads, the parent thread will import the
			resul nexus of the helper as usual but the helper will
			import the argument nexus from the parent immediately.
			This can be done because the parent is required in this
			situation to export the argument nexus first and only then
			create the helper thread.
			</p><p>
			The sequence in
			<a class="xref" href="#seq784immed" title="Figure 19.1. The use of immediate import.">Figure 19.1</a>
			shows it in detail.
			</p><div class="figure"><a name="seq784immed"></a><div class="figure-contents"><div class="informaltable"><table cellspacing="0" cellpadding="0" border="0"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><tbody><tr><td colspan="4" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread A creates the nexus O;</li></ul></div>
  </td></tr><tr><td colspan="4" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread A creates the helper thread B and tells it to import the nexus A/O for its input immediately and create the reverse nexus R for result;</li></ul></div>
  </td></tr><tr><td colspan="4" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread A requests a (normal) import of the nexus B/R and falls asleep because B is not constructed yet;</li></ul></div>
  </td></tr><tr><td align="left">&#8195;</td><td colspan="3" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread B starts running;</li></ul></div>
  </td></tr><tr><td align="left">&#8195;</td><td colspan="3" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread B imports the nexus A/O immediately and succeeds;</li></ul></div>
  </td></tr><tr><td align="left">&#8195;</td><td colspan="3" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread B defines its result nexus R;</li></ul></div>
  </td></tr><tr><td align="left">&#8195;</td><td colspan="3" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread B marks itself as constructed and ready;</li></ul></div>
  </td></tr><tr><td colspan="4" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread A wakes up after B is constructed, finds the nexus B/R and completes its import;</li></ul></div>
  </td></tr><tr><td colspan="4" align="left">
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Thread A can then complete its initialization, export other nexuses etc;</li></ul></div>
  </td></tr></tbody></table></div></div><p class="title"><b>Figure 19.1. The use of immediate import.</b></p></div><br class="figure-break"><p>
			Default: 0, except if importing a nexus that has been exported from
			the same Triead. Importing from the same Triead is not used often,
			since the export also imports the nexus back right away, and there
			is rarely any use in importing separately. But it's possible, and
			importing back from the same Triead is always treated as immediate
			to avoid deadlocks. 
			</p></dd></dl></div><pre class="programlisting">@exports = $to-&gt;exports();</pre><p>
		The same as the method on the Triead, equivalent to
		<code class="computeroutput">$to-&gt;get()-&gt;exports()</code>. The returned array contains the name-value pairs
		of the nexus names and objects.
		</p><pre class="programlisting">@imports = $to-&gt;imports();</pre><p>
		This method is different from the Triead method. It still returns an
		array of name-value pairs but the values are Facets (not Nexuses, as in
		Triead). It's a natural difference, since the facets are useful in the
		owner thread, and available only in it.
		</p><pre class="programlisting">$result = $to-&gt;flushWriters();</pre><p>
		Flush any data collected in the writer facets, sending them to the
		appropriate nexuses. The data in each facet becomes a tray that is sent
		to the nexus (if there was no data collected on a facet, nothing will
		be sent from it). Returns 1 if the flush was completed, 0 if the thread
		was requested to die and thus the data was discarded. The data is never
		sent out of a facet by itself, it always must be flushed in one of the
		explicit ways (<code class="computeroutput">TrieadOwner::flushWriters()</code>, <code class="computeroutput">Facet::flushWriter()</code>, or
		enqueueing a rowop on the facet's labels <code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code>). The flush
		may get stuck if this is an input-only thread and a drain is active, it
		will wait until the drain is released.
		</p><pre class="programlisting">$to-&gt;requestMyselfDead();</pre><p>
		Request this Triead itself to die. This is the way to disconnect from
		the nexuses while the thread is exiting on its own. For example, if
		this thread is going to dump its data before exit to a large file that
		takes half an hour to write, normally the data queued for this thread
		might fill up the queues in the nexuses, and it's a bad practice to
		keep the other threads stuck due to the overflowing buffers. Requesting
		this thread to die disconnects it from the nexuses and prevents the
		data from collecting. The thread could also be disconnected by marking
		it dead, but that would keep the harvester stuck waiting to join it while
		the thread completes its long write, and that's not so good either.
		This call provides the solution, avoiding both pitfalls.
		</p><pre class="programlisting">$result = $to-&gt;nextXtray();</pre><a class="indexterm" name="id579584"></a><p>
		Process one incoming tray from a single reader nexus (any nexus where
		data is available, respecting the priorities). A tray essentially embodies a transaction, and <span class="quote">&#8220;<span class="quote">X</span>&#8221;</span>
		stands for <span class="quote">&#8220;<span class="quote">cross-thread</span>&#8221;</span>. There actually is the Xtray type that
		represents the Tray in a special thread-safe format but it's used only
		inside the nexuses and not visible from outside.
		</p><p>
		If there is currently no data to process, this method will wait.
		</p><p>
		The return value is 1 normally, or 0 if the thread was requested to
		die. So the typical usage is:
		</p><pre class="programlisting">while($to-&gt;nextXtray()) { ... }</pre><p>
		The method <code class="computeroutput">mainLoop()</code> encapsulates the most typical usage, and
		<code class="computeroutput">nextXtray()</code> needs to be used directly only in the more unusual
		circumstances.
		</p><p>
		The data is read from the reverse nexuses first, at a higher priority.
		If any reverse nexus has data available, it will always be read before
		the direct nexuses. A reverse nexus typically completes a topological
		loop, so this priority creates the preference to cycle the data through
		the loop until it comes out, before accepting more data into the loop.
		Since all the nexuses have non-zero-length queues, obviously, there
		will be multiple data items traveling through the loop, in different
		phases, but this priority solution limits the amount of data kept in
		the loop's queues and allows the queue flow control to prevent too much
		data from entering the loop.
		</p><p>
		The raised priority of the reverse nexuses can also be used to deliver
		the urgent messages. Remember, there is nothing preventing you from
		marking any nexus as reverse (as long as it doesn't create a loop
		consisting of only the reverse nexuses).
		</p><p>
		The downside of having the reverse nexuses connected to a thread is
		that it causes an extra overhead from the check with a mutex
		synchronization on each <code class="computeroutput">nextXtray()</code>. The regular-priority direct
		nexuses use double-buffering, with locking a mutex only when the second
		buffer runs dry, and refilling it by swapping its contents with the
		whole collected first buffer. But the high-priority reverse nexuses
		have to be checked every time, even if they have no incoming data.
		</p><p>
		Within the same priority the data is processed in the round-robin
		order. More exactly, each refill of the double-buffering grabs the data
		from the first buffer of each facet and moves it to the second buffer.
		Then the second buffer is processed in the round-robin fashion until it
		runs out and another refill becomes needed.
		</p><p>
		The <code class="computeroutput">nextXtray()</code> processes all the rowops from the incoming tray by
		calling them on the facet's FnReturn. Two special rowops are generated
		automatically even if they haven't been queued up explicitly, on the
		facet's labels <code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code> (to avoid extra overhead, they are
		actually generated only if there is any processing chained for them).
		</p><p>
		The <code class="computeroutput">nextXtray()</code> automatically flushes the writers after processing a
		tray.
		</p><p>
		If a fatal error is encountered during processing (such as some code in
		a label dies), <code class="computeroutput">nextXtray()</code> will catch the exception, discard the rest
		of the tray and confess itself, without flushing the writers.
		</p><pre class="programlisting">$result = $to-&gt;nextXtrayNoWait();</pre><p>
		Similar to <code class="computeroutput">nextXtray()</code>, but returns immediately if there is no data to
		process. Returns 0 if there is either no input data or the thread was
		requested to die (the way to differentiate between these cases is to
		call <code class="computeroutput">$to-&gt;isRqDead()</code>).
		</p><pre class="programlisting">$result = $to-&gt;nextXtrayTimeout($timeout);</pre><p>
		Similar to <code class="computeroutput">nextXtrayNoWait()</code>, only if there is no data, waits for up to
		the length of timeout. The timeout value is floating-point seconds.
		Returns 0 if the timeout has expired or the thread was requested to
		die.
		</p><pre class="programlisting">$result = $to-&gt;nextXtrayTimeLimit($deadline);</pre><a class="indexterm" name="id580496"></a><p>
		Similar to <code class="computeroutput">nextXtrayNoWait()</code>, only if there is no data, waits until the
		absolute deadline. The deadline value is time since epoch in
		floating-point seconds, such as returned by <code class="computeroutput">Triceps::now()</code>. Returns 0
		if the wait reached the deadline or the thread was requested to die.
		</p><pre class="programlisting">$to-&gt;mainLoop();</pre><p>
		Process the incoming trays until the thread is requested to die. The
		exact implementation of the main loop (in C++) is:
		</p><pre class="programlisting">void TrieadOwner::mainLoop()
{
  while (nextXtray())
    { }
}</pre></div><div class="sect2" title="19.22.3. TrieadOwner drains"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_triead_owner_drains"></a>19.22.3. TrieadOwner drains</h3></div></div></div><p>
		The drain API of the TrieadOwner is very similar to the one in the App.
		The best way to do the drain is by the automatically-scoped AutoDrain
		class. If a drain doesn't need an automatic scoping, use the
		TrieadOwner API. And finally if you want to mess with drains from
		outside an App's Triead and thus don't have a TrieadOwner, only then
		use the App API.
		</p><pre class="programlisting">$to-&gt;requestDrainShared();
$to-&gt;requestDrainExclusive();
$to-&gt;waitDrain();
$to-&gt;drainShared();
$to-&gt;drainExclusive();
$to-&gt;undrain();
$result = $to-&gt;isDrained();</pre><p>
		The methods are used in exactly the same way as the similar App
		methods, with only the difference of the names on the shared drains.
		</p><p>
		The exclusive drains always make the exclusion for this Triead. (Only
		one thread can be excluded from a drain). Normally the exclusive drains
		should be used only for the input-only threads. They could potentially
		be used to exclude a non-input-only thread too but I'm not sure,
		what's the point, and haven't worked out if it would work reliably (it
		might, or it might not).
		</p><pre class="programlisting">$result = $to-&gt;isRqDrain();</pre><p>
		Check whether a drain request is active. This can be used in the
		threads that generate data based on the real-time clock yet aren't
		input-only: if they find that a drain is active, they should refrain
		from generating the data and go back to the waiting. There is no way
		for them to find when the drain is released, so they should just
		continue to the next timeout as usual. Such code must use
		<code class="computeroutput">nextXtrayTimeout()</code> or <code class="computeroutput">nextXtrayTimeLimit()</code> for the timeouts, or the
		drain would never complete. These two methods know how to handle
		the timeouts and also how to properly interact with the drains
		without causing the race conditions.
		The input-only threads don't have this
		limitation. And of course keep in mind that the better practice is to
		deal with the real time either in the input-only threads or by driving
		it from outside the model altogether.
		</p></div><div class="sect2" title="19.22.4. TrieadOwner file interrruption"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_triead_owner_interrupt"></a>19.22.4. TrieadOwner file interrruption</h3></div></div></div><p>
		The file interruption part of the API deals with how the thread handles
		a request to die. It should stop its work and exit, and for the normal
		threads that read from nexuses, this is fairly straightforward. The
		difficulty is with the threads that read from the outside sources
		(sockets and such). They may be in the middle of a read call, with no
		way to tell when the next chunk of data will arrive. These long calls
		on the file descriptors need to be interrupted when the thread is
		requested to die.
		</p><p>
		The interruption is done by revoking the file descriptors (dupping a
		<code class="computeroutput">/dev/null</code> into it) and sending the signal <code class="computeroutput">SIGUSR2</code> to the thread. Even
		if the dupping doesn't interrupt the file operation, <code class="computeroutput">SIGUSR2</code> does, and
		on restart it will find that the file descriptor now refers to
		<code class="computeroutput">/dev/null</code> and return immediately. Triceps defines a <code class="computeroutput">SIGUSR2</code> handler
		that does nothing, but you can override it with a custom one.
		</p><p>
		For this to work, Triceps needs to know, which file descriptors are to
		be revoked, which is achieved by registering them for tracking in the
		TrieadOwner. To avoid accidentally revoking the unrelated descriptors, the descriptors must be
		unregistered before closing. The normal sequence is:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			open a file descriptor;
			</li><li class="listitem">
			register it for tracking;
			</li><li class="listitem">
			do the file operations;
			</li><li class="listitem">
			unregister the file descriptor;
			</li><li class="listitem">
			close it.
			</li></ul></div><p>
		The lowest-level calls deal with the raw tracking:
		</p><pre class="programlisting">$to-&gt;trackFd($fd);</pre><p>
		Register the file descriptor (obtained with <code class="computeroutput">fileno()</code> or such) for
		tracking. The repeated calls for the same descriptor have no effect.
		</p><pre class="programlisting">$to-&gt;forgetFd($fd);</pre><p>
		Unregister the file descriptor. If the descriptor is not registered,
		the call is ignored.
		</p><p>
		The next level of the API deals with the file handles, extracting the
		file descriptors from them as needed.
		</p><pre class="programlisting">$to-&gt;track(FILE);</pre><p>
		Get a file descriptor from the file handle and track it.
		</p><pre class="programlisting">$to-&gt;forget(FILE);</pre><p>
		Get a file descriptor from the file handle and unregister it.
		</p><pre class="programlisting">$to-&gt;close(FILE);</pre><p>
		Unegister the file handle's descriptor then close the file handle. It's
		a convenience wrapper, to make the unregistering easier to remember.
		</p><p>
		The correct sequence might be hard to follow if the code involves some
		dying and evals catching these deaths. To handle that, the next level
		of the API provides the automatic tracking by scope. The scoping is
		done with the class Triceps::TrackedFile. Which is probably easier to
		describe right here.
		</p></div><div class="sect2" title="19.22.5. TrackedFile"><div class="titlepage"><div><div><h3 class="title"><a name="sc_ref_triead_owner_tracked_file"></a>19.22.5. TrackedFile</h3></div></div></div><a class="indexterm" name="id581125"></a><p>
		A TrackedFile object keeps a reference of a file handle and also knows
		of its file descriptor being tracked by the TrieadOwner (so yes, it has
		a reference to the TrieadOwner too). Until the TrackedFile is
		destroyed, the file handle in it will never have its reference count go
		to 0, so it will never be automatically closed and destroyed. And when
		the TrackedFile is destroyed, first it tells the TrieadOwner to forget
		the file descriptor and only then unreferences the file handle,
		preserving the correct sequence.
		</p><p>
		And the scope of the TrackedFile is controlled by the scope of a
		variable that keeps a reference to it. If it's a local/my variable,
		TrackedFile will be destroyed on leaving the block, if it's a field in
		an object, it will be destroyed when the object is destroyed or the
		field is reset. Basically, the usual Perl scope business in Triceps.
		</p><p>
		If you want to close the file handle before leaving the scope of
		TrackedFile, don't call <code class="computeroutput">close()</code> on the file handle. Instead, call <code class="computeroutput">close()</code>
		on the TrackedFile:
		</p><pre class="programlisting">$trf-&gt;close();</pre><p>
		This will again properly untrack the file descriptor, and then close
		the file handle, and remember that it has been closed, so no seconds
		attempt at that will be done when the TrackedFile gets destroyed.
		</p><p>
		There also are a couple of getter methods on the TrackedFile:
		</p><pre class="programlisting">$fd = $trf-&gt;fd();</pre><p>
		Get the tracked file descriptor. If the file handle has been already
		closed, will return -1.
		</p><pre class="programlisting">$fh = $trf-&gt;get();</pre><p>
		Get the tracked file handle. If the file handle had already been
		closed, will confess.
		</p><p>
		Now we get back to the TrieadOwner.
		</p><pre class="programlisting">$trf = $to-&gt;makeTrackedFile(FILE);</pre><p>
		Create a TrackedFile object from a file handle.
		</p><pre class="programlisting">$trf = $to-&gt;makeTrackedFileFd(FILE, $fd);</pre><p>
		The more low-level way to construct a TrackedFile, with specifying the
		file descriptor as a separate explicit argument. <code class="computeroutput">makeTrackedFile()</code> is
		pretty much a wrapper that calls <code class="computeroutput">fileno()</code> on the file handle and then
		calls <code class="computeroutput">makeTrackedFileFd()</code>.
		</p><p>
		And the following methods combine the loading of a file descriptor from
		the App and tracking it by the TrieadOwner. They are the most typically
		used interface for passing around the file handles through the App.
		</p><pre class="programlisting">($trf, $file) = $to-&gt;trackDupFile($name, $mode);</pre><p>
		Load the dupped file handle from the App, create a file handle
		object from it according to the IO::Handle subclass received from
		the App and <code class="computeroutput">$mode</code> (in either <code class="computeroutput">r/w/a/r+/w+/a+</code> or
		<code class="computeroutput">&lt;/&gt;/&gt;&gt;/+&lt;/+&gt;/+&gt;&gt;</code> format), and make a TrackedFile from it. Returns a
		pair of the TrackedFile object and the created file handle. The App
		still keeps the original file descriptor. The <code class="computeroutput">$mode</code> must be consistent
		with the original mode of the file stored into the App. <code class="computeroutput">$name</code> is the
		name that was used to store the file descriptor into the App.
		</p><pre class="programlisting">($trf, $file) = $to-&gt;trackGetFile($name, $mode);</pre><p>
		Similar to <code class="computeroutput">trackDupFile()</code> only the file descriptor is moved from the
		App, and the App forgets about it.
		</p><pre class="programlisting">($trf, $file) = $to-&gt;trackDupClass($name, $mode, $class);
($trf, $file) = $to-&gt;trackGetClass($name, $mode, $class);</pre><p>
		Similar to the File versions, only creates the file handle of an
		explicitly specified subclass of IO::Handle (per <code class="computeroutput">$class</code>).
		</p></div></div><div class="sect1" title="19.23. Nexus reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_nexus"></a>19.23. Nexus reference</h2></div></div></div><a class="indexterm" name="id582526"></a><p>
		The Nexus class is pretty much opaque. It's created and managed
		entirely inside the App infrastructure from a Facet, and even the
		public API for importing a nexus doesn't deal with the Nexus object
		itself, but only with its name. The only public use of the Nexus object
		is for the introspection and entertainment value, to see what Trieads
		export and import what Nexuses: pretty much the only way to get a Nexus
		reference is by listing the exports or imports of a Triead.
		</p><p>
		The API of a Nexus is very limited:
		</p><pre class="programlisting">$nxname = $nx-&gt;getName();</pre><p>
		Get the name of the nexus (the short name, inside the Triead).
		</p><pre class="programlisting">$tname = $nx-&gt;getTrieadName();</pre><p>
		Get the name of the Triead that exported this nexus.
		</p><pre class="programlisting">$result = $nx-&gt;same($nx2);</pre><p>
		Check whether two nexus references point to the same object.
		</p><pre class="programlisting">$result = $nx-&gt;isReverse();</pre><p>
		Check whether the nexus is reverse.
		</p><pre class="programlisting">$limit = $nx-&gt;queueLimit();</pre><p>
		Get the queue limit of the nexus.
		</p></div><div class="sect1" title="19.24. Facet reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_facet"></a>19.24. Facet reference</h2></div></div></div><a class="indexterm" name="id542971"></a><p>
		A Facet represents a Nexus endpoint imported into a Triead. A facet is
		either a reader (reading from the nexus) or a writer (writing into the
		nexus).
		</p><p>
		In the Perl API the Facets are created by <code class="computeroutput">TrieadOwner::makeNexus()</code> or
		<code class="computeroutput">TrieadOwner::importNexus()</code>. After that the metadata in the Facet is
		fixed and is available for reading only. Of course, the rowops can then
		be read or written.
		</p><p>
		The reading of data from a Facet is done by <code class="computeroutput">TrieadOwner::nextXtray()</code>.
		There is no way to read a tray from a particular facet, <code class="computeroutput">nextXtray()</code>
		reads from all the Triead's imported reader facets, alternating in a
		fair fashion if more than one of them has data available.
		</p><p>
		Each Facet has an FnReturn connected to it. The reading from a reader
		facet happens by forwarding the incoming rowops to that FnReturn. To
		actually process the data, you can either chain your handler labels
		directly to the FnReturn labels, or push an FnBinding onto that
		FnReturn. An incoming Xtray is always processed as a unit, with no
		intermixing with the other Xtrays.
		</p><a class="indexterm" name="id553539"></a><p>
		The writing to a writer facet happens by calling the labels of its
		FnReturn. Which then has the logic that collects all these rowops into
		a buffer. Then when the facet is flushed, that buffer becomes an
		indivisible Xtray that gets sent to the nexus as a unit, and then read
		by the reader facets as a unit.
		</p><p>
		The facet metadata consists of:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			a set of labels, same as for an FnReturn, used to build the facet's
			internal FnReturn; these labels define the data that can be carried
			through the nexus;
			</li><li class="listitem">
			a set of row types that gets exported through the nexus;
			</li><li class="listitem">
			a set of table types that gets exported through the nexus.
			</li></ul></div><p>
		The table types must not contain any references to the Perl functions,
		or the export will fail. The Perl code snippets in the text format can
		be used instead.
		</p><p>
		There are two special labels, named <code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code>. They may be
		defined explicitly, but if they aren't, they will be always added
		implicitly, with an empty row type (i.e. a row type with no fields).
		</p><p>
		When reading an Xtray, the <code class="computeroutput">_BEGIN_</code> label will always be called first,
		and <code class="computeroutput">_END_</code> last, thus framing the rest of the data. There are
		optimizations that skip the calling if there is nothing chained to
		these labels in FnReturn nor to the top FnBinding, and the rowop as
		such carries no extra data. The optimization is actually a bit deeper:
		the <code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code> rowops that have no extra data in them aren't
		even carried in the Xtray through the nexus. They are generated on the
		fly if there is an interest in them, or otherwise the generation is
		skipped.
		</p><p>
		What is meant by the <span class="quote">&#8220;<span class="quote">extra data</span>&#8221;</span>? It means, either the opcode is not
		<code class="computeroutput">OP_INSERT</code> or there are some non-NULL fields (or both). If the <code class="computeroutput">_BEGIN_</code>
		and <code class="computeroutput">_END_</code> labels were auto-generated, their row type will contain no
		fields, so the only way to send the non-default data in them will be
		the non-default opcode. But if you define them explicitly with a
		different row type, you can also send the data in them.
		</p><p>
		When sending the data into a writer Facet, you don't have to send the
		<code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code> rowops, if you don't, they will be generated
		automatically as needed, with the default contents (opcode <code class="computeroutput">OP_INSERT</code>
		and NULLs in all the fields). Moreover, they will really be generated
		automatically on the reader side, thus saving the overhead of passing
		them through the nexus. Another consequence of this optimization is
		that it's impossible to create an Xtray consisting of only a default
		<code class="computeroutput">_BEGIN_</code>, a default <code class="computeroutput">_END_</code> and no payload rowops between them. It would
		be an empty Xtray, that would never be sent through the nexus. Even if
		you create these <code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code> rowops manually (but with the
		default contents), they will be thrown away when they reach the writer
		facet. If you want an Xtray to get through, you've got to either send
		the payload or put something non-default into at least one of the
		<code class="computeroutput">_BEGIN_</code> or <code class="computeroutput">_END_</code> rowops, at the very minimum a different opcode.
		</p><p>
		Sending the <code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code> rowops into a writer facet also has the
		effect of flushing it. Even if these rowops have the default contents
		and become thrown away by the facet, the flushing effect still works.
		The <code class="computeroutput">_BEGIN_</code> rowop flushes any data that has been collected in the
		buffer before it. The <code class="computeroutput">_END_</code> rowop gets added to the buffer (or might
		get thrown away) and then flushes the buffer. If the buffer happens to
		contain anything at the flush time, that contents forms an Xtray and
		gets forwarded to the nexus.
		</p><p>
		It's a long and winding explanation, but really it just does what is
		intuitively expected.
		</p><p>
		A Facet has two names, the <span class="emphasis"><em>full</em></span> one and the <span class="emphasis"><em>short</em></span> one:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			The full name is copied from the nexus and consists of the name of
			the thread that exported the nexus and the name of the nexus itself
			separated by a slash, such as <span class="quote">&#8220;<span class="quote">t1/nx1</span>&#8221;</span>.
			</li><li class="listitem">
			The short name is the name with which the facet was imported. By
			default it's taken from the short name of the nexus. But it can
			also be given a different explicit name during the import, which is
			known as the <span class="quote">&#8220;<span class="quote">as-name</span>&#8221;</span> (because it's similar to the SQL <span class="emphasis"><em>AS</em></span>
			clause). So if the full name is <span class="quote">&#8220;<span class="quote">t1/nx1</span>&#8221;</span>, the default short name
			will be <span class="quote">&#8220;<span class="quote">nx1</span>&#8221;</span>, but it can be overridden. The facet's FnReturn is
			named with the facet's short name.
			</li></ul></div><p>
		A Facet object is returned from either a nexus creation or nexus
		import. Then the owner thread can work with it.
		</p><pre class="programlisting">$result = $fa-&gt;same($fa2);</pre><p>
		Check whether two references point to the same Facet object.
		</p><pre class="programlisting">$name = $fa-&gt;getShortName();</pre><p>
		Get the short name of the facet (AKA <span class="quote">&#8220;<span class="quote">as-name</span>&#8221;</span>, with which it has been
		imported).
		</p><pre class="programlisting">$name = $fa-&gt;getFullName();</pre><p>
		Get the full name of the nexus represented by this facet. The name
		consists of two parts separated by a slash, <span class="quote">&#8220;<span class="quote"><code class="computeroutput">$thread/$nexus</code></span>&#8221;</span>.
		</p><pre class="programlisting">$result = $fa-&gt;isWriter();</pre><p>
		Check whether this is a writer facet (i.e. writes to the nexus). Each
		facet is either a writer or a reader, so if this method returns 0, it
		means that this is a reader facet.
		</p><pre class="programlisting">$result = $fa-&gt;isReverse();</pre><p>
		Check whether this facet represents a reverse nexus.
		</p><pre class="programlisting">$limit = $fa-&gt;queueLimit();</pre><p>
		Get the queue size limit of the facet's nexus. 
		For a reverse nexus the returned
		value will be a large integer (currently <code class="computeroutput">INT32_MAX</code> but the exact value
		might change in the future). And if some different limit value was
		specified during the creation of the reverse nexus, it will be ignored.
		</p><pre class="programlisting">$limit = &amp;Triceps::Facet::DEFAULT_QUEUE_LIMIT;</pre><p>
		The constant of the default queue size limit that is used for the nexus
		creation, unless explicitly overridden.
		</p><pre class="programlisting">$fret = $fa-&gt;getFnReturn();</pre><p>
		Get the FnReturn object of this facet. This FnReturn will have the same
		name as the facet's short name, and it has a special symbiotic relation
		with the Facet object. Its use depends on whether this is a reader or
		writer facet. For a writer facet, sending rowops to the labels in
		FnReturn (directly or by chaining them off the other labels) causes
		these rowops to be buffered for sending into the nexus. For a reader
		facet, you can either chain your logic directly off the FnReturn's
		labels, or push an FnBinding onto it as usual.
		</p><pre class="programlisting">$nexus = $fa-&gt;nexus();</pre><p>
		Get the facet's nexus. There is not a whole lot that can be done with
		the nexus object, just getting the introspection information, and the same
		information can be obtained directly with the facet's methods.
		</p><pre class="programlisting">$idx = $fa-&gt;beginIdx();</pre><p>
		Index (as in <span class="quote">&#8220;<span class="quote">integer offset</span>&#8221;</span>, not a table index) of the <code class="computeroutput">_BEGIN_</code> label
		in the FnReturn's set of labels. There probably isn't much use for this
		method, and its name is somewhat confusing.
		</p><pre class="programlisting">$idx = $fa-&gt;endIdx();</pre><p>
		Index (as in <span class="quote">&#8220;<span class="quote">integer offset</span>&#8221;</span>, not a table index) of the <code class="computeroutput">_END_</code> label in
		the FnReturn's set of labels. There probably isn't much use for this
		method, and its name is somewhat confusing.
		</p><pre class="programlisting">$label = $fa-&gt;getLabel($labelName);</pre><p>
		Get a label from FnReturn by name. This is a convenience method,
		equivalent to <code class="computeroutput">$fa-&gt;getFnReturn()-&gt;getLabel($labelName)</code>. Confesses if
		the label with this name is not found.
		</p><pre class="programlisting">@rowTypes = $fa-&gt;impRowTypesHash();</pre><p>
		Get (<span class="quote">&#8220;<span class="quote">import</span>&#8221;</span>) the whole set of row types exported through the nexus.
		The result is an array containing the name-value pairs, values being
		the imported row types. This array can be assigned into a hash to
		populate it. As it happens, the pairs will be ordered by name in the
		ASCII alphabetical order but there are no future guarantees about it.
		</p><p>
		The actual import of the types is done only once, when the nexus is
		imported to create the facet, and the repeated calls of the <code class="computeroutput">imp*</code>
		methods will return the same objects.
		</p><pre class="programlisting">$rt = $fa-&gt;impRowType($rtName);</pre><p>
		Get (<span class="quote">&#8220;<span class="quote">import</span>&#8221;</span>) one row type by name. If the name is not known, will
		confess.
		</p><pre class="programlisting">@tableTypes = $fa-&gt;impTableTypesHash();</pre><p>
		Get (<span class="quote">&#8220;<span class="quote">import</span>&#8221;</span>) the whole set of table types exported through the nexus.
		The result is an array containing the name-value pairs, values being
		the imported table types. This array can be assigned into a hash to
		populate it. As it happens, the pairs will be ordered by name in the
		ASCII alphabetical order but there are no future guarantees about it.
		</p><p>
		The actual import of the types is done only once, when the nexus is
		imported to create the facet, and the repeated calls of the <code class="computeroutput">imp*</code>
		methods will return the same objects.
		</p><pre class="programlisting">$tt = $fa-&gt;impTableType($ttName);</pre><p>
		Get (<span class="quote">&#8220;<span class="quote">import</span>&#8221;</span>) one table type by name. If the name is not known, will
		confess.
		</p><pre class="programlisting">$result = $fa-&gt; flushWriter();</pre><p>
		Flush the collected buffered rowops to the nexus as a single Xtray. If
		there are no collected rowops, does nothing. Returns 1 if the flush
		succeeded (even if there was no data to send), 0 if this thread was
		requested to die and thus all the collected data gets thrown away, same
		as for the <code class="computeroutput">TrieadOwner::flushWriters()</code>. The rules for when this method
		may be called is also the same: it may be called only after calling <code class="computeroutput">readyReady()</code>, or it
		will confess.
		</p><p>
		If this facet is in an input-only Triead, this call may sleep if a
		drain is currently active, until the drain is released.
		</p></div><div class="sect1" title="19.25. AutoDrain reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_ref_autodrain"></a>19.25. AutoDrain reference</h2></div></div></div><a class="indexterm" name="id600211"></a><p>
		The AutoDrain class creates the drains on an App with the automatic
		scoping. When the returned AutoDrain object gets destroyed, the drain
		becomes released. So placing the object into a lexically-scoped
		variable in a block with cause the release on the block exit. Placing
		it into another object will cause the release on deletion of that
		object. And just not storing the object anywhere works as a barrier:
		the drain gets completed and then immediately released, guaranteeing
		that all the previously sent data is processed and then continuing with
		the processing of the new data.
		</p><p>
		All the drain caveats described in the App class apply to the automatic
		drains too.
		</p><pre class="programlisting">$ad = Triceps::AutoDrain::makeShared($app);
$ad = Triceps::AutoDrain::makeShared($to);</pre><p>
		Create a shared drain and wait for it to complete. A drain may be
		created from either an App or a TrieadOwner object. Returns the
		AutoDrain object.
		</p><pre class="programlisting">$ad = Triceps::AutoDrain::makeSharedNoWait($app);
$ad = Triceps::AutoDrain::makeSharedNoWait($to);</pre><p>
		Same as <code class="computeroutput">makeShared()</code> but doesn't wait for the drain to complete before
		returning. May still sleep if an exclusive drain is currently active.
		</p><pre class="programlisting">$ad = Triceps::AutoDrain::makeExclusive($to);</pre><p>
		Create an exclusive drain on a TrieadOwner and wait for it to complete.
		Returns the AutoDrain object. Normally the excluded thread (the current one,
		idendified by the TrieadOwner) should be
		input-only. Such an input-only thread is allowed to send more data in
		without blocking. To wait for the app become drained again after that,
		use the method <code class="computeroutput">wait()</code>.
		</p><pre class="programlisting">$ad = Triceps::AutoDrain::makeExclusiveNoWait($to);</pre><p>
		Same as <code class="computeroutput">makeExclusive()</code> but doesn't wait for the drain to complete
		before returning. May still sleep if a shared or another exclusive
		drain is currently active.
		</p><pre class="programlisting">$ad-&gt;wait();</pre><p>
		Wait for the drain to complete. Particularly useful after the <code class="computeroutput">NoWait</code>
		creation, but can also be used to wait for the App to become drained
		again after injecting some rowops through the excluded Triead of the
		exclusive drain.
		</p><pre class="programlisting">$ad-&gt;same($ad2);</pre><p>
		Check that two AutoDrain references point to the same object. 
		</p></div></div><div class="chapter" title="Chapter 20. Triceps C++ API Reference"><div class="titlepage"><div><div><h2 class="title"><a name="ch_cpp_ref"></a>Chapter 20. Triceps C++ API Reference</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_cpp_intro">20.1. C++ API Introduction</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_const">20.2. The const-ness in C++</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_mem">20.3. Memory management in the C++ API and the Autoref reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_copy">20.4. The many ways to do a copy</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_string">20.5. String utilities</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_perl">20.6. Perl wrapping for the C++ objects</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_errors">20.7. Error reporting and Errors reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_exception">20.8. Exception reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_init">20.9. Initialization templates</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_types">20.10. Types reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_types_simple">20.11. Simple types reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_rowtype">20.12. RowType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_row">20.13. Row and Rowref reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_tabtype">20.14. TableType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_nameset">20.15. NameSet reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_idxtype">20.16. IndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_idx">20.17. Index reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_fifoidx">20.18. FifoIndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_hashidx">20.19. HashedIndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_sortidx">20.20. SortedIndexType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_gadget">20.21. Gadget reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_table">20.22. Table reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sc_cpp_table_dump">20.22.1. Data dump</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_table_sticky">20.22.2. Sticky errors</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sc_cpp_rowhandle">20.23. RowHandle and Rhref reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_aggregator">20.24. Aggregator classes reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sc_cpp_aggregator_type">20.24.1. AggregatorType reference</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_aggregator_gadget">20.24.2. AggregatorGadget reference</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_aggregator_obj">20.24.3. Aggregator reference</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_aggregator_basic">20.24.4. BasicAggregatorType reference</a></span></dt><dt><span class="sect2"><a href="#sc_cpp_aggregator_example">20.24.5. Aggegator example</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sc_cpp_unit">20.25. Unit reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_unit_tracer">20.26. Unit Tracer reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_label">20.27. Label reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_rowop">20.28. Rowop reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_tray">20.29. Tray reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_framemark">20.30. FrameMark reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_rowset">20.31. RowSetType reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_fnreturn">20.32. FnReturn reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_fnbind">20.33. FnBinding reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_autofn">20.34. ScopeFnBind and AutoFnBind reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_app">20.35. App reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_triead">20.36. Triead reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_triead_owner">20.37. TrieadOwner reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_nexus">20.38. Nexus reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_facet">20.39. Facet reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_autodrain">20.40. AutoDrain reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_sigusr2">20.41. Sigusr2 reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_triead_join">20.42. TrieadJoin reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_file_interrupt">20.43. FileInterrupt reference</a></span></dt><dt><span class="sect1"><a href="#sc_cpp_basic_pthread">20.44. BasicPthread reference</a></span></dt></dl></div><div class="sect1" title="20.1. C++ API Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_intro"></a>20.1. C++ API Introduction</h2></div></div></div><a class="indexterm" name="id546359"></a><p>
		Fundamentally, the C++ and Perl APIs are shaped similarly. So I won't
		be making a version of all the examples in C++. Please read the
		Perl-based documentation first to understand the spirit and usage of
		Triceps. The C++-based documentation is more of the reference type and
		concentrates on the low-level specifics and differences from Perl
		necessitated by this specifics.
		</p><p>
		In many cases just reading the descriptions of the methods in the <code class="computeroutput">.h</code>
		files should be enough to understand the details and be able to use the
		API. However in some cases the class hierarchies differ, with the Perl
		API covering the complexities exposed in the C++ API.
		</p><p>
		Writing directly in C++ is significantly harder than in Perl, so I
		highly recommend sticking with the Perl API unless you have a good
		reason to do otherwise. Even when the performance is important, it's
		usually enough to write a few critical elements in C++ and then bind
		them together in Perl. (If you wonder about Java, and why I didn't use
		it instead, the answer is that Java successfully combines the drawbacks
		of both and adds some of its own).
		</p><p>
		The C++ Triceps API is much more sensitive to the errors. The Perl API
		checks all the arguments for consistency, it's principle is that the
		interpreter must never crash. The C++ API is geared towards the
		efficiency of execution. It checks for errors when constructing the
		major elements but then does almost no checks at run time. The
		expectation is that the caller knows what he is doing. If the caller
		sends bad data, mislays the pointers etc., the program will crash. The
		idea here is that most likely the C++ API will be used from another
		layer: either an interpreted one (like Perl) or a compiled one (like a
		possible future custom language). Either way that layer is responsible
		for detecting the user errors at either interpretation or compile time.
		By the time the data gets to the C++ code, it's already checked and
		there is no need to check it again. Of course, if you write the
		programs manually in C++, that checking is upon you.
		</p><p>
		The more high-level features are currently available only in Perl. For
		example, there are no joins in the C++ API. If you want to do the joins
		in C++, you have to code your own. This will change over time, as these
		features will solidify and move to a C++ implementation to become more
		efficient and available through all the APIs. But it's much easier to
		experiment with the initial implementations in Perl.
		</p><p>
		The C++ code is located in the <code class="computeroutput">cpp/</code> subdirectory, and all
		the further descriptions refer to the subdirectories under it.
		</p></div><div class="sect1" title="20.2. The const-ness in C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_const"></a>20.2. The const-ness in C++</h2></div></div></div><a class="indexterm" name="id576592"></a><p>
		I've been using the <code class="computeroutput">const</code> keyword for two purposes:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			To let the compiler optimize a little better the methods that do not
			change the state of the objects.
			</li><li class="listitem">
			To mark the fragments of the read-only object internal state returned
			by the methods. This is much more efficient than making copies of them.
			</li></ul></div><p>
		So if you get a <code class="computeroutput">const vector&lt;&gt; &amp;</code> returned from a method, this is a
		gentle reminder that you should not be modifying this vector. Of
		course, nothing can stop a determined programmer from doing a type cast
		and modifying it anyway, but be aware that such inconsistent
		modifications will likely cause the program to crash in the future. And
		if the vector contains references to other objects, these objects
		usually should not be modified either, even they might not be marked
		with const.
		</p><a class="indexterm" name="id551219"></a><p>
		However all this <code class="computeroutput">const</code> stuff is not all rainbows and unicorns but also
		produces a sizable amount of suffering. One consequence is that you can
		not use the normal iterators on the <code class="computeroutput">const</code> vectors, you have to use the
		const_iterators. Another is that once in a while you get something like
		a <code class="computeroutput">(const RowType *)</code> from one method and need to pass it as an argument
		to another method that takes a <code class="computeroutput">(RowType *)</code>. In this case make sure that
		you know what you are doing and then proceed boldly with using a
		<code class="computeroutput">const_cast</code>. There is just no way to get all the const-ness
		self-consistent without ripping it out altogether. 
		</p></div><div class="sect1" title="20.3. Memory management in the C++ API and the Autoref reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_mem"></a>20.3. Memory management in the C++ API and the Autoref reference</h2></div></div></div><a class="indexterm" name="id577941"></a><p>
		The memory management fundamentals have been described in
		<a class="xref" href="#sc_memory_fund" title="4.3. Memory management fundamentals">Section 4.3: &#8220;Memory management fundamentals&#8221; </a>,
		and the application-level considerations have been descibed in
		<a class="xref" href="#ch_memory" title="Chapter 8. Memory Management">Chapter 8: &#8220;<i>Memory Management</i>&#8221; </a>.
		This section goes deeper into the issues specific to the C++ API.
		</p><p>
		The code related to the memory management is generally collected under <code class="computeroutput">mem/</code>. 
		The memory management is done through the reference counting, which has two parts to it:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			The objects that can be managed by reference counting.
			</li><li class="listitem">
			The references that do the counting.
			</li></ul></div><a class="indexterm" name="id591625"></a><a class="indexterm" name="id565920"></a><p>
		The managed objects come in two varieties: single-threaded and
		multi-threaded. The single-threaded objects lead their whole life in a
		single thread, so their reference counts don't need locking. The
		multi-threaded objects can be shared by multiple threads, so their
		reference counts are kept thread-safe by using the atomic integers (if
		the NSPR library is available) or by using a lock (if NSPR is not
		used). That whole implementation of atomic data with or without NSPR is
		encapsulated in the class AtomicInt in <code class="computeroutput">mem/Atomic.h</code>.
		</p><p>
		The way a class selects whether it will be single-threaded or
		multi-threaded is by inheriting from the appropriate class:
		</p><div class="variablelist"><dl><dt><span class="term">Starget</span></dt><dd><a class="indexterm" name="id564992"></a><p>
				for single-threaded (defined in <code class="computeroutput">mem/Starget.h</code>).
				</p></dd><dt><span class="term">Mtarget</span></dt><dd><a class="indexterm" name="id588771"></a><p>
				for multi-threaded (defined in <code class="computeroutput">mem/Mtarget.h</code>).
				</p></dd></dl></div><p>
		If you do the multiple inheritance, the [SM]target has to be inherited
		only once. Also, you can't change the choice along the inheritance
		chain. Once chosen, you're stuck with it. The only way around it is by
		encapsulating that inner class's object instead of inheriting from it.
		</p><a class="indexterm" name="id533931"></a><p>
		The references are created with the template <code class="computeroutput">Autoref&lt;&gt;</code>, defined in
		<code class="computeroutput">mem/Autoref.h</code>. For example, if you have an object of class RowType, the
		reference to it will be <code class="computeroutput">Autoref&lt;RowType&gt;</code>. There are are some similar
		references in the Boost library, but I prefer to avoid the avoidable
		dependencies (and anyway, I've never used Boost much).
		</p><p>
		The target objects are created in the constructors with the reference
		count of 0. The first time the object pointer is assigned to an
		Autoref, the count goes up to 1. After that it stays above 0 for the
		whole life of the object. As soon as it goes back to 0 (meaning that
		the last reference to it has disappeared), the object gets destroyed. No
		locks are held during the destruction itself. After all the references
		are gone, nobody should be using it, and destroying it is safe without
		any extra locks.
		</p><p>
		Starget and Mtarget are independent classes but Autoref 
		can work transparently on both of them because Autoref
		doesn't modify the reference counters by itself. Instead the target
		class is expected to provide the methods 
		</p><pre class="programlisting">void incref() const;
int decref() const;</pre><p>
		They are defined as const to allow the reference counting of even the
		const objects, but of course the reference counter field must be mutable.
		<code class="computeroutput">decref()</code> returns the resulting counter value. When it goes down to 0,
		Autoref calls the destructor. 
		</p><p>
		An important point is that to do all this, the Autoref must be able to
		execute the correct destructor when it destroys the object that ran out
		of references. Starget and Mtarget do not provide the virtual
		destructors. This allows to keep the reference-counted classes
		non-virtual, and save a little bit of memory in their objects,
		which might be important for the objects used in large numbers.
		If you don't use the polymorphism for some class, you
		don't have to use the virtual destructors. But if you do use it, i.e.
		create a class B inheriting from A, inheriting from [SM]target, and
		then assign something like
		</p><pre class="programlisting">Autoref&lt;A&gt; ref = new B;</pre><p>
		then the class A (and by extension all the classes inheriting from it)
		must have a virtual destructor to get everything working right.
		</p><p>
		It's also possible to mess up the destruction with the use of pointers.
		For example, look at this sequence:
		</p><pre class="programlisting">Autoref&lt;RowType&gt; rt = new RowType(...);
RowType *rtp = rt; // copies a reference to a pointer
rt = NULL; // reference cleared, count down to 0, object destroyed
Autoref &lt;RowType&gt; rt2 = rtp; // resurrects the dead pointer, corrupts memory</pre><p>
		The lesson here is that even though you can mix the references with
		pointers to reduce the overhead (the reference assignments change the
		reference counters, the pointer assignments don't), and I do it in my
		code, you need to be careful. A pointer may be used only when you know
		that there is a reference that holds the object in place. Once that
		reference is gone, the pointer can't be used any more, and especially
		can't be assigned to another reference. Be careful.
		</p><p>
		There are more varieties of the Autoref template, also
		defined in <code class="computeroutput">mem/Autoref.h</code>:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Onceref
			</li><li class="listitem">
			const_Autoref
			</li><li class="listitem">
			const_Onceref
			</li></ul></div><a class="indexterm" name="id597645"></a><p>
		The Onceref is an attempt at optimization when passing the function
		arguments and results. It's supposed to work like the standard
		auto_ptr: you assign a value there once, and then when that value gets
		assigned to an Autoref or another Onceref, it moves to the new
		location, leaving the reference count unchanged and the original
		Onceref as NULL. This way you avoid a spurious extra increase-decrease.
		However in practice I haven't got around to implementing it yet, so for
		now it's a placeholder that is defined to be an alias of Autoref,
		and const_Onceref is an alias of const_Autoref.
		</p><a class="indexterm" name="id599160"></a><a class="indexterm" name="id592071"></a><p>
		const_Autoref is a template defined over the Autoref template:
		</p><pre class="programlisting">template &lt;typename Target&gt;
class const_Autoref : public Autoref&lt;const Target&gt;</pre><p>
		The const_Autoref is a reference to a constant object. As you can see,
		<code class="computeroutput">const_Autoref&lt;T&gt;</code> is equivalent to <code class="computeroutput">Autoref&lt;const T&gt;</code>, 
		only it handles the
		automatic type casts much better. The approach is patterned after the
		const_iterator. The only problem with const_Autoref is that when you
		try to assign a NULL to it, that blows the compiler's mind. So you have
		to write an explicit cast 
		of <code class="computeroutput">const_Autoref&lt;T&gt;::null()</code> 
		or <code class="computeroutput">Autoref&lt;T&gt;::null()</code> 
		or <code class="computeroutput">(T*)NULL</code> of <code class="computeroutput">(const T*)NULL</code> 
		to help it out. Either way would work as long as one or the other
		path for casting is selected (by default the compiler is
		confused by the presence of two possible paths).
		</p><a class="indexterm" name="id605895"></a><p>
		Finally, const_Onceref is the const version of Onceref. 
		</p><p>
		The method prototypes of Autoref and all its varieties
		are (Target is the argument class of the
		Autoref template, Ptr is the pointer to it):
		</p><pre class="programlisting">typedef Target *Ptr;
static Ptr null();
Autoref();
Autoref(Target *t);
Autoref(const Autoref &amp;ar);
Autoref(const Autoref&lt;OtherTarget&gt; &amp;ar);
Target &amp;operator*() const;
Target *operator-&gt;() const;
Target *get() const;
operator Ptr() const; // type conversion to pointer
bool isNull() const;
Autoref &amp;operator=(const Autoref &amp;ar);
Autoref &amp;operator=(const Autoref&lt;OtherTarget&gt; &amp;ar);
bool operator==(const Autoref &amp;ar);
bool operator!=(const Autoref &amp;ar);
bool operator==(const Autoref&lt;OtherTarget&gt; &amp;ar);
bool operator!=(const Autoref&lt;OtherTarget&gt; &amp;ar);
void swap(Autoref &amp;other);</pre><p>
		Since the typical usage might be hard to understand from the
		method prototypes, the examples follow.
		Autoref can be constructed with or assigned from another Autoref or a
		pointer, or with a NULL value:
		</p><pre class="programlisting">T *ptr;
Autoref&lt;T&gt; ref1(ptr);
Autoref&lt;T&gt; ref2(ref1);
Autoref&lt;T&gt; ref3; // initialized as NULL by default
ref1 = ref2;
ref1 = ptr;
ref2 = NULL; // releases the reference
ref2 = Autoref&lt;T&gt;::null(); // another way to assign NULL</pre><p>
		The simple NULL usually works but there are cases with ambiguity,
		and the static method <code class="computeroutput">null()</code> helps to create the NULL of the correct
		type and remove that ambiguity.
		</p><p>
		The assignments work for exactly the same type and also for assignment
		to any parent in the class hierarchy:
		</p><pre class="programlisting">Autoref&lt;Label&gt; = new DummyLabel(...);</pre><p>
		The automatic conversion to pointers works too:
		</p><pre class="programlisting">ptr = ref1;</pre><p>
		Or a pointer can be extracted from an Autoref explicitly:
		</p><pre class="programlisting">ptr = ref1.get();</pre><p>
		The dereferencing and arrow operations work like on a pointer:
		</p><pre class="programlisting">T val = *ref1;
ref1-&gt;method();</pre><p>
		The Autorefs can also be compared for equality and inequality:
		</p><pre class="programlisting">ref1 == ref2
ref1 != ref2</pre><p>
		To compare them to pointers, use <code class="computeroutput">get()</code>. Except for one special case:
		the comparison to NULL happens so often that a special method is
		provided for it:
		</p><pre class="programlisting">ref1.isNull()</pre><p>
		Two Autorefs may swap their values, without changing the reference
		counts of either value:
		</p><pre class="programlisting">ref1.swap(ref2);</pre><p>
		There is also a special variety of Autoref for referring to rows,
		Rowref, described in
		<a class="xref" href="#sc_cpp_row" title="20.13. Row and Rowref reference">Section 20.13: &#8220;Row and Rowref reference&#8221; </a>.
		</p></div><div class="sect1" title="20.4. The many ways to do a copy"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_copy"></a>20.4. The many ways to do a copy</h2></div></div></div><a class="indexterm" name="id603718"></a><a class="indexterm" name="id505450"></a><p>
		The Triceps objects need occasionally to be copied. But as the objects
		are connected into the deep topologies, a question arises, how much of
		this topology needs to be copied along with the object?
		</p><a class="indexterm" name="id599462"></a><a class="indexterm" name="id543625"></a><p>
		The objects that are copied the most are the IndexType and TableType.
		The method <code class="computeroutput">copy()</code>, in both Perl and C++, is the general way to copy them. 
		It copies the object, and as needed its
		components, but tries to share the referred objects that can be shared (such as
		the row types). But the multithreading support required more kinds of
		copying.
		</p><p>
		The Perl method <code class="computeroutput">TableType::copyFundamental()</code> copies a table type with
		only a limited subset of its index types, and excludes all the
		aggregators. It is implemented in Perl, and if you look in
		<code class="computeroutput">lib/Triceps/TableType.pm</code>, you can find that it starts by making a new
		table type with the same row type, and then one by one adds the needed
		index types to it. It needs the index types without any aggregators or
		nested index types, and thus there is a special method for doing this
		kind of copies:
		</p><pre class="programlisting">$idxtype2 = $idxtype-&gt;flatCopy();</pre><p>
		The <span class="quote">&#8220;<span class="quote">flat</span>&#8221;</span> means exactly what it looks like: copy just the object
		itself without any connected hierarchies.
		</p><p>
		On the C++ level there is no such method, instead there is an optional
		argument to <code class="computeroutput">IndexType::copy()</code>:
		</p><pre class="programlisting">virtual IndexType *copy(bool flat = false) const;</pre><p>
		So if you want a flat copy, you call
		</p><pre class="programlisting">idxtype2 = idxtype-&gt;copy(true);</pre><p>
		There is no <code class="computeroutput">copyFundamental()</code> on the C++ level, though it probably
		should be, and should be added in the future. For now, if you really
		want it, you can make it yourself by copying the logic from Perl.
		</p><p>
		In the implementation of the index types, this argument <code class="computeroutput">flat</code> mostly
		just propagates to the base class, without a whole lot needed from the
		subclass. For example, this is how it works in the SortedIndexType:
		</p><pre class="programlisting">IndexType *SortedIndexType::copy(bool flat) const
{
  return new SortedIndexType(*this, flat);
}

SortedIndexType::SortedIndexType(const SortedIndexType &amp;orig, bool flat) :
  TreeIndexType(orig, flat),
  sc_(orig.sc_-&gt;copy())
{ }</pre><p>
		The base class TreeIndexType takes care of everything, all the subclass
		needs to do is carry the flat argument to it.
		</p><p>
		The next kind of copying is exactly the opposite: it copies the whole
		table type or index type, including all the objects involved, including
		the row types or such. It is used for passing the table types through
		the nexus to the other threads.
		</p><a class="indexterm" name="id512579"></a><a class="indexterm" name="id518858"></a><p>
		Remember that all these objects are reference-counted. Whenever a Row
		object is created or deleted in Perl, it increases or decreases the
		reference of the RowType to which that row belongs. 
		If the same RowType object is shared between
		multiple threads, they will have  a contention for this atomic counter,
		or at the very least will be shuttling the cache line with it back and
		forth between the CPUs. It's more efficient to give each thread its own
		copy of a RowType, and then it can stay stuck in one CPU's cache.
		</p><a class="indexterm" name="id562606"></a><a class="indexterm" name="id592322"></a><p>
		So wherever a table type is exported into a nexus, it's deep-copied
		(and when a row type is exported into a nexus, it's simply copied, and
		so are the row types of the labels in the nexus). Then when a nexus is
		imported, the types are again deep-copied into the thread's facet.
		</p><p>
		But there is one more catch. Suppose we have a label and a table type
		that use the same row type. Whenever a row coming from a label is
		inserted into the table (in Perl), the row types of the row (i.e. the
		label's row type in this case) and of the table are checked for a
		match. If the row type is the same, this check is very quick. But if
		the same row type gets copied and then different copies are used for
		the label and for the table, the check will have to go and actually
		compare the contents of these row types, and will be much slower. To
		prevent this slowness, the deep copy has to be smart: it must be able
		to copy a bunch of things while preserving the identity of the
		underlying row types. If it's given a label and then a table type, both
		referring to the same row type, it will copy the row type from the
		label, but then when copying the table type it will realize that this row type had
		already been seen and copied, so it will reuse the same row type copy for the table type.
		And the same applies even within a table type: it may have multiple
		references to the same row type from the aggregators, and will be smart
		enough to figure out if they are the same, and copy the same row type
		only once.
		</p><p>
		This smartness stays mostly undercover in Perl. When you import a
		facet, it will do all the proper copying, sharing the row types.
		(Though of course if you export the same row type through two separate
		nexuses, and then import them both into another thread, these facets
		will not share the types between them any more). There is a method
		<code class="computeroutput">TableType::deepCopy()</code> but it was mostly intended for testing and it's
		self-contained: it will copy one table type with the correct row type
		sharing inside it but it won't do the sharing between two table types.
		It's not even documented in the TableType reference.
		</p><p>
		All the interesting uses of the <code class="computeroutput">deepCopy()</code> are at the C++ level. It's
		used all over the place: for the TableType, IndexType, AggregatorType,
		SortedIndexCondition and RowSetType (the type of FnReturn and
		FnBinding). If you decide to create your own subclass of these classes,
		you need to implement the <code class="computeroutput">deepCopy()</code> as well as the normal <code class="computeroutput">copy()</code>
		for it.
		</p><p>
		Its prototype generally looks like this (substitute the correct return
		type as needed):
		</p><pre class="programlisting">virtual IndexType *deepCopy(HoldRowTypes *holder) const;</pre><a class="indexterm" name="id586203"></a><p>
		The HoldRowTypes object is what takes care of sharing the underlying
		row types. To copy a bunch of objects with sharing, you create a
		HoldRowTypes, copy the bunch, destroy the HoldRowTypes.
		</p><p>
		For example, the Facet copies the row and table types from a Nexus like this:
		</p><pre class="programlisting">Autoref&lt;HoldRowTypes&gt; holder = new HoldRowTypes;

for (RowTypeMap::iterator it = nx-&gt;rowTypes_.begin();
    it != nx-&gt;rowTypes_.end(); ++it)
  rowTypes_[it-&gt;first] = holder-&gt;copy(it-&gt;second);
for (TableTypeMap::iterator it = nx-&gt;tableTypes_.begin();
    it != nx-&gt;tableTypes_.end(); ++it)
  tableTypes_[it-&gt;first] = it-&gt;second-&gt;deepCopy(holder);</pre><p>
		It also uses the same holder to copy the labels.
		A row type gets copied through a holder like this:
		</p><pre class="programlisting">Autoref&lt;RowType&gt; rt2 = holder-&gt;copy(rt);</pre><p>
		For all the other purposes, HoldRowTypes is an opaque object.
		</p><p>
		A special feature is that you can pass the holder pointer as NULL, and
		the deep copy will still work, only it obviously won't be able to share
		the underlying row types. So if you don't care about sharing, you can
		always use NULL as an argument. It even works for the direct copying:
		</p><pre class="programlisting">HoldRowTypes *holder = NULL;
Autoref &lt;RowType&gt; rt2 = holder-&gt;copy(rt);</pre><p>
		Its method <code class="computeroutput">copy()</code> is smart enough to recognize the <code class="computeroutput">this</code> being NULL and
		do the correct thing.
		</p><p>
		In the subclasses, the <code class="computeroutput">deepCopy()</code> is typically implemented like this:
		</p><pre class="programlisting">IndexType *SortedIndexType::deepCopy(HoldRowTypes *holder) const
{
  return new SortedIndexType(*this, holder);
}

SortedIndexType::SortedIndexType(const SortedIndexType &amp;orig, HoldRowTypes *holder) :
  TreeIndexType(orig, holder),
  sc_(orig.sc_-&gt;deepCopy(holder))
{ }</pre><p>
		The wrapper passes the call to the deep-copy constructor with a holder
		which in turn propagates the deep-copying to all the components using
		their constructor with a holder. Of course, if some component doesn't
		have any RowType references in it, it doesn't need a constructor with a
		holder, and can be copied without it. But again, the idea of the
		<code class="computeroutput">deepCopy()</code> it to copy as deep as it goes, without sharing any
		references with the original. 
		</p></div><div class="sect1" title="20.5. String utilities"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_string"></a>20.5. String utilities</h2></div></div></div><p>
		Triceps has a number of small helper functions for string handling
		that are used throughout the code. This description includes a few
		forward references but you don't really need to understand them to
		understand these functions.
		</p><p>
		The first two are declared in <code class="computeroutput">common/Strprintf.h</code>:
		</p><a class="indexterm" name="id560504"></a><a class="indexterm" name="id488430"></a><pre class="programlisting">string strprintf(const char *fmt, ...);
string vstrprintf(const char *fmt, va_list ap);</pre><p>
		They are entirely similar to <code class="computeroutput">sprintf()</code> and <code class="computeroutput">vsprintf()</code> with the
		difference that they place the result of formatting into a newly
		constructed string and return that string.
		</p><p>
		The rest are defined in <code class="computeroutput">common/StringUtil.h</code>.
		</p><pre class="programlisting">extern const string &amp;NOINDENT;</pre><a class="indexterm" name="id554738"></a><a class="indexterm" name="id566450"></a><p>
		The special constant that when passed to the printing of the Type
		(see
		<a class="xref" href="#sc_cpp_types" title="20.10. Types reference">Section 20.10: &#8220;Types reference&#8221; </a>)
		causes it to print without line breaks. Doesn't have any special effect
		on Errors, there it's simply treated as an empty string.
		</p><pre class="programlisting">const string &amp;nextindent(const string &amp;indent, const string &amp;subindent, string &amp;target);</pre><p>
		Compute the indentation for the next level when printing a Type. The
		arguments are:
		</p><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">indent</code></span></dt><dd><p>
				indent string of the current level.
				</p></dd><dt><span class="term"><code class="computeroutput">subindent</code></span></dt><dd><p>
				characters to append for the next indent level.
				</p></dd><dt><span class="term"><code class="computeroutput">target</code></span></dt><dd><p>
				buffer to store the extended indent string.
				</p></dd></dl></div><p>
		The passing of <code class="computeroutput">target</code> as an argument allows to reuse the same string
		object and avoid the extra construction.
		</p><p>
		The function returns the computed reference: if <code class="computeroutput">indent</code> was NOINDENT,
		then reference to NOINDENT, otherwise reference to <code class="computeroutput">target</code>. This
		particular calling pattern is strongly tied to how things are computed
		inside the type printing, but you're welcome to look inside it and do
		the same for any other purpose.
		</p><pre class="programlisting">void newlineTo(string &amp;res, const string &amp;indent);</pre><p>
		Another helper function for the printing of Type, inserting a line
		break. The <code class="computeroutput">indent</code> argument specifies the indentation, with the special
		handling of NOINDENT: if <code class="computeroutput">indent</code> is NOINDENT, a single space is added,
		thus printing everything in one line; otherwise a <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span> and the contents
		of <code class="computeroutput">indent</code> are added. The <code class="computeroutput">res</code> argument is the result string, where the
		line break characters are added.
		</p><pre class="programlisting">void hexdump(string &amp;dest, const void *bytes, size_t n, const char *indent = "");</pre><p>
		Print a hex dump of a sequence of bytes (at address <code class="computeroutput">bytes</code> and of length
		<code class="computeroutput">n</code>), appending the dump to the destination string <code class="computeroutput">dest</code>. The data will be
		nicely broken into lines, with 16 bytes printed per line. The first
		line is added directly to the end of the <code class="computeroutput">dest</code> as-is,  but if <code class="computeroutput">n</code> is over
		16, the other lines will follow after <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span>. The <code class="computeroutput">indent</code> argument allows to
		add indentation at the start of each following line.
		</p><pre class="programlisting">void hexdump(FILE *dest, const void *bytes, size_t n, const char *indent = "");</pre><p>
		Another version, sending the dumped data directly into a file descriptor.
		</p><p>
		The next pair of functions provides a generic mechanism for converting
		enums between a string and integer representation:
		</p><pre class="programlisting">struct Valname
{
    int val_;
    const char *name_;
};

int string2enum(const Valname *reft, const char *name);
const char *enum2string(const Valname *reft, int val, const char *def = "???");</pre><p>
		The reference table is defined with an array of Valnames, with the
		last element being <code class="computeroutput">{ -1, NULL }</code>. Then it's passed as the argument <code class="computeroutput">reft</code>
		of the conversion functions which do a sequential look-up by that
		table. If the argument is not found, <code class="computeroutput">string2enum()</code> will return -1, and
		<code class="computeroutput">enum2string()</code> will return the value of the <code class="computeroutput">def</code> argument (which may be
		NULL).
		</p><p>
		Here is an example of how it's used for the conversion of opcode flags:
		</p><pre class="programlisting">Valname opcodeFlags[] = {
    { Rowop::OCF_INSERT, "OCF_INSERT" },
    { Rowop::OCF_DELETE, "OCF_DELETE" },
    { -1, NULL }
};

const char *Rowop::ocfString(int flag, const char *def)
{
    return enum2string(opcodeFlags, flag, def);
}

int Rowop::stringOcf(const char *flag)
{
    return string2enum(opcodeFlags, flag);
}</pre></div><div class="sect1" title="20.6. Perl wrapping for the C++ objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_perl"></a>20.6. Perl wrapping for the C++ objects</h2></div></div></div><a class="indexterm" name="id578624"></a><p>
		The subject of this section is not a part of the C++ API as such but the
		connection between the C++ and Perl APIs. You need to bother about it
		only if you want to write more of the components in C++ and export them into
		Perl.
		</p><p>
		When exporting the C++ (or any compiled language) API into Perl (or
		into any scripting language) there are two things to consider:
		</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
			The script must never crash the interpterer. The interpreted program
			might die but the interpreter itself must never crash. If you've ever
			dealt with <code class="computeroutput">wksh</code> (not thankfully long dead), you know how
			horrible is the debugging of such crashes.
			</li><li class="listitem">
			Perl has its memory management by reference counting, which needs to
			be married with the memory management at the C++ level.
			</li></ol></div><p>
		The solution to the second problem is fairly straightforward: have an
		intermediate wrapper structure. Perl has its reference counting for the
		pointer to this structure.  When you construct a Perl object, return
		the pointer to a newly allocated instance of this structure. When the
		Perl reference count goes down to zero, it calls the method <code class="computeroutput">DESTROY</code> for
		this object, and then you destroy this structure.
		</p><p>
		And inside this structure will be the C++ reference to the actual
		C++ object. When the wrapper structure gets created, it gets a new
		reference and when the wrapper structure gets destroyed, it releases
		this reference.
		</p><p>
		Here is a small example of how the RowType object gets created and
		destroyed in the Perl XS code, using the wrapper structure WrapRowType:
		</p><pre class="programlisting">WrapRowType *
Triceps::RowType::new(...)
  CODE:
    RETVAL = NULL; // shut up the warning
    try { do {
      RowType::FieldVec fld;

      clearErrMsg();
      ...
      Onceref&lt;RowType&gt; rt = new CompactRowType(fld);
      Erref err = rt-&gt;getErrors();
      if (err-&gt;hasError()) {
        throw Exception::f(err, "Triceps::RowType::new: incorrect data");
      }

      RETVAL = new WrapRowType(rt);
    } while(0); } TRICEPS_CATCH_CROAK;
  OUTPUT:
    RETVAL

void
DESTROY(WrapRowType *self)
  CODE:
    // warn("RowType destroyed!");
    delete self;</pre><p>
		This example also shows the way the Triceps XS code deals with the conversion
		of the C++ Exceptions to the Perl confessions. The <code class="computeroutput">while(0)</code> part
		is a hold-over from the earlier implementation of error handling that allows
		to set the error message directly in a buffer and then do a <code class="computeroutput">break</code> to jump
		to the end of the pseudo-loop. The new way is the throwing of Exceptions.
		The shown code is a hybrid that handles both. The handling itself is done
		in the macro <code class="computeroutput">TRICEPS_CATCH_CROAK</code>.
		</p><p>
		Now let's look more in-depth at the first problem. How does Perl know to call a particular XS
		method for a object? From the package this object is blessed to. If the
		package happens to be an XS package, the XS method will be called.
		However it's entirely possible to re-bless the object to a completely
		different package. If the user does this, a completely wrong method may
		be called and will crash when it tries to reach a wrong object at the
		pointer.
		</p><p>
		Things get even worse for the other arguments of the methods. For
		example, the argument <code class="computeroutput">other</code> here:
		</p><pre class="programlisting">int
equals(WrapRowType *self, WrapRowType *other)</pre><p>
		Well, Perl lets you provide a code snippet for the <code class="computeroutput">typemap</code> file
		that would check that the object is as expected. But how would that snippet
		know? Going just by the blessed package is unreliable.
		</p><p>
		Triceps solves this problem by placing an 8-byte magic code at the
		front of every wrap object. Each class has its own magic value for this
		field. 8 bytes allow to have great many unique codes, and is quick to
		check because it's just one CPU word.
		</p><p>
		This magic code is defined  in the C++ part in <code class="computeroutput">wrap/Wrap.h</code> as:
		</p><pre class="programlisting">struct WrapMagic {
  ~WrapMagic()
  {
    (*(int64_t *)v_) = 0; // makes sure that it gets invalidated
  }

  char v_[8]; // 8 bytes to make a single 64-bit comparison

  bool operator!=(const WrapMagic &amp;wm) const
  {
    return (*(int64_t *)v_) != (*(int64_t *)wm.v_);
  }
};</pre><p>
		Then the wrapper is implemented as follows:
		</p><pre class="programlisting">template&lt;const WrapMagic &amp;magic, class Class&gt;
class Wrap
{
public:
  Wrap(Onceref&lt;Class&gt; r) :
    magic_(magic),
    ref_(r)
  { }

  // returns true if the magic value is bad
  bool badMagic() const
  {
    return magic_ != magic;
  }

  Class *get() const
  {
    return ref_.get();
  }

  operator Class*() const
  {
    return ref_.get();
  }

public:
  WrapMagic magic_;
  Autoref&lt;Class&gt; ref_; // referenced value
private:
  Wrap();
};</pre><p>
		The check is done with the method <code class="computeroutput">badMagic()</code>.
		</p><p>
		And the <code class="computeroutput">typemap</code> entry is:
		</p><pre class="programlisting">O_WRAP_OBJECT
  if( sv_isobject($arg) &amp;&amp; (SvTYPE(SvRV($arg)) == SVt_PVMG) ) {
    $var = ($type)SvIV((SV*)SvRV( $arg ));
    if ($var == 0 || $var-&gt;badMagic()) {
      croakWithMsg( \"${Package}::$func_name(): $var has an incorrect magic for $ntype\" );
    }
  } else{
    croakWithMsg( \"${Package}::$func_name(): $var is not a blessed SV reference to $ntype\" );
  }</pre><p>
		It checks that this is an object, of an XS package, and then that the
		pointer to the C/C++ object is not NULL, and that the value at this
		pointer starts with the right magic.
		</p><p>
		<code class="computeroutput">croakWithMsg()</code> is the Triceps function for building the confession
		trace and then croaking with it.
		</p><p>
		The template shown above is normally used through a macro that
		substitutes the repeated values from one source.
		For example,  the definition for the RowType wrapper
		is:
		</p><pre class="programlisting">DEFINE_WRAP(RowType);</pre><p>
		The static definition of the magic code that the macro passes to the
		template is defined in <code class="computeroutput">wrap/Wrap.cpp</code>:
		</p><pre class="programlisting">WrapMagic magicWrapRowType = { "RowType" };</pre><p>
		Just make sure that the string contains no more than 7 characters.
		</p><p>
		Some objects in Triceps are reached through the special references that
		know both the object and its type (such as rows and row handles). For
		them there is a separate template and a separate macro:
		</p><pre class="programlisting">DEFINE_WRAP2(const RowType, Rowref, Row);
DEFINE_WRAP2(Table, Rhref, RowHandle);</pre><p>
		The arguments are the type class, the reference class and finally the
		object class itself.
		</p><p>
		And there is one more twist: sometimes the objects are self-contained
		but when you use them, you must use them only with a correct parent
		object. Right now there is only one such class: the Tray must be used
		with its correct Unit, and the Perl code checks it. In this case the
		wrapper has the reference to both Tray and the Unit, and is defined as:
		</p><pre class="programlisting">DEFINE_WRAP_IDENT(Unit, Tray);</pre><p>
		Triceps has a substantial library of helper methods and objects
		for wrappig the C++ objects, located in the Perl part of the code.
		Many of them are located in <code class="computeroutput">TricepsPerl.h</code>. Feel free
		to refer to them if you need to, but for now they are out of scope
		of the documentation.
		</p><a class="indexterm" name="id474888"></a><a class="indexterm" name="id598323"></a><p>
		Just one more thing: Perl is not happy about sharing the objects
		between multiple threads. Even when a C++ object is OK with multithreading,
		Perl requires the separate wrappers to be created for it from each thread.
		When a new Perl thread is started, Perl can not properly ask the XS
		code to split the wrappers, so instead all the objects need to be invalidated
		in the new thread. To do that, the XS package needs to define the method
		<code class="computeroutput">CLONE_SKIP</code>:
		</p><pre class="programlisting">int
CLONE_SKIP(...)
  CODE:
    RETVAL = 1;
  OUTPUT:
    RETVAL</pre></div><div class="sect1" title="20.7. Error reporting and Errors reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_errors"></a>20.7. Error reporting and Errors reference</h2></div></div></div><a class="indexterm" name="id518813"></a><p>
		When building some kind of a language, the complicated errors often
		need to be reported. Often there are many errors at a time, or an error
		that needs to be tracked through multiple nested layers. And then these
		error messages need to be nicely printed, with the indentation by
		nested layers. Think of the errors from a C++ compiler. Triceps is a
		kind of a language, so it has a class to represent such errors. It
		hasn't propagated to the Perl layer yet and is available only in the
		C++ API.
		</p><a class="indexterm" name="id469427"></a><a class="indexterm" name="id463376"></a><a class="indexterm" name="id478301"></a><p>
		The class is Errors, defined in <code class="computeroutput">common/Errors.h</code>, and inheriting from
		Starget (for single-threaded reference counting). The references to it
		are used so often, that <code class="computeroutput">Autoref&lt;Errors&gt;</code> is defined to have its own
		name <code class="computeroutput">Erref</code> (yes, that's double <code class="computeroutput">r</code>, not triple), as well as
		a couple of helper methods on it.
		</p><p>
		Triceps also has the exceptions (more on them in 
		<a class="xref" href="#sc_cpp_exception" title="20.8. Exception reference">Section 20.8: &#8220;Exception reference&#8221; </a>)
		which also contain the Errors objects inside them.
		</p><a class="indexterm" name="id583977"></a><p>
		In general an Errors object contains messages, not all of which have to be errors.
		Some might be warnings. But in practice is has turned out that without
		a special dedicated compile stage it's hard to report the warnings.
		Even when there is a special compile stage, and the code gets compiled
		before it runs, as it was in Aleri, with the warnings written to a log file,
		still people rarely pay attention to the warnings. You would not
		believe, how may people would be calling support while the source of
		their problem is clearly described in the warnings in the log file.
		Even in C/C++ it's difficult to pay attention to the warnings. I better
		like the approach of a separate lint tool for this purpose: at least
		when you run it, you're definitely looking for warnings.
		</p><p>
		Because of this, the current Triceps approach is to not have warnings.
		If something looks possibly right but suspicious, report it as an error
		but provide an option to override that error (and tell about that
		option in the error message).
		</p><p>
		In general, the Errors are built of two kinds of information:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			the error messages;
			</li><li class="listitem">
			the nested Errors reports.
			</li></ul></div><p>
		More exactly, an Errors contains a sequence of elements, each of which
		may contain a string, a nested Errors object, or both. When both, the
		idea is that the string gives a high-level description and the location
		of the error in the high-level object while the nested Errors digs into
		the further detail. The string gets printed before the nested Errors.
		The nested Errors get printed with an indentation. The indentation gets
		added only when the errors get <span class="quote">&#8220;<span class="quote">printed</span>&#8221;</span>, i.e. the top-level Errors
		object gets converted to a string. Until then the elements may be
		nested every which way without incurring any extra overhead.
		</p><p>
		Obviously, you must not try to nest an Errors object inside itself,
		directly or indirectly. Not only will it create a memory reference
		cycle, but also an endless recursion when printing.
		</p><p>
		The most typical way to construct an Errors object
		is with the functions taking the printf-like arguments.
		They have been a relatively recent addition, so there is plenty of code in Triceps that
		uses the older ways, but this is the latest and greatest, and
		recommended for all the future use.
		</p><p>
		The consistent theme in its usage is <span class="quote">&#8220;<span class="quote">check if the Errors reference (Erref) is
		NULL, if it is, allocate a new Errors, and then add a formatted error
		message to it</span>&#8221;</span>. So the printf-like methods are defined not on Errors but on
		Erref. They check if the Erref object is NULL, allocate a new Errors
		object into it if needed, and then format the arguments. The simplest
		one is:
		</p><pre class="programlisting">void f(const char *fmt, ...);</pre><p>
		It adds a simple formatted message, always marked as an error. It is used
		like this:
		</p><pre class="programlisting">Erref e; // initially NULL by default
...
e.f("a message with integer %d", n);</pre><a class="indexterm" name="id599431"></a><p>
		The message may be multi-line, it will be split appropriately, to make
		it all render with the correct indenting level. If the error message
		contains a <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span> at the end, that <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span>
		will be discarded (since the line feed after each line is implicit).
		</p><p>
		The next one is used to build the nested error messages:
		</p><pre class="programlisting">bool fAppend(Autoref&lt;Errors&gt; clde, const char *fmt, ...);</pre><p>
		It first checks that the child errors object is not NULL and contains
		an error, and if it does then it goes through the dance of allocating a
		new Errors object if needed, appending the formatted message and the
		child errors. The message goes before the child errors, unlike the
		method signature. So you can use it blindly like this to do the right
		thing:
		</p><pre class="programlisting">Erref checkSubObject(int idx);

Erref checkObject()
{
  Erref err; // initially NULL by default
  ...
  for (int i = 0; i &lt; sz; i++)
    err.fAppend(checkSubObject(i),  "error in the sub-object %d:", i);
  ...
  return err; // NULL on success, Errors reference on error
}</pre><p>
		No additional <span class="bold"><strong>if</strong></span>s are necessary to check the result of
		<code class="computeroutput">checkSubObject()</code>, <code class="computeroutput">fAppend()</code> contains this <span class="bold"><strong>if</strong></span> inside it.
		Similar to <code class="computeroutput">f()</code>, the error message may be multi-line.
		</p><p>
		The more basic way to create an Errors is by calling one of
		the constructors:
		</p><pre class="programlisting">Errors(bool e = false);
Errors(const char *msg);
Errors(const string &amp;msg);
Errors(const string &amp;msg, Autoref&lt;Errors&gt; clde);</pre><p>
		For example:
		</p><pre class="programlisting">Erref err = Errors("error message");</pre><p>
		The default constructor creates an empty object, which then needs
		to be filled with the messages (or not, returning an empty Errors
		object is also possible, meaning that no errors were found, though
		returning NULL is more efficient).
		The argument <code class="computeroutput">e</code> is an indicator than it contains an actual error.
		By default it's unset but will be set when an error message is added, or whan a nested Errors
		object with an error in it is added.
		</p><p>
		The rest of the above are the convenience constructors that make one-off
		Errors from one element (though of course more elements can be added
		afterwards).
		In all of them the error flag is always set, and the multi-line messages
		are properly handled.
		</p><p>
		After an Errors object is constructed, more elements can be added to it
		by one of the following methods.
		</p><pre class="programlisting">void appendMsg(bool e, const string &amp;msg);</pre><p>
		The argument <code class="computeroutput">e</code> shows whether the message is an error message
		(and it will set the error flag in Errors),
		otherwise just a warning. 
		There are no special per-message indications whether it's an error
		or warning, the Errors keeps just a single flag per object, and the messages
		are eventually printed as-is. So if you want the user to recognize
		some message as a warning, prefix its text with something like
		<span class="quote">&#8220;<span class="quote">warning:</span>&#8221;</span>.
		</p><p>
		The argument <code class="computeroutput">msg</code> must be a single-line message, don't use a <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span> in it!
		If you want to append multiple lines, call <code class="computeroutput">appendMsg()</code> once per line, or
		use <code class="computeroutput">appendMultiline()</code> to append the whole multi-line message.
		</p><pre class="programlisting">void appendMultiline(bool e, const string &amp;msg);</pre><p>
		The same as <code class="computeroutput">appendMsg()</code>, only it will safely break a multi-line message into
		multiple single-liners and will ignore the <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span> at the end.
		Inside the Errors object each line will become a separate message.
		</p><pre class="programlisting">bool append(const string &amp;msg, Autoref&lt;Errors&gt; clde);</pre><p>
		The <code class="computeroutput">append()</code> method is somewhat like <code class="computeroutput">Erref::fAppend()</code> but
		different, because they represent different ages of the API.
		When <code class="computeroutput">append()</code> was written, the warnings were considered important,
		and a common way to return a no-error condition was by returning
		an Errors object with no contents. When <code class="computeroutput">fAppend()</code> was written,
		I've pretty much given up on the use of warnings, and the preferred
		way to return the no-error condition had become by returning NULL.
		</p><p>
		In <code class="computeroutput">append()</code> the following situations are possible:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			The argument <code class="computeroutput">clde</code> is NULL or empty (that is contains no
			messages nor sub-objects), and the error flag in it is false. In this case
			<code class="computeroutput">append()</code> does nothing, and the message <code class="computeroutput">msg</code> is thrown away.
			</li><li class="listitem">
			The argument <code class="computeroutput">clde</code> is not empty but the error flag is false.
			Both <code class="computeroutput">msg</code> and child object will be appended to the Errors.
			</li><li class="listitem">
			The argument <code class="computeroutput">clde</code> is not empty and the error flag is true.
			Both <code class="computeroutput">msg</code> and child object will be appended to the Errors,
			and the error flag will be set in it.
			</li><li class="listitem">
			The argument <code class="computeroutput">clde</code> is empty and the error flag is true.
			The <code class="computeroutput">msg</code> will be appended to the Errors and
			the error flag will be set in it. The child object will be thrown
			away (it's reference-counted, so it will be freed when the last
			reference is gone).
			</li></ul></div><p>
		Just like <code class="computeroutput">appendMsg()</code>, the argument <code class="computeroutput">msg</code> must be a single-line message.
		</p><p>
		The return value of <code class="computeroutput">append()</code> will be true
		if the child element contained any data in it or an error indication
		flag. This can be used together with another method
		</p><pre class="programlisting">void replaceMsg(const string &amp;msg);</pre><p>
		to add a complex high-level description if a child element has reported
		an error. By now it has become old-fashioned, and <code class="computeroutput">Erref::fAppend()</code> is
		a better choice. Before <code class="computeroutput">fAppend()</code> came along, the typical way to
		create an error message was by calling <code class="computeroutput">strprintf()</code> that formats a
		printf-like string into a C++ string object. And it's kind of expensive
		to call <code class="computeroutput">strprintf()</code> in any case, even if the child returned no error.
		So the optimization was to call <code class="computeroutput">append()</code> with an empty string, and
		if it happened to actually append something, replace that empty
		message with the real one. As the following pattern shows:
		</p><pre class="programlisting">Erref clde = someThing(...);
if (e.append("", clde)) {
    // ... generate msg in some complicated way
    e.replaceMsg(strprintf(...));
}</pre><p>
		The <code class="computeroutput">replaceMsg()</code> replaces the string portion of the last element, which
		owns the last added child error.
		</p><p>
		This pattern can still be used if the error message is truly
		difficult to generate, but usually <code class="computeroutput">fAppend()</code> is a better choice.
		</p><p>
		It's also possible to include the contents of another Errors directly,
		without nesting it:
		</p><pre class="programlisting">bool absorb(Autoref&lt;Errors&gt; clde);</pre><p>
		The return value has the same meaning as with <code class="computeroutput">append()</code> (but <code class="computeroutput">replaceMsg()</code>
		can not be used with this method for anything reasonable). The argument
		<code class="computeroutput">clde</code> may be NULL. The error flag propagates to the parent as usual.
		</p><p>
		Finally, an
		Errors object can be cleared to its empty state:
		</p><pre class="programlisting">void clear();</pre><p>
		Usually the clearing of an Errors object is not such a good idea.
		Remember, they are built into a tree. So if you later modify an
		Errors object, that would also modify what is seen by all the
		objects that refer to it. The proper approach is to treat an Errors
		object as append-only while it's being built. And after it has been
		completed and returned, treat it as read-only.
		</p><p>
		To get the number of elements in Errors, use
		</p><pre class="programlisting">size_t size() const;</pre><p>
		Remember, a child object with its associated top-level error message
		counts as a single element, not two of them.
		</p><p>
		However the more typical methods are:
		</p><pre class="programlisting">bool isEmpty();
bool hasError();</pre><p>
		They check whether there is nothing at all or whether there is an
		error. The special convenience of these methods is that they can be
		called on NULL pointers. Quite a few Triceps methods return a NULL
		Erref if there was no error. In the following example, even if 
		<code class="computeroutput">er</code> is NULL, these calls are still safe and officially supported. 
		But <span class="bold"><strong>not</strong></span> <code class="computeroutput">er-&gt;size()</code>.
		</p><pre class="programlisting">Erref er = NULL;
er-&gt;isEmpty();
er-&gt;hasError();
parent_er-&gt;append(msg, er);
parent_er-&gt;absorb(er);
parent_er.fAppend(er, msg);</pre><p>
		The data gets extracted from Erref by converting it to a string, either
		appending to an existing string, or creating a new one:
		</p><pre class="programlisting">void printTo(string &amp;res, const string &amp;indent = "", const string &amp;subindent = "  ");
string print(const string &amp;indent = "", const string &amp;subindent = "  ");</pre><p>
		The <code class="computeroutput">res</code> argument provides the result string to append the error messages
		to. <code class="computeroutput">print()</code> works by constructing a new string internally, calling <code class="computeroutput">printTo()</code>
		on it, and then returning it, so <code class="computeroutput">print()</code> is more expensive than <code class="computeroutput">printTo()</code>.
		</p><p>
		The messages will be separated by the newline characters <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span>,
		with the proper indentation after each of these characters.
		The <code class="computeroutput">indent</code> argument specifies the initial indentation, <code class="computeroutput">subindent</code> the
		additional indentation for each level. 
		</p><p>
		The very first line will have nothing prepended to it, it's assumed that you've
		already done that indentation manually, or maybe you're appending to the end
		of some ongoing line. But all the following top-level lines will have
		the <code class="computeroutput">indent</code> text following the <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span>. The nested error
		lines will have the concatenation of <code class="computeroutput">indent</code> and one copy of <code class="computeroutput">subindent</code>
		in front of them after <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span>, the second level of nesting will have
		an <code class="computeroutput">indent</code> and two copies of <code class="computeroutput">subindent</code>, and so on.
		</p><p>
		All the lines are terminated by <span class="quote">&#8220;<span class="quote">\n</span>&#8221;</span> (except if the Errors object
		is empty, then nothing will be appended).
		</p><a class="indexterm" name="id554313"></a><p>
		Note that the constant <code class="computeroutput">NOINDENT</code> has no special effect on 
		the printing of Errors (unlike the printing of types), it's just treated 
		here as an empty string.
		</p></div><div class="sect1" title="20.8. Exception reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_exception"></a>20.8. Exception reference</h2></div></div></div><a class="indexterm" name="id582266"></a><a class="indexterm" name="id468138"></a><p>
		There are different ways to report the errors. Sometimes a function
		would return a false value. Sometime it would return an Erref with an
		error in it. And there is also a way to throw the exceptions.
		</p><p>
		In general I don't particularly like the exceptions. They tend to break
		the logic in the unexpected ways, and if not handled properly, mess up
		the multithreading. The safe way of working with exceptions is with the
		scope-based variables. This guarantees that all the allocated memory
		will be freed and all the locked data will be unlocked when the block
		exits, naturally or on an exception. However not everything can be done
		with the scopes, and this results in a whole mess of try-catch blocks,
		and a missed catch can mess up the program in horrible ways.
		</p><p>
		However sometimes the exceptions come handy. They have been a late
		addition to the Triceps version 1.0 and they have blossomed in the version 2.0. 
		</p><p>
		The overall approach in Triceps is that the exceptions are used for the
		things that Should Never Happen in a correct program, or in other words
		for the substantially fatal events. If the user attempts to do something that
		can't be executed, this qualifies for an exception. Essentially, use
		the exceptions for the things that qualify for the classic C <code class="computeroutput">abort()</code> or
		<code class="computeroutput">assert()</code>. The idea is that at this point we want to print an error
		message, print the call stack the best we can, and dump the core for
		the future analysis.
		</p><a class="indexterm" name="id486154"></a><a class="indexterm" name="id592720"></a><p>
		Why not just use an <code class="computeroutput">abort()</code> then? In the C++ code you certainly can if
		you're not interested in the extra niceties provided by the exceptions.
		In fact, that's what the Triceps exceptions do by default: when you
		construct an exception, it prints a log message,
		the Triceps scheduler stack trace (the sequence of the label calls
		that led to the code throwing the exception) and the C++ stack trace
		(using a nice feature of glibc), then calls <code class="computeroutput">abort()</code>. The error output gives the
		basic idea of what went wrong and the rest can be found from the core
		file created by <code class="computeroutput">abort()</code>.
		</p><a class="indexterm" name="id573353"></a><a class="indexterm" name="id598332"></a><p>
		However remember that Triceps is designed to be embedded into the
		interpreted (or compiled) languages. When something goes wrong
		inside the Triceps program in Perl, you don't want to get a core dump
		of the Perl interpreter. An interpreted program must never ever crash
		the interpreter. You want to get the error reported in the Perl <code class="computeroutput">die()</code>
		or its nicer cousin <code class="computeroutput">confess()</code>, and possibly intercept it in <code class="computeroutput">eval</code>.
		So the Perl wrapper of the Triceps library changes the mode of Triceps exceptions
		to actually throw the C++ exceptions instead of aborting. Since  the
		Perl code is not really interested in the details at the C++ level, the
		C++ stack trace in this case is configured not to be included into the
		text of the exception. The Triceps scheduler trace is still included.
		Eventually the
		XS interface does an analog of <code class="computeroutput">confess()</code>, including the Perl stack
		trace. When the code goes through multiple layers of Perl and C++ code
		(Perl code calling the Triceps scheduler, calling the label handlers in
		Perl, calling the Triceps scheduler again etc.), the whole layered
		sequence gets nicely unwound and reported. However the state of the
		scheduler suffers along the way: all the scheduled rowops get freed
		when their stack frame is unwound, so prepare to repair the state of
		your model if you catch the exception. Most of the time you don't
		want to catch it, just let it propagate and let the program die
		with the error message. After all, it's still a substantially fatal
		event, even in Perl, just the fatality is translated to the Perl level.
		</p><p>
		If you are willing to handle the exceptions (for example, if you add
		elements dynamically by user description and don't want the whole
		program to abort because of one faulty description), you can do the
		same in C++. Just disable the abort mode for the exceptions and catch
		them. Of course, it's even better to catch your exceptions before they
		reach the Triceps scheduler, since then you won't have to repair the
		state.
		</p><p>
		The same feature comes handy in the unit tests: when you test for the
		detection of a fatal error, you don't want your test to abort, you want
		it to throw a nice catchable exception.
		</p><a class="indexterm" name="id592959"></a><a class="indexterm" name="id603609"></a><p>
		After all this introductory talk, on to the gritty details. The class is
		Exception (as usual, in the namespace Triceps or whatever custom
		namespace you define as TRICEPS_NS), defined in <code class="computeroutput">common/Exception.h</code>.
		Inside it contains an Erref with the errors. The Exception is not intended
		for the reference counting, so it doesn't inherit from either of
		[SM]target.
		</p><p>
		An Exception can be constructed in multiple ways. Just like Errors,
		the most typical modern way is to use the static factory methods that
		perform the printf-line formatting.
		</p><pre class="programlisting">static Exception f(const char *fmt, ...);
static Exception fTrace(const char *fmt, ...);</pre><p>
		The difference between them is whether the C++ stack trace will
		ever be included.
		With <code class="computeroutput">Exception::fTrace()</code> the C++ stack trace will be
		added to the messages, if it is otherwise permitted by the Exception
		modes (see the descriptions of the flags below). 
		With <code class="computeroutput">Exception::f()</code>, the stack trace definitely won't ever be added. Why
		would you want to not add the stack trace? Two reasons:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			If you're throwing the Exception from the XS code, you know in
			advance that the user is interested only in the Perl stack trace,
			not in the C++ one. So there is no point in adding the trace.
			This is the case for <code class="computeroutput">Exception::f()</code>.
			</li><li class="listitem">
			If you catch an
			Exception, add some information to it and re-throw a new Exception. The
			information from the original Exception will already contain the full stack
			trace, so there is no need to include the partial stack trace again.
			This case is not applicable to <code class="computeroutput">Exception::f()</code> but I'll show the other
			methods where it's used.
			</li></ul></div><p>
		These factory methods are used like this:
		</p><pre class="programlisting">throw Exception::f("a message with integer %d", n);</pre><p>
		And the similar methods for construction with the nested errors,
		from an Erref or another Exception:
		</p><a class="indexterm" name="id569236"></a><pre class="programlisting">static Exception f(Onceref&lt;Errors&gt; err, const char *fmt, ...);
static Exception fTrace(Onceref&lt;Errors&gt; err, const char *fmt, ...);
static Exception f(const Exception &amp;exc, const char *fmt, ...);</pre><p>
		Unlike the Erref method, these work unconditionally (since their result
		is normally used in <code class="computeroutput">throw</code>, and it's too late to do anything by that
		time), so you better make sure in advance that there is a child error.
		A typical usage would be like this:
		</p><pre class="programlisting">try {
  ...
} catch (Exception e) {
  throw Exception::f(e.getErrors(), "error at stage %d:",  n);
}

// or more directly

try {
  ...
} catch (Exception e) {
  throw Exception::f(e, "error at stage %d:",  n);
}</pre><p>
		The methods that use Errors are available as <code class="computeroutput">f()</code> and <code class="computeroutput">fTrace()</code> while
		the method for a direct re-throwing of an Exception exists only as <code class="computeroutput">f()</code>
		because if any stack tracing was to be done, it would be already done
		in the original Exception.
		</p><p>
		Just like the Errors methods, in the resulting Exception the message
		goes before the nested errors. 
		</p><p>
		Also an Exception can be constructed by absorbing an Erref instead
		of wrapping it:
		</p><pre class="programlisting">explicit Exception(Onceref&lt;Errors&gt; err, bool trace);</pre><p>
		The <code class="computeroutput">trace</code> flag works similarly to the difference between <code class="computeroutput">f()</code> and
		<code class="computeroutput">fTrace()</code>.
		The Errors object is remembered by reference, so changing it later will
		change the contents of the Exception.
		</p><pre class="programlisting">explicit Exception(const string &amp;err, bool trace);</pre><p>
		A convenience constructor to make  a simple string with the error.
		Internally creates an Errors object with the string in it.
		</p><pre class="programlisting">explicit Exception(Onceref&lt;Errors&gt; err, const string &amp;msg);
explicit Exception(Onceref&lt;Errors&gt; err, const char *msg);
explicit Exception(const Exception &amp;exc, const string &amp;msg);</pre><p>
		The older ways of wrapping a nested error with a descriptive message
		and re-throwing it. These constructors get called inside <code class="computeroutput">f()</code> and
		<code class="computeroutput">fTrace()</code>, but the new tradition is not to use them in the user
		code, use <code class="computeroutput">f()</code> and <code class="computeroutput">fTrace()</code> instead.
		</p><pre class="programlisting">virtual const char *what();</pre><p>
		The usual, returns the text of the error messages in the Exception.
		</p><pre class="programlisting">virtual Errors *getErrors() const;</pre><p>
		Return the Errors object from the Exception.
		</p><a class="indexterm" name="id595098"></a><p>
		The modes I've mentioned before are set with the class static variables:
		</p><pre class="programlisting">static bool abort_;</pre><p>
		Flag: when attempting to create an Exception, instead print the message
		on stderr and abort. This behavior is more convenient for debugging of the C++
		programs, and is the default one. Also forces the stack trace in the
		error reports. The interpreted language wrappers should reset it to get
		the proper exceptions. Default: true.
		</p><p>

</p><pre class="programlisting">static bool enableBacktrace_;</pre><p>

		Flag: enable the backtrace if the constructor requests it. The
		interpreted language wrappers should reset it to remove the confusion
		of the C++ stack traces in the error reports. Default: true. 
		</p></div><div class="sect1" title="20.9. Initialization templates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_init"></a>20.9. Initialization templates</h2></div></div></div><a class="indexterm" name="id588413"></a><a class="indexterm" name="id565523"></a><p>
		Triceps has the common approach for building the complex objects in stages
		by the chained mehod calls (demonstrated here on a fictional class Object):
		</p><pre class="programlisting">Autoref&lt;Object&gt; o = Object::make()-&gt;addOption1(arg)-&gt;addOption2(arg);</pre><p>
		Here <code class="computeroutput">Object::make()</code> is a convenience wrapper for <code class="computeroutput">new Object</code>, 
		because the operator <code class="computeroutput">new</code> has an inconvenient
		priority. The <code class="computeroutput">new</code> or <code class="computeroutput">make()</code> returns a pointer to
		the newly constructed object, and then each method in the chain returns
		the same pointer (<code class="computeroutput">this</code>, from its standpoint) to facilitate
		the chaining.
		</p><p>
		While the chain executes, the pointer stays a simple pointer, not a
		reference. So the methods in the chain can't throw any exceptions, or
		the memory will leak. Instead they collect the error messages in an
		Errors object that has to be checked afterwards, like:
		</p><pre class="programlisting">if (o-&gt;getErrors()-&gt;hasError()) ...</pre><p>
		Note that a reference to the object gets created first, so that on
		an error the object would be properly destroyed.
		</p><p>
		The convenience template <code class="computeroutput">checkOrThrow()</code> allows to do the check along
		with the chain, and if an error is found, convert it to an Exception:
		</p><a class="indexterm" name="id415303"></a><pre class="programlisting">Autoref&lt;Object&gt; o = checkOrThrow(
  Object::make()-&gt;addOption1(arg)-&gt;addOption2(arg)
);</pre><p>
		It does all the right things with the references.
		</p><p>
		Some objects  need to be initialized after all the options have been
		set, since it's much easier to check things once and get the
		interaction of the options right rather than check on every option. And
		since the initialization might create the references to the object, to
		get it right, it has to be done after the <span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> reference is created.
		</p><pre class="programlisting">Autoref&lt;Object&gt; o = Object::make()-&gt;addOption1(arg)-&gt;addOption2(arg);
o-&gt;initialize();</pre><p>
		The template <code class="computeroutput">initialize()</code> allows to do it in one expression:
		</p><pre class="programlisting">Autoref&lt;Object&gt; o = initialize(
  Object::make()-&gt;addOption1(arg)-&gt;addOption2(arg)
);</pre><p>
		For some objects the initialization can't fail (nor any other errors
		can be created by the options). For the others, the errors needs to be
		checked afterwards, in the same way as shown above. 
		The template <code class="computeroutput">initializeOrThrow()</code> takes care of the whole sequence of
		the initialization, the check, and Exception throwing on errors:
		</p><pre class="programlisting">Autoref&lt;Object&gt; o = initializeOrThrow(
  Object::make()-&gt;addOption1(arg)-&gt;addOption2(arg)
);</pre><p>
		That's basically it. All these templates are defined in <code class="computeroutput">common/Initialize.h</code>. 
		</p></div><div class="sect1" title="20.10. Types reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_types"></a>20.10. Types reference</h2></div></div></div><a class="indexterm" name="id499756"></a><a class="indexterm" name="id585129"></a><p>
		Fundamentally, Triceps is a language, even though it is piggybacking on
		the other languages. And as in pretty much any programming language,
		pretty much anything in it has a type. Only the tip of that type system
		is exposed in the Perl API, as the RowType and TableType. But the C++
		API has the whole depth. The types go all the way down to the simple
		types of the fields.
		</p><p>
		The classes for types are generally defined in the subdirectory <code class="computeroutput">type/</code>.
		The class Type, defined in <code class="computeroutput">type/Type.h</code> is the common base class,
		inheriting from Mtarget. The types are gererally fullly constructed in one thread,
		and then they become read-only and accessible from multiple threads.
		</p><a class="indexterm" name="id553467"></a><p>
		The base class has a field that identifies, which kind of a type it is.
		Each subclass, every kind of type has its entry in the enum TypeId:
		</p><pre class="programlisting">TT_VOID, // no value
TT_UINT8, // unsigned 8-bit integer (byte)
TT_INT32, // 32-bit integer
TT_INT64,
TT_FLOAT64, // 64-bit floating-point, what C calls "double"
TT_STRING, // a string: a special kind of byte array
TT_ROW, // a row of a table
TT_RH, // row handle: item through which all indexes in the table own a row
TT_TABLE, // data store of rows (AKA "window")
TT_INDEX, // a table contains one or more indexes for its rows
TT_AGGREGATOR, // user piece of code that does aggregation on the indexes
TT_ROWSET, // an ordered set of row types</pre><a class="indexterm" name="id479775"></a><a class="indexterm" name="id572850"></a><a class="indexterm" name="id512531"></a><a class="indexterm" name="id498208"></a><p>
		Most of it is straightforward, and maps directly to the types described
		in the Perl API. TT_ROWSET is not directly exported to Perl, but
		internally and in the C++ API it's the underlying type for anything
		that uses a set of row types: an FnReturn, FnBinding, Nexus or Facet.
		TT_VOID is pretty much a placeholder, in case if a void type
		would be needed later. 
		</p><p>
		The TypeId gets hardcoded in the constructor of
		every Type subclass. It can be obtained back with the method
		</p><pre class="programlisting">TypeId getTypeId() const;</pre><p>
		Another method finds out if the type is the simple type of a field:
		</p><pre class="programlisting">bool isSimple() const;</pre><p>
		It would be true for the types of ids TT_VOID, TT_UINT8,  TT_INT32,
		TT_INT64, TT_FLOAT64, TT_STRING.
		</p><a class="indexterm" name="id573315"></a><p>
		Generally, you can check the TypeId and then cast the Type pointer to
		its subclass. All the simple types have the common base class
		SimpleType, which is described in
		<a class="xref" href="#sc_cpp_types_simple" title="20.11. Simple types reference">Section 20.11: &#8220;Simple types reference&#8221; </a>.
		</p><p>
		There is also a static Type method that finds a simple type object by
		the type name (like "int32", "string" etc.):
		</p><pre class="programlisting">static Onceref&lt;const SimpleType&gt; findSimpleType(const char *name);</pre><p>
		If the type name is incorrect and the type is not found,
		<code class="computeroutput">findSimpleType()</code> will return NULL.
		</p><p>
		There is not a whole lot of point in having many copies
		of the simple type objects (though if you want, you can). So there is
		one common copy of each simple type that can be found by name with
		<code class="computeroutput">findSimpleType()</code>. If the type is known at the compilation time of the
		C++ program, you can even avoid the look-up and refer to these
		objects directly:
		</p><pre class="programlisting">static Autoref&lt;const SimpleType&gt; r_void;
static Autoref&lt;const SimpleType&gt; r_uint8;
static Autoref&lt;const SimpleType&gt; r_int32;
static Autoref&lt;const SimpleType&gt; r_int64;
static Autoref&lt;const SimpleType&gt; r_float64;
static Autoref&lt;const SimpleType&gt; r_string;</pre><p>
		All of them are defined in the class Type, so you refer to them like
		<code class="computeroutput">Type::r_string</code>.
		</p><a class="indexterm" name="id469395"></a><p>
		The type construction may cause errors. The construction is usually done either by a
		single constructor call with all the needed arguments, or a simple
		constructor, then additional methods to add the information in bits and
		pieces, then an initialization method. In both cases there is a problem
		of how to report the errors. They're not easy to return from a
		constructor and a pain to check in the bit-by-bit construction.
		</p><p>
		Instead the error information gets internally collected in an Errors
		object, and can be read after the construction and/or initialization is
		completed:
		</p><pre class="programlisting">virtual Erref getErrors() const;</pre><a class="indexterm" name="id484718"></a><a class="indexterm" name="id567945"></a><p>
		There also are the convenience templates that do the initialization,
		check the errors and throw an Exception on failure. They are described in
		<a class="xref" href="#sc_cpp_init" title="20.9. Initialization templates">Section 20.9: &#8220;Initialization templates&#8221; </a>.
		</p><p>
		A type with errors may not be used for anything other than reading the
		errors (and of course it can be destroyed by deleting all the references
		to it). Its behavior for anything else is undefined and may cause a crash.
		</p><p>
		The rest of the common virtual methods has to do with the type
		comparison and print-outs. The comparison methods essentially check if
		two type objects are aliases for each other:
		</p><pre class="programlisting">virtual bool equals(const Type *t) const;
virtual bool match(const Type *t) const;</pre><a class="indexterm" name="id598657"></a><a class="indexterm" name="id587985"></a><p>
		The concept has been previously described with the Perl API in
		<a class="xref" href="#sc_RowTypesEquiv" title="5.3. Row types equivalence">Section 5.3: &#8220;Row types equivalence&#8221; </a>,
		but it really applies not only to the row types but to any types.
		The equal
		types are exactly the same. The matching types are the same except for
		the names of their elements, so it's generally safe to pass the values
		between these types.
		</p><p>
		<code class="computeroutput">equals()</code> is also available as <code class="computeroutput">operator==</code>.
		</p><p>
		The print methods create a string representation of a type, used mostly
		for the error messages. There is no method to parse this string
		representation back, at least not yet.
		</p><pre class="programlisting">virtual void printTo(string &amp;res, const string &amp;indent = "", const string &amp;subindent = "  ") const = 0;
string print(const string &amp;indent = "", const string &amp;subindent = "  ") const;</pre><p>
		<code class="computeroutput">printTo()</code> appends the information to an existing string. <code class="computeroutput">print()</code>
		returns a new string with the message. <code class="computeroutput">print()</code> is a wrapper around
		<code class="computeroutput">printTo()</code> that creates an empty string, does <code class="computeroutput">printTo()</code> into it and
		returns it.
		</p><p>
		The printing is normally done in a multi-line format, nicely indented,
		and the arguments <code class="computeroutput">indent</code> and <code class="computeroutput">subindent</code> define the initial indent level
		and the additional indentation for every level.
		</p><a class="indexterm" name="id537179"></a><p>
		There is also a way to print everything in one line: pass the special
		constant NOINDENT (defined in <code class="computeroutput">common/StringUtil.h</code>) in the argument
		<code class="computeroutput">indent</code>. This is similar to using an <span class="bold"><strong>undef</strong></span> for the same purpose in the
		Perl API.
		</p><a class="indexterm" name="id553901"></a><a class="indexterm" name="id594492"></a><p>
		The definitions of all the types are collected together in
		<code class="computeroutput">type/AllTypes.h</code>. 
		</p></div><div class="sect1" title="20.11. Simple types reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_types_simple"></a>20.11. Simple types reference</h2></div></div></div><a class="indexterm" name="id596354"></a><p>
		The simple types are defined as instances of the abstract class
		SimpleType, defined in <code class="computeroutput">type/SimpleType.h</code>.
		They have one method in addition to the base Type:
		</p><pre class="programlisting">int getSize() const;</pre><p>
		It returns the size of the value of this type. For void it's 0, for
		string 1 (the minimal size of an empty string, consisting of only a
		\0 at the end), for the rest of them it's a sizeof.
		This size is used to extract the values from and copy the values to the
		compact row format.
		</p><p>
		For now this is the absolute minimum of information that makes the data
		usable. The list of methods will be extended over time. For example,
		the methods for value comparisons will eventually go here. And if the
		rows will ever hold the aligned values, the alignment information too.
		</p><p>
		The classes for all the actual
		simple types are defined in <code class="computeroutput">type/AllSimpleTypes.h</code>:
		</p><a class="indexterm" name="id569371"></a><a class="indexterm" name="id601968"></a><a class="indexterm" name="id600494"></a><a class="indexterm" name="id544543"></a><a class="indexterm" name="id558691"></a><a class="indexterm" name="id606136"></a><pre class="programlisting">VoidType
Uint8Type
Int32Type
Int64Type
Float64Type
StringType</pre><p>
		You can construct the new objects of these classes but usually the
		pre-created shared objects are easier to use, as described in
		<a class="xref" href="#sc_cpp_types" title="20.10. Types reference">Section 20.10: &#8220;Types reference&#8221; </a>.
		The shared objects also make the type comparisons for equality and match more efficient,
		since the comparison gets short-circuited at the object pointer stage.
		</p></div><div class="sect1" title="20.12. RowType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_rowtype"></a>20.12. RowType reference</h2></div></div></div><a class="indexterm" name="id577386"></a><p>
		In the Perl API a row type is a collection of fields. Under the hood
		the things are more complicated. In the C++ API Triceps allows for more
		flexibility, more ways to represent a row. The row type is represented
		by the abstract base class RowType that tells the logical structure of
		a row and by its concrete subclasses that define the concrete layout of
		data in a row. To create, read or manipulate a row, all you need to
		know is a reference to RowType. It would refer to a concrete row type
		object, and the concrete row operations are accessed by the virtual
		methods. But when you create a row type, you need to know the concrete
		row type subclass.
		</p><a class="indexterm" name="id565400"></a><p>
		Currently the choice is easy: there is only one such concrete subclass
		CompactRowType. The <span class="quote">&#8220;<span class="quote">compact</span>&#8221;</span> means that the data is stored in the rows
		in a compact form, one field value after another, without alignment.
		Perhaps some day there will be an AlignedRowType, allowing to read the
		values more efficiently. Or perhaps some day there will be a
		ZippedRowType that would store the data in the compressed format.
		</p><p>
		Naturally, RowType is a Mtarget, since it inherits
		from Type, and CompactRowType inherits from it. 
		They are defined in <code class="computeroutput">type/RowType.h</code> and
		<code class="computeroutput">type/CompactRowType.h</code> but for the include purposes it's
		more customary to simply include <code class="computeroutput">type/AllTypes.h</code>.
		</p><p>
		You would never use the RowType constructor directly, it's called from
		the subclasses.  Even if you care
		only about the logical structure of a row but not representation, you still
		can't directly construct a RowType because it's an abstract class. But
		just construct any concrete subclass, say CompactRowType (since it's
		the only one available at the moment anyway), and then use its logical
		structure.
		Every subclass is expected to define a similar
		constructor:
		</p><pre class="programlisting">RowType(const FieldVec &amp;fields);
CompactRowType(const FieldVec &amp;fields);</pre><p>
		The FieldVec is the definition of fields in the row type. It's defined
		as simple as:
		</p><pre class="programlisting">typedef vector&lt;Field&gt; FieldVec;</pre><a class="indexterm" name="id596278"></a><a class="indexterm" name="id561298"></a><p>
		An important side note is that the field is defined within the RowType,
		so it's really RowType::FieldVec and RowType::Field, and you need to
		refer to them in your code by this qualified name. So, to create a row
		type, you create a vector of field definitions first and then construct
		the row type from it. You can throw away or modify that vector
		afterwards.
		</p><p>
		As usual for Type, the constructor arguments might not be correct, and any
		errors will be remembered and returned with <code class="computeroutput">getErrors()</code>. Don't use a
		type with errors (other than to read the error messages from it, and to
		destroy it), it might cause your program to crash.
		</p><p>
		A Field consists of the basic information about it: the name, the type,
		and the array indication (remember, a Triceps field may contain an
		array). The array indication is either RowType::Field::AR_SCALAR for a
		scalar value or RowType::Field::AR_VARIABLE for a variable-sized array.
		The original plan was also to use the integer values for the
		fixed-sized array fields, but in reality the variable-sized array
		fields have turned out to be easier to implement and that was it. So
		don't use the integer values. Most probably they would work like the
		same variable-sized arrays but they haven't been tested, and something
		somewhere might crash. Use the symbolic enum AR_*.
		</p><p>
		The normal Field constructor provides all this information:
		</p><pre class="programlisting">Field(const string &amp;name, Autoref&lt;const Type&gt; t, int arsz = AR_SCALAR);</pre><p>
		Or you can use the default constructor and later change the fields in
		the Field (or of course read them) as you please, they are all public:
		</p><pre class="programlisting">string name_;
Autoref &lt;const Type&gt; type_;
int arsz_;</pre><p>
		Or you can assign them later in one fell swoop:
		</p><pre class="programlisting">void assign(const string &amp;name, Autoref&lt;const Type&gt; t, int arsz = AR_SCALAR);</pre><a class="indexterm" name="id601195"></a><p>
		Note that even though theoretically you can define a field of any Type,
		in practice it has to be of a SimpleType, or the RowType constructor
		will return an error later. Why isn't it defined as an
		<code class="computeroutput">Autoref&lt;SimpleType&gt;</code> then? The grand plan for the future 
		is to allow some more
		interesting data structures in the rows, and this keeps the door open.
		In particular, the rows will be able to hold references to the other
		rows, just I haven't got to implementing it yet.
		</p><p>
		Once again, a RowType constructor makes a copy of the FieldVec for its
		use, so you can modify or destroy the original FieldVec right away. You
		can get back the information about the fields in RowType:
		</p><pre class="programlisting">const vector&lt;Field&gt; &amp;fields() const;</pre><p>
		It returns a reference directly to the FieldVec contained in the row
		type, so you must never modify it! The const-ness gives a reminder
		about it.
		</p><p>
		There are more row type constructors (but no default one). First, each
		subclass variety is supposed to be able to construct its variety by
		copying the logical structure of any RowType:
		</p><pre class="programlisting">CompactRowType(const RowType &amp;proto);
CompactRowType(const RowType *proto);</pre><p>
		The version with the pointer argument also works for passing an
		<code class="computeroutput">Autoref&lt;RowType&gt;</code> as the argument which gets automatically converted to
		a pointer (but be careful to not destroy the last reference until after the constructor
		returns). And it's really the more typically used one than the
		&amp;-reference version.
		</p><p>
		The resulting type will have the same logical structure but possibly a
		different concrete representation than the original. 
		</p><p>
		The second constructor variety is a factory method:
		</p><pre class="programlisting">virtual RowType *newSameFormat(const FieldVec &amp;fields) const;</pre><p>
		It combines the representation format from one row type and the
		arbitrary logical structure (the fields vector) from possibly another
		row type. Or course, until more of the concrete type representations become
		available, its use is largely theoretical. 
		</p><p>
		And there is also a factory method that copies the current row type
		together with its concrete representation (it's really a convenience
		wrapper over <code class="computeroutput">newSameFormat()</code>):
		</p><pre class="programlisting">RowType *copy() const;</pre><p>
		Let's get to some examples of constructing the row types. To reiterate,
		you don't construct the objects of RowType class itself, it's an
		abstract class. You construct the objects of the concrete subclass(es),
		specifically CompactRowType. Make a vector describing the fields and do
		the construction.
		</p><p>
		You can make the vector by either starting with an empty one and adding
		the fields to it or allocating a vector of the right size in advance
		and  setting the fields in it:
		</p><pre class="programlisting">RowType::FieldVec fields1;
fields1.push_back(RowType::Field("a", Type::r_int64)); // scalar by default
fields1.push_back(RowType::Field("b", Type::r_int32, RowType::Field::AR_SCALAR));
fields1.push_back(RowType::Field("c", Type::r_uint8, RowType::Field::AR_VARIABLE));

RowType::FieldVec fields2(2);
fields2[0].assign("a", Type::r_int64); // scalar by default
fields2[1].assign("b", Type::r_int32, RowType::Field::AR_VARIABLE);</pre><p>
		You can also reuse the same vector and clean/resize is as needed to
		create more types.
		</p><p>
		If you're used to laying out the C structures placing the larger
		elements first for the more efficient alignment, know that this is not
		needed for the Triceps rows. The CompactRowType stores the row data
		unaligned, so any field order will result in the same size of the rows.
		And it can't make use of some fields happening to be aligned either.
		</p><p>
		You can also find the simple types by their string names:
		</p><pre class="programlisting">fields1.push_back(RowType::Field("d", Type::findSimpleType("uint8"), RowType::Field::AR_VARIABLE));</pre><a class="indexterm" name="id610174"></a><p>
		If the type name is incorrect and the type is not found,
		<code class="computeroutput">findSimpleType()</code> will return NULL, which NULL will be caught later at
		the row type creation times. Note that there is no automatic look-up of
		the array types. You can't simply pass <span class="quote">&#8220;<span class="quote">uint8[]</span>&#8221;</span> to <code class="computeroutput">findSimpleType()</code>.
		You have to break it up into the simple type name as such an the array
		indication, like is done in <code class="computeroutput">perl/Triceps/RowType.xs</code>. This would
		probably a good thing to add to RowType::Field in the future.
		</p><p>
		You can't use the type Type::r_void for the fields, it will be reported
		as an error.
		</p><p>
		After the fields array is created, create the row type:
		</p><pre class="programlisting">Autoref&lt;RowType&gt; rt1 = new CompactRowType(fields1);
if (rt1-&gt;getErrors()-&gt;hasError())
  throw Exception(rt1-&gt;getErrors(), true);</pre><p>
		Or using the inialization templates:
		</p><pre class="programlisting">Autoref&lt;RowType&gt; rt1 = checkOrThrow(new CompactRowType(fields1));</pre><p>
		You could also use <code class="computeroutput">Autoref&lt;CompactRowType&gt;</code> but there isn't any point to
		it, since all the methods of CompactRowType are virtuals inherited from
		RowType.
		</p><p>
		Don't forget to check that the constructed type has no errors, and bail
		out if so. Throwing an Exception is a convenient way to abort with a
		nice error message, and the template <code class="computeroutput">checkOrThrow()</code> takes care of wrapping
		all the details.
		</p><p>
		The RowType and its subclasses are immutable after construction, so
		they can be shared between threads all you want. Depending on your
		approach to the threads, it might be more efficient to create a 
		separate copy of the row type for each thread. This way when the
		references to the row types are created and deleted, the reference
		count can stay in the cache of one CPU and thus be more efficient.
		The thread support of the Triceps library does use this approach
		and creates the copies whenever the row types are imported from a
		nexus.
		</p><p>
		There are multiple equivalent ways to create a copy:
		</p><pre class="programlisting">Autoref&lt;RowType&gt; rt2 = rt1-&gt;copy();
Autoref&lt;RowType&gt; rt3 = rt1-&gt;newSameFormat(rt1-&gt;fields());
Autoref&lt;RowType&gt; rt4 = new CompactRowType(rt1);</pre><p>
		Checking the errors after the copy creation is optional if the
		original type was correct.
		</p><p>
		If you want to extend a type with more fields, make a copy
		of its fields and extend it:
		</p><pre class="programlisting">RowType::FieldVec fields3 = rt1-&gt;fields();
fields3.push_back(RowType::Field("z", Type::r_string));
Autoref&lt;RowType&gt; rt3 = checkOrThrow(new CompactRowType(fields3));</pre><p>
		That's about it for the RowType construction. 
		</p><p>
		The information about the contents of a RowType can be read back:
		</p><pre class="programlisting">int fieldCount() const;
const vector&lt;Field&gt; &amp;fields() const;
int findIdx(const string &amp;fname) const;
const Field *find(const string &amp;fname) const;</pre><p>
		<code class="computeroutput">fields()</code> had already been described. <code class="computeroutput">fieldCount()</code> returns the count of
		fields. <code class="computeroutput">findIdx()</code> finds the index of the field by name, so that it can
		then be looked up in the result of <code class="computeroutput">fields()</code>. Or -1 if there is no such
		field. <code class="computeroutput">find()</code> directly returns the pointer to the field by name,
		combining these two actions. (Or it returns NULL if there is no such
		field).
		</p><p>
		The rest of the RowType methods have to do with the manipulation of the
		rows. They are described in 
		<a class="xref" href="#sc_cpp_row" title="20.13. Row and Rowref reference">Section 20.13: &#8220;Row and Rowref reference&#8221; </a>.
		</p></div><div class="sect1" title="20.13. Row and Rowref reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_row"></a>20.13. Row and Rowref reference</h2></div></div></div><a class="indexterm" name="id578764"></a><a class="indexterm" name="id583707"></a><p>
		The class Row implements a data row and is fundamentally
		an opaque buffer. You can't do anything with it directly other than
		having a pointer to it. You can't even delete a Row object using that
		pointer. To do anything with a Row, you have to go through that row's
		RowType. There are some helper classes, like
		CompactRow, but you don't need to concern yourself with them: they are
		helpers for the appropriate row types and are never used directly.
		</p><p>
		That opaque buffer is internally wired for the reference counting, of
		the Mtarget multithreaded variety. The rows can be passed and shared
		freely between the threads. No locks are needed for that (other than in
		the reference counter), the thread safety is achieved by the rows being
		immutable. Once a row is created, it stays the same. If you need to
		change a row, just create a new row with the new contents. Basically,
		it's the same rules as in the Perl API.
		</p><a class="indexterm" name="id490788"></a><p>
		The tricky part in the C++ API is that you can't simply use an
		<code class="computeroutput">Autoref&lt;Row&gt;</code> for rows. As described above, it won't know how to
		destroy the Row when its reference counter goes to zero. Instead you
		use a special variety of it called Rowref, defined in <code class="computeroutput">type/RowType.h</code>.
		It holds a reference both to the Row (that keeps the data) and to the RowType (that knows
		how to work with the Row). The RowType must be correct for the Row.
		It's possible to combine the completely unrelated Row and RowType, and
		the result will be at least some garbage data, or at most a program
		crash. The Perl wrapper goes to great lengths to make sure that this
		doesn't happen. In the C++ API you're on your own. You gain the
		efficiency at the price of higher responsibility.
		</p><p>
		The general rule is that it's safe to combine a Row and RowType if this
		RowType matches the RowType used to create that row. The matching
		RowTypes may have different names of the fields but the same substance.
		The methods described here do no type checking, and it's your responsibility
		to make sure that the types are matching.
		</p><a class="indexterm" name="id594863"></a><a class="indexterm" name="id581831"></a><p>
		A Row is created similarly to a RowType: build a vector describing the
		values in the row, call the constructor, you get the row. The vector
		type is FdataVec, and its element type is Fdata. Both of them are
		top-level (i.e. Triceps::FdataVec and Triceps::Fdata), not inside some
		other class, and both are defined in <code class="computeroutput">type/RowType.h</code>.
		</p><p>
		An Fdata describes the data for one field. It tells whether the field
		is not NULL, and if so, where to find the data to place into that
		field. It doesn't know anything about the field types or such. It deals
		with the raw bytes: the pointer to the first byte of the value, and the
		number of bytes. As a special case, if you want the field to be filled
		with zeroes, set the data pointer to NULL. It is possible to specify an
		incorrect number of bytes, such as to create an int64 field of 3
		bytes. This data will be garbage, and if it happens to be at the end of
		the row, might cause a crash when read. It's your responsibility to store the
		correct data. The same goes for the string fields: it's your
		responsibility to make sure that the data is terminated with a <span class="quote">&#8220;<span class="quote">\0</span>&#8221;</span>,
		and that <span class="quote">&#8220;<span class="quote">\0</span>&#8221;</span> is included into the length of the data. On the other
		hand, the <span class="bold"><strong>uint8[]</strong></span> array fields don't need a <span class="quote">&#8220;<span class="quote">\0</span>&#8221;</span> at the end, all the bytes
		included into them are a part of the value.
		</p><p>
		The data vector gets constructed similarly to the field vector: either
		start with an empty vector and push pack the elements, or allocate one
		of the right size and set the elements. The relevant Fdata constructors
		and methods are:
		</p><pre class="programlisting">Fdata();
Fdata(bool notNull, const void *data, intptr_t len);
void setPtr(bool notNull, const void *data, intptr_t len);
void setNull();</pre><p>
		If the argument <code class="computeroutput">notNull</code> is false, the values of <code class="computeroutput">data</code> and <code class="computeroutput">len</code>
		don't matter. The default constructor sets the <code class="computeroutput">notNull</code> to false,
		and thus can be used to create the NULL fields.
		<code class="computeroutput">setNull()</code> is also a shortcut of <code class="computeroutput">setPtr()</code> that sets the <code class="computeroutput">notNull</code> to false
		and ignores the other fields. 
		</p><p>
		The construction itself is done with the factory method <code class="computeroutput">RowType::makeRow()</code>, and typically
		the result it stored in a Rowref. Or there is a convenience constructor of Rowref
		directly from an FdataVec.
		It calls <code class="computeroutput">makeRow()</code> internally so both forms provide the same result.
		For example:
		</p><pre class="programlisting">uint8_t v_uint8[10] = "123456789"; // just a convenient representation
int32_t v_int32 = 1234;
int64_t v_int64 = 0xdeadbeefc00c;
double v_float64 = 9.99e99;
char v_string[] = "hello world";

FdataVec fd1;
fd1.push_back(Fdata(true, &amp;v_uint8, sizeof(v_uint8)-1)); // exclude \0
fd1.push_back(Fdata(true, &amp;v_int32, sizeof(v_int32)));
fd1.push_back(Fdata()); // a NULL field
fd1.push_back(Fdata(false, NULL, 0)); // another NULL field
fd1.push_back(Fdata(true, &amp;v_float64, sizeof(v_float64)));
fd1.push_back(Fdata(true, &amp;v_string, sizeof(v_string)));

Rowref r1(rt1,  rt1-&gt;makeRow(fd1));
Rowref r2(rt1,  fd1);

FdataVec fd2(3);
fd2[0].setPtr(true, &amp;v_uint8, sizeof(v_uint8)-1); // exclude \0
fd2[1].setNull();
fd2[2].setFrom(r1.getType(), r1.get(), 2); // copy from r1 field 2

Rowref r3(rt1,  fd2);</pre><p>
		The field fd2[2] shows yet another feature, copying the data from a
		field of another row. It sets the data pointer to the location inside
		the original row, and the data will be copied when the new row gets
		created. So make sure to not release the reference to the original row
		until the new row is created (Fdata has a helper field for that,
		it will be shown later).  The prototype is:
		</p><pre class="programlisting">void setFrom(const RowType *rtype, const Row *row, int nf);</pre><p>
		In the example above the vector fd2 is smaller than the number of fields in the row. The
		rest of fields are then filled with NULLs. They actually are literally
		filled with NULLs in fd2: if the size of the argument vector for
		<code class="computeroutput">makeRow()</code> is smaller than the number of fields in the row type, the
		vector gets extended with the NULL values before anything is done with
		it. It's no accident that the argument of the <code class="computeroutput">RowType::makeRow()</code> is not
		const, and the same applies to the Rowref constructor and assignment
		from FdataVec:
		</p><pre class="programlisting">class RowType {
  virtual Row *makeRow(FdataVec &amp;data) const;
};

class Rowref {
  Rowref(const RowType *t, FdataVec &amp;data);
  Rowref &amp;operator=(FdataVec &amp;data);
};</pre><p>
		It's also possible to have more elements in the FdataVec than in the
		row type. In this case the extra arguments are considered the
		<span class="quote">&#8220;<span class="quote">overrides</span>&#8221;</span>: the <span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> elements set the size and
		initial contents of the fields while the
		overrides copy the data fragments over that. 
		Remember, setting the <code class="computeroutput">data</code> argument of Fdata methods to NULL makes the elements
		initially set to all zeroes.
		</p><a class="indexterm" name="id564398"></a><a class="indexterm" name="id601919"></a><a class="indexterm" name="id569146"></a><p>
		There is a special form of constructor and a setting method to build the
		override fields:
		</p><pre class="programlisting">Fdata(int nf, intptr_t off, const void *data, intptr_t len);
void setOverride(int nf, intptr_t off, const void *data, intptr_t len);</pre><p>
		Here <code class="computeroutput">nf</code> is the number (AKA index) of the field (starting from 0) whose 
		contents is to be overridden, <code class="computeroutput">off</code> is
		the byte offset in it where the override will start, 
		and <code class="computeroutput">data</code> and <code class="computeroutput">len</code> point to the location to copy
		from as usual. 
		</p><p>
		The overrides are a convenient way to
		assemble the array fields from the fragments. The following
		example shows the various permutations:
		</p><pre class="programlisting">RowType::FieldVec fields4;
fields4.push_back(RowType::Field("a", Type::r_int64, RowType::Field::AR_VARIABLE));

Autoref&lt;RowType&gt; rt4 = checkOrThrow(new CompactRowType(fields4));

FdataVec fd4;
Fdata fdtmp;

// allocate space for 10 int64s, initially all 0s
fd4.push_back(Fdata(true, NULL, sizeof(v_float64)*10));

// override an element at index 2
fd4.push_back(Fdata(0, sizeof(v_int64)*2, &amp;v_int64, sizeof(v_int64)));

// fill a temporary element with setOverride and apply it at index 4
fdtmp.setOverride(0, sizeof(v_int64)*4, &amp;v_int64, sizeof(v_int64));
fd4.push_back(fdtmp);

// manually copy an element from r1 to the index 5
fdtmp.nf_ = 0;
fdtmp.off_ = sizeof(v_int64)*5;
r1.getType()-&gt;getField(r1.get(), 2, fdtmp.data_, fdtmp.len_);
fd4.push_back(fdtmp);

Rowref r4(rt4,  fd4);</pre><p>
		This creates a row type from a single field <span class="quote">&#8220;<span class="quote">a</span>&#8221;</span> at index 0, an array of
		int64. The data vector  fd4 has the 0th element define the space for 10
		elements in the array, filled by default with zeroes. It doesn't have
		to zero them, it could have copied the data from some location in memory. I've
		just done the zeroing here to show how it can be done.
		</p><p>
		The rest of elements are the overrides constructed in different ways.
		</p><p>
		The first override sets the 2nd element (counting from 0) of the
		array with the value from v_int64.
		</p><p>
		The second override uses the method <code class="computeroutput">setOverride()</code> for the same purpose
		on the 4th element.
		It sets a temporary Fdata which then gets appended (copied) to the
		vector. 
		</p><p>
		The third override shows a more involved way.
		It copies the value from the row r1. Since there is no
		ready method for this purpose (perhaps there should be?), it goes about
		its way manually, setting the fields explicitly. <code class="computeroutput">nf_</code> is the same as <code class="computeroutput">nf</code>
		in the methods, the field number to override. <code class="computeroutput">off_</code> is the offset. And
		the location and length get filled into <code class="computeroutput">data_</code> and <code class="computeroutput">len_</code> by <code class="computeroutput">getField()</code>,
		which takes the data from the row r1, field 2.
		</p><p>
		But wait, the field 2 of r1 has been set to NULL! Should not the NULL
		indication be set in the copy as well? As it turns out, no. The NULL
		indication (the field <code class="computeroutput">notNull_</code> being set to false) is ignored by
		<code class="computeroutput">makeRow()</code> in the override elements. However <code class="computeroutput">getField()</code> will set the
		length to 0, so nothing will get copied. The value at index 5 will be
		left as it was initially set, which happens to be 0.
		</p><p>
		So in the end the values in the field <span class="quote">&#8220;<span class="quote">a</span>&#8221;</span> array at indexes 2 and 4 will
		be set to the same as v_int64, and at the other indexes 0...9 to 0.
		</p><p>
		If multiple overrides specify the overlapping ranges, they will just
		sequentially overwrite each other, and the last one will win.
		</p><p>
		If an override attempts to specify writing past the end of the
		originally reserved area of the field, it will be quietly ignored. Just
		don't do this. If the field was originally set to NULL, its reserved
		area will be zero bytes, so any overrides attempting to write into it
		will be silently ignored.
		</p><p>
		The summary is: the overrides allow to build the array values
		efficiently from the disjointed areas of memory, but if they are used,
		they have to be used with care.
		</p><p>
		And for the reference the fields of Fdata that can be accessed directly:
		</p><pre class="programlisting">Rowref row_; // in case if data comes from another row, can be used
  // to keep a hold on it, but doesn't have to
  // if the row won't be deleted anyway
const char *data_; // data to store, may be NULL to just zero-fill
intptr_t len_; // length of data to store
intptr_t off_; // for overrides only: offset into the field
int nf_; // for overrides only: index of field to fill
bool notNull_; // this field is not null (only for non-overrides)</pre><p>
		The field <code class="computeroutput">row_</code> has been mentioned before. It's a convenience placeholder
		for copying data from another row (and possibly replacing some of the
		fields). You don't have to use it if you know that a reference to
		the original row is kept somewhere until the construction of the new
		row is completed. But sometimes this is difficult to do while
		keeping the scopes straight. Then you can make <code class="computeroutput">row_</code> refer to the
		original row, and it's guaranteed to stay valid. Of course, if
		you want to copy the fields from more than one original row,
		you really have to keep the references to them in some other way.
		</p><a class="indexterm" name="id578364"></a><p>
		As has been said at the start of this section, all the operations
		on the rows are done through the RowType's methods. Let's take a closer
		look at them. And to reiterate once again, the row must be created
		with a matching type.
		</p><pre class="programlisting">bool isFieldNull(const Row *row, int nf) const;</pre><p>
		Check whether a field is NULL, <code class="computeroutput">nf</code> is the number (AKA index) of the field
		starting from 0.
		</p><pre class="programlisting">bool getField(const Row *row, int nf, const char *&amp;ptr, intptr_t &amp;len) const;</pre><p>
		Get a field's data, <code class="computeroutput">nf</code> is the index (AKA <span class="quote">&#8220;<span class="quote">number</span>&#8221;</span>) of the field starting from
		0.  The returned value will be true if the field is not NULL.  The
		values at arguments <code class="computeroutput">ptr</code> and <code class="computeroutput">len</code> will be populated with
		the pointer to the field's data in the row and its length information.
		If the field is NULL, they will be set to NULL and 0.
		</p><p>
		The returned data pointer type is constant, to remind that the rows are
		immutable and the data in them must not be changed.
		However for the most types you can't refer by this pointer and get the
		desired value directly, because the data might not be aligned right for
		that data type. Because of this the returned pointer is a <code class="computeroutput">char*</code> and not
		<code class="computeroutput">void*</code>. If you have an int64 field, you can't just do:
		</p><pre class="programlisting">int64_t *data;
intptr_t len;
if (getField(myrow, myfield, data, len)) {
  int64_t val = *data; // WRONG!
}</pre><p>
		Fortunately, the type checks will catch this usage attempt right at the
		call of <code class="computeroutput">getField()</code>. But there also are the convenience functions that
		return the values of particular types. They are implemented over
		<code class="computeroutput">getField()</code> and take care of the alignment issue.
		</p><pre class="programlisting">uint8_t getUint8(const Row *row, int nf, int pos = 0) const;
int32_t getInt32(const Row *row, int nf, int pos = 0) const;
int64_t getInt64(const Row *row, int nf, int pos = 0) const;
double getFloat64(const Row *row, int nf, int pos = 0) const;
const char *getString(const Row *row, int nf) const;</pre><p>
		The convenience wrappers for getting the values of specific types.
		The <code class="computeroutput">getString()</code> returns only the pointer to the start of the
		string, not the length, expecting that you will treat it like a C
		string and rely on the <span class="quote">&#8220;<span class="quote">\0</span>&#8221;</span> at the end. Obviously,
		if a string contains <span class="quote">&#8220;<span class="quote">\0</span>&#8221;</span> in the middle, that would
		not work very well, and if you care about that, use <code class="computeroutput">getField()</code>
		directly instead.
		</p><p>
		If the field is NULL, these methods return the value of 0 for the numeric types,
		and an empty string (<span class="quote">&#8220;<span class="quote"></span>&#8221;</span>) for the string type, thus
		simulating the Perl semantics of undefined values. If you care
		about the field being NULL, check it separately:
		</p><pre class="programlisting">if (!rt1-&gt;isFieldNull(r1, nf)) {
  int64_t val = rt1-&gt;getInt64(r1, nf);
  ...
}</pre><p>
		The field <code class="computeroutput">pos</code> is the position in an array field. 
		It's an array index, not a byte offset.
		These methods don't
		care very much about the differentiation of scalars and arrays, from
		their standpoint a scalar is the same thing as an array of length 1.
		So the default value <code class="computeroutput">pos</code> = 0 works well for the scalars. For the arrays,
		if pos is beyond the end of the array, the result is the same as
		for a NULL field. Even more so, a NULL field is considered the same 
		thing as an array of length 0, and it's really just a specific case
		of the general rule: for a NULL field any <code class="computeroutput">pos</code> value is considered
		to be beyond the end of the array.
		</p><p>
		For a side note, the arguments of these calls are Row*, not Rowref.
		It's cheaper, and OK for memory management because it's expected that
		the row would be held in a Rowref variable anyway while the data is
		extracted from it. Don't construct an anonymous rowref object and
		immediately try to extract a value from it!
		</p><pre class="programlisting">int64_t val = rt1-&gt;getInt64(Rowref(rt1, datavec), nf); // WRONG!</pre><p>
		However if you have an Fdata vector, there is no point in constructing a
		row to extract back the same data in the first place.
		</p><p>
		The Rowref has the same-named convenience methods to access the
		row stored in it, using the type stored in it. They are described in
		detail below.
		</p><pre class="programlisting">void splitInto(const Row *row, FdataVec &amp;data) const;</pre><p>
		A convenience for copying the rows with modification of some fields.
		Does the first part of the copying: splits the original row into the
		field data references which can then be modified (the Fdata entries,
		not the data itself) to change some fields. The vector referred by
		the <code class="computeroutput">data</code> argument will be resized to the number of fields in this row
		type and filled with the information. This method <span class="bold"><strong>does not</strong></span>
		modify <code class="computeroutput">data.row_</code> in any way, if you want to put a reference to
		the original row in there, you have to do it manually.
		</p><pre class="programlisting">Row *makeRow(FdataVec &amp;data) const;</pre><p>
		Create a row from the data vector, as described above. If the size of
		<code class="computeroutput">data</code> is less than the number of fields in this row type, the vector
		will be extended with the NULL fields before creating the row. If the
		vector size is larger, the rest of fields will be treated as overrides.
		</p><pre class="programlisting">void destroyRow(Row *row) const;</pre><p>
		The destructor for the rows. Normally is should never be called manually,
		instead use Rowref to maintain the proper reference count and do the
		destruction when the reference count goes to 0.
		</p><pre class="programlisting">Row *copyRow(const RowType *rtype, const Row *row) const;</pre><p>
		Copy a row, essentially a combination of <code class="computeroutput">splitInto()</code> and <code class="computeroutput">makeRow()</code>.
		Here the current row type and the <code class="computeroutput">rtype</code> argument (which is
		the type of the argument <code class="computeroutput">row</code>) don't have to
		be completely matching, the restriction is more loose:
		one of them has to be a matching prefix of the other.
		In other words, one of the types may have extra fields.
		This method automatically takes care of either cutting these
		extra fields if the result type is shorter or adding extra NULL fields
		if the result type is longer.
		</p><pre class="programlisting">static void fillFdata(FdataVec &amp;v, int nf);</pre><p>
		Fill an FdataVec, extending it with NULL fields to the size <code class="computeroutput">nf</code>.
		If the vector is of an already the same length or longer, it is left
		unchanged. Note that this method is static. There is practically no
		need to call it manually, <code class="computeroutput">makeRow()</code> calls it for you automatically.
		</p><pre class="programlisting">bool equalRows(const Row *row1, const Row *row2) const;</pre><a class="indexterm" name="id606477"></a><p>
		Check two rows for an absolute equality. Returns true if the rows are
		equal, otherwise false. This is the method used by the FIFO indexes
		to find the equal rows by value.
		Right now it's defined to work only on the rows of the same type,
		including the same representation (but since only one CompactRowType
		representation is available, this is not a problem). When more
		representations become available, it will likely be extended.
		</p><pre class="programlisting">bool isRowEmpty(const Row *row) const;</pre><p>
		Check the row for emptiness. Returns true if all the fields in the
		row are NULL.
		</p><pre class="programlisting">void hexdumpRow(string &amp;dest, const Row *row, const string &amp;indent="") const;</pre><p>
		Dump the bytes of the row in a hexadecimal format, appending to the
		destination string <code class="computeroutput">dest</code>. This method is rarely needed in practice,
		only to investigate some strange data corruptions. Since the Row object
		is opaque, the length of its data is hidden. This method finds the
		length and then passes the data to <code class="computeroutput">hexdump()</code>, described in
		<a class="xref" href="#sc_cpp_string" title="20.5. String utilities">Section 20.5: &#8220;String utilities&#8221; </a>.
		</p><a class="indexterm" name="id591758"></a><a class="indexterm" name="id610115"></a><p>
		And finally, as promised at the start of the section, a reference of Rowref,
		defined in <code class="computeroutput">type/RowType.h</code>.
		Overall, it's a variety of Autoref, so all the Autoref methods (except constructors)
		work unchanged, and a few more methods are added.
		</p><p>
		First, let's dig into some more details of why it is needed.
		The rows in Triceps aren't necessarily just blobs of memory.
		This feature isn't used anywhere yet, but the rows in Triceps are designed to be
		able to contain references to the other rows and in general to the other
		objects.  So they can't be destroyed by just freeing the memory. The
		destructor must know, how to release the references to these nested
		objects first. And knowing where these references are depends on the
		type of the row. And rows may be of different types. This calls for a
		virtual destructor.
		</p><p>
		But having a virtual destructor requires that every object has a
		pointer to the table of virtual functions. That adds an overhead of 8
		bytes per row, and the rows are likely to be kept by the million, and
		that overhead adds up. So I've made the decision to save these 8 bytes
		and split that knowledge. It might turn out to be a premature optimization,
		but since it's something that would be difficult to change later, I've
		got it in early.
		</p><p>
		The knowledge of how to destroy a row (and also how to copy the row and
		to access the elements in it) is kept in the row type object. So a
		reference to a row needs to know two things: the row and the row's
		type. It's still the same extra 8 bytes of a pointer, but there are only a
		few row references active at a time (the tables don't use the common
		row references to keep the rows, instead they are implemented as a
		special case and have one single row type for all the rows they store).
		</p><p>
		The constructor puts both these items into a Rowref:
		</p><pre class="programlisting">Rowref();
Rowref(const RowType *t, Row *r = NULL);
Rowref(const Rowref &amp;ar);</pre><p>
		The RowType will be referred from the new Rowref through an Autoref. So after
		you've created the Rowref, feel free to discard any other references to the
		RowType, the Rowref will keep it alive.
		</p><p>
		The RowType may be NULL if the Row is NULL.
		</p><p>
		The default constructor sets them both to NULL. Which is dangerous: make
		sure to assign a proper RowType when you assign a Row, or your program
		will crash on a NULL pointer. In fact, initially this class had no default
		constructor because of this danger. But eventually the convenience of the
		default constructor had outweighed the danger. Just be careful.
		</p><pre class="programlisting">Rowref(const RowType *t, FdataVec &amp;data);</pre><p>
		The convenience constructor that wraps the making of the Row from FdataVec.
		</p><pre class="programlisting">Rowref &amp;operator=(const Rowref &amp;ar);</pre><p>
		Assign from another Rowref, copying both the RowType and Row.
		</p><pre class="programlisting">void assign(const RowType *t, Row *r);</pre><p>
		Assign the explicit RowType and Row. The Row may be NULL. The RowType might
		also be NULL, but only if the Row is NULL.
		</p><pre class="programlisting">Rowref &amp;operator=(Row *r);</pre><p>
		Assign just the Row, preserving the RowType. Make sure that the previously set
		type is not NULL and matches the row!
		</p><pre class="programlisting">Rowref &amp;operator=(FdataVec &amp;data)</pre><p>
		A convenience wrapper: make the Row from FdataVec and assign it. Rowref's
		current RowType is used to construct the Row, so it must be not NULL.
		</p><pre class="programlisting">Rowref &amp;copyRow(const RowType *rtype, const Row *row);
Rowref &amp;copyRow(const Rowref &amp;ar);</pre><p>
		More convenience wrappers: make a copy of a Row and assign it. The usual
		caveats of copying and assignment apply. And the original row must not be NULL.
		</p><pre class="programlisting">Row *get() const;
const RowType *getType() const;</pre><p>
		Get the row an the type back. 
		</p><p>
		The usual conversion to a Row pointer and
		the operator <code class="computeroutput">-&gt;</code> on it also work automatically, and <code class="computeroutput">isNull()</code>
		checks if the Row is NULL. The operators <code class="computeroutput">==</code> and <code class="computeroutput">!=</code> check for the
		equality of the Row pointer, ignoring the RowType pointer.
		</p><pre class="programlisting">bool isRowEmpty() const</pre><p>
		Another convenience wrapper for checking if all the fields in the Row are NULL.
		The Row pointer itself must not be NULL.
		</p><pre class="programlisting">uint8_t getUint8(int nf, int pos = 0) const;
int32_t getInt32(int nf, int pos = 0) const;
int64_t getInt64(int nf, int pos = 0) const;
double getFloat64(int nf, int pos = 0) const;
const char *getString(int nf) const;</pre><p>
		These convenience wrappers work exactly the same as the methods of the RowType.
		The Row must not be NULL.
		</p></div><div class="sect1" title="20.14. TableType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_tabtype"></a>20.14. TableType reference</h2></div></div></div><a class="indexterm" name="id587217"></a><p>
		The TableType describes the type of a table, defined in
		<code class="computeroutput">type/TableType.h</code>. It inherits being an Mtarget from the Type,
		and can be shared between the threads after it has been initialized.
		However like RowType, it can benefit from creating a separate copy
		for each thread, to keep the reference count changes local to one
		CPU (see the method <code class="computeroutput">deepCopy()</code> below).
		</p><p>
		In the C++ API it's built very similarly to the current
		Perl API, by constructing a bare object, then adding information to it,
		and finally initializing it. The Perl API will eventually change to
		something more Perl-like, the C++ API will stay this way.
		</p><p>
		The creation goes like this:
		</p><a class="indexterm" name="id461536"></a><pre class="programlisting">Autoref&lt;TableType&gt; tt = initializeOrThrow( (new TableType(rt1))
  -&gt;addSubIndex("primary", it
  )-&gt;addSubIndex("secondary", itcopy
  )
);</pre><p>
		In reality the index types would also be constructed as a part of this
		long statement but for clarity they were assumed to be pre-created
		as <code class="computeroutput">it</code> and <code class="computeroutput">itcopy</code>. 
		</p><p>
		After a table type has been initialized, nothing can be added to it any
		more. Just as in the Perl API, the <code class="computeroutput">addSubIndex()</code> adds not its argument
		index type object but its deep copy (see more about the copy varieties in 
		<a class="xref" href="#sc_cpp_copy" title="20.4. The many ways to do a copy">Section 20.4: &#8220;The many ways to do a copy&#8221; </a>).
		When the table type gets initialized, these index types get tied to it.
		</p><p>
		Note that the operator <code class="computeroutput">new</code> has to be in parenthesis to get the
		priorities right. It's kind of annoying, so the better-looking
		equivalent way to do it is to use the static method <code class="computeroutput">make()</code>:
		</p><pre class="programlisting">Autoref&lt;TableType&gt; tt = initializeOrThrow(TableType::make(rt1)
  -&gt;addSubIndex("primary", it
  )-&gt;addSubIndex("secondary", itcopy
  )
);</pre><p>
		And here is a more complete example, with making of all the
		components in one chain:
		</p><pre class="programlisting">Autoref&lt;TableType&gt; tt = initializeOrThrow(TableType::make(rt1)
  -&gt;addSubIndex("primary", HashedIndexType::make(
    NameSet::make()-&gt;add("a")-&gt;add("e"))
    -&gt;setAggregator(new MyAggregatorType("onPrimary", NULL))
    -&gt;addSubIndex("level2", new FifoIndexType)
  )
);</pre><p>
		The construction-related methods are:
		</p><pre class="programlisting">TableType(Onceref&lt;RowType&gt; rt);
static TableType *make(Onceref&lt;RowType&gt; rt);
TableType *addSubIndex(const string &amp;name, IndexType *index);
void initialize();</pre><p>
		The method <code class="computeroutput">initialize()</code> is called by the <code class="computeroutput">initializeOrThrow()</code> template,
		which then checks for errors and throws an Exception if it finds any.
		But you can call it manually instead if you wish.
		</p><p>
		The working of the <code class="computeroutput">addSubIndex()</code> is such that it doesn't put its
		<code class="computeroutput">this</code> object into any kind of Autoref. Because of that it's able to
		pass that pointer right through to its result for chaining. It doesn't
		check anything and can't throw any exceptions. So the TableType object
		created by the constructor gets through the chain of <code class="computeroutput">addSubIndex()</code>
		without having any counted references to it created, its reference
		count stays at 0. Only when the result of the chain is assigned to an
		Autoref, the first reference gets created. Obviously, this chain must
		not be interrupted by any exceptions or the memory will leak. Any
		detected errors must be collected in the embedded error objects, that
		will be read after initialization.
		</p><p>
		The result of initialization is void for a good reason: if you call
		<code class="computeroutput">initialize()</code> manually, you can't include it into this chain, and the
		void result forces the non-chained call. Before the initialization is
		called, the TableType object must be properly held in a counted
		reference.  For example:
		</p><pre class="programlisting">Autoref&lt;TableType&gt; tt = TableType::make(rt1)
  -&gt;addSubIndex("primary", it
  )-&gt;addSubIndex("secondary", itcopy
  );
tt-&gt;initialize();
if (tt-&gt;getErrors()-&gt;hasError())
  throw Exception(tt-&gt;getErrors());</pre><p>
		But <code class="computeroutput">initializeOrThrow()</code> is smart enough to do things correctly
		within the chained call format.
		It saves the TableType in an Autoref, then calls <code class="computeroutput">initialize()</code>,
		and on success returns that Autoref, never corrupting the references.
		It involves a little more overhead but the TableType construction
		usually happens only once at the start-up time, and thus a minor
		difference in efficiency doesn't matter.
		</p><p>
		It's safe to call <code class="computeroutput">initialize()</code> multiple times, the repeated calls will
		simply have no effect.
		</p><a class="indexterm" name="id572113"></a><p>
		The sub-indexes may be added only while the table type is not
		initialized, afterwards it will throw an Exception.
		</p><p>
		The methods to examine the contents of the table type are:
		</p><pre class="programlisting">bool isInitialized() const;</pre><p>
		Check whether the table type has been initialized.
		</p><pre class="programlisting">const RowType *rowType() const;</pre><p>
		Returns the row type of the table type. Since the table type is not
		expected to be destroyed immediately, it's OK to return a plain
		pointer.
		</p><pre class="programlisting">IndexType *findSubIndex(const string &amp;name) const;</pre><p>
		Find the index by name. Returns NULL if not found.  This looks only for
		the top-level indexes, to find the nested indexes, the similar calls
		have to be continued on the further levels. At the moment there is no
		ready method to resolve a whole index path in C++, however the
		same method in IndexType has a special feature that allows to
		do it by simple chaining:
		</p><pre class="programlisting">Autoref&lt;IndexType&gt; it = tt-&gt;findSubIndex("level1")-&gt;findSubIndex("level2");
if (it.isNull()) {
  // not found
}</pre><p>
		That special feature is that <code class="computeroutput">findSubIndex()</code> in IndexType works
		even on a NULL reference, simply returning NULL. So if 
		<code class="computeroutput">findSubIndex("level1")</code> returns NULL,
		<code class="computeroutput">findSubIndex("level2")</code> will simply propagate that NULL.
		The downside compared with the path-resolving method in Perl
		is that this chain doesn't tell you, which of the indexes in the
		path were not found.
		</p><pre class="programlisting">IndexType *findSubIndexById(IndexType::IndexId it) const;</pre><p>
		Finds the first index type of a particular kind (or NULL if none
		found). The ids are like IndexType::IT_HASHED, IndexType::IT_FIFO,
		IndexType::IT_SORTED.
		</p><pre class="programlisting">IndexType *getFirstLeaf() const;</pre><p>
		Finds the first leaf index type. This call does search through the
		whole depth of the index tree for the first leaf index type.
		</p><pre class="programlisting">const IndexTypeVec &amp;getSubIndexes() const;</pre><p>
		Returns the vector with all the top-level index type references. The
		vector is read-only, you must not change it. 
		</p><pre class="programlisting">TableType *copy() const;</pre><a class="indexterm" name="id553215"></a><a class="indexterm" name="id618998"></a><p>
		Copy the table type, including all its contents of IndexTypes
		and AggregatorTypes, because they get tied to no more than one
		TableType. However the RowTypes stay shared.
		The copied table type is always uninitialized and thus can
		be further extended by defining more indexes and aggregators.
		</p><p>
		In case if the table type collected errors, the errors aren't copied,
		and in general you should not copy such a table type. The errors
		will be detected again when you try to initialize the copy.
		</p><pre class="programlisting">TableType *deepCopy(HoldRowTypes *holder) const;</pre><a class="indexterm" name="id482083"></a><a class="indexterm" name="id588493"></a><p>
		Copy the whole strucutre all the way down, up to and including the
		row types. This is used for exporting the TableTypes to the other
		threads through a Nexus. It keeps the reference counts localized to
		each thread, preventing the thrashing of them between CPUs as the
		references are created and destroyed.
		</p><p>
		The HoldRowTypes object is what takes care of sharing the underlying
		row types. To copy a bunch of objects with sharing, you create a
		HoldRowTypes, copy the bunch, destroy the HoldRowTypes,
		as described in more detail in
		<a class="xref" href="#sc_cpp_copy" title="20.4. The many ways to do a copy">Section 20.4: &#8220;The many ways to do a copy&#8221; </a>.
		</p><p>
		The Perl API contains one more copy method, <code class="computeroutput">copyFundamental()</code>.
		It's not directly available in the C++ API yet but the same task can be
		done manually.
		</p><p>
		Ultimately, the TableType is used to construct the tables. The factory
		method is:
		</p><pre class="programlisting">Onceref&lt;Table&gt; makeTable(Unit *unit, const string &amp;name) const;</pre><p>
		This creates a table with the given name in a given unit. 
		If the table type is not initialized or the initialization
		returned an error, will return NULL.
		</p><p>
		Finally, there is a call that you don't need to use:
		</p><pre class="programlisting">RowHandleType *rhType() const;</pre><a class="indexterm" name="id591718"></a><p>
		Like everything else, the RowHandles have a type. But this type is very
		much internal, and it knows very little about the row handles. All it
		knows is how much memory to allocate when constructing a new RowHandle.
		The rest of the knowledge about the RowHandles is placed inside the
		Table. So, a Table (yes, a Table, <span class="bold"><strong>not</strong></span> a TableType) acts among
		the other things as a type for its RowHandles. 
		</p></div><div class="sect1" title="20.15. NameSet reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_nameset"></a>20.15. NameSet reference</h2></div></div></div><a class="indexterm" name="id550094"></a><a class="indexterm" name="id568733"></a><p>
		NameSet is a helper class used as an argument for construction of
		other classes, most notably HashedIndexType. It's an Mtarget.
		</p><p>
		NameSet is fundamentally a reference-counted vector of strings that
		allows to construct them with a chain of calls. It's used to
		construct such things as field list for the index key. 
		Properly, the names in the set should be different
		but NameSet itself doesn't check for that.
		The order of values in it usually matters. So its class name is slightly
		misleading: it's not really a set, it's a vector, but the name has been
		applied historically. And in the future it might include the set
		functionality too, by adding a quick look up of index by name.
		</p><p>
		It's defined in <code class="computeroutput">type/NameSet.h</code> as
		</p><pre class="programlisting">class NameSet : public Mtarget, public vector&lt;string&gt; { ... }</pre><p>
		The typical usage is like this:
		</p><pre class="programlisting">HashedIndexType::make(NameSet::make()-&gt;add("a")-&gt;add("e"))</pre><p>
		The factory method <code class="computeroutput">make()</code> gives the
		more convenient operator priority than <code class="computeroutput">new()</code>.
		The varieties of constructors and <code class="computeroutput">make()</code> are:
		</p><pre class="programlisting">NameSet();
NameSet(const vector&lt;string&gt; *other);
NameSet(const vector&lt;string&gt; &amp;other);
static NameSet *make();
static NameSet *make(const vector&lt;string&gt; *other);
static NameSet *make(const vector&lt;string&gt; &amp;other);</pre><p>
		This approach to the copy constructors allows to
		construct from a plain vector, and since NameSet is its
		subclass, that works as a real copy constructor too. 
		The constructor from a pointer makes the use of Autorefs more
		convenient, such as:
		</p><pre class="programlisting">Autoref&lt;NameSet&gt; ns1 = NameSet::make()-&gt;add("a")-&gt;add("b");
Autoref&lt;NameSet&gt; ns2 = NameSet::make(ns1)-&gt;add("c");</pre><p>
		All the vector methods are directly accessible, plus the ones
		added in NameSet.
		</p><pre class="programlisting">NameSet *add(const string &amp;s);</pre><p>
		The method for the chained construction, adds a name to the vector
		and returns back the same NameSet object.
		</p><pre class="programlisting">bool equals(const NameSet *other) const;</pre><p>
		Comparison for equality. Returns true if both the name vectors
		are equal.
		</p></div><div class="sect1" title="20.16. IndexType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_idxtype"></a>20.16. IndexType reference</h2></div></div></div><a class="indexterm" name="id597672"></a><p>
		Very much like the Perl API, the IndexType is an abstract class, in
		which you can't create the objects directly, you have to create the
		objects with its concrete sub-classes. It has the methods common for
		all the index types, it is defined in <code class="computeroutput">type/IndexType.h</code>
		and like all types it's an Mtarget.
		</p><p>
		The index type id, defined as enum IndexType::IndexId, allows to find
		out the subclass of the actual object and cast it if desired.
		The supported index types are:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			IT_HASHED,
			</li><li class="listitem">
			IT_FIFO,
			</li><li class="listitem">
			IT_SORTED. 
			</li></ul></div><p>
		There is
		also the semi-hidden type IT_ROOT: you can't create it directly but
		every table type creates one implicitly, as the root of its index tree.
		And the value IT_LAST is defined past the last actual type, so if you ever
		need to iterate through the types, you can do it as
		</p><pre class="programlisting">for (int i = 0; i &lt; IndexType::IT_LAST; i++) { ... }</pre><p>
		The conversion between the index type id and name can be done with the
		methods:
		</p><pre class="programlisting">static const char *indexIdString(int enval, const char *def = "???");
static int stringIndexId(const char *str);</pre><p>
		As usual with the contant-and-name conversions, if the numeric id <code class="computeroutput">enval</code> is
		invalid, the string <code class="computeroutput">def</code> is returned, by default <span class="quote">&#8220;<span class="quote">???</span>&#8221;</span>. If the string
		name <code class="computeroutput">str</code> is unknown, -1 is returned.
		</p><pre class="programlisting">IndexId getIndexId() const;</pre><p>
		Returns the type id of this index type. The id can't be changed, it gets
		hardcoded in the subclass constructor.
		</p><pre class="programlisting">IndexType *addSubIndex(const string &amp;name, Onceref&lt;IndexType&gt; index);</pre><p>
		Add a sub-index, in exactly the same way as adding an index type to
		the TableType. 
		</p><p>
		In works like TableType in all the other ways as well:
		it adds a copy of the argument, not the argument
		itself, and it designed for chaining. For example:
		</p><pre class="programlisting">Autoref&lt;TableType&gt; tt = initializeOrThrow( TableType::make(rt1)
  -&gt;addSubIndex("primary", HashedIndexType::make(
    NameSet::make()-&gt;add("b")-&gt;add("c"))
  )-&gt;addSubIndex("limit", FifoIndexType::make()
    -&gt;setLimit(2) // will policy-delete 2 rows
  )
);</pre><a class="indexterm" name="id606301"></a><p>
		Not all index types allow sub-indexes but this method
		works silently for all of them. Any mistakes will be detected and
		reported at the initialization time. The sub-indexes may be added
		only until the index type is initialized. Any modification attempts
		after that will throw an Exception.
		</p><pre class="programlisting">bool isLeaf() const;</pre><p>
		Returns true if this index type has no sub-indexes. Of course, if this
		type is not initialized yet, more sub-types can be added to it to make
		it non-leaf later.
		</p><pre class="programlisting">IndexType *findSubIndex(const string &amp;name) const;
IndexType *findSubIndexById(IndexId it) const;</pre><p>
		Find the sub-index by name or id, works in the same way as for
		TableType. A special feature is that it can be applied on a NULL object
		reference, like this:
		</p><pre class="programlisting">Autoref&lt;IndexType&gt; it; // NULL by default
Autoref&lt;IndexType&gt; itsub = it-&gt;findSubIndex("xxx"); // doesn't crash, returns NULL</pre><p>
		The idea here is to allow the safe chaining of <code class="computeroutput">findSubIndex()</code> for the
		look-ups of the nested types:
		</p><pre class="programlisting">Autoref&lt;IndexType&gt; it = tt-&gt;findSubIndex("level1")-&gt;findSubIndex("level2");
if (it.isNull()) {
  // not found
}</pre><p>
		If any of the elements in the path are missing, the end result will be
		NULL, conveniently. But it won't tell you, which one was missing,
		inconveniently.
		</p><pre class="programlisting">const IndexTypeVec &amp;getSubIndexes() const;</pre><p>
		Returns back the whole set of sub-indexes.
		</p><pre class="programlisting">IndexType *getFirstLeaf() const;</pre><p>
		Returns the first leaf index type (if a leaf itself, will return
		itself).
		</p><pre class="programlisting">const NameSet *getKey() const;</pre><p>
		Get the key information from the index.
		It will work with any kind of index, but will return a NULL if the
		index doesn't support the key. There is no matching method to
		set it, setting the key is up to the subclasses.
		</p><pre class="programlisting">IndexType *setAggregator(Onceref&lt;AggregatorType&gt; agg);
const AggregatorType *getAggregator() const;</pre><p>
		Set or get an aggregator type for this index type. As usual, any
		setting can be done only until the index type is initialized. 
		Any modification attempts after that will throw an Exception.
		</p><pre class="programlisting">bool isInitialized() const;</pre><p>
		Check whether the index type has been initialized.
		The index types are initialized as a part of the table type
		initialization, there is no method to initialize an index
		type directly.
		</p><pre class="programlisting">TableType *getTabtype() const;</pre><p>
		Returns the table type, to which this index type is tied. The
		tying-together happens at the initialization time, so for an
		initialized index type this method will return NULL.
		</p><pre class="programlisting">IndexType *copy(bool flat = false) const;</pre><p>
		Create an un-initialized copy of this index. If <code class="computeroutput">flat</code> is <code class="computeroutput">false</code> then
		the copy is done with all the sub-index and
		aggregator types also copied, but the row types shared. This method is used by
		<code class="computeroutput">addSubIndex()</code> to copy its argument before adding. By the way, the usual
		copy constructor could theoretically be used on the index types but
		usually doesn't make a whole lot of a sense because the sub-types and
		such will end up shared by reference.
		</p><p>
		If <code class="computeroutput">flat</code> is true, the copy is flat, with the sub-index types and aggregator
		types simply not included. It's the C++ analog of the Perl method
		<code class="computeroutput">flatCopy()</code>. This allows to re-create the partial index hierarchies,
		recursively flat-copying the parts that need to be included.
		</p><pre class="programlisting">IndexType *deepCopy(HoldRowTypes *holder) const;</pre><p>
		Create a deep copy, up to and including the row types. See the
		<a class="xref" href="#sc_cpp_tabtype" title="20.14. TableType reference">Section 20.14: &#8220;TableType reference&#8221; </a>
		and
		<a class="xref" href="#sc_cpp_copy" title="20.4. The many ways to do a copy">Section 20.4: &#8220;The many ways to do a copy&#8221; </a>
		for the detailed explanation. When you deep-copy a table type,
		the <code class="computeroutput">holder</code> argument propagates recurively to all the
		index types in it.
		</p><p>
		There are great many more methods on the IndexType, that are used to
		maintain the index trees, but you don't need to look at them unless you
		are interested in the inner workings of the Triceps tables.
		</p></div><div class="sect1" title="20.17. Index reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_idx"></a>20.17. Index reference</h2></div></div></div><a class="indexterm" name="id600930"></a><a class="indexterm" name="id600642"></a><p>
		The Index object can be accessed directly only in one place, in the aggregator handlers.
		In case if you're not sure about the difference between the Index and IndexType, 
		it's explained in 
		<a class="xref" href="#sc_table_indextree" title="9.10. The index tree">Section 9.10: &#8220;The index tree&#8221; </a>.
		The examples of the usage are shown in
		<a class="xref" href="#sc_cpp_aggregator" title="20.24. Aggregator classes reference">Section 20.24: &#8220;Aggregator classes reference&#8221; </a>,
		while this section lists the available methods.
		</p><p>
		The base Index class is defined in <code class="computeroutput">table/Index.h</code>, and its subclasses in
		<code class="computeroutput">table/RootIndex.h</code>, <code class="computeroutput">table/FifoIndex.h</code>, <code class="computeroutput">table/TreeIndex.h</code>,
		<code class="computeroutput">table/TreeNestedIndex.h</code>.
		</p><pre class="programlisting">const IndexType *getType() const;</pre><p>
		Get the type of this index.
		</p><pre class="programlisting">RowHandle *begin() const;</pre><p>
		Get the handle of the first row of the group, in the default order according to its first leaf index type. Note that here it's not the whole table's first leaf index type but the first leaf in the index type subtree under this index's type. All the iteration methods return NULL if there are no more rows.
		</p><pre class="programlisting">RowHandle *next(const RowHandle *cur) const;</pre><p>
		Get the handle of the next row (or NULL if that was the last one) in the default order. The NULL argument makes the NULL result.
		</p><pre class="programlisting">RowHandle *last() const;</pre><p>
		Get the handle of the last row in the group in the default order.
		</p><p>
		The rest of the methods of Index aren't really to be used directly.
		</p></div><div class="sect1" title="20.18. FifoIndexType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_fifoidx"></a>20.18. FifoIndexType reference</h2></div></div></div><a class="indexterm" name="id537861"></a><p>
		The FifoIndexType is defined in <code class="computeroutput">type/FifoIndexType.h</code>.
		It works the same way as in Perl, except that it
		provides two ways to set the configuration values: either as the
		constructor/factory arguments or as chainable methods:
		</p><pre class="programlisting">FifoIndexType(size_t limit = 0, bool jumping = false, bool reverse = false);
static FifoIndexType *make(size_t limit = 0, bool jumping = false, bool reverse = false);

FifoIndexType *setLimit(size_t limit);
FifoIndexType *setJumping(bool jumping);
FifoIndexType *setReverse(bool reverse);</pre><p>
		So the following are equivalent:
		</p><pre class="programlisting">Autoref&lt;IndexType&gt; it1 = new FifoIndexType(100, true, true);
Autoref&lt;IndexType&gt; it2 = FifoIndexType::make()
  -&gt;setLimt(100)
  -&gt;setJumping(true)
  -&gt;setReverse(true);</pre><p>
		As usual, the settings can be changed only until the initialization.
		The settings can be read back at any time with:
		</p><pre class="programlisting">size_t getLimit() const;
bool isJumping() const;
bool isReverse() const;</pre><p>
		Note that the limit is unsigned, and setting it to negative values
		results in it being set to very large positive values. The limit of 0
		means <span class="quote">&#8220;<span class="quote">unlimited</span>&#8221;</span>.
		</p><p>
		All the common methods inherited from IndexType and Type work as usual.
		</p><p>
		The <code class="computeroutput">equals()</code> and <code class="computeroutput">match()</code> are equivalent for the FifoIndexType, and are
		true when all the parameters are set to the same values. 
		</p></div><div class="sect1" title="20.19. HashedIndexType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_hashidx"></a>20.19. HashedIndexType reference</h2></div></div></div><a class="indexterm" name="id587199"></a><p>
		The HashedIndexType is defined in <code class="computeroutput">type/HashedIndexType.h</code>. It also
		allows to specify its only argument, the selection of the key fields,
		in the constructor, or set it later with a chainable call:
		</p><pre class="programlisting">HashedIndexType(NameSet *key = NULL);
static HashedIndexType *make(NameSet *key = NULL);
HashedIndexType *setKey(NameSet *key);</pre><p>
		One way or the other, the key has to be set, or a missing key will be
		detected as an error at the initialization time. Obviously, all the
		conditions described in the Perl API apply: the key fields must be
		present in the table's row type, and so on.
		</p><p>
		The key can be read back using the parent class method
		<code class="computeroutput">IndexType::getKey()</code>. The value returned there is a
		<code class="computeroutput">const NameSet*</code>, telling you that the key NameSet must not be
		changed afterward.
		</p><p>
		The check for <code class="computeroutput">equals()</code> requires that the key fields are the same
		(not the exact same NameSet object, but its contents being the same).
		The check for <code class="computeroutput">match()</code> is more tricky and depends on whether
		the index type has been initialized. The match check of initialized types
		is correct, while for the uninitialized types it's simplified.
		This may lead to slightly surprising effects when the two indexes match
		inside the initialized table types but their uninitialized copies
		don't.  However the comparison of the uninitialized index types is
		probably not that usable anyway.
		</p><p>
		The simplified <code class="computeroutput">match()</code> check is the same as <code class="computeroutput">equals()</code>:
		the list of key fields must be the same.
		However this has a tricky effect: if two table types have matching row
		types with different field names, and the same Hashed indexes differing
		only in the key field names (following the difference in the row
		types), these table types will be considered non-matching because their
		hashed indexes are non-matching.
		</p><p>
		After the indexes are initialized, they can do a better match check.
		They can find their table types, and from there the
		row types. And then compare if the keys refer to the matching fields or
		not, even if their names are different. The condition then becomes that
		the key fields are matching in the row type, even if their names are not.
		</p></div><div class="sect1" title="20.20. SortedIndexType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_sortidx"></a>20.20. SortedIndexType reference</h2></div></div></div><a class="indexterm" name="id602065"></a><p>
		The SortedIndexType is defined in <code class="computeroutput">type/SortedIndexType.h</code>, and provides
		a way to define any custom sorting criteria. That is done by defining
		your condition class, derived from SortedIndexCondition, and passing it
		to the SortedIndexType. Because of this the index type itself is
		simple, all the complex things are in the condition:
		</p><pre class="programlisting">SortedIndexType(Onceref&lt;SortedIndexCondition&gt; sc);
static SortedIndexType *make(Onceref&lt;SortedIndexCondition&gt; sc);
SortedIndexCondition *getCondition() const;</pre><p>
		A few example of the sort conditions are discussed below, they can also
		be found in <code class="computeroutput">type/test/t_xSortedIndex.cpp</code>.  More examples
		are available in <code class="computeroutput">type/test/t_TableType.cpp</code> and in
		<code class="computeroutput">perl/Triceps/PerlSortCondition.*</code>.  SortedIndexCondition
		provides a set of virtual methods that can be re-defined in the
		subclass to create a custom condition. Indeed, some of them must be
		re-defined, since they are pure virtual.
		</p><p>
		The following basic example defines only
		the absolute minimum of methods. It sorts by an int32 field, whose
		index (starting as usual from 0) is specified in the constructor:
		</p><a class="indexterm" name="id597750"></a><pre class="programlisting">class Int32SortCondition : public SortedIndexCondition
{
public:
  // @param idx - index of field to use for comparison (starting from 0)
  Int32SortCondition(int idx) :
    idx_(idx)
  { }

  Int32SortCondition(const Int32SortCondition *other, Table *t) :
    SortedIndexCondition(other, t),
    idx_(other-&gt;idx_)
  { }

  virtual SortedIndexCondition *copy() const
  {
    return new Int32SortCondition(*this);
  }

  virtual TreeIndexType::Less *tableCopy(Table *t) const
  {
    return new Int32SortCondition(this, t);
  }

  virtual void initialize(Erref &amp;errors, TableType *tabtype, SortedIndexType *indtype)
  {
    SortedIndexCondition::initialize(errors, tabtype, indtype);
    if (idx_ &lt; 0)
      errors.f("The index must not be negative.");
    if (rt_-&gt;fieldCount() &lt;= idx_)
      errors.f("The row type must contain at least %d fields.", idx_+1);

    if (!errors-&gt;hasError()) { // can be checked only if index is within range
      const RowType::Field &amp;fld = rt_-&gt;fields()[idx_];
      if (fld.type_-&gt;getTypeId() != Type::TT_INT32)
        errors.f("The field at index %d must be an int32.", idx_);
      if (fld.arsz_ != RowType::Field::AR_SCALAR)
        errors.f("The field at index %d must not be an array.", idx_);
    }
  }

  virtual bool equals(const SortedIndexCondition *sc) const
  {
    // the cast is safe to do because the caller has checked the typeid
    Int32SortCondition *other = (Int32SortCondition *)sc;
    return idx_ == other-&gt;idx_;
  }

  virtual bool match(const SortedIndexCondition *sc) const
  {
    return equals(sc);
  }

  virtual void printTo(string &amp;res, const string &amp;indent = "", const string &amp;subindent = "  ") const
  {
    res.append(strprintf("Int32Sort(%d)", idx_));
  }

  virtual bool operator() (const RowHandle *rh1, const RowHandle *rh2) const
  {
    const Row *row1 = rh1-&gt;getRow();
    const Row *row2 = rh2-&gt;getRow();
    {
      bool v1 = rt_-&gt;isFieldNull(row1, idx_);
      bool v2 = rt_-&gt;isFieldNull(row2, idx_);
      if (v1 &gt; v2) // isNull at true goes first, so the direction is opposite
        return true;
      if (v1 &lt; v2)
        return false;
    }
    {
      int32_t v1 = rt_-&gt;getInt32(row1, idx_);
      int32_t v2 = rt_-&gt;getInt32(row2, idx_);
      return (v1 &lt; v2);
    }
  }

  int idx_;
};

...

Autoref&lt;IndexType&gt; it = new SortedIndexType(new Int32SortCondition(1));</pre><p>
		There are four kinds of constructors for a sort condition:
		</p><div class="itemizedlist"><a class="indexterm" name="id570685"></a><ul class="itemizedlist" type="disc"><li class="listitem"><p>
			One used to create the SortedIndexType in the first place, specifying
			the condition argument, such as Int32SortCondition(int idx) here.
			</p></li><li class="listitem"><p>
			The copy constructor, used to copy the sort condition when its
			index gets copied. It should copy all the elements
			that could be modified by someone else but can share the references
			for the reference-counted elements that are unchangeable.
			Feel free to just use the default compiler-created
			copy constructor, as Int32SortCondition did, unless you really
			need it to do something more smart.
			</p></li><li class="listitem"><p>
			The deep-copy constructor, used when SortedIndexType gets deep-copied,
			including the copying of the RowTypes and other
			referenced objects that are more efficient to not share between
			different threads.  See the discussion of the deep-copying in
			<a class="xref" href="#sc_cpp_tabtype" title="20.14. TableType reference">Section 20.14: &#8220;TableType reference&#8221; </a>.
			Most of the sort conditions would not have any row types in them,
			nor anything deeper to copy than in the normal copy constructor,
			so they don't need to bother. The base class provides the default <code class="computeroutput">deepCopy()</code>
			method that simply reverts to calling <code class="computeroutput">copy()</code>, so no separate constructor
			is used.  If you need to define it, the typical prototype for the
			deep-copy constructor will be:
			</p><pre class="programlisting">MySortCondition(const MySortCondition &amp;other, HoldRowTypes *holder);</pre></li><li class="listitem"><p>
			The table-copy constructor. The need for this one is driven by the
			error reporting from the sort condition. For most of the sort condition
			classes defined directly in C++ it doesn't matter, they just can't
			experience any errors. But when the interpreted code is involved,
			the possibility of errors arises and something has to be done
			about them, and thus the infrastructure has to accomodate.
			</p><a class="indexterm" name="id518995"></a><p>
			When the comparison operator
			runs, throwing an Exception from the middle of the STL map logic
			is not a good idea. I've actually looked into the GCC implementation,
			and it would leak memory and be unhappy in this situation. This
			means that the sort condition has to report the error back to the
			Table in some other way. Which means that it has to have a link
			back to the table, and that link gets provided in the field
			<code class="computeroutput">table_</code>. But that means that the sort condition instance
			gets tied to a table. And normally a sort condition belongs to
			an index type which belongs to a table type which can be shared
			by multiple tables. This dilemma is solved by making a copy
			of the sort condition for each created table. 
			</p><p>
			This copying
			and setting of the Table pointer gets handled by the sort
			condition method tableCopy()
			which in turn calls the table-copy constructor. Most of the work is
			done by the base class, you just need to pass through the arguments
			and copy your extra fields, as shown in the example.
			</p></li></ul></div><p>
		There are three kinds of copy methods for a sort condition:
		</p><div class="itemizedlist"><a class="indexterm" name="id576314"></a><ul class="itemizedlist" type="disc"><li class="listitem"><p>
			<code class="computeroutput">copy()</code> copies the sort condition by calling the copy constructor,
			as shown above.  In particular, the
			SortedIndexType constructor makes a private copy of the condition, and
			remembers that copy, not the original.
			</p></li><li class="listitem"><p>
			<code class="computeroutput">deepCopy()</code> copies the sort condition all the way deep, as described in 
			<a class="xref" href="#sc_cpp_tabtype" title="20.14. TableType reference">Section 20.14: &#8220;TableType reference&#8221; </a>,
			by calling the deep-copy constructor. Most of the sort conditions don't
			need to bother since they don't have any RowTypes in them, the base
			class implements this method by calling <code class="computeroutput">copy()</code>. If you need one, the
			typical implementation looks like:
			</p><pre class="programlisting">IndexType *MySortCondition::deepCopy(HoldRowTypes *holder) const
{
  return new MySortCondition(*this, holder);
}</pre></li><li class="listitem"><p>
			<code class="computeroutput">tableCopy()</code> creates a per-table instance of the copy condition,
			by calling the table-copy constructor.
			</p></li></ul></div><p>
		The method <code class="computeroutput">initialize()</code> is called at the table type initialization
		time. The argument <code class="computeroutput">errors</code> is an already allocated Errors object to
		return the error messages in, <code class="computeroutput">tabtype</code> is the table type where the
		initialization is happening, and <code class="computeroutput">indtype</code> is the index type that owns
		this condition. Also the field <code class="computeroutput">rt_</code> gets magically initialized to the
		table's row type reference before the sort condition initialization is
		called. This method is expected to do all the initialization of the
		internal state, check for all the errors, and return these errors if
		found.
		</p><p>
		To be more systematic, the following useful fields are defined in the
		sort condition base class:
		</p><pre class="programlisting">Autoref&lt;const RowType&gt; rt_;
Table *table_;
intptr_t rhOffset_;</pre><a class="indexterm" name="id582208"></a><p>
		<code class="computeroutput">rt_</code> is set to NULL on construction and the gets properly set when the
		SortedIndexType is initialized, before it calls the initialization of the
		sort condition. <code class="computeroutput">table_</code> is also NULL to start with and gets set
		in <code class="computeroutput">tableCopy()</code>, as described above. <code class="computeroutput">table_</code> can be used by the
		comparison operator to report the fatal errors back to the table,
		as described in more detail below.
		<code class="computeroutput">rhOffset_</code> is used by the more advanced sort conditions that
		want to cache some per-row information in the RowHandle, I'll show
		another example of that. It's the offset of that cached data in the
		RowHandle.
		</p><p>
		<code class="computeroutput">equals()</code> and <code class="computeroutput">match()</code> compare two conditions for equality and match.
		Before they get called, the caller checks that both conditions are of
		the same type (i.e. have the same C++ typeid), so it's safe to cast the
		second condition's pointer to our type. The easiest way to define
		<code class="computeroutput">match()</code> is to make it the same as <code class="computeroutput">equals()</code>. These methods may be called
		on both uninitialized and initialized conditions; if not initialized
		then the field <code class="computeroutput">rt_</code> will be NULL.
		</p><p>
		<code class="computeroutput">printTo()</code> appends the printout of this index's description to a string.
		For the simple single-line printouts it just appends to the result
		string. The multi-line prints have to handle the indenting correctly,
		as is described in
		<a class="xref" href="#sc_cpp_types" title="20.10. Types reference">Section 20.10: &#8220;Types reference&#8221; </a>.
		</p><p>
		Finally, the <code class="computeroutput">operator()</code> implements the comparison for <span class="quote">&#8220;<span class="quote">Less</span>&#8221;</span>: it gets
		two row handles and returns true if the first one contains a row that
		is <span class="quote">&#8220;<span class="quote">less</span>&#8221;</span> (i.e. goes before in the sorting order) than the second one.
		The reason for why it's done like this is that the SortedIndexCondition
		is really a Less comparator class for the STL tree that had grown a few
		extra methods.
		</p><p>
		This example shows how to compare a value consisting of multiple
		elements. Even though this sort condition sorts by only one field, it
		first compares separately for NULL in that field, and then for the
		actual value. For each element you must:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			find the values of the element in both rows;
			</li><li class="listitem">
			compare for <span class="quote">&#8220;<span class="quote">&lt;</span>&#8221;</span>, and if so, return true;
			</li><li class="listitem">
			compare for <span class="quote">&#8220;<span class="quote">&gt;</span>&#8221;</span>, and if so, return false;
			</li><li class="listitem">
			otherwise (if they are equal), fall through to the next element.
			</li></ul></div><p>
		The last element doesn't have to go through the whole procedure, it can
		just return the result of <span class="quote">&#8220;<span class="quote">&lt;</span>&#8221;</span>. And in this case the comparison for NULL
		wants the NULL value go before all the non-NULL values, so the result
		of true must go before false, and the comparison signs are reversed.
		It's real important that the second comparison, normally for <span class="quote">&#8220;<span class="quote">&gt;</span>&#8221;</span>, can
		not be skipped (except for the last element). If you skip it, you will
		make a mess of the data and will spend a lot of time trying to figure
		out, what is going on.
		</p><p>
		That's it for the basics, the minimal subset of the methods that has to
		be defined. Now let's look at some more advances subjects.
		</p><a class="indexterm" name="id566599"></a><p>
		What if <code class="computeroutput">operator()</code> needs to to report an error? It has to set
		the sticky error in the table and return false:
		</p><pre class="programlisting">Erref err;
err.f("error message");
table_-&gt;setStickyError(err);
return false;</pre><p>
		One more method that can be supported in the sort condition is <code class="computeroutput">getKey()</code>:
		</p><pre class="programlisting">virtual const NameSet *getKey() const;</pre><p>
		The default implementation just returns NULL, thus saying that the
		key is not available.
		The SortedIndexType's <code class="computeroutput">getKey()</code> is really just a wrapper for the
		SortedIndexCondition's <code class="computeroutput">getKey()</code>.
		</p><p>
		To show <code class="computeroutput">getKey()</code> and a bit more
		techniques, so I've done a fairly big extension of the previous
		example. Now it can compare multiple fields, and the fields are
		specified by names. The only part missing from it being a general
		OrderedIndexType is the support of all the field types, not just int32.
		</p><pre class="programlisting">class MultiInt32SortCondition : public SortedIndexCondition
{
public:
  // @param key - the key fields specification
  MultiInt32SortCondition(NameSet *key):
    key_(key)
  { }

  MultiInt32SortCondition(const MultiInt32SortCondition *other, Table *t) :
    SortedIndexCondition(other, t),
    idxs_(other-&gt;idxs_),
    key_(other-&gt;key_)
  { }

  virtual SortedIndexCondition *copy() const
  {
    return new MultiInt32SortCondition(*this);
  }

  virtual TreeIndexType::Less *tableCopy(Table *t) const
  {
    return new MultiInt32SortCondition(this, t);
  }

  virtual void initialize(Erref &amp;errors, TableType *tabtype, SortedIndexType *indtype)
  {
    SortedIndexCondition::initialize(errors, tabtype, indtype);
    idxs_.clear();

    for (int i = 0; i &lt; key_-&gt;size(); i++) {
      const string &amp;s = (*key_)[i];
      int n = rt_-&gt;findIdx(s);
      if (n &lt; 0) {
        errors.f("No such field '%s'.", s.c_str());
        continue;
      }
      const RowType::Field &amp;fld = rt_-&gt;fields()[n];
      if (fld.type_-&gt;getTypeId() != Type::TT_INT32) {
        errors.f("The field '%s' must be an int32.", s.c_str());
        continue;
      }
      if (fld.arsz_ != RowType::Field::AR_SCALAR) {
        errors.f("The field '%s' must not be an array.", s.c_str());
        continue;
      }
      idxs_.push_back(n);
    }
  }

  virtual bool equals(const SortedIndexCondition *sc) const
  {
    // the cast is safe to do because the caller has checked the typeid
    MultiInt32SortCondition *other = (MultiInt32SortCondition *)sc;

    // names must be the same
    if (!key_-&gt;equals(other-&gt;key_))
      return false;

    // and if initialized, the indexs must be the same too
    if (!rt_.isNull()) {
      if (idxs_.size() != other-&gt;idxs_.size())
        return false;

      for (int i = 0; i &lt; idxs_.size(); i++) {
        if (idxs_[i] != other-&gt;idxs_[i])
          return false;
      }
    }

    return true;
  }

  virtual bool match(const SortedIndexCondition *sc) const
  {
    MultiInt32SortCondition *other = (MultiInt32SortCondition *)sc;
    if (rt_.isNull()) {
      // not initialized, check by names
      return key_-&gt;equals(other-&gt;key_);
    } else {
      // initialized, check by indexes
      if (idxs_.size() != other-&gt;idxs_.size())
        return false;

      for (int i = 0; i &lt; idxs_.size(); i++) {
        if (idxs_[i] != other-&gt;idxs_[i])
          return false;
      }
      return true;
    }
  }

  virtual void printTo(string &amp;res, const string &amp;indent = "", const string &amp;subindent = "  ") const
  {
    res.append("MultiInt32Sort(");
    for (NameSet::iterator i = key_-&gt;begin(); i != key_-&gt;end(); ++i) {
      res.append(*i);
      res.append(", "); // extra comma after last field doesn't hurt
    }
    res.append(")");
  }

  virtual const NameSet *getKey() const
  {
    return key_;
  }

  virtual bool operator() (const RowHandle *rh1, const RowHandle *rh2) const
  {
    const Row *row1 = rh1-&gt;getRow();
    const Row *row2 = rh2-&gt;getRow();

    int sz = idxs_.size();
    for (int i = 0; i &lt; sz; i++) {
      int idx = idxs_[i];
      {
        bool v1 = rt_-&gt;isFieldNull(row1, idx);
        bool v2 = rt_-&gt;isFieldNull(row2, idx);
        if (v1 &gt; v2) // isNull at true goes first, so the direction is opposite
          return true;
        if (v1 &lt; v2)
          return false;
      }
      {
        int32_t v1 = rt_-&gt;getInt32(row1, idx);
        int32_t v2 = rt_-&gt;getInt32(row2, idx);
        if (v1 &lt; v2)
          return true;
        if (v1 &gt; v2)
          return false;
      }
    }
    return false; // falls through on equality, which is not less
  }

  vector&lt;int&gt; idxs_;
  Autoref&lt;NameSet&gt; key_;
};</pre><a class="indexterm" name="id586743"></a><p>
		The key is specified as a NameSet in the constructor. Unlike the HashedIndexType, there
		is no changing the key later, it must be specified in the constructor,
		and must not be NULL. The same as with HashedIndexType, the original
		name set becomes referenced by this sort condition and all its copies.
		So don't change and don't even use the original condition any more
		after you've passed it to the sort condition. This sort condition doesn't
		care to copy the NameSet in the deep copy, just leaves the deep copy the
		same as the default.
		</p><p>
		The initialization translates the field names to indexes (um, that's a
		confusing double usage of the word "index", here it's like "array
		indexes") in the row type, and checks that the fields are as expected.
		</p><p>
		The equality and match checks follow the fashion of HashedIndexType:
		if not initialized, they rely on field names, if initialized, they
		take the field indexes into the consideration (for equality both the
		names and indexes must be equal, for matching, only the indexes need to
		be equal).
		</p><p>
		The printing and copying is nothing particularly new and fancy.
		<code class="computeroutput">getKey()</code> simply returns back the key. This feels a bit like an
		anti-climax, a whole big example for this little one-liner, but again,
		that's not the only thing that this example shows.
		</p><p>
		The <span class="quote">&#8220;<span class="quote">less</span>&#8221;</span> comparison function now loops through all the fields in the
		key. It can't do the shortcuts in the int32 comparison part any more,
		so that has been expanded to the full condition. If the whole loop
		falls through without returning, it means that the key fields in both
		rows are equal, so it returns false.
		</p><p>
		And an example, of its use, the key argument is created similarly
		to the hashed index:
		</p><pre class="programlisting">Autoref&lt;IndexType&gt; it = new SortedIndexType(new MultiInt32SortCondition(
  NameSet::make()-&gt;add("b")-&gt;add("c")
));</pre><a class="indexterm" name="id591604"></a><p>
		Now we get to another advanced feature that has been mentioned before
		in the description of the row handles but is not accessible from Perl.
		A row handle contains a chunk of memory for every index type in the
		table. It is called a <span class="quote">&#8220;<span class="quote">row handle section</span>&#8221;</span>. At the very least this
		chunk of memory contains the iterator in an index of that type, which
		allows to navigate through the table and to delete the row handles from
		the table efficiently.
		</p><p>
		But an index type may request more memory (the same fixed amount for each
		row handle) to store some row-specific information. For example, the
		hashed index type stores the value of the hash in its section, and uses this
		value for the efficient comparisons.
		</p><p>
		A sort condition may request and use memory in this section of a
		SortedIndexType. It is done by defining a few more virtual methods that
		handle the row section.
		</p><p>
		I could have made an example of the Hashed index re-implementation
		through the Sorted interface, but it's kind of boring, since you could
		as well look directly at the source code of the HashedIndexType.
		Instead I want to show a different kind of index that doesn't use the
		data in the rows for comparison at all but keeps the rows in the order
		they were inserted. Like a more expensive variety of FIFO index type.
		It's also a bit of a preview of a future feature. It assigns a new
		auto-generated sequence number to each row handle, and uses that
		sequence number for ordering. Later you can find the row handle quickly
		if you know its sequence number. If a table contains multiple copies
		of a row, the sequence numbers allow you to tell, which copy you are
		dealing with. It comes handy for such things as results of joins
		without a natural primary key. Of course, the usefulness of this
		preview is limited by the fact that there is no place for the sequence
		numbers in the rowops, and thus there is no way to propagate the
		sequence numbers in the model. That would have to be addressed before
		it becomes a full feature.
		</p><a class="indexterm" name="id568713"></a><p>
		Now, you might ask, why not just add an extra field and put the
		sequence number in there? Sure, that would work too, and also solve the
		issue with the propagation in the rowops. However this means that as a
		row goes through a table, it gets copied to set the sequence number in
		it, which is less efficient. So ultimately keeping the sequence numbers
		<span class="quote">&#8220;<span class="quote">on the side</span>&#8221;</span> is more beneficial.
		</p><p>
		The implementation is:
		</p><pre class="programlisting">class SeqSortCondition : public SortedIndexCondition
{
protected:
  class SeqRhSection : public TreeIndexType::BasicRhSection
  {
  public:
    SeqRhSection(int64_t val) :
      seq_(val)
    { }

    int64_t seq_; // the sequence number of this row handle
  };

public:
  SeqSortCondition() :
    seq_(0)
  { }

  SeqSortCondition(const SeqSortCondition *other, Table *t) :
    SortedIndexCondition(other, t),
    seq_(other-&gt;seq_)
  { }

  virtual SortedIndexCondition *copy() const
  {
    return new SeqSortCondition(*this);
  }

  virtual TreeIndexType::Less *tableCopy(Table *t) const
  {
    return new SeqSortCondition(this, t);
  }

  virtual void initialize(Erref &amp;errors, TableType *tabtype, SortedIndexType *indtype)
  {
    SortedIndexCondition::initialize(errors, tabtype, indtype);
    seq_ = 0;
  }

  virtual bool equals(const SortedIndexCondition *sc) const
  {
    return true;
  }

  virtual bool match(const SortedIndexCondition *sc) const
  {
    return true;
  }

  virtual void printTo(string &amp;res, const string &amp;indent = "", const string &amp;subindent = "  ") const
  {
    res.append("Sequenced");
  }

  virtual size_t sizeOfRhSection() const
  {
    return sizeof(SeqRhSection);
  }

  virtual void initRowHandleSection(RowHandle *rh) const
  {
    // initialize the Seq part, the general Sorted index
    // will initialize the iterator
      SeqRhSection *rs = rh-&gt;get&lt;SeqRhSection&gt;(rhOffset_);
      new(rs) SeqRhSection(seq_++);
  }

  virtual void clearRowHandleSection(RowHandle *rh) const
  {
      // clear the iterator by calling its destructor
      SeqRhSection *rs = rh-&gt;get&lt;SeqRhSection&gt;(rhOffset_);
      rs-&gt;~SeqRhSection();
  }

  virtual void copyRowHandleSection(RowHandle *rh, const RowHandle *fromrh) const
  {
      SeqRhSection *rs = rh-&gt;get&lt;SeqRhSection&gt;(rhOffset_);
      SeqRhSection *fromrs = fromrh-&gt;get&lt;SeqRhSection&gt;(rhOffset_);

      // initialize the iterator by calling its copy constructor inside the placement,
    // the sequence number gets copied too
      new(rs) SeqRhSection(*fromrs);
  }

  // Helper method to read the sequence from the row handle,
  // can also be used by the end-user. The row handle must as usual
  // belong to a table of this type.
  int64_t getSeq(const RowHandle *rh) const
  {
      return rh-&gt;get&lt;SeqRhSection&gt;(rhOffset_)-&gt;seq_;
  }

  // Helper method to set the sequence in the row handle.
  // May be used only on the rows that are not in a table.
  void setSeq(const RowHandle *rh, int64_t val) const
  {
    if (rh-&gt;isInTable()) {
      throw Exception("Attempted to change the sequence on a row in table.", true);
    }
      rh-&gt;get&lt;SeqRhSection&gt;(rhOffset_)-&gt;seq_ = val;
  }

  virtual bool operator() (const RowHandle *rh1, const RowHandle *rh2) const
  {
    return getSeq(rh1) &lt; getSeq(rh2);
  }

  mutable int64_t seq_; // the next sequence number to assign
};

...
Autoref&lt;IndexType&gt; it = new SortedIndexType(new SeqSortCondition());
...</pre><p>
		The nested class SeqRhSection defines the structure of the
		section that a SortedIndexType with a SeqSortCondition allocates in the RowHandle.
		The section class for a sort condition must always inherit from
		TreeIndexType::BasicRhSection, to get the general SortedIndexType
		parts from it, such as the iterator. Any
		extra fields are owned by the sort condition.
		</p><p>
		The SeqSortCondition contains the sequence number generator seq_ (not
		to be confused with the same-named field seq_ in SeqRhSection), that
		gets initialized to 0, and will be incremented from there. Since each
		table will get its own copy of the condition, each of them will be counting
		independently. 
		</p><p>
		The <code class="computeroutput">equals()</code> and <code class="computeroutput">match()</code> always return true because there is nothing
		configurable in this sort condition.
		</p><p>
		The new features start at <code class="computeroutput">sizeOfRhSection()</code>. The size of each row
		handle in a table type is the same, and is computed by asking every
		index type in it at initialization time and adding up the totals (plus
		alignment and some fixed amount of basic data). <code class="computeroutput">sizeOfRhSection()</code> does
		its part by telling the caller the size of SeqRhSection.
		</p><p>
		Then each row handle section must provide the ways to construct and
		destruct it. Naturally, to save space, a section must have no virtual
		table, so like for the rows, a separate method in the index type acts
		as its virtual destructor. And there is no such thing as a virtual
		constructor in C++, which gets simulated through more methods in the
		index type. The SortedIndexType delegates most of this work to the sort
		condition in it. The basic constructor is <code class="computeroutput">initRowHandleSection()</code>, the
		copy constructor is <code class="computeroutput">copyRowHandleSection()</code>, and the destructor is
		<code class="computeroutput">clearRowHandleSection()</code>.
		</p><p>
		Each of them gets the location of this index type's section in the row
		handle using:
		</p><pre class="programlisting">SeqRhSection *rs = rh-&gt;get&lt;SeqRhSection&gt;(rhOffset_);</pre><p>
		The field <code class="computeroutput">rhOffset_</code> gets initialized by the SortedIndexType machinery
		before either of these methods gets ever called. Here <code class="computeroutput">rs</code> points to the
		raw bytes, on which the placement constructors and the explicit
		destructor are called.
		</p><p>
		The methods <code class="computeroutput">getSeq()</code> and <code class="computeroutput">setSeq()</code> are not virtual, they are unique to
		this SeqSortCondition. They allow to read the sequence from a row
		handle or set the sequence in it. Naturally, the sequence number may be
		changed only when the row handle is not in the table yet, or it would
		mess up the indexing horribly. It's OK to throw the exceptions from
		<code class="computeroutput">setSeq()</code> and <code class="computeroutput">getSeq()</code> since they are called directly from the user code
		and won't confuse any Triceps code along the way.
		</p><p>
		If you want to find a row handle in the table by its sequence number,
		you start with creating a new row handle (which can even use an empty
		row). That new row handle will have a new sequence number assigned to
		it, but it doesn't matter, because next you call <code class="computeroutput">setSeq()</code> and overwrite
		it with your desired number. Then you use this row handle to call
		<code class="computeroutput">find()</code> or <code class="computeroutput">delete()</code> on the table as usual. 
		</p><p>
		The creation goes like this:
		</p><pre class="programlisting">Rhref rh1(table, r1);
sc-&gt;setSeq(rh1, desired_number);</pre><p>
		The class Rhref, a row handle reference, is similar in spirit to Rowref,
		and is described in detail in
		<a class="xref" href="#sc_cpp_rowhandle" title="20.23. RowHandle and Rhref reference">Section 20.23: &#8220;RowHandle and Rhref reference&#8221; </a>.
		Or to read the number, you do:
		</p><pre class="programlisting">int64_t seq = sc-&gt;getSeq(rh);</pre><p>
		Here <code class="computeroutput">sc</code> is the exact initialized sort condition from the actual table
		type (not from the exact table, since you can't get the sort condition from a table,
		but the table type is good enough). If you use a wrong or uninitialized
		sort condition, the <code class="computeroutput">rhOffset_</code> in it will likely be wrong, and
		will cause all kinds of memory corruption. You can get the sort
		condition from a table type like this:
		</p><pre class="programlisting">Autoref&lt;SortedIndexType&gt; ixt = dynamic_cast&lt;SortedIndexType *&gt;(tt-&gt;findSubIndex("primary"));
Autoref&lt;SeqSortCondition&gt; sc = dynamic_cast&lt;SeqSortCondition *&gt;(ixt-&gt;getCondition());</pre><p>
		You don't have to use the dynamic cast but it's safer, and since you'd
		normally do it once at the model setup time and then just keep using
		the value, there is no noticeable performance penalty for it.
		</p></div><div class="sect1" title="20.21. Gadget reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_gadget"></a>20.21. Gadget reference</h2></div></div></div><a class="indexterm" name="id477456"></a><p>
		The Gadget is unique to the C++ API, it has no parallels in Perl.
		It had also become somewhat obsolete in the recent times but still
		clinging to life for now.
		</p><p>
		Gadget is a base class, a single-threaded Starget, defined in 
		<code class="computeroutput">sched/Gadget.h</code>, its object being a
		something with an output label. And the details of what this something
		is, are determined by the subclass. Presumably, it also has some kind
		of inputs but it's up to the subclass. The Gadget itself defines only
		the output label. To make a concrete example, a table is a gadget, and
		every aggregator in the table is also a gadget. However the <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span> labels of the table are not gadgets, they are just extra labels
		strapped on the side.
		</p><p>
		The reasons for the Gadget creation are mostly historic by now.
		At some point it seemed important to have the ability to associate a
		particular enqueueing mode with each output label. Most tables might be
		using <code class="computeroutput">EM_CALL</code> but some, ones in a loop, would use <code class="computeroutput">EM_FORK</code>, and those
		that don't need to produce the streaming output would use <code class="computeroutput">EM_IGNORE</code>.
		This approach didn't work out as well as it seemed at first, and now is
		outright deprecated: the tables have <code class="computeroutput">EM_CALL</code> hardcoded everywhere, and there are the
		newer and better ways to handle the loops. The whole Gadget thing
		should be removed at some point but for now I'll just describe it as
		it is.
		</p><a class="indexterm" name="id553086"></a><p>
		As the result of that history, the enqueueing mode constants are
		defined in the Gadget class, enum EnqMode: <code class="computeroutput">EM_SCHEDULE</code>, <code class="computeroutput">EM_FORK</code>,
		<code class="computeroutput">EM_CALL</code>, <code class="computeroutput">EM_IGNORE</code>.
		</p><pre class="programlisting">static const char *emString(int enval, const char *def = "???");
static int stringEm(const char *str);</pre><p>
		Convert from the enqueueing mode constant to string, and back.
		</p><pre class="programlisting">Gadget(Unit *unit, EnqMode mode, const string &amp;name, const_Onceref&lt;RowType&gt; rt = (const RowType*)NULL);</pre><p>
		The Gadget constructor is protected, since Gadget is intended to be
		used only as a base class, and never instantiated directly. The
		row type can be left undefined if it isn't known yet and
		initialized later. The output label will be created as soon as the row type
		is known. The
		enqueueing mode may also be changed later, so initially it can be set
		to anything. All this is intended only to split the initialization in a
		more convenient way, once the Gadget components are set, they must not
		be changed any more.
		</p><p>
		The output label of the Gadget is a DummyLabel, and it shares the name
		with the Gadget. So if you want to differentiate that label with a
		suffix in the name, you have to give the suffixed name to the whole
		Gadget. For example, the Table constructor does:
		</p><pre class="programlisting">Gadget(unit, Gadget::EM_CALL, name + ".out", rowt),</pre><a class="indexterm" name="id550634"></a><p>
		A Gadget keeps a reference to both its output label and its unit. This
		means that the unit won't disappears from under a Gadget, but to avoid
		the circular references, the Unit must not have references to the
		Gadgets (having references to their output labels is fine).
		</p><pre class="programlisting">void setEnqMode(EnqMode mode);
void setRowType(const_Onceref&lt;RowType&gt; rt);</pre><p>
		The protected methods to finish the initialization. Once the values are
		set, they must not be changed any more. Calling <code class="computeroutput">setRowType()</code> creates
		the output label.
		</p><pre class="programlisting">EnqMode getEnqMode() const;
const string &amp;getName() const;
Unit *getUnit() const;
Label *getLabel() const;</pre><p>
		Get back the gadget's information. The label will be returned only
		after it's initialized (i.e. the row type is known), before then
		<code class="computeroutput">getLabel()</code> would return NULL. And yes, it's <code class="computeroutput">getLabel()</code>, <span class="bold"><strong>not</strong></span>
		<code class="computeroutput">getOutputLabel()</code>.
		</p><p>
		The rest of the methods are for convenience of sending the rows to the
		output label. They are protected, since they are intended for the
		Gadget subclasses (which in turn may decide to make them public).
		</p><pre class="programlisting">void send(const Row *row, Rowop::Opcode opcode) const;</pre><p>
		Construct a Rowop from the given row and opcode, and enqueue it to the
		output label according to the gadget's enqueueing method. This is the
		most typical use.
		</p><pre class="programlisting">void sendDelayed(Tray *dest, const Row *row, Rowop::Opcode opcode) const;</pre><p>
		Create a Rowop and put it into the <code class="computeroutput">dest</code> tray. The rowop will have the
		enqueueing mode populated according to the Gadget's setting. This
		method is used when the whole set of the rowops needs to be generated
		before any of them can be enqueued, such as when a Table computes its
		aggregators. After the delayed tray is fully generated, it can be
		enqueued with <code class="computeroutput">Unit::enqueueDelayedTray()</code>, which will consult each
		rowop's enqueueing method and process it accordingly. Again, this stuff
		exists for the historic reasons, and will likely be removed somewhere
		soon. 
		</p></div><div class="sect1" title="20.22. Table reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_table"></a>20.22. Table reference</h2></div></div></div><a class="indexterm" name="id595041"></a><a class="indexterm" name="id553204"></a><p>
		The Table is defined in <code class="computeroutput">table/Table.h</code>. It inherits from Gadget, with
		the table's output label being the gadget's output label. Naturally,
		it's an Starget and usable from one thread only.
		</p><a class="indexterm" name="id466884"></a><p>
		Its constructor is not public, and it's created from the TableType
		with its  method <code class="computeroutput">makeTable()</code>:
		</p><pre class="programlisting">Autoref&lt;Table&gt; t = tabType-&gt;makeTable(unit, "t");</pre><p>
		The arguments are the unit where the table will belong and the name of
		the table.
		</p><p>
		Yeah, it's kind of weird that in Perl the method <code class="computeroutput">makeTable()</code> is defined
		on Unit, and in C++ on TableType. But if I remember correctly, it has
		to do with avoiding the circular dependency in the C++ header files. 
		</p><p>
		For the reference, that TableType method is:
		</p><pre class="programlisting">Onceref&lt;Table&gt; makeTable(Unit *unit, const string &amp;name) const;</pre><p>
		The table has a large number of methods, grouped into multiple subsets.
		</p><pre class="programlisting">const string &amp;getName() const;
Unit *getUnit() const;
Label *getLabel() const;</pre><p>
		These methods are inherited from the Gadget. The only special thing to
		remember is that <code class="computeroutput">getLabel()</code> returns the table's output label.
		Technically, <code class="computeroutput">getName()</code> has an overriding implementation in the Table,
		to return the table's proper name while its output label and the underlying
		gadget have the suffix <span class="quote">&#8220;<span class="quote">.out</span>&#8221;</span> appended to their name.
		</p><pre class="programlisting">const TableType *getType() const;
const RowType *getRowType() const;
const RowHandleType *getRhType() const;</pre><a class="indexterm" name="id574450"></a><a class="indexterm" name="id578231"></a><p>
		Get back the type of the table, of its rows, and of its row handles.
		There is not much direct use for the RowHandleType, the Table uses it
		internally to construct the RowHandles.
		</p><pre class="programlisting">Label *getInputLabel() const;
Label *getPreLabel() const;
Label *getDumpLabel() const;
Label *getAggregatorLabel(const string &amp;agname) const;</pre><p>
		Get the assorted labels (remember, <code class="computeroutput">getLabel()</code> inherited from Gadget
		is used for the output label). The aggregator label getter takes the name of
		the aggregator (as was defined in the TableType) as an argument.
		</p><pre class="programlisting">FnReturn *fnReturn() const;</pre><a class="indexterm" name="id582845"></a><p>
		Get the FnReturn of this table's outputs. It gets created and
		remembered on the first call, and the subsequent calls return the same
		object.  It has a few labels with the fixed names: <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> and
		<span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span>, and a label for each aggregator with the aggregator's name. It
		could throw an Exception if you name an aggregator to conflict with one
		of the fixed labels, which you should not. The FnReturn's name will be
		<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>tableName</em></span>.fret</span>&#8221;</span>.
		</p><p>
		Next go the operations on the table (and of course the table may also
		be modified by sending the rowops to its input label).
		</p><pre class="programlisting">RowHandle *makeRowHandle(const Row *row) const;</pre><a class="indexterm" name="id609591"></a><a class="indexterm" name="id465590"></a><p>
		Create a row handle for a row. Remember, the row handles are
		reference-counted, and also have the special kind of references with
		Rhref. So the returned pointer should be stored in an Rhref. The row
		handle created will not be inserted into the table yet.
		</p><pre class="programlisting">bool insert(RowHandle *rh);</pre><p>
		Insert a row handle into the table. This invokes all the row
		replacement policies along the way. If the handle is already in the
		table, does nothing and returns false. May also return false if a
		replacement policy refuses the row, but in practice there are no such
		refusing policies yet. Otherwise returns true.
		</p><p>
		It may throw an Exception. It may throw directly if the row handle
		doesn't belong to this table or propagate the exception up from the
		functions it calls: since the
		execution involves calling the output labels and such, an exception
		might be thrown from there.
		</p><pre class="programlisting">bool insertRow(const Row *row);</pre><p>
		The version that combines the row handle construction and insertion.
		Unlike Perl, in C++ this method is named differently instead of
		overloading. The comments about the replacement policies and return
		code, and about exceptions apply here too.
		</p><pre class="programlisting">void remove(RowHandle *rh);</pre><p>
		Remove a row handle from the table. If the handle is not in the table,
		silently does nothing. May throw an Exception.
		</p><pre class="programlisting">bool deleteRow(const Row *row);</pre><p>
		Find a matching row and delete it (internally this involves creating
		a new RowHandle for the argument row and finding it in the first leaf
		index by value, and disposing of that temporary row handle afterwards). 
		Returns true if the row was found and removed, false if not found. May
		throw an Exception.
		</p><pre class="programlisting">void clear(size_t limit = 0);</pre><p>
		Clear the table by removing all the rows from it. The removed rows are
		sent as usual to the <span class="quote">&#8220;<span class="quote">pre</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">out</span>&#8221;</span> labels. If the limit is not 0, no
		more than that number of the rows will be removed. The rows are removed
		in the usual order of the first leaf index.
		</p><p>
		Next go the iteration methods. The rule of thumb is that for them a
		NULL row handle pointer means <span class="quote">&#8220;<span class="quote">end of iteration</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">not found</span>&#8221;</span> (or
		sometimes <span class="quote">&#8220;<span class="quote">bad arguments</span>&#8221;</span>). And they can handle silently the NULL row handles
		on the input, just returning NULL on the output.
		</p><pre class="programlisting">RowHandle *begin() const;</pre><p>
		Get the first row handle in the default order of the first leaf index.
		If the table is empty, returns NULL.
		</p><pre class="programlisting">RowHandle *beginIdx(IndexType *ixt) const;</pre><p>
		Get the first handle in the order of a particular index. The index type
		must belong to this table's type. For an incorrect index type it
		returns NULL (perhaps in the future this will be changed to an
		exception).
		</p><pre class="programlisting">RowHandle *next(const RowHandle *cur) const;
RowHandle *nextIdx(IndexType *ixt, const RowHandle *cur) const;</pre><p>
		Get the next row handle in the order of the default or specific index.
		Returns NULL after the last handle. It's safe to pass the current row
		handle as NULL, the result will be NULL, as well as on any other error.
		</p><pre class="programlisting">RowHandle *firstOfGroupIdx(IndexType *ixt, const RowHandle *cur) const;
RowHandle *lastOfGroupIdx(IndexType *ixt, const RowHandle *cur) const;</pre><p>
		Get the first or last row handle in the same group as the current row
		according to a non-leaf index. The NULL current handle will cause NULL
		returned. See the details in the description of the Perl API.
		</p><pre class="programlisting">RowHandle *nextGroupIdx(IndexType *ixt, const RowHandle *cur) const;</pre><p>
		Get the first row handle of the next group. The return will be NULL if
		the current group was the last one, or if the current handle is NULL.
		</p><p>
		The iteration loops may look as:
		</p><pre class="programlisting">for (RowHandle *iter = t-&gt;begin(); iter != NULL; iter = t-&gt;next(iter)) {
  ...
}

for (Rhref iter(t, t-&gt;beginIdx(level3)); !iter-&gt;isNull();
    iter = t-&gt;nextIdx(level3, iter)) {
  ...
}</pre><p>
		Note that if the table does not change during the iteration (or at the
		very least if the row handle at the iterator is not being affected by
		the changes), the iterator doesn't have to be kept in an Rhref.
		A pointer to RowHandle is perfectly adequate and more efficient since
		it doesn't modify the reference counts. However you must be perfectly
		sure that the table will not be changed by any of the code in any
		labels called from the iteration loop.
		</p><p>
		Unlike Perl, there are no methods on RowHandle that produce the next
		RowHandle in the table, all the <code class="computeroutput">next*()</code> methods are defined on the Table.
		It's possible to define them on Rhref, and will probably be done in the future.
		</p><p>
		Next go the size operations:
		</p><pre class="programlisting">size_t size() const;</pre><p>
		Get the number of rows currently in the table.
		</p><pre class="programlisting">size_t groupSizeIdx(IndexType *ixt, const RowHandle *what) const;</pre><p>
		Get the size of the group where the handle belongs according to a
		non-leaf index. If any arguments are wrong, returns 0. The row handle
		doesn't have to be in the table. If it isn't in the table, the method
		will find the group where the row would belong if it were inserted and
		return its current size.
		</p><pre class="programlisting">size_t groupSizeRowIdx(IndexType *ixt, const Row *what) const;</pre><p>
		A convenience version that makes a row handle from a row, finds the
		group size and disposes of the handle.
		</p><p>
		Next go the finding methods:
		</p><pre class="programlisting">RowHandle *find(const RowHandle *what) const;
RowHandle *findIdx(IndexType *ixt, const RowHandle *what) const;</pre><p>
		Find the handle of a matching row according to the default (first leaf)
		or the specific index, or return NULL if not found.
		</p><pre class="programlisting">RowHandle *findRow(const Row *what) const;
RowHandle *findRowIdx(IndexType *ixt, const Row *what) const;</pre><p>
		The convenience versions that create a temporary row handle and then
		perform the search.
		</p><div class="sect2" title="20.22.1. Data dump"><div class="titlepage"><div><div><h3 class="title"><a name="sc_cpp_table_dump"></a>20.22.1. Data dump</h3></div></div></div><p>
		The dump API of the table sends the whole contents of the table to
		the <span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span> label, thus making any labels connected to it perform an
		implicit iteration over the table.
		</p><pre class="programlisting">void clear(size_t limit = 0);</pre><p>
		Deletes the rows from the table.
		If <code class="computeroutput">limit</code> is 0, the whole table gets cleared. If it's greater
		than 0, no more than this number of rows will be deleted. 
		The deletion happens in the usual order of the first
		leaf index, and the rowops are sent to the table's output label as
		usual. It's really the same thing as running a loop over all the row
		handles and removing them.
		</p><pre class="programlisting">void dumpAll(Rowop::Opcode op = Rowop::OP_INSERT) const;
void dumpAllIdx(IndexType *ixt, Rowop::Opcode op = Rowop::OP_INSERT) const;</pre><a class="indexterm" name="id558190"></a><p>
		The dump can go in the order of default or specific index. The opcode
		argument is used for the rowops sent on the dump label. Using the
		argument index type of NULL makes <code class="computeroutput">dumpAllIdx()</code> use the default index
		and work just like <code class="computeroutput">DumpAll()</code>. In the future there probably will also be
		methods that dump only a group of records.
		</p><p>
		As usual, the general logic of the methods matches the Perl API unless
		said otherwise. Please refer to the Perl API description for the
		details and examples.
		</p></div><div class="sect2" title="20.22.2. Sticky errors"><div class="titlepage"><div><div><h3 class="title"><a name="sc_cpp_table_sticky"></a>20.22.2. Sticky errors</h3></div></div></div><a class="indexterm" name="id498597"></a><p>
		The table
		internals contain a few places where the errors can't just throw an
		Exception because it will mess up the logic big time, most specifically
		the comparator functions for the indexes. The Triceps built-in indexes
		can't encounter any errors in the comparators but the user-defined
		ones, such as the Perl Sorted Index, can. Previously there was no way
		to report these errors other than print the error message and then
		either continue pretending that nothing happened or abort the program.
		</p><p>
		The sticky errors provide a way out of this sticky situation. When an
		index comparator encounters an error, it reports it as a sticky error
		in the table and then returns false. The table logic then unrolls like
		nothing happened for a while, but before returning from the
		user-initiated method it will find this sticky error and throw an
		Exception at a safe time. Obviously, the incorrect comparison means
		that the table enters some messed-up state, so all the further
		operations on the table will keep finding this sticky error and throw
		an Exception right away, before doing anything. The sticky error can't
		be unstuck. The only way out of it is to just discard the table and
		move on.
		</p><pre class="programlisting">void setStickyError(Erref err);</pre><p>
		Set the sticky error from a location where an exception can not be
		thrown, such as from the comparators in the indexes. Only the first
		error sticks, all the others are ignored since (a) the table will be
		dead and throwing this error in exceptions from this point on anyway
		and (b) the comparator is likely to report the same error repeatedly
		and there is no point in seeing multiple copies.
		</p><pre class="programlisting">Errors *getStickyError() const;</pre><p>
		Get the table's sticky error. Normally there is no point in doing this
		manually, but just in case.
		</p><pre class="programlisting">void checkStickyError() const;</pre><p>
		If the sticky error has been set, throws an Exception with it. 
		</p></div></div><div class="sect1" title="20.23. RowHandle and Rhref reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_rowhandle"></a>20.23. RowHandle and Rhref reference</h2></div></div></div><a class="indexterm" name="id567648"></a><p>
		RowHandle is a mostly opaque class. It's defined in <code class="computeroutput">table/RowHandle.h</code>
		but you never need to include that file directly: when you include
		<code class="computeroutput">table/Table.h</code>, that takes care of it. If you look at the class
		definition, there are two public sections. The first one is really public,
		the second one is really for the internal use, I just didn't want to mess
		too much with the lists of friend classes. The really-public part is
		quite small:
		</p><pre class="programlisting">const Row *getRow() const;
bool isInTable() const;</pre><p>
		The meaning of these methods is the same as in Perl, get the row contained
		in the handle, and check whether this handle has been inserted into its table.
		</p><p>
		The constructor of RowHandle is private. It's constructed with a factory method
		in the Table, but normally a better approach is to use the wrapper constructor
		of Rhref, as described below. For the record, that Table factory method is:
		</p><pre class="programlisting">RowHandle *makeRowHandle(const Row *row) const;</pre><p>
		There is also a side API that allows the indexes and aggregators to place their sections into
		the RowHandles. It's not a part of the RowHandle class as such, which is quite
		dumb and only knows how to carry the bytes of the data. The smart part of the
		RowHandle construction is contained in the API between the Table and its indexes
		and aggregators, and is outlined in 
		<a class="xref" href="#sc_cpp_sortidx" title="20.20. SortedIndexType reference">Section 20.20: &#8220;SortedIndexType reference&#8221; </a>.
		</p><a class="indexterm" name="id592401"></a><p>
		The row handles have the requirements very similar to the rows. They
		get created by the million, so the efficiency is important. In addition, they
		may contain the user data that has to be properly destroyed, the index and aggregator
		state mentioned above. For example, when an
		additive Perl aggregator stores its last state, it's stored in a row
		handle.
		</p><a class="indexterm" name="id486604"></a><p>
		So the row handle references are handled similarly to the rows. They don't have a virtual
		destructor but rely on the Table that owns them to destroy them right.
		The special reference type for them is Rhref, defined in <code class="computeroutput">mem/Rhref.h</code>.
		</p><p>
		It follows in the exact same mold as Rowref, only uses the Table
		instead of a RowType:
		</p><pre class="programlisting">Rhref(Table *t, RowHandle *r = NULL);
void assign(Table *t, RowHandle *r);</pre><a class="indexterm" name="id599938"></a><p>
		The rest of comparisons, assignments etc. work the same as with Rowref.
		</p><p>
		The RowHandle pointer may be NULL, creating an Rhref to a yet unknown
		handle in a known table. The Table pointer may be NULL too (of course,
		only if the RowHandle is NULL), creating a completely NULL reference.
		As usual in the C++ API, these rules are not checked in the functions, 
		so if you assign the incorrect NULLs, the program will crash.
		</p><p>
		As with Rowrefs, if the Table is not NULL, a RowHandle can be assigned
		into the Rowref through the assignment operator, but if the Table was not
		set, or if assigning a row handle from another table, the <code class="computeroutput">assign()</code>
		method must be used to set both.
		</p><p>
		An important point is that an Rhref contains an Autoref to the Table,
		safely holding the table in place while the Rhref is alive, it's the same
		as the relation between the Rowref and RowType.
		</p><p>
		To find out the table of a Rhref, use:
		</p><pre class="programlisting">Table *t = rhr.getTable();</pre><p>
		Why is the value returned a simple pointer to the table and not an
		Autoref or Onceref? Basically, because it's the cheapest way and
		because the row handle is not likely to go anywhere. Nobody is likely
		to construct a RowHandle only to get the table from it and have it
		immediately destroyed. And even if someone does something of the sort
		</p><pre class="programlisting">Autoref&lt;Table&gt; t = Rhref(t_orig, rh).getTable();</pre><p>
		then the table itself is likely to not go anywhere, there is still
		likely to be another reference to the table that will still hold it in
		place. If there isn't then of course all bets are off, and it will end
		up with a dead reference to corrupted memory. Just exercise a little
		care, and everything will be fine. The same reasoning was used for the
		argument of the RowHandle constructor being also a table pointer, not
		an Autoref or Onceref.
		</p><p>
		An Rhref constructor may also be conveniently used to construct a RowHandle for a
		Row or directly from the field data:
		</p><pre class="programlisting">Rhref(Table *t, Row *row);
Rhref(Table *t, FdataVec &amp;data);</pre><p>
		In fact, this is the recommended way to construct a RowHandle, immediately
		holding it in a reference, instead of doing all the intermediate calls
		manually.
		</p></div><div class="sect1" title="20.24. Aggregator classes reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_aggregator"></a>20.24. Aggregator classes reference</h2></div></div></div><div class="sect2" title="20.24.1. AggregatorType reference"><div class="titlepage"><div><div><h3 class="title"><a name="sc_cpp_aggregator_type"></a>20.24.1. AggregatorType reference</h3></div></div></div><a class="indexterm" name="id558117"></a><p>
		The AggregatorType is a base class from which you derive the concrete
		aggregator types, similarly to how it's done for the index types.
		It's defined in <code class="computeroutput">type/AggregatorType.h</code>.
		It has a chunk of functionality common for all the aggregator types and
		the virtual functions that create the aggregator objects.
		</p><pre class="programlisting">AggregatorType(const string &amp;name, const RowType *rt);</pre><p>
		The constructor provides a name and the result row type. Remember, that
		AggregatorType is an abstract class,  and will never be instantiated
		directly. Instead your subclass that performs a concrete aggregation
		will invoke this constructor as a part of its constructor.
		</p><p>
		As has been described in the Perl part of the manual, the aggregator
		type is unique in the fact that it has a name.  And it's a bit weird
		name: each aggregator type is kind of by itself and can be reused in
		multiple table types, but all the aggregator types in a table type must
		have different names. This is the name that is used to generate the
		name of the aggregator's output label in a table:
		<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>table_name.aggregator_type_name</em></span></span>&#8221;</span>. Fundamentally, the aggregator
		type itself should not have a name, it should be given a name when
		connected to an index in the table type. But at the time the current
		idea looked good enough, it's easy, convenient for error messages, and
		doesn't get much in the way.
		</p><p>
		The result row type might not be known at the time of the aggregator
		type creation. All the constructor does with it is place the value into
		a reference field, so if the right type is not known, just use NULL,
		then change later at the initialization time.
		If it's still NULL after initialization, this will be reported as an 
		initialization error.
		</p><pre class="programlisting">AggregatorType(const AggregatorType &amp;agg);
virtual AggregatorType *copy() const;
AggregatorType(const AggregatorType &amp;agg, HoldRowTypes *holder);
virtual AggregatorType *deepCopy(HoldRowTypes *holder) const;</pre><p>
		An aggregator type must provide the copy constructors 
		and the virtual methods that invoke them. 
		Both kinds of copies are deep but <code class="computeroutput">deepCopy()</code> is even deeper,
		copying even the row types.
		See 
		<a class="xref" href="#sc_cpp_copy" title="20.4. The many ways to do a copy">Section 20.4: &#8220;The many ways to do a copy&#8221; </a>
		for details.
		</p><p>
		The basic copy is the same as
		with the index types: when an agggregator type gets connected into a
		table type, it gets actually copied, and the copy must always be
		uninitialized.
		</p><p>
		The virtual methods are typically defined in the subclasses as follows:
		</p><pre class="programlisting">AgregatorType *MyAggregatorType::copy() const
{
  return new MyAggregatorType(*this);
}

AgregatorType *MyAggregatorType::deepCopy(HoldRowTypes *holder) const
{
  return new MyAggregatorType(*this, holder);
}</pre><p>
		Some of the fields in the AggregatorType are directly usable
		by the subclasses:
		</p><pre class="programlisting">const_Autoref&lt;RowType&gt; rowType_; // row type of result
Erref errors_; // errors from initialization
string name_; // name inside the table's dotted namespace
int pos_; // a table has a flat vector of AggregatorGadgets in it, this is the index for this one (-1 if not set)
bool initialized_; // flag: already initialized, no future changes</pre><div class="variablelist"><dl><dt><span class="term">rowType_</span></dt><dd><p>
				is the row type of the result. The constructor puts
				the argument value there but it can be changed at any time
				(until the initialization is completed) later.
				</p></dd><dt><span class="term">errors_</span></dt><dd><p>
				is a place to put the errors during initialization. It
				comes set to NULL, so if you want to report any errors, you
				have to create an Errors object first, there are the
				helper functions for that.
				</p></dd><dt><span class="term">name_</span></dt><dd><p>
				is where the aggregator name is kept. Generally, don't change it,
				treat it as read-only.
				</p></dd><dt><span class="term">pos_</span></dt><dd><p>
				has to do with management of the aggregator types in a
				table type. Before initialization it's -1, after initialization
				each aggregator type (that becomes tied to its table type) will
				be assigned a sequential number. Again, treat it as read-only,
				and you probably would never need to even read it.
				</p></dd><dt><span class="term">initialized_</span></dt><dd><p>
				shows that the initialization has already
				happened. Your initialization should call the initialization
				of the base class, which would set this flag. No matter if the
				initialization succeesed or failed, this flag gets set. It
				never gets reset in the original AggregatorType object, it gets
				reset only in the copies.
				</p></dd></dl></div><pre class="programlisting">const string &amp;getName() const;
const RowType *getRowType() const;
bool isInitialized() const;
virtual Erref getErrors() const;</pre><p>
		The convenience getter functions that return the data from the fields.
		You can override <code class="computeroutput">getErrors()</code> but there probably is no point to it.
		</p><pre class="programlisting">virtual bool equals(const Type *t) const;
virtual bool match(const Type *t) const;</pre><p>
		The equality and match comparisons are as usual. The defaults provided
		in the base AggregatorType check that the result row type is equal or
		matching (or that both result row types are NULL), and
		that the C++ typeid of both are the same. So if your aggregator type has no
		parameters, this is good enough and you don't need to redefine these
		methods. If you do have parameters, you call the base class method
		first, if it returns false, you return false, otherwise you check the
		parameters. Like this:
		</p><pre class="programlisting">bool MyAggregatorType::equals(const Type *t) const
{
     if (!AggregatorType::equals(t))
        return false;

    // the typeid matched, so safe to cast
    const MyAggregatorType *at = static_cast&lt;const MyAggregatorType *&gt;(t);
    // ... check the type-specific parameters ...
}</pre><p>
		The other method that you can re-define or leave alone is <code class="computeroutput">printTo()</code>:
		</p><pre class="programlisting">virtual void printTo(string &amp;res, const string &amp;indent = "", const string &amp;subindent = "  ") const;</pre><p>
		The default one prints <span class="quote">&#8220;<span class="quote">aggregator (<span class="emphasis"><em>result row type</em></span>) <span class="emphasis"><em>name</em></span></span>&#8221;</span>. If you
		want to print more information, such as the name of the aggregator
		class and its arguments, you can define your own.
		</p><pre class="programlisting">virtual void initialize(TableType *tabtype, IndexType *intype);</pre><p>
		This method is called at the TableType initialization time, as it goes through
		all the components. This is the place where the aggregator type parses its
		arguments, matches them up with the information about the table type and produces
		any parsed internal representations. It may also compute the
		aggregation result type if that was not done earlier. The <code class="computeroutput">initialize()</code>
		method in the subclass must always call the method in the parent class,
		to let it do its part. If any errors are found, they must be reported by
		setting an Errors object in the field <code class="computeroutput">errors_</code>. If the aggregator
		type has no parameters, and its result type was set in the constructor,
		it doesn't have to define the <code class="computeroutput">initialize()</code> method.
		</p><p>
		Finally, there are methods that will produce objects that do the actual
		work:
		</p><pre class="programlisting">virtual AggregatorGadget *makeGadget(Table *table, IndexType *intype) const;
virtual Aggregator *makeAggregator(Table *table, AggregatorGadget *gadget);</pre><a class="indexterm" name="id553654"></a><a class="indexterm" name="id566805"></a><a class="indexterm" name="id568152"></a><p>
		This exposes quite a bit of the inherent complexity of the aggregators.
		For the simpler cases you can use the subclass BasicAggregatorType that
		handles most of this complexity for you and just skip these <span class="quote">&#8220;<span class="quote">make</span>&#8221;</span>
		methods. By the way, the IndexType has a <span class="quote">&#8220;<span class="quote">make</span>&#8221;</span> method of this kind too
		but it was not discussed because unless you define a completely new
		IndexType, you don't need to worry about it: it just happens under the
		hood. The SortedIndexType just asks you to define a condition and takes
		care of the rest, like the BasicAggregatorType for aggregators.
		</p></div><div class="sect2" title="20.24.2. AggregatorGadget reference"><div class="titlepage"><div><div><h3 class="title"><a name="sc_cpp_aggregator_gadget"></a>20.24.2. AggregatorGadget reference</h3></div></div></div><p>
		The Gadget concept is discussed in
		<a class="xref" href="#sc_cpp_gadget" title="20.21. Gadget reference">Section 20.21: &#8220;Gadget reference&#8221; </a>.
		Each aggregator in a table is a gadget. So whenever a table is
		created from a table type, each aggregator type in that table type is
		called to produce its gadget, and these gadgets are collected in the
		table. When you call <code class="computeroutput">table-&gt;getAggregatorLabel("name")</code>, you get the
		output label from the appropriate gadget.
		</p><p>
		The short summary: one AggregatorGadget per table per aggregator type.
		</p><a class="indexterm" name="id501372"></a><a class="indexterm" name="id576363"></a><p>
		The AggregatorGadget is a subclass of Gadget that keeps the extra
		information typically needed by all the aggregator types. It's defined in
		<code class="computeroutput">sched/AggregatorGadget.h</code>. 
		The original grand plan was that the different aggregator types may
		define their own subclasses of AggregatorGadget but in reality there
		appears no need to. So far all the aggregators happily live with the
		base AggregatorGadget.  It's constructed as:
		</p><pre class="programlisting">AggregatorGadget(const AggregatorType *type, Table *table, IndexType *intype);</pre><p>
		The arguments are pretty much a pass-through from the <code class="computeroutput">makeGadget()</code>.
		The AggregatorGadget will keep references to the AggregatorType and
		to the IndexType, and a pointer to the Table, for the future use.
		The reason why the Table is not referenced is that it would create
		cyclic references, because the table already references
		all its aggregator gadgets. There is normally no need to worry that the
		table will disappear: when the table is destroyed, it will never call
		the aggregator gadget again. And that would remove the references
		to the Aggregator and AggregatorGadget, thus likely causing them
		to be destroyed too (unless you hold another reference to
		AggregatorGadget from outside Aggregator, which you normally should
		not).
		</p><p>
		This information can be obtained back from the AggregatorGadget with:
		</p><pre class="programlisting">Table *getTable() const;
const AggregatorType *getType() const;
template&lt;class C&gt; const C *typeAs() const;
const IndexType *getIndexType() const;</pre><p>
		The AggregatorType can be extracted in two ways, as a plain base
		class pointer with <code class="computeroutput">getType()</code> and with the template <code class="computeroutput">typeAs()</code> that
		casts it to the appropriate subclass. For example:
		</p><pre class="programlisting">MyAggregatorType *agt = gadget-&gt;typeAs&lt;MyAggregatorType&gt;();</pre><p>
		Of course, the subclasses can also read the fields directly.
		</p><p>
		The AggregatorGadget also publicly exports the method <code class="computeroutput">sendDelayed()</code>
		of the Gadget (which is normally protected) and provides
		a convenience wrapper that constructs a row from fields data
		and sends it:
		</p><pre class="programlisting">void sendDelayed(Tray *dest, const Row *row, Rowop::Opcode opcode) const
void sendDelayed(Tray *dest, FdataVec &amp;data, Rowop::Opcode opcode) const;</pre><p>
		The Gadget method <code class="computeroutput">send()</code> is not exported, and is even marked as
		private. The rows are always sent from the aggregators in the delayed
		fashion. The reasons for that are partially historic, having to do with
		the per-Gadget enqueueing modes, but the bigger reason is that it also helps with the error
		handling inside the Table and Aggregator code, separating the errors in
		the Aggregators themselves from the errors in the labels called by
		them.
		</p></div><div class="sect2" title="20.24.3. Aggregator reference"><div class="titlepage"><div><div><h3 class="title"><a name="sc_cpp_aggregator_obj"></a>20.24.3. Aggregator reference</h3></div></div></div><p>
		Unlike AggregatorGadget, an Aggergator represents a concrete aggregation 
		group, on a concrete index (not on an index type, on an index!). Whenever an index
		of some type is created, an aggregator of its connected type is created
		with it. Remember, an index contains a single aggregation group. A table with nested indexes can have
		lots of aggregators of a single type. The difference between an index
		type and an index is explained in detail in
		<a class="xref" href="#sc_table_indextree" title="9.10. The index tree">Section 9.10: &#8220;The index tree&#8221; </a>,
		and the available Index methods are enumerated in
		<a class="xref" href="#sc_cpp_idx" title="20.17. Index reference">Section 20.17: &#8220;Index reference&#8221; </a>.
		</p><p>
		The way it works, whenever some row in the table gets deleted or
		inserted, the table determines for each index type, which actual index
		in the tree (i.e. which group) got changed. Then for aggregation
		purposes, if that index has an aggegator on it, that aggregator is
		called to do its work on the group. It produces an output row or two
		(or maybe none, or it can get creative and produce many rows) 
		for that group and sends it to the aggregator gadget of
		the same type.
		</p><p>
		The short summary: one Aggregator object per group, produces
		the updates when asked, sends them to the single common gadget.
		</p><p>
		The pointers to the Table and Gadget are passed to the <code class="computeroutput">makeAggregator()</code>  method
		for convenience, the Aggergator object doesn't need to remember them. Whenever
		it will be called, it will also be given these pointers as arguments.
		This is done in an attempt to reduce the amount of data stored per
		aggregator. 
		</p><a class="indexterm" name="id490815"></a><p>
		The Aggregator class (defined in <code class="computeroutput">table/Aggregator.h</code>) is the
		base class for the per-aggregation-group objects. Its main purpose
		is in the handler method:
		</p><a class="indexterm" name="id484428"></a><a class="indexterm" name="id570182"></a><pre class="programlisting">virtual void handle(Table *table, AggregatorGadget *gadget, Index *index,
  const IndexType *parentIndexType, GroupHandle *gh, Tray *dest,
  AggOp aggop, Rowop::Opcode opcode, RowHandle *rh);</pre><p>
		In retrospect, this method might be better off belonging to the
		AggregatorType class, but for now it is what it is.
		</p><p>
		You would create a subclass that would get instantiated for every
		aggregation group. Then the handler would be called every time
		this group gets modified, exactly as it was described for the
		Perl API. The arguments are fundamentally the same as in Perl,
		just structured differently: they're passed directly instead of
		being hidden in an aggregation context. The C++  programmers are
		expected to behave responsibly and not try to mess with these
		parameters outside of the call scope, or prepare to meet the dire
		consequences.
		</p><p>
		Before digging more into the arguments, a few more words about the
		subclass structure.  The subclass may define any additional fields to
		keep its aggregation state.  If you're doing an additive aggregation,
		it allows you to keep the previous results. If you're doing the
		optimization of the deletes, it allows you to keep the previous sent
		row.
		</p><p>
		What if your aggregator keeps no state? You still have to make a
		separate Aggregator object for every group, and no, you can't just
		return NULL from <code class="computeroutput">makeAggregator()</code>, and no, the Aggregators
		are not reference-countable, so you have to make a new copy of it for
		every group. This looks decidedly sub-optimal, and eventually I'll get
		around to straighten it out. The good news though is that most of the
		real aggerators keep the state anyway, so it doesn't matter much.  
		</p><p>
		Now getting back to the arguments. Probably the easiest way is to
		start with showing how the Perl AggregatorContext calls translate
		to the C++ API.
		</p><a class="indexterm" name="id582216"></a><a class="indexterm" name="id576937"></a><a class="indexterm" name="id608299"></a><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">$result = $ctx-&gt;groupSize();</code></span></dt><dd><pre class="programlisting">size_t sz = parentIndexType-&gt;groupSize(gh);</pre><p>
				Get the size of the group. The result is of the type size_t.
				This is pretty much the only method of the IndexType base class that should be
				called directly, and only in the aggregation; and also pretty much the
				only use of the arguments <code class="computeroutput">parentIndexType</code> and <code class="computeroutput">gh</code>. 
				The rest of the IndexType methods should be accessed through the similar
				methods in the Table, and I won't even document them. However
				if you really, really want to, you can find the description of
				the other methods in <code class="computeroutput">type/IndexType.h</code> and call them in the
				aggregation as well.
				</p></dd><dt><span class="term"><code class="computeroutput">$rowType = $ctx-&gt;resultType();</code></span></dt><dd><pre class="programlisting">const RowType *rt = gadget-&gt;getLabel()-&gt;getType();</pre><p>
				</p>
				Get the result row type.
				</dd><dt><span class="term"><code class="computeroutput">$rh = $ctx-&gt;begin();</code></span></dt><dd><pre class="programlisting">RowHandle *rhi = index-&gt;begin();</pre><p>
				Get the first row handle of the group, in the order of the index
				(or technically, if it's not a leaf index, of its first leaf sub-index).
				As usual, it would return NULL if the group is empty.
				The aggregators are a weird place where the Index methods are
				called directly and not through the Table API. You <span class="emphasis"><em>could</em></span>
				use the Table API as well, by getting the index type with
				<code class="computeroutput">index-&gt;getType()</code>, and then using it in the table API,
				but then you would also need to supply a sample row from the group
				to the Table API, and getting that sample is also done through
				<code class="computeroutput">index-&gt;begin()</code>, so there is no way around it. Note that
				you can't just use the <code class="computeroutput">rh</code> argument, since it might be
				the handle that had already been deleted from the table.
				Besides, going directly to the index is slightly more efficient,
				since it skips the step of finding the index by its type and
				a sample row.
				</p><p>
				It's fine to use a pointer to RowHandle instead of a reference here,
				since the handles are already held in the table which is guaranteed not
				to change while the iterators run.
				</p><p>
				Just as in Perl's AggregatorContext, there is no <code class="computeroutput">index-&gt;end()</code>.
				When the end of the group is reached, the iteration will return a NULL
				handle.
				</p></dd><dt><span class="term"><code class="computeroutput">$rh = $ctx-&gt;next($rh);</code></span></dt><dd><pre class="programlisting">rhi = index-&gt;next(rhi);</pre><p>
				Get the handle of the next row (or NULL if that was the last
				one) in the order of the index. The NULL argument produces the NULL
				result.
				</p></dd><dt><span class="term"><code class="computeroutput">$rh = $ctx-&gt;last();</code></span></dt><dd><pre class="programlisting">RowHandle *rhi = index-&gt;last();</pre><p>
				Get the handle of the last row in the group in the default order.
				Returns NULL if the group is empty.
				</p></dd><dt><span class="term"><pre class="programlisting">$rh = $ctx-&gt;beginIdx($idxType);
$rh = $ctx-&gt;endIdx($idxType);
$rh = $ctx-&gt;lastIdx($idxType);</pre></span></dt><dd><pre class="programlisting">RowHandle *sample = index-&gt;begin();
RowHandle *rhend =  table-&gt;nextGroupIdx(otherIndexType, sample);
for (RowHandle *rhit = table-&gt;firstOfGroupIdx(otherIndexType, sample); rhit != rhend; rhit = table-&gt;nextIdx(otherIndexType, rhit)) {
  ...
}</pre><p>
				Unlike the Perl API of AggregatorContext, there are no direct
				analogs of <code class="computeroutput">beginIdx()</code> and such in the C++ API. To get them in
				C++, you need to translate the iteration to another index type
				through the Table (and of course, just like in Perl, you would
				need somehow to get the reference or pointer to another index type into
				your aggregator, and that index type better be in the subtree
				of the <code class="computeroutput">parentIndexType</code>). To translate through the Table, you
				take any row from the group, usually the first one, and use it
				with the table methods that accept a sample row.
				</p></dd><dt><span class="term"><code class="computeroutput">$ctx-&gt;send($opcode, $row);</code></span></dt><dd><pre class="programlisting">gadget-&gt;sendDelayed(dest, row, opcode);</pre><p>
				In Perl I've named this method just <code class="computeroutput">send()</code> but in C++
				it comes with its proper name of <code class="computeroutput">sendDelayed()</code>.
				</p></dd><dt><span class="term"><code class="computeroutput">$ctx-&gt;makeHashSend($opcode, $fieldName =&gt; $fieldValue, ...);</code></span></dt><dd><pre class="programlisting">gadget-&gt;sendDelayed(dest, fields, opcode);</pre><p>
				This is a convenience wrapper that builds the row from the fields
				and sends it on.
				</p></dd></dl></div><p>
		And here goes the honest description of the handler arguments:
		</p><a class="indexterm" name="id564292"></a><div class="variablelist"><dl><dt><span class="term"><code class="computeroutput">Table *table</code></span></dt><dd><p>
				Table where this Aggregator belongs.
				</p></dd><dt><span class="term"><code class="computeroutput">AggregatorGadget *gadget</code></span></dt><dd><p>
				The Gadget where this Aggregator sends its results.
				</p></dd><dt><span class="term"><code class="computeroutput">Index *index</code></span></dt><dd><p>
				Index that defines the group on which this Aggregator runs.
				</p></dd><dt><span class="term"><code class="computeroutput">const IndexType *parentIndexType</code></span></dt><dd><p>
				The IndexType of the parent Index, one level above the <code class="computeroutput">index</code>
				argument. It's needed mostly because the group size is kept at that
				level.
				</p></dd><dt><span class="term"><code class="computeroutput">GroupHandle *gh</code></span></dt><dd><p>
				This is an opaque object that can be used as an argument to the
				<code class="computeroutput">parentIndexType</code> methods. It's an internal object that
				ties together all the indexes in the group under the parent index.
				</p></dd><dt><span class="term"><code class="computeroutput">Tray *dest</code></span></dt><dd><p>
				The tray where the results will be collected. This tray is created and
				then processed by the Table logic.
				</p></dd><dt><span class="term"><code class="computeroutput">AggOp aggop</code></span></dt><dd><p>
				The aggregation operation, with the same meaning as described for Perl in 
				<a class="xref" href="#sc_aggregation_manual" title="11.2. Manual aggregation">Section 11.2: &#8220;Manual aggregation&#8221; </a>.
				The <code class="computeroutput">enum AggOp</code> is defined in the Aggregator class
				and contains the elemends AO_BEFORE_MOD, AO_AFTER_DELETE,
				AO_AFTER_INSERT, AO_COLLAPSE.
				</p><a class="indexterm" name="id609622"></a><a class="indexterm" name="id570871"></a></dd><dt><span class="term"><code class="computeroutput">Rowop::Opcode opcode</code></span></dt><dd><p>
				The suggested opcode for the result rowops. The meaning is also as in Perl.
				</p></dd><dt><span class="term"><code class="computeroutput">RowHandle *rh</code></span></dt><dd><p>
				The handle that is about to or had just been inserted or removed, depending
				on the <code class="computeroutput">aggop</code>. It may be NULL for the operation AO_COLLAPSE.
				</p></dd></dl></div><p>
		The methods to convert the <code class="computeroutput">AO_*</code> constants to and from the strings
		are also defined in the Aggregator class:
		</p><pre class="programlisting">static const char *aggOpString(int code, const char *def = "???");
static int stringAggOp(const char *code);</pre><p>
		They work in the same way as the other constant conversion methods.
		</p></div><div class="sect2" title="20.24.4. BasicAggregatorType reference"><div class="titlepage"><div><div><h3 class="title"><a name="sc_cpp_aggregator_basic"></a>20.24.4. BasicAggregatorType reference</h3></div></div></div><a class="indexterm" name="id600428"></a><p>
		In many cases a simple stateless aggregation is good enough.
		For that, you don't need to define the whole set of classes
		for your aggregation, you can use the BasicAggregatorType 
		(defined in <code class="computeroutput">type/BasicAggregatorType.h</code>)
		instead.
		</p><p>
		You just define a simple C-style function to compute the aggregation
		and pass it to the BasicAggregatorType constructor:
		</p><pre class="programlisting">BasicAggregatorType(const string &amp;name, const RowType *rt, Callback *cb);</pre><p>
		This function has all the arguments of Aggregator::handle forwarded to it:
		</p><pre class="programlisting">typedef void Callback(Table *table, AggregatorGadget *gadget, Index *index,
  const IndexType *parentIndexType, GroupHandle *gh, Tray *dest,
  Aggregator::AggOp aggop, Rowop::Opcode opcode, RowHandle *rh, Tray *copyTray);</pre><p>
		BasicAggregatorType takes care of the rest of the infrastructure:
		gadgets, aggregators etc. 
		</p><p>
		If you need to pass some additional information to this function,
		you do it by extending the BasicAggregatorType class. Add your
		extra fields to your subclass, and then the callback function
		can find the type object from the gadget, and read the values
		from there.
		</p></div><div class="sect2" title="20.24.5. Aggegator example"><div class="titlepage"><div><div><h3 class="title"><a name="sc_cpp_aggregator_example"></a>20.24.5. Aggegator example</h3></div></div></div><p>
		Since the aggregator classes are somewhat convoluted and substantially
		different from the Perl version, I've decided to provide not just 
		the reference but also a couple of small examples.  The full text can be found in
		the unit test file <code class="computeroutput">table/test/t_Aggr.cpp</code>.
		</p><p>
		First, if your aggregator is truly stateless and fully hardcoded, the
		easier way to do it as by defining a plain function with the same
		handler arguments and building a BasicAggregatorType with it. And here
		is one that sums the values of an int64 field (the test case
		<code class="computeroutput">aggBasicSum</code>):
		</p><a class="indexterm" name="id596259"></a><pre class="programlisting">void sumC(Table *table, AggregatorGadget *gadget, Index *index,
  const IndexType *parentIndexType, GroupHandle *gh, Tray *dest,
  Aggregator::AggOp aggop, Rowop::Opcode opcode, RowHandle *rh)
{
  // don't send the NULL record after the group becomes empty
  if (opcode == Rowop::OP_NOP || parentIndexType-&gt;groupSize(gh) == 0)
    return;

  int64_t sum = 0;
  for (RowHandle *rhi = index-&gt;begin(); rhi != NULL; rhi = index-&gt;next(rhi)) {
    sum += table-&gt;getRowType()-&gt;getInt64(rhi-&gt;getRow(), 2, 0); // field c at idx 2
  }

  // pick the rest of fields from the last row of the group
  RowHandle *lastrh = index-&gt;last();

  // build the result row; relies on the aggregator result being of the
  // same type as the rows in the table
  FdataVec fields;
  table-&gt;getRowType()-&gt;splitInto(lastrh-&gt;getRow(), fields);
  fields[2].setPtr(true, &amp;sum, sizeof(sum)); // set the field c from the sum

  // could use the table row type again, but to exercise a different code,
  // use the aggregator's result type:
  // gadget()-&gt;getType()-&gt;getRowType() and gadget-&gt;getLabel()-&gt;getType()
  // are equivalent
  Rowref res(gadget-&gt;getLabel()-&gt;getType(), fields);
  gadget-&gt;sendDelayed(dest, res, opcode);
}

...
  Autoref&lt;TableType&gt; tt = TableType::make(rt1)
    -&gt;addSubIndex("Hashed", HashedIndexType::make( // will be the default index
        (new NameSet())-&gt;add("e")
      )-&gt;addSubIndex("Fifo", FifoIndexType::make()
        -&gt;setAggregator(new BasicAggregatorType("aggr", rt1, sumC))
      )
    );
...</pre><p>
		As described above, you create the BasicAggregatorType by giving it
		the aggregator name, aggregator result row type, and the handler
		function.
		</p><p>
		In this case the handler function is completely hardcoded. It works on
		the int64 field at index 2. The row type I used in this example is:
		</p><pre class="programlisting">row {
  uint8[10] a,
  int32[] b,
  int64 c,
  float64 d,
  string e,
}</pre><p>
		So the field is actually named <span class="quote">&#8220;<span class="quote">c</span>&#8221;</span>, and that's why the aggregator
		function is named <span class="quote">&#8220;<span class="quote">sumC</span>&#8221;</span>.  But since in this case everything is known
		in advance, to make it more efficient, the look-up of the field by name
		has been skipped, and the field index has been pre-computed and hardcoded
		into the function.
		</p><p>
		The general outline of the aggregator is exactly the same as in Perl:
		check for an empty group, then iterate through all the rows in the
		group and compute a the sum, fill the rest of the fields from the last
		row, and send the result. The difference is that there is no
		AggregatorContext, and the calls are done directly on the bits and
		pieces received as arguments.
		</p><p>
		The input row type for reading the rows from the group is found as:
		</p><pre class="programlisting">table-&gt;getRowType()</pre><p>
		The result row is built in this example by copying the last row and
		replacing one field. The data from the last row is split into FdataVec
		(the data itself is not copied at this point but the data descriptors
		in the construction vector are made to point to the data in the
		original row). Then the descriptor for the field <span class="quote">&#8220;<span class="quote">c</span>&#8221;</span> is changed to
		point to the computed sum. Then the new row is built from the
		descriptor.
		</p><p>
		In this particular case the type of the input rows and of the result
		rows is the same, so either could have been used to construct the
		result rows.  There are two ways to find the result type:
		</p><pre class="programlisting">gadget-&gt;getType()-&gt;getRowType()
gadget-&gt;getLabel()-&gt;getType()</pre><p>
		They are exactly the same, just there are two paths leading to the same
		object.
		</p><p>
		Finally, the constructed row is sent. <code class="computeroutput">sendDelayed()</code> takes care of
		constructing the rowop from the components. The version of <code class="computeroutput">sendDelayed()</code> 
		that also constructs the row from the fields is shown in the next example.
		</p><p>
		And now on to the next example.
		</p><p>
		Doing a proper custom aggregator is more involved, and requires making
		subclasses of both Aggregator and AggregatorType. The test case <code class="computeroutput">aggSum</code>
		shows an example of aggregator that can sum any 64-bit field.
		It still could be done with subclassing the BasicAggregatorType, since
		it still doesn't keep any group state, but I wanted to show a
		full-size example as well.
		</p><p>
		The subclass of Aggregator contains only one method that is very
		similar to the BasicAggregator handler shown before:
		</p><pre class="programlisting">class MySumAggregator: public Aggregator
{
public:
  // same as sumC but finds the field from the type
  virtual void handle(Table *table, AggregatorGadget *gadget, Index *index,
    const IndexType *parentIndexType, GroupHandle *gh, Tray *dest,
    Aggregator::AggOp aggop, Rowop::Opcode opcode, RowHandle *rh);
};

void MySumAggregator::handle(Table *table, AggregatorGadget *gadget, Index *index,
  const IndexType *parentIndexType, GroupHandle *gh, Tray *dest,
  Aggregator::AggOp aggop, Rowop::Opcode opcode, RowHandle *rh)
{
  // don't send the NULL record after the group becomes empty
  if (opcode == Rowop::OP_NOP || parentIndexType-&gt;groupSize(gh) == 0)
    return;

  int fidx = gadget-&gt;typeAs&lt;MySumAggregatorType&gt;()-&gt;fieldIdx();

  int64_t sum = 0;
  for (RowHandle *rhi = index-&gt;begin(); rhi != NULL; rhi = index-&gt;next(rhi)) {
    sum += table-&gt;getRowType()-&gt;getInt64(rhi-&gt;getRow(), fidx, 0);
  }

  // pick the rest of fields from the last row of the group
  RowHandle *lastrh = index-&gt;last();

  // build the result row; relies on the aggregator result being of the
  // same type as the rows in the table
  FdataVec fields;
  table-&gt;getRowType()-&gt;splitInto(lastrh-&gt;getRow(), fields);
  fields[fidx].setPtr(true, &amp;sum, sizeof(sum));

  // use the convenience wrapper version
  gadget-&gt;sendDelayed(dest, fields, opcode);
}</pre><p>
		The difference is that the field index is not hardcoded but taken from
		the aggregator type. The aggregator type is found with
		</p><pre class="programlisting">gadget-&gt;typeAs&lt;MySumAggregatorType&gt;()</pre><p>
		The method <code class="computeroutput">fieldIdx()</code> is a custom addition to
		the MySumAggregatorType, not inherited from any base class.
		</p><p>
		The version of <code class="computeroutput">AggregatorGadget::sendDelayed()</code> used here
		takes care of constructing the row from the fields and then
		sends it on.
		</p><p>
		Then the aggregator type needs to be defined with a fixed set of
		inherited virtual methods plus any needed custom parts.
		</p><pre class="programlisting">class MySumAggregatorType: public AggregatorType
{
public:
  // @param fname - field name to sum on
  MySumAggregatorType(const string &amp;name, const string &amp;fname):
    AggregatorType(name, NULL),
    fname_(fname),
    fidx_(-1)
  { }
  // the copy constructor works fine
  // (might set the non-NULL row type, but it will be overwritten
  // during initialization)

  // constructor for deep copy
  // (might set the non-NULL row type, but it will be overwritten
  // during initialization)
  MySumAggregatorType(const MySumAggregatorType &amp;agg, HoldRowTypes *holder):
    AggregatorType(agg, holder),
    fname_(agg.fname_),
    fidx_(agg.fidx_)
  { }

  virtual AggregatorType *copy() const
  {
    return new MySumAggregatorType(*this);
  }

  virtual AggregatorType *deepCopy(HoldRowTypes *holder) const
  {
    return new MySumAggregatorType(*this, holder);
  }

  virtual bool equals(const Type *t) const
  {
    if (this == t)
      return true; // self-comparison, shortcut

    if (!AggregatorType::equals(t))
      return false;

    const MySumAggregatorType *sumt = static_cast&lt;const MySumAggregatorType *&gt;(t);

    if (fname_ != sumt-&gt;fname_)
      return false;

    return true;
  }

  virtual bool match(const Type *t) const
  {
    if (this == t)
      return true; // self-comparison, shortcut

    if (!AggregatorType::match(t))
      return false;

    const MySumAggregatorType *sumt = static_cast&lt;const MySumAggregatorType *&gt;(t);

    if (fname_ != sumt-&gt;fname_)
      return false;

    return true;
  }

  virtual AggregatorGadget *makeGadget(Table *table, IndexType *intype) const
  {
    return new AggregatorGadget(this, table, intype);
  }

  virtual Aggregator *makeAggregator(Table *table, AggregatorGadget *gadget) const
  {
    return new MySumAggregator;
  }

  virtual void initialize(TableType *tabtype, IndexType *intype)
  {
    const RowType *rt = tabtype-&gt;rowType();
    setRowType(rt); // the result has the same type as the argument
    fidx_ = rt-&gt;findIdx(fname_);
    if (fidx_ &lt; 0)
      errors_.fAppend(new Errors(rt-&gt;print()), "Unknown field '%s' in the row type:", fname_.c_str());
    else {
      if (rt-&gt;fields()[fidx_].arsz_ != RowType::Field::AR_SCALAR
      || rt-&gt;fields()[fidx_].type_-&gt;getTypeId() != Type::TT_INT64)
        errors_.fAppend(new Errors(rt-&gt;print()),
          "Field '%s' is not an int64 scalar in the row type:", fname_.c_str());
    }
    AggregatorType::initialize(tabtype, intype);
  }

  // called from the handler
  int fieldIdx() const
  {
    return fidx_;
  }

protected:
  string fname_; // name of the field to sum, must be an int64
  int fidx_; // index of field named fname_
};</pre><p>
		The constructor accepts the aggregator name and the name of the field
		on which it will sum. The field name will be translated to field index
		during initialization, and made available to the
		<code class="computeroutput">MySumAggregator::handler()</code> via the method <code class="computeroutput">fieldIdx()</code>. The aggregator
		type starts with the result row type of NULL, with the actual row type
		set during initialization.  The idea here is
		that the result row type of this aggregator is always equal to the
		input row type, so rather than specifying the result type explicitly
		and then having to check it for compatibility, why not just take the
		table's row type when it becomes available? And it works beautifully.
		</p><p>
		The copy constructor and the constructor with HoldRowTypes are the
		implementations of the virtual methods <code class="computeroutput">copy()</code> and <code class="computeroutput">deepCopy()</code>. The
		<code class="computeroutput">deepCopy()</code> is used in the multithreaded support for passing the
		table types through the nexus.
		See 
		<a class="xref" href="#sc_cpp_copy" title="20.4. The many ways to do a copy">Section 20.4: &#8220;The many ways to do a copy&#8221; </a>
		and
		<a class="xref" href="#sc_mt_objects" title="16.4. Object passing between threads">Section 16.4: &#8220;Object passing between threads&#8221; </a>
		for details.
		</p><p>
		The methods <code class="computeroutput">match()</code> and <code class="computeroutput">equals()</code> follow the same general shape as
		everywhere else. <code class="computeroutput">makeGadget()</code> creates a generic gadget, and
		<code class="computeroutput">makeAggregator()</code> creates an instance of aggregator for each group.
		</p><p>
		The interesting stuff starts happening in the initialization. The row
		type gets found from the table and set as the result type. Then the
		aggregation field is found in the row type and checked for being of the
		proper type. Its index is remembered for the later use.
		</p><p>
		<code class="computeroutput">errors_.fAppend()</code> makes the error
		construction more convenient. It is smart enough to check the reference
		for NULL and allocate a new Errors if so, then append a
		printf-formatted message and nested errors to it. 
		</p></div></div><div class="sect1" title="20.25. Unit reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_unit"></a>20.25. Unit reference</h2></div></div></div><a class="indexterm" name="id598970"></a><p>
		The Unit is declared in <code class="computeroutput">sched/Unit.h</code>. It represents an
		execution unit that controls the execution order of a sequential
		part of a model.
		An unit is an Mtarget but in reality
		it may be used in one thread only. The multithreading support in the
		references is needed to build the multithreaded applications but
		each Unit in the application belongs to one thread (possibly sharing 
		it with other Units).
		</p><pre class="programlisting">Unit(const string &amp;name);</pre><p>
		Constructs an execution unit. 
		</p><pre class="programlisting">const string &amp;getName() const;</pre><p>
		Get back the name.
		</p><pre class="programlisting">void schedule(Onceref&lt;Rowop&gt; rop);
void scheduleTray(const_Onceref&lt;Tray&gt; tray);
void fork(Onceref&lt;Rowop&gt; rop);
void forkTray(const_Onceref&lt;Tray&gt; tray);
void call(Onceref&lt;Rowop&gt; rop);
void callTray(const_Onceref&lt;Tray&gt; tray);

void enqueue(int em, Onceref&lt;Rowop&gt; rop);
void enqueueTray(int em, const_Onceref&lt;Tray&gt; tray);</pre><p>
		Schedule, fork or call a rowop or tray, like in Perl. Unlike Perl, the
		methods with a tray argument have different names. And the enqueueing
		mode is always an integer constant. These constants are defined in the
		enum Gadget::EnqMode (the Gadget class is described in
		<a class="xref" href="#sc_cpp_gadget" title="20.21. Gadget reference">Section 20.21: &#8220;Gadget reference&#8221; </a>), and is
		one of <code class="computeroutput">Gadget::EM_SCHEDULE</code>, <code class="computeroutput">Gadget::EM_FORK</code>, <code class="computeroutput">Gadget::EM_CALL</code> and
		<code class="computeroutput">Gadget::EM_IGNORE</code>. 
		</p><pre class="programlisting">void enqueueDelayedTray(const_Onceref&lt;Tray&gt; tray);</pre><a class="indexterm" name="id599783"></a><a class="indexterm" name="id498562"></a><a class="indexterm" name="id560219"></a><p>
		Enqueue (schedule, fork or call) the rowops from a tray built by
		Gadget's method <code class="computeroutput">sendDelayed()</code>.  The Rowop has a semi-undocumented
		field to store the enqueuing mode for that particular Rowop, that
		gets populated by <code class="computeroutput">Gadget::sendDelayed()</code>.
		The <code class="computeroutput">enqueueDelayedTray()</code> uses the value from this field
		to determine the enqueueing method individually for each Rowop.
		The whole arraggement is largely obsolete: it used to be used for
		the aggregators in a Table, mixing the outputs from multiple
		aggregators with potentially different enqueueing methods in one
		tray. But now everything just uses <code class="computeroutput">EM_CALL</code> and there
		is no need for this any more.
		</p><pre class="programlisting">bool empty() const;</pre><p>
		Check whether all the Unit's frames are empty.
		</p><pre class="programlisting">bool isFrameEmpty() const;</pre><p>
		Check whether the current inner frame is empty.
		</p><pre class="programlisting">bool isInOuterFrame() const;</pre><p>
		Check whether the unit's current inner frame is the same as its outer
		frame, which means that the unit is not in the middle of a call.
		</p><pre class="programlisting">void callNext();
void drainFrame();</pre><p>
		Execute the next rowop from the current (inner) frame, or all the
		rowops on the current frame. The semantics is the same as in the Perl
		code.
		</p><pre class="programlisting">void setMark(Onceref&lt;FrameMark&gt; mark);</pre><p>
		Set a mark on the current frame, same as in Perl.
		</p><pre class="programlisting">void loopAt(FrameMark *mark, Onceref&lt;Rowop&gt; rop);
void loopTrayAt(FrameMark *mark, const_Onceref&lt;Tray&gt; tray);</pre><p>
		Enqueue a rowop or a tray at the marked frame.
		</p><pre class="programlisting">void callAsChained(const Label *label, Rowop *rop, const Label *chainedFrom);</pre><p>
		This method was introduced in Triceps version 2, and hasn't propagated to
		Perl yet. I'm not even sure that I want it visible in Perl, since it's
		kind of low-level. It executes a label call, assuming that it was
		chained from another label (before version 2 the functionality itself had
		obviously existed but was not visible in the API).
		</p><p>
		The row types of all the arguments must be matching, or the method
		would likely crash. 
		</p><p>
		The label will be called with rowop, just as if this label was chained
		from another label. Since the chaining might be multi-level, the
		<code class="computeroutput">chainedFrom</code> label is not necessarily the one in the rowop,
		it can itself be chained from the label in the rowop, directly or
		indirectly.
		</p><p>
		All the tracing for the chained calls is automatically invoked.
		Keeping the consistency of the
		tracing is up to you: if you use the <code class="computeroutput">chainedFrom</code> argument label that
		hasn't actually been called through the chain, the trace will look surprising.
		</p><a class="indexterm" name="id518679"></a><a class="indexterm" name="id475050"></a><a class="indexterm" name="id603128"></a><p>
		This method is used in Triceps in such places as calling a label in
		FnBinding through an FnReturn. You can use it directly as
		well, just be very careful. 
		</p><pre class="programlisting">void clearLabels();</pre><p>
		Clear all the unit's labels, same semantics as when called from Perl.
		</p><pre class="programlisting">void rememberLabel(Label *lab);</pre><p>
		The method that connects a label to the unit. Normally you don't need
		to call it manually, the label constructor calls it (and that's why
		it's not in the Perl API). The only real reason to use this method
		manually is if you've disconnected a label manually from the unit, and
		want to reconnect it back (and I'm not sure if anyone would ever want
		that). Calling this method repeatedly with the same label and unit will
		have no effect. Remembering the same label in multiple units is not a
		good idea.
		</p><pre class="programlisting">void  forgetLabel(Label *lab);</pre><p>
		Make the unit forget a label, so on <code class="computeroutput">clearLabels()</code> that label won't be
		cleared. This is another dangerous low-level method, since only the
		unit will forget about the label but the label will still keep the
		pointer to the unit, unless it's cleared. Because of the danger, it's
		also not in the Perl API. The reason to use it would be if you want to
		disassemble and discard a part of the unit without disturbing the rest
		of it. However a safer alternative is to just create multiple units in
		one thread and discard by a whole unit.
		</p><pre class="programlisting">RowType *getEmptyRowType() const;</pre><p>
		A convenience method to get a reference to a row type with no fields.
		Such row type is useful for creation of pseudo-labels that have the
		user-defined clearing handlers that clear some user data.
		</p><p>
		Each unit has its own instance of an empty row type. The separate instances
		(instead of having a single global one) are purely for the conveniece of memory management
		in the threads, they are all equivalent. You could also create
		your own empty row type.
		</p><pre class="programlisting">void setMaxStackDepth(int v);
int maxStackDepth() const;
void setMaxRecursionDepth(int v);
int maxRecursionDepth() const;</pre><p>
		Set and get the maximal unit stack depth and recursion depth, works the
		same as in Perl.
		</p><pre class="programlisting">int getStackDepth() const;</pre><p>
		Returns the current depth of the execution stack.
		It isn't of any use for the model logic as such but comes handy
		for debugging, to check in the loops that you haven't accidentally
		created a stack growing with iterations. When the unit is not
		running, the stack depth is 1, since the outermost frame always
		stays on the stack. When a rowop is being executed, the stack
		depth is at least 2.
		</p><pre class="programlisting">void clearLabels();</pre><a class="indexterm" name="id605526"></a><a class="indexterm" name="id468271"></a><p>
		Clear all the labels in the unit, then drop the references from unit to them.
		Normally should be called only when the unit is about to be destroyed,
		and is called automatically when the unit gets destroyed. However
		in case of cyclic references to the unit, may need to be called
		manually or through a UnitClearingTrigger object to break these
		cycles. For more information, see
		<a class="xref" href="#sc_ref_cycles" title="8.1. Reference cycles">Section 8.1: &#8220;Reference cycles&#8221; </a>.
		</p><p>
		The Unit has a few helper classes: the tracers and the clearing triggers.
		</p><p>
		The tracer classes inherit from the nested virtual class Unit::Tracer.
		They will be described in
		<a class="xref" href="#sc_cpp_unit_tracer" title="20.26. Unit Tracer reference">Section 20.26: &#8220;Unit Tracer reference&#8221; </a>.
		The Unit class contains the definition of the enums of the tracers
		and provides a way to set the tracer in the unit.
		</p><a class="indexterm" name="id469416"></a><pre class="programlisting">enum TracerWhen {
  // The values go starting from 0 in before-after pairs
  TW_BEFORE, // before calling the label's execution as such
  TW_AFTER, // after all the execution is done
  TW_BEFORE_CHAINED, // after execution, before calling the chained labels (if they are present)
  TW_AFTER_CHAINED, // after calling the chained labels (if they were present)
  TW_BEFORE_DRAIN, // before draining the label's frame if it's not empty
  TW_AFTER_DRAIN, // after draining the label's frame if was not empty
};</pre><p>
		This enum describes the point of the tracer invocation.
		The meaning of the values is described in detail in
		<a class="xref" href="#sc_sched_tracing" title="7.10. Tracing the execution">Section 7.10: &#8220;Tracing the execution&#8221; </a>.
		</p><pre class="programlisting">static const char *tracerWhenString(int when, const char *def = "???");
static int stringTracerWhen(const char *when);</pre><p>
		The usual conversions between the integer constants and their
		string representations.
		<code class="computeroutput">def</code> is as usual the default placeholder that will be used
		for an invalid value. And the conversion from string would return a -1
		on an invalid value.
		</p><pre class="programlisting">static const char *tracerWhenHumanString(int when, const char *def = "???");
static int humanStringTracerWhen(const char *when);</pre><p>
		The same kind of conversion as above, only the strings are more
		human-readable.  Basically, the same thing, only in the lowercase
		words. For example, TW_BEFORE_CHAINED would become "before-chained".
		This conversion is used by the provided tracer classes in their traces.
		</p><pre class="programlisting">static bool tracerWhenIsBefore(int when);
static bool tracerWhenIsAfter(int when);</pre><p>
		Check a TracerWhen value for whether it represents a point before or after
		calling a label. Right now all the valid values fall into one or the
		other classification.
		But more trace points that are neither <span class="quote">&#8220;<span class="quote">before</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">after</span>&#8221;</span> could get added
		in the future, so a good practice is to check explicitly for both
		conditions rather than a simple if/else with one condition.
		</p><pre class="programlisting">void setTracer(Onceref&lt;Tracer&gt; tracer);
Onceref&lt;Tracer&gt; getTracer() const;</pre><p>
		Set and get back the tracer object for the Unit. <code class="computeroutput">NULL</code> means
		that no tracer is set. It's possible to use the same tracer object
		for multiple units, as long as these units are in the same threads;
		that will combine the traces from these units into one trace.
		If you really want, it's even possible to use the same tracer object
		for the units in different threads but for that you must define
		your own tracer class that does the proper synchronization. None
		of the pre-defined tracers have the synchronization, since using
		them from multiple threads is usually not a good idea.
		</p><p>
		The clearing trigger objects are constructed with:
		</p><pre class="programlisting">UnitClearingTrigger(Unit *unit);</pre><p>
		The trigger is an Mtarget, so the typical use would be:
		</p><pre class="programlisting">{
  Autoref&lt;UnitClearingTrigger&gt; ctrig = new UnitClearingTrigger(myunit);
  ...
}</pre><p>
		At the block exit when the Autoref will get destroyed, it will destroy the trigger,
		which would in turn cause the clearing of the unit. Of course, you can
		also place the Autoref into another object, and then the destruction of
		that object would cause the clearing, instead of the end of the block.
		</p></div><div class="sect1" title="20.26. Unit Tracer reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_unit_tracer"></a>20.26. Unit Tracer reference</h2></div></div></div><a class="indexterm" name="id619316"></a><a class="indexterm" name="id485723"></a><p>
		Unlike Perl, in C++ the tracer is defined by inheriting from the class
		Unit::Tracer. The base class inherits from the Mtarget, and in the subclass
		you need at the minimum to define your virtual method:
		</p><pre class="programlisting">virtual void execute(Unit *unit, const Label *label, const Label
  *fromLabel, Rowop *rop, TracerWhen when);</pre><p>
		It gets called at the exactly same points as the Perl tracer (the C++
		part of the UnitTracerPerl forwards the calls to the Perl level). The
		arguments are also the same as described in the Perl docs:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="computeroutput">unit</code> is the unit being traced.
		</li><li class="listitem"><code class="computeroutput">label</code> is the current label being traced.
		</li><li class="listitem"><code class="computeroutput">fromLabel</code> is the parent label in the chaining (would be
		<code class="computeroutput">NULL</code> if the current label is called directly, without
		chaining from anything).
		</li><li class="listitem"><code class="computeroutput">rop</code> is the current row operation.
		</li><li class="listitem"><code class="computeroutput">when</code> is a constant showing the point when the
		tracer is being called. It's value may be one of
		<code class="computeroutput">Unit::TW_BEFORE</code>, 
		<code class="computeroutput">Unit::TW_AFTER</code>, 
		<code class="computeroutput">Unit::TW_BEFORE_DRAIN</code>,
		<code class="computeroutput">Unit::TW_AFTER_DRAIN</code>,
		<code class="computeroutput">Unit::TW_BEFORE_CHAINED</code>, 
		<code class="computeroutput">Unit::TW_AFTER_CHAINED</code>; 
		the prefix <code class="computeroutput">TW</code> stands for <span class="quote">&#8220;<span class="quote">tracer when</span>&#8221;</span>.
		</li></ul></div><p>
		Here is a simple example of a tracer:
		</p><pre class="programlisting">class SampleTracer : public Unit::Tracer
{
public:
  virtual void execute(Unit *unit, const Label *label,
    const Label *fromLabel, Rowop *rop, Unit::TracerWhen when)
  {
    printf("trace %s label '%s' %c\n", Unit::tracerWhenHumanString(when),
      label-&gt;getName().c_str(), Unit::tracerWhenIsBefore(when)? '{' : '}');
  }
};</pre><p>
		The Unit methods shown are documented in
		<a class="xref" href="#sc_cpp_unit" title="20.25. Unit reference">Section 20.25: &#8220;Unit reference&#8221; </a>.
		</p><p>
		The SampleTracer above was just printing the trace right away. Usually
		a better idea is to save the trace in the tracer object and return it
		on demand. Unit::Tracer provides the means to do that:
		an Erref object is used as a buffer, where the data can be added
		efficiently line-by-line, and later read back. The buffer is defined
		protected, so that the subclasses can access it but the end users can't:
		</p><pre class="programlisting">protected:
  Erref buffer_; // buffer for collecting the trace</pre><p>
		On each call the tracer's <code class="computeroutput">execute()</code> would build a string,
		and append it to the buffer:
		</p><pre class="programlisting">buffer_-&gt;appendMsg(false, traceString);</pre><p>
		The public interface for the buffer is:
		</p><pre class="programlisting">virtual Erref getBuffer();
virtual void clearBuffer();</pre><p>
		These methods are virtual to let the subclasses define their own
		version if they want. The methods do exactly what their names say.
		<code class="computeroutput">getBuffer()</code> returns the reference
		to the buffer in <code class="computeroutput">buffer_</code>, after which the end user has
		the full access to it.
		</p><p>
		The pattern of reading the buffer contents works like this:
		</p><pre class="programlisting">string tlog = trace-&gt;getBuffer()-&gt;print();
trace-&gt;clearBuffer();</pre><p>
		The log string can then be printed, or used in any other way.
		</p><p>
		The clearing of the buffer is done by discarding the old one and
		allocating a new one. An interesting consequence is that if you
		call <code class="computeroutput">getBuffer()</code>, save the reference, then call
		<code class="computeroutput">clearBuffer()</code>, the original buffer is still available
		at your saved reference and won't be changed any more, for example:
		</p><pre class="programlisting">Erref buf = trace-&gt;getBuffer();
trace-&gt;clearBuffer();
string tlog = buf-&gt;print();</pre><p>
		Of course, if a tracer subclass defines its own version of virtual methods,
		it may change this semantics.
		</p><p>
		It can be quite useful to include the row being processed into the trace,
		as the Perl examples show in 
		<a class="xref" href="#sc_sched_tracing" title="7.10. Tracing the execution">Section 7.10: &#8220;Tracing the execution&#8221; </a>.
		The C++ part of Triceps doesn't provide a ready row printer yet
		but Unit::Tracer provides a way for you to use your own row printer.
		Even two ways. One is to re-define the public method <code class="computeroutput">printRow()</code>:
		</p><pre class="programlisting">virtual void printRow(string &amp;res, const RowType *rt, const Row *row);</pre><p>
		The job of this method is to append the information from the row <code class="computeroutput">row</code> of the type
		<code class="computeroutput">rt</code> to the result string <code class="computeroutput">res</code>. <span class="emphasis"><em>Append</em></span>, not replace.
		</p><p>
		The second way is by providing a pointer to a simple C-style function of the type:
		</p><pre class="programlisting">typedef void RowPrinter(string &amp;res, const RowType *rt, const Row *row);</pre><p>
		The arguments and functionality are exactly the same as for the 
		method <code class="computeroutput">printRow()</code>. The base class implementation of
		<code class="computeroutput">printRow()</code> works by calling this function pointer of it's
		not NULL.  This pointer can be given to the Tracer constructor:
		</p><pre class="programlisting">Tracer(RowPrinter *rp = NULL);</pre><p>
		In general, the subclasses should also take this argument and pass it
		through to the parent class.  This allows the separation of the tracer
		itself and of the row printing: the user becomes capable of specifying
		any row printer.
		Since the default row printer is NULL, the row contents doesn't get printed
		by default.
		</p><p>
		Triceps provides a couple of stock tracer classes:
		</p><div class="variablelist"><dl><dt><span class="term">StringTracer</span></dt><dd><p>
				Collects the trace in a buffer, identifying the objects
				as addresses. This is not exactly easy to read normally but may come
				useful if you want to analyze a core dump.
				</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term">StringNameTracer</span></dt><dd><p>
				Similar but prints the object identification as
				names. More convenient but prone to the duplicate names used for
				different objects.
				</p></dd></dl></div><p>
		Everything but the constructors of these classes follows the general
		Tracer interface.  The constructors are:
		</p><pre class="programlisting">StringTracer(bool verbose = false, RowPrinter *rp = NULL);
StringNameTracer(bool verbose = false, RowPrinter *rp = NULL);</pre><p>
		The <code class="computeroutput">verbose</code> flag enables the tracing at all points,
		if it's set to <code class="computeroutput">false</code> then only the <code class="computeroutput">TW_BEFORE</code>
		points are traced. The argument <code class="computeroutput">rp</code> lets the end user supply
		a row printer function.
		</p><p>
		The tracing does not have to be used just for tracing. It can also be
		used as a breakpoint: check in your tracer for an
		arbitrary condition and stop if it has been met.
		</p><p>
		There is only one tracer per unit at a time. However if you want, you
		can implement the chaining in your own tracer (particularly useful if
		it's a breakpoint tracer): accept a reference to another tracer
		object, and after doing your own part, call that object's <code class="computeroutput">execute()</code>
		method.
		</p><p>
		Even though the Tracer class inherits from Mtarget, none of its methods
		have the synchronization in them. Thus each object must be used in only
		one thread. If you really want to use your tracer object from multiple
		threads, define your own subclass and re-implement all the virtual methods
		in it with synchronization.
		</p></div><div class="sect1" title="20.27. Label reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_label"></a>20.27. Label reference</h2></div></div></div><a class="indexterm" name="id565019"></a><p>
		In C++ the custom labels are defined by defining your own class that
		inherits from Label (which is defined in <code class="computeroutput">sched/Label.h</code>). 
		Like this small example from a unit test:
		</p><pre class="programlisting">class ForkingLabel : public Label
{
public:
  ForkingLabel(Unit *unit, Onceref&lt;RowType&gt; rtype, const string &amp;name,
      Onceref&lt;Label&gt; next) :
    Label(unit, rtype, name),
    next_(next)
  { }

  virtual void execute(Rowop *arg) const
  {
    unit_-&gt;fork(next_-&gt;adopt(arg));
  }

  Autoref&lt;Label&gt; next_;
};</pre><p>
		The subclass needs to define its own execution method:
		</p><pre class="programlisting">virtual void execute(Rowop *arg) const;</pre><p>
		The base class takes care of all the general execution mechanics,
		chaining etc. All you need to do in this method is perform your
		user-defined actions. By the way, this method is protected and should
		never be called directly. The labels must always be called through a
		unit, which will then execute them in the correct way.
		</p><p>
		The subclass may (though doesn't have to) also define the custom clearing method:
		</p><pre class="programlisting">virtual void clearSubclass();</pre><p>
		Currently this method is called by the public method <code class="computeroutput">clear()</code>
		after the label is marked as cleared but before clearing of the chain
		(though this order may change in the future).
		</p><p>
		The base class constructor is also protected, 
		it's always constructed from a subclass.
		You can not instantiate the base Label class because it contains an
		abstract <code class="computeroutput">execute()</code> method. 
		</p><pre class="programlisting">Label(Unit *unit, const_Onceref&lt;RowType&gt; rtype, const string &amp;name);</pre><p>
		The arguments are similar to the Perl version, only the Unit is passed
		as an argument to the Label constructor. 
		</p><p>
		The constructed label keeps a reference to its row type, and a pointer
		(not reference, to avoid the circular references!) to the unit. The unit
		automatically keeps a reference to the label, so there is no need to call
		<code class="computeroutput">Unit::rememberLabel()</code> manually. On the other hand, if you do not want
		the label to be remembered by its unit (though why?), the only way to achieve
		that is to call <code class="computeroutput">Unit::forgetLabel()</code> after its construction.
		</p><p>
		Now, the public methods of Label.
		</p><pre class="programlisting">const string &amp;getName() const;
const RowType *getType() const;
Unit *getUnitPtr() const;</pre><p>
		Read back the information from the constructor.
		The method <code class="computeroutput">getUnitPtr()</code> is named this way and not <code class="computeroutput">getUnit()</code> to
		emphasize that the Label has only a pointer to the Unit, not a
		reference. After the label gets cleared, <code class="computeroutput">getUnitPtr()</code> will return
		NULL.The reason is that after that the label doesn't know any more
		whether the unit still exists or has been deleted, and doesn't want to
		return a pointer to a potentially freed memory.
		</p><pre class="programlisting">const string &amp;getUnitName() const;</pre><p>
		A convenience method for the special case of getting the label's unit
		name. It's used in many error message. You can't just say
		<code class="computeroutput">label-&gt;getUnitPtr()-&gt;getName()</code> because <code class="computeroutput">getUnitPtr()</code> might return a
		NULL if the label has been already cleared. <code class="computeroutput">getUnitName()</code> takes care of it and returns a special string
		"[label cleared]" if the label has been cleared.
		</p><pre class="programlisting">void clear();</pre><p>
		Clears the label. After that the label stops working. Note that
		clearing a label doesn't disconnect it from its unit. Well, the label
		won't tell you its unit any more (the pointer will be reset to NULL) but the unit will still have a
		reference to the label! Use the unit's method <code class="computeroutput">forgetLabel()</code> to
		disconnect it (but that won't clear the label itself, so you have to
		call both <code class="computeroutput">unit-&gt;forgetLabel()</code> and <code class="computeroutput">label-&gt;clear()</code>). Of course, if you
		call <code class="computeroutput">unit-&gt;clearLabels()</code>, that would take care of everything.
		</p><p>
		Clearing cleans the chaining list of this label but doesn't call
		recursively <code class="computeroutput">clear()</code> on the formerly chained labels. If you need that,
		you have to do it yourself.
		</p><pre class="programlisting">bool isCleared() const;</pre><p>
		Check if the label has been cleared.
		</p><pre class="programlisting">void setNonReentrant();
bool isNonReentrant() const;</pre><p>
		Mark the label as non-reentrant, and check this flag. There is no way
		to unset this flag. The meaning of it is described in
		<a class="xref" href="#sc_sched_recursion" title="7.13. Recursion control">Section 7.13: &#8220;Recursion control&#8221; </a>.
		</p><pre class="programlisting">Erref chain(Onceref&lt;Label&gt; lab, bool front = false);</pre><p>
		Chain another label to this one (so when this label is executed, the
		chained labels will also be executed in order). This label will keep a
		reference of the chained label. The circular chainings are forbidden
		and will throw an Exception.
		If the argument <code class="computeroutput">front</code> is <code class="computeroutput">false</code> (default), the chaining 
		will be done at the back of the chain, if <code class="computeroutput">true</code> then at the front,
		same as the method <code class="computeroutput">chainFront()</code> in the Perl API.
		In the C++ API both kinds of chainings are done with the same method.
		</p><pre class="programlisting">typedef vector&lt;Autoref&lt;Label&gt; &gt; ChainedVec;
const ChainedVec &amp;getChain() const;</pre><p>
		Get back the information about the chained labels. This returns a
		reference to the internal vector, so if the chainings are changed
		afterwards, the changes will be visible in the vector.
		</p><pre class="programlisting">bool hasChained() const;</pre><p>
		A quick check, whether there is anything chained.
		</p><pre class="programlisting">void clearChained();</pre><p>
		Clear the chaining list of this label. (But doesn't call <code class="computeroutput">clear()</code> on
		these labels!)
		</p><pre class="programlisting">Rowop *adopt(Rowop *from) const;</pre><p>
		A convenient factory method for adopting the rowops. Treat it similarly to a
		constructor: the returned Rowop will be newly constructed and have the
		reference count of 0; the returned pointer must be stored in an Autoref (or
		Onceref). This method by itself doesn't check whether the original
		Rowop has a matching type, it simply makes a copy with the label
		reference replaced. It's up to you to make sure that the labels are
		correct.
		</p><p>
		A special subclass of the Label is DummyLabel: it's a label that does
		nothing. It's <code class="computeroutput">execute()</code> method is empty. It's constructed very
		similarly to the normal Label:
		</p><pre class="programlisting">DummyLabel(Unit *unit, const_Onceref&lt;RowType&gt; rtype, const string &amp;name);</pre><a class="indexterm" name="id577179"></a><p>
		The dummy labels are convenient for chaining the other labels to them. 
		</p></div><div class="sect1" title="20.28. Rowop reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_rowop"></a>20.28. Rowop reference</h2></div></div></div><a class="indexterm" name="id582047"></a><p>
		The Rowop class is defined in <code class="computeroutput">sched/Rowop.h</code> though usually
		there is no need to include it directly, just include <code class="computeroutput">sched/Unit.h</code>
		which will pull in the rest of the scheduling classes.
		</p><p>
		The Rowop in C++ consists of all the same parts as in Perl API: a
		label, a row, and opcode.
		</p><p>
		It has one more item that's not really visible in the Perl API, the
		enqueueing mode, but it's semi-hidden in the C++ API as well. The only
		place where it's used is in <code class="computeroutput">Unit::enqueueDelayedTray()</code>. This
		allows to build a tray of rowops, each with its own enqueueing mode,
		and then enqueue all of them appropriately in one go. This feature is
		kind of historic and will be removed somewhere soon.
		</p><p>
		The Rowop class inherits from Starget, usable in one thread only. Since
		it refers to the Labels, that are by definition single-threaded, this
		makes sense. A consequence is that you can't simply pass the Rowops
		between the threads. The passing-between-threads is handled by the
		Nexuses, performing the translation of the Labels along the way.
		</p><p>
		The opcodes are defined in the enum Rowop::Opcode, so you normally use
		them as <code class="computeroutput">Rowop::OP_INSERT</code> etc. The opcodes actually
		contain a bitmap of individual flags, defined in the enum
		Rowop::OpcodeFlags: <code class="computeroutput">Rowop::OCF_INSERT</code> and <code class="computeroutput">Rowop::OCF_DELETE</code>. You don't
		really need to use these flags directly unless you really, really want
		to.
		</p><a class="indexterm" name="id549298"></a><p>
		Besides the 3 already described opcodes (OP_NOP, OP_INSERT and
		OP_DELETE) there is another one, OP_BAD. It's a special value returned
		by the string-to-opcode conversion method instead of the -1 returned by
		the other similar method. The reason is that OP_BAD is specially
		formatted to be understood by all the normal opcode type checks as NOP
		(i.e. both flags OCF_INSERT and OCF_DELETE are reset in it),
		while -1 would be seen as a combination of INSERT and DELETE. So if you
		miss checking the result of conversion on a bad string, at least you
		would get a NOP and not some mysterious operation. The reason why
		OP_BAD is not exported to Perl is that in Perl an <code class="computeroutput">undef</code> is used as the
		indication of the invalid value, and works even better.
		</p><p>
		There is a pretty wide variety of Rowop constructors:
		</p><pre class="programlisting">Rowop(const Label *label, Opcode op, const Row *row);
Rowop(const Label *label, Opcode op, const Rowref &amp;row);

Rowop(const Label *label, Opcode op, const Row *row, int enqMode);
Rowop(const Label *label, Opcode op, const Rowref &amp;row, int enqMode);

Rowop(const Rowop &amp;orig);
Rowop(const Label *label, const Rowop *orig);</pre><p>
		The constructors with the explicit <code class="computeroutput">enqMode</code> are best not be used outside
		of the Triceps internals, and will eventually be obsoleted. The last
		two are the copy constructor, and the adoption constructor which
		underlies <code class="computeroutput">Label::adopt()</code> and can as well be used directly.
		</p><p>
		Once a rowop is constructed, its components can not be changed any
		more, only read.
		</p><pre class="programlisting">Opcode getOpcode() const;
const Label *getLabel() const;
const Row *getRow() const;
int getEnqMode() const;</pre><p>
		Read back the components of the Rowop. Again, the <code class="computeroutput">getEnqMode()</code> is on
		the way to obsolescence. And if you need to check the opcode for being
		an insert or delete, the better way is to use the explicit test
		methods, rather than getting the opcode and comparing it for equality:
		</p><pre class="programlisting">bool isInsert() const;
bool isDelete() const;
bool isNop() const;</pre><p>
		Check whether the opcode requests an insert or delete (or neither).
		</p><p>
		The same checks are available as static methods that can be used on the
		opcode values:
		</p><pre class="programlisting">static bool isInsert(int op);
static bool isDelete(int op);
static bool isNop(int op);</pre><p>
		And the final part is the conversion between the strings and integer values for
		the Opcode and OpcodeFlags enums:
		</p><pre class="programlisting">static const char *opcodeString(int code);
static int stringOpcode(const char *op);
static const char *ocfString(int flag, const char *def = "???");
static int stringOcf(const char *flag);</pre><p>
		As mentioned above, <code class="computeroutput">stringOpcode()</code> returns OP_BAD for the unknown strings, not -1. 
		</p></div><div class="sect1" title="20.29. Tray reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_tray"></a>20.29. Tray reference</h2></div></div></div><a class="indexterm" name="id583336"></a><p>
		A Tray in C++, defined in <code class="computeroutput">shed/Tray.h</code>, is simply a deque of Rowop
		references, plus an Starget, so that it can be reference-counted like the
		rest of Triceps classes:
		</p><pre class="programlisting">class Tray : public Starget, public deque&lt; Autoref&lt;Rowop&gt; &gt;</pre><p>
		All it really defines is the constructors:
		</p><pre class="programlisting">Tray();
Tray(const Tray &amp;orig);</pre><p>
		The operations on the Tray are just the usual deque operations.
		</p><p>
		Yes, you can copy the trays by constructing a new one from an old one:
		</p><pre class="programlisting">Autoref&lt;Tray&gt; t1 = new Tray;
t1-&gt;push_back(op1);

Autoref&lt;Tray&gt; t3 = new Tray(*t1);</pre><p>
		Afterwards <code class="computeroutput">t3</code> will contain references to the same rowops as <code class="computeroutput">t1</code> (but
		will be a different Tray than <code class="computeroutput">t1</code>!).
		</p><p>
		The assignments (<code class="computeroutput">operator=</code>) happen to just work out of the box because
		the <code class="computeroutput">operator=</code> implementation in Starget does the smart thing and avoids
		the corruption of the reference counter. So you can do things like
		</p><pre class="programlisting">*t3 = *t1;</pre><p>
		It's worth noting once more that unlike Rows and Rowops, the Trays
		are mutable. If you have multiple references to the same Tray,
		modifying the Tray will make the new contents visible through all
		the references!
		</p><p>
		An important difference from the Perl API is that in C++ the Tray is
		not associated with a Unit. It's constructed simply by calling its
		constructor, and there is no Unit involved. It's possible to create a
		tray that contains a mix of rowops for different units. If you combine
		the C++ and Perl code, and then create such mixes in the C++ part, the
		Perl part of your code won't be happy.
		</p><p>
		And there is actually a way to create the mixed-unit trays even in the
		Perl code, in the tray of FnBinding. But this situation would be caught
		when trying to get the tray from FnBinding into the Perl level, and the workaround 
		for handling them is to use the method <code class="computeroutput">FnBinding:callTray()</code>.
		</p><p>
		The reason why Perl associates the trays with a unit is to make the
		check of enqueueing a tray easy: just check that the tray belongs to
		the right unit, and it's all guaranteed to be right. At the C++ level
		no such checks are made. If you enqueue the rowops on labels belonging
		to a wrong unit, they will be enqueued quietly, will attempt to
		execute, and from there everything will likely go very wrong. So be
		disciplined. And maybe I'll think of a better way for keeping the unit
		consistency in the future. 
		</p></div><div class="sect1" title="20.30. FrameMark reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_framemark"></a>20.30. FrameMark reference</h2></div></div></div><a class="indexterm" name="id601936"></a><p>
		The FrameMark (defined in <code class="computeroutput">sched/FrameMark.h</code>) marks the unit's frame at
		the start of the loop, to fork there the rowops for the next iterations
		of the loop. It's pretty simple:
		</p><pre class="programlisting">FrameMark(const string &amp;name);</pre><p>
		The constructor. It gives the mark a name. A FrameMark is an Starget,
		so it may be used only in one thread.
		</p><pre class="programlisting">const string &amp;getName() const;</pre><p>
		Read back the name.
		</p><pre class="programlisting">Unit *getUnit() const;</pre><p>
		This method is different from <code class="computeroutput">getUnit()</code> on most of the other classes.
		It returns the pointer to the unit, on which it has been set. A freshly
		created FrameMark would return NULL. Internally a FrameMark doesn't
		keep a reference to the unit, it's just a pointer, and a way for the
		Unit to check in <code class="computeroutput">loopAt()</code> that the mark has been indeed set on this
		unit (it would refuse to fork the rowops there otherwise). 
		And you can use it for the entertainment purposes too. Normally
		when the frame marked with this mark gets popped from the Unit's stack,
		the mark becomes unset, and its <code class="computeroutput">getUnit()</code> will return NULL.
		</p><p>
		All the actions on the FrameMark are done by passing it to the
		appropriate methods of the Unit. When a mark is set on a frame, the
		frame has a reference to it, so the mark won't be destroyed until the
		frame is freed. 
		</p></div><div class="sect1" title="20.31. RowSetType reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_rowset"></a>20.31. RowSetType reference</h2></div></div></div><a class="indexterm" name="id482267"></a><p>
		RowSetType, defined in <code class="computeroutput">types/RowSetType.h</code>, is another item that is not
		visible in Perl. Maybe it will be in the future but at the moment
		things look good enough without it. It 
		expresses the type (<span class="quote">&#8220;<span class="quote">return type</span>&#8221;</span> if you want to be precise) of a
		streaming function (FnReturn and FnBinding classes). Naturally, it's a
		sequence of the row types, and despite the word <span class="quote">&#8220;<span class="quote">set</span>&#8221;</span>, the order
		of its elements matters.
		</p><p>
		A RowSetType is one of these objects that get assembled from many
		parts and then initialized, like this:
		</p><pre class="programlisting">Autoref&lt;RowSetType&gt; rst = initializeOrThrow(RowSetType::make()
  -&gt;addRow("name1", rt1)
  -&gt;addRow("name2", rt2)
);</pre><p>
		Of course, nothing stops you from adding the row types one by one, in a
		loop or in some other way, and then calling <code class="computeroutput">initialize()</code> manually. And
		yes, of course you can keep a reference to a row set type as soon as it
		has been constructed, not waiting for initialization. You could do
		instead:
		</p><pre class="programlisting">Autoref&lt;RowSetType&gt; rst = new RowSetType();
rst-&gt;addRow("name1", rt1);
rst-&gt;addRow("name2", rt2);
rst-&gt;initialize();
if (rst-&gt;getErrors()-&gt;hasError()) {
  ...
}</pre><p>
		You could use the <code class="computeroutput">initializeOrThrow()</code> template after the
		piecemeal construction as well, just I
		also wanted to show the way for the manual handling of the errors. And
		you can use the <code class="computeroutput">new</code> or <code class="computeroutput">make()</code> interchangeably.
		</p><p>
		All that the initialization does is fixate the row set, forbid the
		addition of the further row types to it. Which makes sense at
		the moment but I'm not so sure about the future, in the future the
		dynamically expandable row sets might come useful. We'll see when we
		get there.
		</p><pre class="programlisting">RowSetType();
static RowSetType *make();</pre><p>
		Construct a row set type. The method <code class="computeroutput">make()</code> is just a wrapper around
		the constructor that is more convenient to use with the following
		<code class="computeroutput">-&gt;addRow()</code>, because of the way the operator priorities work in C++.
		Like any other type, RowSetType is unnamed by itself, and takes no
		constructor arguments. Like any other type, RowSetType is an Mtarget
		and can be shared between multiple threads after it has been
		initialized.
		</p><pre class="programlisting">RowSetType *addRow(const string &amp;rname, const_Autoref&lt;RowType&gt;rtype);</pre><p>
		Add a row type to the set. All the row types are named, and all the
		names must be unique within the set. The order of the addition matters
		too. See the further explanation of why it does in the description of
		the FnReturn in
		<a class="xref" href="#sc_cpp_fnreturn" title="20.32. FnReturn reference">Section 20.32: &#8220;FnReturn reference&#8221; </a>.
		If this method detects an error (such as duplicate
		names), it will append the error to the internal Errors object, that
		can be read later by <code class="computeroutput">getErrors()</code>. A type with errors must not be used.
		</p><p>
		The row types may not be added after the row set type has been
		initialized.
		</p><pre class="programlisting">void initialize();</pre><p>
		Initialize the type. Any detected errors can be read afterwards with
		<code class="computeroutput">getErrors()</code>. The repeated calls of <code class="computeroutput">initialize()</code> are ignored.
		</p><pre class="programlisting">bool isInitialized() const;</pre><p>
		Check whether the type has been initialized.
		</p><pre class="programlisting">typedef vector&lt;string&gt; NameVec;
const NameVec &amp;getRowNames() const;
typedef vector&lt;Autoref&lt;RowType&gt; &gt; RowTypeVec;
const RowTypeVec &amp;getRowTypes() const;</pre><p>
		Read back the contents of the type. The elements will go in the order
		they were added.
		</p><pre class="programlisting">int size() const;</pre><p>
		Read the number of row types in the set.
		</p><pre class="programlisting">int findName(const string &amp;name) const;</pre><p>
		Translate the row type name to index (i.e. the order in which it was
		added, starting from 0). Returns -1 on an invalid name.
		</p><pre class="programlisting">RowType *getRowType(const string &amp;name) const;</pre><p>
		Find the type by name. Returns NULL on an invalid name.
		</p><pre class="programlisting">const string *getRowTypeName(int idx) const;
RowType *getRowType(int idx) const;</pre><p>
		Read the data by index. These methods check that the index is in the
		valid range, and otherwise return NULL.
		</p><p>
		The usual methods inherited from Type also work: <code class="computeroutput">getErrors()</code>, <code class="computeroutput">equals()</code>,
		<code class="computeroutput">match()</code>, <code class="computeroutput">printTo()</code>.
		</p><p>
		The row set types are considered equal if they contain the equal row
		types with equal names going in the same order. They are considered
		matching if they contain matching row types going in the same order,
		with any names. If the match condition seems surprising to you, think
		of it as <span class="quote">&#8220;<span class="quote">nothing will break if one type is substituted for another at
		execution time</span>&#8221;</span>.
		</p><pre class="programlisting">void addError(const string &amp;msg);
Erref appendErrors();</pre><p>
		The ways to add extra errors to the type's errors. It's for convenience
		of the users of this type, the thinking being that since we already
		have one Errors object, we can as well use it for everything, and also
		keep all the errors reported in the order of the fields, rather than
		first all the errors from the type then all the errors from its user.
		The FnReturn and FnBinding use it. 
		</p></div><div class="sect1" title="20.32. FnReturn reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_fnreturn"></a>20.32. FnReturn reference</h2></div></div></div><a class="indexterm" name="id585569"></a><p>
		FnReturn, defined in <code class="computeroutput">sched/FnReturn.h</code>, is generally constructed
		similarly to the RowSetType:
		</p><pre class="programlisting">ret = initializeOrThrow(FnReturn::make(unit, name)
  -&gt;addLabel("lb1", rt1)
  -&gt;addFromLabel("lb2", lbX)
);</pre><p>
		Or of course piece-meal. As it gets built, it actually builds a
		RowSetType inside itself.
		</p><pre class="programlisting">FnReturn(Unit *unit, const string &amp;name);
static FnReturn *make(Unit *unit, const string &amp;name);</pre><p>
		The constructor and convenience wrapper. The unit will be remembered
		only as a pointer, not reference, to avoid the reference loops. However
		this pointer will be used to construct the internal labels. So until
		the FnReturn is fully initialized, you better make sure that the Unit
		object has a reference and doesn't get freed. FnReturn is an Starget,
		and must be used in only one thread.
		</p><pre class="programlisting">const string &amp;getName() const;
Unit *getUnitPtr() const;
const string &amp;getUnitName() const;</pre><p>
		Get back the information from the constructor. Just like for the Label class,
		it reminds you that the Unit is only available as a pointer, not a
		reference, here.  The FnReturn also has a concept of clearing: it has
		the special labels inside, and once any of these labels gets cleared,
		the FnReturn is also cleared by setting the unit pointer to NULL and
		forgetting the FnContext (see more on that below).  So after the
		FnReturn is cleared, <code class="computeroutput">getUnitPtr()</code> will return NULL. And again similarly
		to the Label, there is a convenience function to get the unit name for
		informational printouts. When FnReturn is cleared, it returns the constant string
		<span class="quote">&#8220;<span class="quote">[fn return cleared]</span>&#8221;</span>.
		</p><pre class="programlisting">FnReturn *addFromLabel(const string &amp;lname, Autoref&lt;Label&gt;from, bool front = true);</pre><p>
		Add a label to the return by chaining it off another label. <code class="computeroutput">lname</code> is
		the name within the return. The full name of the label will be
		<span class="quote">&#8220;<span class="quote">return_name.label_name</span>&#8221;</span>. The label names within a return must be unique
		and not empty, or it will be returned as an initialization error. The
		label type will be copied (actually, referenced) from the <code class="computeroutput">from</code> label,
		and the new label will be automatically chained off it. If the argument
		<code class="computeroutput">front</code> is <code class="computeroutput">false</code>, the chaining will be done at the
		back of the chain, if <code class="computeroutput">true</code> (default) then at the front.
		The front chaining is convenient if you want to pass both
		the original request and the result into the return. Usually you
		would define the result computation and then define the return.
		With the chaining at the back, this would lead to the computation
		chained off the input label first and the return going after it.
		This would lead to the result coming out before the argument,
		and special contortions would be needed to avoid it. With chaining
		at the front, the return will go in the chain before the computation,
		even if the return was defined last.
		The labels can
		be added only until the return is initialized, or it will throw an
		Exception.
		</p><pre class="programlisting">FnReturn *addLabel(const string &amp;lname, const_Autoref&lt;RowType&gt;rtype);</pre><p>
		Add a new independent label to the return. Works very similarly to
		<code class="computeroutput">addFromLabel()</code>, only uses the explicit row type and doesn't chain to
		anything. The label can be later found with <code class="computeroutput">getLabel()</code> and either
		chained off something or used to send the rows to it explicitly. The
		labels can be added only until the return is initialized.
		</p><pre class="programlisting">class FnContext: public Starget
{
public:
  virtual ~FnContext();
  virtual void onPush(const FnReturn *fret) = 0;
  virtual void onPop(const FnReturn *fret) = 0;
};
FnReturn *setContext(Onceref&lt;FnContext&gt; ctx);</pre><p>
		Set the context with handlers for the pushing and popping of the
		bindings in the FnReturn. FnContext is a top-level class, not nested
		in FnReturn.  
		I.e. <span class="bold"><strong>not</strong></span> Triceps::FnReturn::FnContext but Triceps::FnContext. 
		Triceps generally tries to follow the C++
		tradition of using the virtual methods for the callbacks, with the user
		then subclassing the base class and replacing the callback methods.
		However subclassing FnReturn is extremely inconvenient, because it gets
		connected to the other objects in a quite complicated way. So the
		solution is to make a separate context class for the callbacks, and
		then connect it.  
		The callbacks will be called just before the
		binding is pushed or popped, but after the check for the correctness of
		the push or pop. They can be used to adjust the state of the streaming
		function by pushing or popping its stack of local variables, like was
		shown in the Perl examples in
		<a class="xref" href="#sc_strf_more_recursion" title="15.10. Streaming functions and more recursion">Section 15.10: &#8220;Streaming functions and more recursion&#8221; </a>.
		The context may be set only until the return is initialized.
		</p><pre class="programlisting">template&lt;class C&gt; C *contextIn() const;</pre><p>
		Get back the context. Since the context will be a subclass of
		FnContext, this also handles the correct type casting. Use it like:
		</p><pre class="programlisting">Autoref&lt;MyFnCtx&gt; ctx = fret1-&gt;contextIn&lt;MyFnCtx&gt;();</pre><p>
		The type is converted using the <code class="computeroutput">static_cast</code>, and you need to know the
		correct type in advance, or your program will break in some horrible
		ways. If the context has not been set, it will return a NULL.
		</p><pre class="programlisting">void initialize();</pre><p>
		Initialize the FnReturn. Very similar to the Type classes, it will
		collect the errors in an Errors object that has to be checked
		afterwards, and an FnReturn with errors must not be used. The
		initialization can be called repeatedly with no ill effects. After
		initialization the structure of the return (labels and context) can not
		be changed any more.
		</p><pre class="programlisting">Erref getErrors() const;</pre><p>
		Get the errors that were detected during construction and initialization. 
		Normally called after initialization but can
		also be called at any stage, as the errors are collected all the way
		through the object construction.
		</p><pre class="programlisting">bool isInitialized() const;</pre><p>
		Check whether the return is initialized.
		</p><pre class="programlisting">RowSetType *getType() const;</pre><p>
		Get the type of the return, which gets built internally by the return.
		The names of the row types in the set will be the same as the names of
		labels in the return, and their order will also be the same. This call
		can be made only after initialization, or it will throw an Exception.
		</p><pre class="programlisting">int size() const;</pre><p>
		Get the number of labels in the return. Can be called at any time.
		</p><pre class="programlisting">const RowSetType::NameVec &amp;getLabelNames() const;
const RowSetType::RowTypeVec &amp;getRowTypes() const;
const string *getLabelName(int idx) const;
RowType *getRowType(const string &amp;name) const;
RowType *getRowType(int idx) const;</pre><p>
		Get the piecemeal information about the label names and types. These
		are really the convenience wrappers around the RowSetType. Note that
		they return pointers to be able to return NULL on the argument that is
		out of range. A somewhat special feature is that even though the row
		set type can be read only after initialization (after it becomes frozen
		and can not be messed with any more), these wrappers work at any time,
		even when the return is being built.
		</p><pre class="programlisting">bool equals(const FnReturn *t) const;
bool match(const FnReturn *t) const;
bool equals(const FnBinding *t) const;
bool match(const FnBinding *t) const;</pre><p>
		Convenience wrappers that compare the equality or match of the
		underlying row set types.
		</p><pre class="programlisting">Label *getLabel(const string &amp;name) const;
int findLabel(const string &amp;name) const;
Label *getLabel(int idx) const;</pre><p>
		Get the label by name or index, or the index of the label by name.
		Return a NULL pointer or -1 index on an invalid argument.
		</p><pre class="programlisting">typedef vector&lt;Autoref&lt;RetLabel&gt; &gt; ReturnVec;
const ReturnVec &amp;getLabels() const;</pre><p>
		Get the whole set of labels. FnReturn::RetLabel is a special private
		label type with undisclosed internals. You need to treat these labels
		as being a plain Label.
		</p><pre class="programlisting">void push(Onceref&lt;FnBinding&gt; bind);</pre><p>
		Push a binding on the return stack. The return must be initialized, and
		the binding must be of a matching type, or an Exception will be thrown.
		The reference to the binding will be kept in the FnReturn until it's popped.
		</p><pre class="programlisting">void pushUnchecked(Onceref&lt;FnBinding&gt; bind);</pre><p>
		Similar to <code class="computeroutput">push()</code>, only the type of the binding is not checked. 
		This method is not available in Perl, it's
		an optimization for the automatically generated code that does all the
		type checks up front at the generation time. The manually written code
		probably should not be using it.
		</p><pre class="programlisting">void pop(Onceref&lt;FnBinding&gt; bind);</pre><p>
		Pop a binding from the return stack. The binding argument specifies,
		which binding is expected to be popped. It's not strictly necessary 
		(use the <code class="computeroutput">pop()</code> without arguments to skip it) but
		allows to catch any mess-ups with the return stack early. If the stack
		is empty or the top binding is not the same as the argument, throws an
		Exception.
		</p><pre class="programlisting">void pop();</pre><p>
		The unchecked version. It still checks and throws if the stack is
		empty. This method may come handy occasionally, but in general the
		checked version should be preferred. Pretty much the only reason to use
		it would be if you try to restore after a major error and want to pop
		everything from all your FnReturns untill their stacks become empty.
		But there is much trouble with this kind of restoration.
		</p><pre class="programlisting">int bindingStackSize() const;</pre><p>
		Get the current size of the return stack (AKA the stack of bindings). Useful
		for debugging.
		</p><pre class="programlisting">typedef vector&lt;Autoref&lt;FnBinding&gt; &gt; BindingVec;
const BindingVec &amp;bindingStack() const;</pre><p>
		Get the current return stack. Useful for debugging. 
		</p><pre class="programlisting">bool isFaceted() const;</pre><a class="indexterm" name="id582946"></a><p>
		Returns <code class="computeroutput">true</code> if this FnReturn object is a part of a Facet.
		</p></div><div class="sect1" title="20.33. FnBinding reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_fnbind"></a>20.33. FnBinding reference</h2></div></div></div><a class="indexterm" name="id491432"></a><p>
		FnBinding is defined in <code class="computeroutput">sched/FnBinding.h</code>, and substantially matches
		the Perl version. It inherits from Starget, and can be used in only one
		thread.
		</p><p>
		Like many other classes, it has the constructor and the static <code class="computeroutput">make()</code>
		function:
		</p><pre class="programlisting">FnBinding(const string &amp;name, FnReturn *fn);
static FnBinding *make(const string &amp;name, FnReturn *fn);</pre><p>
		The binding is constructed on a specific FnReturn and obtains (references)
		the RowSetType from it. The FnReturn must be initialized before it can
		be used to create the bindings. Later the FnBinding can be pushed onto any matching
		FnReturn, not just the one it was constructed with.
		</p><p>
		It's generally constructed in a chain fashion:
		</p><pre class="programlisting">Autoref&lt;FnBinding&gt; bind = FnBinding::make(fn)
  -&gt;addLabel("lb1", lb1, true)
  -&gt;addLabel("lb2", lb2, false);</pre><p>
		Each method in the chain returns the same FnBinding object. The method
		<code class="computeroutput">addLabel()</code> adds one concrete label that gets connected to the
		FnReturn's label by name. The other chainable method is <code class="computeroutput">withTray()</code>
		which switches the mode of collecting the resulting rowops in a tray
		rather than calling them immediately.
		</p><p>
		The errors encountered during the chained construction are remembered
		and can be read later with the method:
		</p><pre class="programlisting">Erref getErrors() const;</pre><p>
		You must check the bindings for errors before using it. A binding with
		errors may not be used.
		</p><p>
		Or you can use the <code class="computeroutput">checkOrThrow()</code> wrapper from <code class="computeroutput">common/Initialize.h</code> to
		automatically convert any detected errors to an Exception:
		</p><pre class="programlisting">Autoref&lt;FnBinding&gt; bind = checkOrThrow(FnBinding::make(fn)
  -&gt;addLabel("lb1", lb1, true)
  -&gt;addLabel("lb2", lb2, false)
  -&gt;withTray(true)
);</pre><p>
		Continuing with the details of chainable methods:
		</p><pre class="programlisting">FnBinding *addLabel(const string &amp;name, Autoref&lt;Label&gt; lb, bool autoclear);</pre><p>
		Adds a label to the binding. The name must match a name from the
		FnReturn, and there may be only one label bound to a name (some names
		from the return may be left unbound, and the rowops coming to them
		will be ignored). The label must have a type
		matching the named FnReturn's label. The autoclear flag enables the
		automatic clearing of the label (and also forgetting it in the Unit)
		when the binding gets destroyed. This allows to create and destroy the
		bindings dynamically as needed. So, basically, if you've created a
		label just for the binding, use <code class="computeroutput">autoclear==true</code>. If you do a binding to
		a label that exists in the model by itself and can be used without the
		binding, use <code class="computeroutput">autoclear==false</code>.
		</p><p>
		In principle, nothing stops you from adding more labels later (though
		you can't remove nor replace the labels that are already added). Just
		make sure that their types match the expected ones.
		</p><p>
		The labels in the FnBinding may belong to a different Unit than the
		FnReturn. This allows to use the FnReturn/FnBinding coupling to connect
		the units.
		</p><pre class="programlisting">FnBinding *withTray(bool on);</pre><p>
		Changes the tray collection mode, the argument <code class="computeroutput">on==true</code> enables it, 
		<code class="computeroutput">on==false</code>
		disables. Can be done at any time, not just at construction. Disabling
		the tray mode discards the current tray. If the tray mode is enabled,
		whenever the binding is pushed onto a return and the rowops come into
		it, the labels in this binding won't be called immediately but they
		would adopt the incoming rowops, and the result will be queued into a
		tray, to be executed later.
		</p><pre class="programlisting">Onceref&lt;Tray&gt; swapTray();</pre><p>
		Used with the tray collection mode, normally after some rowops have
		been collected in the tray. Returns the current tray and replaces it in
		the binding with a new clean tray. You can call the returned tray
		afterwards. If the tray mode is not enabled, will return NULL, and
		won't create a new tray.
		</p><pre class="programlisting">Tray *getTray() const;</pre><p>
		Get the current tray. You can use and modify the tray contents in any
		usual way.  If the tray mode is not enabled, will return NULL.
		</p><pre class="programlisting">void callTray();</pre><p>
		A convenience combination method that swaps the tray and calls it. This
		method is smart about the labels belonging to different units. Each
		rowop in the tray is called with its proper unit, that is found from
		the rowop's label. Mixing the labels of multiple units in one binding
		is probably still not such a great idea, but it works anyway.
		</p><pre class="programlisting">const string &amp;getName() const;</pre><p>
		Get back the binding's name.
		</p><pre class="programlisting">RowSetType *getType() const;</pre><p>
		Get the type of the binding. It will be the same row set type object as
		created in the FnReturn that was used to construct this FnBinding.
		</p><pre class="programlisting">int size() const;</pre><p>
		Get the number of labels in the row set type (of all available labels,
		not just the ones that have been added).
		</p><pre class="programlisting">const RowSetType::NameVec &amp;getLabelNames() const;
const RowSetType::RowTypeVec &amp;getRowTypes() const;
const string *getLabelName(int idx) const;
RowType *getRowType(const string &amp;name) const;
RowType *getRowType(int idx) const;</pre><p>
		The convenience wrappers that translate to the same methods in the
		RowSetType.
		</p><pre class="programlisting">Label *getLabel(const string &amp;name) const;
int findLabel(const string &amp;name) const;
Label *getLabel(int idx) const;</pre><p>
		Methods similar to FnReturn that allow to translate the names to
		indexes and get the labels by name or index. The same return values,
		the index -1 is returned for an unknown name, and a NULL label pointer
		is returned for an unknown name, an incorrect index and an undefined label
		at a correct name or index.
		</p><pre class="programlisting">typedef vector&lt;Autoref&lt;Label&gt; &gt; LabelVec;
const LabelVec &amp;getLabels() const;</pre><p>
		Return all the labels as a vector. This is an internal vector of the
		class, so only a const reference is returned. The elements for
		undefined labels will contain NULLs.
		</p><pre class="programlisting">typedef vector&lt;bool&gt; BoolVec;
const BoolVec &amp;getAutoclear() const;</pre><p>
		Return the vector of the autoclear flags for the labels.
		</p><pre class="programlisting">bool isAutoclear(const string &amp;name) const;</pre><p>
		Get the autoclear flag for a label by name. If the name is unknown,
		will quietly return <code class="computeroutput">false</code>.
		</p><pre class="programlisting">bool equals(const FnReturn *t) const;
bool match(const FnReturn *t) const;
bool equals(const FnBinding *t) const;
bool match(const FnBinding *t) const;</pre><p>
		Similarly to the FnReturn, the convenience methods that compare the
		types between the FnReturns and FnBindings. They really translate to
		the same methods on the types of the returns or bindings. 
		</p></div><div class="sect1" title="20.34. ScopeFnBind and AutoFnBind reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_autofn"></a>20.34. ScopeFnBind and AutoFnBind reference</h2></div></div></div><a class="indexterm" name="id558361"></a><p>
		A couple more of helper classes are defined in <code class="computeroutput">sched/FnReturn.h</code>.
		</p><p>
		ScopeFnBind does a scoped pushing and popping of a binding on an
		FnReturn. Its only method is the constructor:
		</p><pre class="programlisting">ScopeFnBind(Onceref&lt;FnReturn&gt; ret, Onceref&lt;FnBinding&gt; binding);</pre><p>
		It's used as:
		</p><pre class="programlisting">{
    ScopeFnBind autobind(ret, binding);
    ...
}</pre><p>
		It will pop the binding at the end of the block. An unpleasant feature
		is that if the return stack get messed up, it will throw an Exception
		from a destructor, which is a big no-no in C++. However since normally
		in the C++ code the Triceps Exception is essentially an abort, this
		works good enough. If you make the Exception catchable, such as when
		calling the C++ code from an interpreter, you better make very sure
		that the stack can not get corrupted, or do not use ScopeFnBind.
		</p><a class="indexterm" name="id519420"></a><p>
		AutoFnBind is a further extension of the scoped binding. It does three
		additional things: 
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			It allows to push multiple bindings on multiple
			returns as a group, popping them all on destruction. 
			</li><li class="listitem">
			It's a
			reference-counted Starget object, which allows the scope to be more
			than one block. 
			</li><li class="listitem">
			It also has a more controllable way of dealing with the
			exceptions. 
			</li></ul></div><p>
		This last two properties allow it to be used from the Perl
		code, making the scope of a Perl block, not C++ block, and to pass the
		exceptions properly back to Perl.
		</p><pre class="programlisting">AutoFnBind();
AutoFnBind *make();</pre><p>
		The constructor just creates an empty object which then gets filled
		with bindings.
		</p><pre class="programlisting">AutoFnBind *add(Onceref&lt;FnReturn&gt; ret, Autoref&lt;FnBinding&gt; binding);</pre><p>
		Add a binding, in a chainable fashion. The simple-minded way of using the
		AutoFnBind is:
		</p><pre class="programlisting">{
    Autoref&lt;AutoFnBind&gt; bind = AutoFnBind::make()
        -&gt;add(ret1, binding1)
        -&gt;add(ret2, binding2);
    ...
}</pre><p>
		However if any of these <code class="computeroutput">add()</code>s throw an Exception, this will leave an
		orphaned AutoFnBind object, since the throwing would happen before it
		had a chance to do the reference-counting. So the safer way to use it
		is:
		</p><pre class="programlisting">{
    Autoref&lt;AutoFnBind&gt; bind = new AutoFnBind;
    bind
        -&gt;add(ret1, binding1)
        -&gt;add(ret2, binding2);
    ...
}</pre><p>
		Then the AutoFnBind will be reference-counted first, and if an <code class="computeroutput">add()</code>
		throws later, this will cause a controlled destruction of the Autoref
		and of AutoFnBind.
		</p><p>
		But it's not the end of the story yet. The throws on destruction are
		still a possibility. To catch them, use an explicit clearing before
		the end of the block:
		</p><pre class="programlisting">void clear();</pre><p>
		Pops all the bindings. If any Exceptions get thrown, they can get
		caught nicely. It tries to be real smart, going through all the
		bindings in the backwards order and popping each one of them. If a
		<code class="computeroutput">pop()</code> throws an exception, its information will be collected but
		<code class="computeroutput">clear()</code> will then continue going through the whole list. At the end of
		the run it will make sure that it doesn't have any references to
		anything any more, and then will re-throw any collected errors as a
		single Exception. This cleans up the things as much as possible and as
		much as can be handled, but the end result will still not be
		particularly clean: the returns that got their stacks corrupted will
		still have their stacks corrupted, and some very serious
		application-level cleaning will be needed to continue. Probably a
		better choice would be to destroy everything and restart from scratch.
		But at least it allows to get safely to this point of restarting from
		scratch.
		</p><p>
		So, the full correct sequence will be:
		</p><pre class="programlisting">{
  Autoref&lt;AutoFnBind&gt; bind = new AutoFnBind;
  bind
    -&gt;add(ret1, binding1)
    -&gt;add(ret2, binding2);
  ...
  bind-&gt;clear();
}</pre><p>
		Or if any code in <span class="quote">&#8220;<span class="quote">...</span>&#8221;</span> can throw anything, then something like this snippet(whis 
		is not actually tested, so use with caution):
		</p><pre class="programlisting">{
  Autoref&lt;AutoFnBind&gt; bind = new AutoFnBind;
  bind
    -&gt;add(ret1, binding1)
    -&gt;add(ret2, binding2);
  try {
  ...
  } catch (Triceps::Exception e) {
    try {
      bind-&gt;clear();
    } catch (Triceps::Exception ee) {
      e-&gt;getErrors()-&gt;append("Unbinding errors triggered by the last error:", ee-&gt;getErrors());
    }
    throw;
  } catch (exception e) {
    bind-&gt;clear(); // might use a try/catch around it as well
    throw;
  }
}</pre><p>
		It tries to be nice if the exception thrown from <span class="quote">&#8220;<span class="quote">...</span>&#8221;</span> was a Triceps
		one, and add nicely any errors from the binding clearing to it.
		</p><p>
		Finally, a little about how the Perl AutoFnBind translates to the C++
		AutoFnBind:
		</p><p>
		The Perl constructor creates the C++-level object and adds the bindings
		to it. If any of them throw, it destroys everything nicely and
		translates the Exception to Perl. Otherwise it saves a reference to the
		AutoFnBind in a wrapper object that gets returned to Perl.
		</p><p>
		The Perl destructor then first clears the AutoFnBind and catches if
		there is any Exception. However there is just no way to return a Perl
		exception from a Perl destructor, so it simply prints the error on stderr
		and calls <code class="computeroutput">exit(1)</code>. If no exception was thrown, the AutoFnBind gets
		destroyed nicely by removing the last reference.
		</p><p>
		For the nicer handling, there is a Perl-level method <code class="computeroutput">clear()</code> that does
		the clearing and translates the exception to Perl.
		</p></div><div class="sect1" title="20.35. App reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_app"></a>20.35. App reference</h2></div></div></div><a class="indexterm" name="id565830"></a><p>
		As usual, I won't be repeating the descriptions from the Perl
		reference, but just point out the methods and differences of the C++
		version. And there are more detailed descriptions directly in the
		header files. The App class is defined in <code class="computeroutput">cpp/app/App.h</code>.
		Naturally, it's an Mtarget.
		</p><p>
		The static part of the API is:
		</p><pre class="programlisting">static Onceref&lt;App&gt; make(const string &amp;name);
static Onceref&lt;App&gt; find(const string &amp;name);
static void drop(Onceref&lt;App&gt; app);

typedef map&lt;string, Autoref&lt;App&gt; &gt; Map;
static void listApps(Map &amp;ret);</pre><p>
		The App constructor is private, and the Apps get constructed with
		<code class="computeroutput">make()</code>. <code class="computeroutput">make()</code> throws an Exception if an App with this name already
		exists, <code class="computeroutput">find()</code> throws an exception if an App with this name does not
		exist, and <code class="computeroutput">drop()</code> just does nothing if its argument App had already
		been dropped.
		</p><p>
		All the operations on the global list of apps are internally
		synchronized and thread-safe. <code class="computeroutput">listApps()</code> clears its argument map and
		fills it with the copy of the current list. Of course, after it returns
		and releases the mutex, other threads may create or delete apps, so the
		returned list (well, map) may immediately become obsolete. But since it
		all is done with the reference counters, the App objects will continue
		to exist and be operable as long as the references to them exist.
		</p><p>
		The App instance API is as follows. It's also all internally
		synchronized.
		</p><pre class="programlisting">const string &amp;getName() const;</pre><p>
		Get the name of the App.
		</p><pre class="programlisting">Onceref&lt;TrieadOwner&gt; makeTriead(const string &amp;tname, const string &amp;fragname = "");</pre><a class="indexterm" name="id567094"></a><p>
		Define a new Triead. This method is called either from the OS thread
		where the Triead will run or from its parent thread (unlike Perl, in
		C++ it's perfectly possible to pass the reference to the TrieadOwner
		from a parent OS thread to the thread that will run it). Either way,
		the OS thread that will run this Triead ends up with the TrieadOwner
		object reference, and no other thread must have it. The arguments are
		the thread name and fragment name, and the empty fragment name means
		that this thread won't belong to any fragment.
		</p><p>
		And just to reiterate, this does not create the OS thread. Creating the
		OS thread is your responsibility (although Triceps provides the
		helper classes for the Posix threads). This call only creates the Triceps
		Triead management structures to put it under control of the App.
		</p><p>
		If a thread with this name has already been defined, or if the thread
		name is empty, throws an Exception.
		</p><pre class="programlisting">void declareTriead(const string &amp;tname);</pre><p>
		Declare a new thread. 
		Declaring a thread more than once, or declaring a thread that has
		been already defined, is perfectly OK.
		</p><pre class="programlisting">void defineJoin(const string &amp;tname, Onceref&lt;TrieadJoin&gt; j);</pre><a class="indexterm" name="id592867"></a><p>
		This is a call without an analog in the Perl API. This defines a way
		for the harvester to join the thread. The Perl API happens to be
		hardcoded to join the Perl threads. But the C++ API can deal with any
		threads: POSIX ones, Perl ones, whatever. If a thread wants to be
		properly joined by the harvester, it must define its join interface,
		done as a TrieadJoin object. Each kind of threads will define its own
		subclass of TrieadJoin.
		</p><p>
		If there is no join defined for a Triead, then when it exits, the
		harvester will just update the state and manage the Triead object
		properly but won't do any joining. Which is useful in case if the OS
		thread is detached (not the best idea but doable) or if the Triead is
		created from the parent OS thread, and then the actual OS thread
		creation fails and there is nothing to join.
		</p><p>
		If the thread is not declared nor defined yet, <code class="computeroutput">defineJoin()</code> throws an
		exception.
		</p><p>
		It's possible (though unusual) to call this method multiple times for
		the same thread. That would just replace the joiner object. The joiner
		is a reference-counted object, so the old object will just have itse
		reference count decreased. It's possible to pass the joiner as NULL,
		that would just drop the existing joiner, if any was defined.
		</p><pre class="programlisting">typedef map&lt;string, Autoref&lt;Triead&gt; &gt; TrieadMap;
void getTrieads(TrieadMap &amp;ret) const;</pre><p>
		List the Trieads in this App. Same as with listing the Apps, the
		argument map gets cleared and then filled with the current contents.
		</p><pre class="programlisting">void harvester(bool throwAbort = true);
bool harvestOnce();
void waitNeedHarvest();</pre><p>
		The harvester API is very similar to Perl, with confession replaced by
		Exception. The only difference is how the argument specifies the throwing of an
		Exception on detecting the App abort (the Exception will still be thrown
		only after joining all the App's threads).
		</p><p>
		The result of <code class="computeroutput">harvestOnce()</code> is <code class="computeroutput">true</code> if the App is dead. The Exceptions
		in <code class="computeroutput">harvestOnce()</code> originate from the <code class="computeroutput">TrieadJoin::join()</code> method that
		performs the actual joining. All the caveats apply in the same way as
		in Perl.
		</p><pre class="programlisting">bool isDead();</pre><p>
		Returns <code class="computeroutput">true</code> if the App is dead.
		</p><pre class="programlisting">void waitDead();</pre><p>
		Wait for the App to become dead.
		</p><pre class="programlisting">bool isAborted() const;</pre><p>
		Returns <code class="computeroutput">true</code> if the App is aborted.
		</p><pre class="programlisting">string getAbortedBy() const;
string getAbortedMsg() const;</pre><p>
		Get the thread name and message that caused the abort. If the App is
		not aborted, will return the empty strings.
		</p><pre class="programlisting">void abortBy(const string &amp;tname, const string &amp;msg);</pre><p>
		Abort the app, by the thread tname, with the error message msg.
		</p><pre class="programlisting">bool isShutdown();</pre><p>
		Returns true if the App has been requested to shut down.
		</p><pre class="programlisting">void shutdown();</pre><p>
		Request the App to shut down. This involves interrupting all the
		threads in case if they are sleeping.  The interruption is another
		functionality of the TrieadJoin object. It's possible for the
		TrieadJoin interruptor to encounter an error and throw an Exception. If
		this happens, <code class="computeroutput">shutdown()</code> will still go through all the Trieads and
		interrupt them, and then repackage the error messages from all the
		received Exceptions into one Exception and re-throw it.
		</p><p>
		Technically, this means that in the Perl API the shutdown might also
		confess, when its underlying C++ call returns an Exception. This should
		theoretically never happen, but practically you never know.
		</p><pre class="programlisting">void shutdownFragment(const string &amp;fragname);</pre><p>
		Shut down a fragment. All the logic described in the Perl API applies.
		Again, this involves interruption of all the threads in the fragment,
		and if any of them throw Exceptions, these will be re-thrown as a
		single Exception.
		</p><pre class="programlisting">enum {
    DEFAULT_TIMEOUT = 30,
};
void setTimeout(int sec, int fragsec = -1);</pre><p>
		Set the readiness timeouts (main and fragment), in seconds. If the
		fragment timeout argument is <code class="computeroutput">&lt;0</code>, it gets set to the same value as the
		main timeout.
		</p><pre class="programlisting">void setDeadline(const timespec &amp;dl);</pre><p>
		Set the deadline (unlike timeout, with fractional seconds) for the main
		readiness.
		</p><pre class="programlisting">void refreshDeadline();</pre><p>
		Explicitly refresh the deadline, using the fragment timeout.
		</p><pre class="programlisting">void requestDrain();</pre><p>
		Request a shared drain.
		</p><pre class="programlisting">void requestDrainExclusive(TrieadOwner *to);</pre><p>
		Request an exclusive drain, with the argument TrieadOwner. Unlike Perl
		API, the C++ API supports the methods for requesting the exclusive
		drain on both App and TrieadOwner classes (the TrieadOwner method is
		really a wrapper for the App method). In general, using the TrieadOwner
		method for this purpose probably looks nicer.
		</p><p>
		Since the TrieadOwner reference is really private to the OS thread that
		runs it, this method can be called only from that OS thread. Of course,
		in C++ you could pass it around to the other threads, but don't,
		TrieadOwner is not thread-safe internally and any operations on it must
		be done from one thread only.
		</p><pre class="programlisting">void waitDrain();</pre><p>
		Wait for the drain (either shared or exclusive) to complete.
		</p><pre class="programlisting">void drain();</pre><p>
		A combination of <code class="computeroutput">requestDrain()</code> and <code class="computeroutput">waitDrain()</code>.
		</p><pre class="programlisting">void drainExclusive(TrieadOwner *to);</pre><p>
		A combination of <code class="computeroutput">requestDrainExclusive()</code> and <code class="computeroutput">waitDrain()</code>.
		</p><pre class="programlisting">bool isDrained();</pre><p>
		Quickly check if the App is currently drained (should be used only if
		the App is known to be requested to drain).
		</p><pre class="programlisting">void undrain();</pre><p>
		End the drain sequence.
		</p><p>
		The file descriptor store/load API is really of not much use in C++ as
		such, in C++ it's easy to pass and share the file descriptors and file
		objects between the threads as-is. It has been built into the App class
		for the benefit of Perl and possibly other interpreted languages.
		</p><pre class="programlisting">void storeFd(const string &amp;name, int fd);
void storeFd(const string &amp;name, int fd, const string &amp;className);</pre><p>
		Store a file descriptor. Unlike the Perl API, the file descriptor is
		<span class="bold"><strong>not</strong></span> dupped before storing. It's stored as is, and if you want dupping,
		you have to do it yourself. The class name argument is optional,
		if not specified, it's set to an empty string.
		Throws an Exception if a file descriptor
		with this name is already stored.
		</p><pre class="programlisting">int loadFd(const string &amp;name, string *className = NULL) const;</pre><p>
		Load back the file descriptor. Again, no dupping, returns the stored
		value as-is. If the name is unknown, returns -1. If the class name
		argument is not NULL, it will be filled with the stored class name.
		</p><pre class="programlisting">bool forgetFd(const string &amp;name);</pre><p>
		Forget the file descriptor. Returns true if this name was known and
		became forgotten, or false if it wasn't known. Normally, you would load
		the descriptor, take over its ownership, and then tell the App to
		forget it.
		</p><pre class="programlisting">bool closeFd(const string &amp;name);</pre><p>
		Close the file descriptor (if it was known) and then forget it. Returns
		true if this name was known and became forgotten, or false if it wasn't
		known.
		</p><p>
		The rest of the Perl App methods have no analogs in C++. They are just
		purely Perl convenience wrappers. 
		</p></div><div class="sect1" title="20.36. Triead reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_triead"></a>20.36. Triead reference</h2></div></div></div><a class="indexterm" name="id553931"></a><p>
		Triead is a class that can be referenced from multiple
		threads and inherits from Mtarget. It's defined in <code class="computeroutput">app/Triead.h</code>.
		</p><p>
		The meaning of the C++ methods is exactly the same as in Perl, only the
		format of values is slightly different. Obviously, the <code class="computeroutput">start*()</code> methods
		are Perl-only, in C++ the Trieads are defined by <code class="computeroutput">App::makeTriead()</code>
		with the help of <code class="computeroutput">App::defineJoin()</code>.
		</p><pre class="programlisting">const string &amp;getName() const;</pre><p>
		Get the Triead's name.
		</p><pre class="programlisting">const string &amp;fragment() const;</pre><p>
		Get the name of the Triead's fragment. If the Triead doesn't belong to
		a fragment, returns an empty string <span class="quote">&#8220;<span class="quote"></span>&#8221;</span>.
		</p><pre class="programlisting">bool isConstructed() const;</pre><p>
		Check whether the Triead has been constructed. For the explanation of
		the Triead lifecycle states, see
		<a class="xref" href="#sc_mt_triead_life" title="16.2. The Triead lifecycle">Section 16.2: &#8220;The Triead lifecycle&#8221; </a>.
		</p><pre class="programlisting">bool isReady() const;</pre><p>
		Check whether the Triead is ready.
		</p><pre class="programlisting">bool isDead() const;</pre><p>
		Check whether the Triead is dead.
		</p><pre class="programlisting">bool isInputOnly() const;</pre><p>
		Check whether the Triead is input-only, that is, it has no reader nexuses
		imported into it. When the Triead is created, this flag starts its life
		as <code class="computeroutput">false</code>, and then its correct value is computed when the
		Triead becomes ready. So, to check this flag correctly, you must first
		check that the Triead is ready.
		</p><pre class="programlisting">typedef map&lt;string, Autoref&lt;Nexus&gt; &gt; NexusMap;
void exports(NexusMap &amp;ret) const;
void imports(NexusMap &amp;ret) const;
void readerImports(NexusMap &amp;ret) const;
void writerImports(NexusMap &amp;ret) const;</pre><p>
		Get the list of nexuses exported from this Triead, or imported, or only
		the reader imports, or only the writer imports. In the result of
		<code class="computeroutput">imports()</code> there is no way to tell, which nexuses are
		imported for reading and which for writing, use the specialized methods
		for that. In all these methods the argument map gets cleared and then
		filled with the new returned contents.
		</p><pre class="programlisting">Onceref&lt;Nexus&gt; findNexus(const string &amp;srcName,
  const string &amp;appName, const string &amp;name) const;</pre><p>
		This is a method unique to the C++ API. It looks up an exported nexus
		by name without involving the overhead of getting the whole map. Here
		<code class="computeroutput">name</code> is the name of the nexus to look up (its short part, without the
		thread's name in it). If there is no such nexus, an Exception will be
		thrown.
		</p><p>
		The <code class="computeroutput">srcName</code> and <code class="computeroutput">appName</code> are used for the error message in the
		Exception: <code class="computeroutput">srcName</code> is the name of the thread that requested the
		look-up, and <code class="computeroutput">appName</code> is the name of the App where the threads belong.
		(It might seem surprising, but a Triead object has no reference to its
		App, and doesn't know the App's name. It has to do with the avoidance
		of the circular references). 
		</p></div><div class="sect1" title="20.37. TrieadOwner reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_triead_owner"></a>20.37. TrieadOwner reference</h2></div></div></div><a class="indexterm" name="id486570"></a><p>
		The TrieadOwner is defined in <code class="computeroutput">app/TrieadOwner.h</code>. 
		Its constructor is
		protected, the normal way of constructing is by calling
		<code class="computeroutput">App::makeTriead()</code>. This is also called <span class="quote">&#8220;<span class="quote">defining a Triead</span>&#8221;</span>.
		</p><p>
		TrieadOwner is an Starget, and must be accessed only from the thread
		that owns it (though it's possible to create it in the parent thread
		and then pass to the actual owner thread, as long as the
		synchronization between the threads is done properly).
		</p><pre class="programlisting">Triead *get() const;</pre><p>
		Get the public side if the Triead. In C++, unlike Perl, the Triead
		methods are not duplicated in TrieadOwner. So they are accessed through
		<code class="computeroutput">get()</code>, and for example to get the Triead name, call
		<code class="computeroutput">to-&gt;get()-&gt;getName()</code>. The TrieadOwner holds a reference to Triead, so
		the Triead object will never get destroyed as long as the TrieadOwner
		is alive.
		</p><pre class="programlisting">App *app() const;</pre><p>
		Get the App where this Triead belongs. The TrieadOwner holds a
		reference to App, so the App object will never get destroyed as long as
		the TrieadOwner is alive.
		</p><pre class="programlisting">bool isRqDead() const;</pre><p>
		Check whether this triead has been requested to die.
		</p><pre class="programlisting">void requestMyselfDead();</pre><p>
		Request this thread itself to die (see the extended description in the
		Perl reference).
		</p><pre class="programlisting">Unit *unit() const;</pre><p>
		Get the main unit of this Triead. It has the same name as the Triead itself.
		</p><pre class="programlisting">void addUnit(Autoref&lt;Unit&gt; u);</pre><p>
		Keep track of an additional unit. Adding a unit multiple times has no
		effect. See the other implications in the Perl reference.
		</p><pre class="programlisting">bool forgetUnit(Unit *u);</pre><p>
		Forget about an additional unit. If the unit is already unknown, has no
		effect. The main unit can not be forgotten.
		</p><pre class="programlisting">typedef list&lt;Autoref&lt;Unit&gt; &gt; UnitList;
const UnitList &amp;listUnits() const;</pre><p>
		List the tracked units. The main unit is always included at the front
		of the list.
		</p><pre class="programlisting">void markConstructed();</pre><p>
		Advance the Triead state to Constructed. Repeated calls have no effect.
		</p><pre class="programlisting">void markReady();</pre><p>
		Advance the Triead state to Ready. Repeated calls have no effect. The
		advancement is cumulative: if the Triead was not constructed yet, it
		will be automatically advanced first to Constructed and then to Ready.
		If this is the last Triead to become ready, it will trigger the App
		topology check, and if the check fails, abort the App and throw an
		Exception.
		</p><pre class="programlisting">void readyReady();</pre><p>
		Advance the Triead to the Ready state, and wait for all the Trieads to
		become ready. The topology check applies in the same way as in
		<code class="computeroutput">markReady()</code>.
		</p><pre class="programlisting">void markDead();</pre><p>
		Advance the Triead to the Dead state. If this Triead was not Ready yet
		and it's the last one to become so, the topology check will run. If the
		topology check fails, the App will be aborted but <code class="computeroutput">markDead()</code> will not
		throw an exception.
		</p><p>
		This method is automatically called from the TrieadOwner destructor, so
		most of the time there is no need to call it explicitly.
		</p><p>
		It also clears all the tracked units.
		</p><pre class="programlisting">void abort(const string &amp;msg) const;</pre><p>
		Abort the App. The name of this thread will be forwarded to the App
		along with the error message. The error message may be multi-line.
		</p><pre class="programlisting">Onceref&lt;Triead&gt; findTriead(const string &amp;tname, bool immed = false);</pre><p>
		Find a Triead in the App by name. The flag <code class="computeroutput">immed</code> controls whether this
		method may wait. If <code class="computeroutput">immed</code> is false, and the target thread is not
		constructed yet (but at least declared), the method will sleep until it
		becomes constructed, and then returns it. If the target thread is not
		declared, it will throw an Exception. If <code class="computeroutput">immed</code> is true, the look-up is
		immediate: it will return the thread even if it's not constructed but
		is at least defined. If it's not defined (even if it's declared), an
		Exception will be thrown. The look-up of this Triead itself is always
		immediate, irrespective of the <code class="computeroutput">immed</code> flag, to avoid deadlocking
		itself.
		</p><p>
		An Exception may also be thrown if a circular sequence of Trieads
		deadlocks waiting for each other.
		</p><pre class="programlisting">Onceref&lt;Facet&gt; exportNexus(Autoref&lt;Facet&gt; facet, bool import = true);</pre><p>
		Export a Nexus. The Nexus definition is constructed as a Facet object,
		which is then used by this method to construct and export the Nexus.
		The same argument Facet reference is then returned back as the result.
		The <code class="computeroutput">import</code> flag tells, whether the Nexus is to be also imported back by
		connecting the same original Facet object to it. If import is false,
		the original Facet reference is still returned back but it can't be
		used for anything, and can only be thrown away. The direction of the
		import (reading or writing) is defined in the Facet, as well as the
		nexus name and all the other information.
		</p><p>
		Throws an Exception on any errors, in particular on the duplicate facet
		names within the Triead.
		</p><pre class="programlisting">Onceref&lt;Facet&gt; exportNexusNoImport(Autoref&lt;Facet&gt; facet);</pre><p>
		A convenience wrapper around exportNexus() with <code class="computeroutput">import=false</code>.
		</p><pre class="programlisting">Onceref&lt;Facet&gt; importNexus(const string &amp;tname,
  const string &amp;nexname, const string &amp;asname,
  bool writer, bool immed = false);</pre><p>
		Import a Nexus from another Triead. <code class="computeroutput">tname</code> is the name of the other
		thread, <code class="computeroutput">nexname</code> is the name of nexus exported from it, <code class="computeroutput">asname</code> is the
		local name for the imported facet (<span class="quote">&#8220;<span class="quote"></span>&#8221;</span> means <span class="quote">&#8220;<span class="quote">same as <code class="computeroutput">nexname</code></span>&#8221;</span>), the
		<code class="computeroutput">writer</code> flag determines if the import is for writing, and the <code class="computeroutput">immed</code> flag
		has the same meaning as in <code class="computeroutput">findTriead()</code>. The import of a nexus involves
		finding its exporting thread, and the <code class="computeroutput">immed</code> flag controls, how this
		finding is done.
		</p><p>
		Throws an Exception if anything is not found, or the local import name
		conflicts with another imported facet.
		</p><pre class="programlisting">Onceref&lt;Facet&gt; importNexusImmed(const string &amp;tname,
  const string &amp;nexname, const string &amp;asname, bool writer);
Onceref&lt;Facet&gt; importReader(const string &amp;tname,
  const string &amp;nexname, const string &amp;asname = "", bool immed=false);
Onceref&lt;Facet&gt; importWriter(const string &amp;tname,
  const string &amp;nexname, const string &amp;asname = "", bool immed=false);
Onceref&lt;Facet&gt; importReaderImmed(const string &amp;tname,
  const string &amp;nexname, const string &amp;asname = "");
Onceref&lt;Facet&gt; importWriterImmed(const string &amp;tname,
  const string &amp;nexname, const string &amp;asname = "");</pre><p>
		Convenience wrappers for <code class="computeroutput">importNexus()</code>, providing the default arguments
		and the more mnemonic names.
		</p><pre class="programlisting">typedef map&lt;string, Autoref&lt;Nexus&gt; &gt; NexusMap;
void exports(NexusMap &amp;ret) const;</pre><p>
		Get the nexuses exported here. The map argument will be cleared and
		refilled with the new values.
		</p><pre class="programlisting">typedef map&lt;string, Autoref&lt;Facet&gt; &gt; FacetMap;
void imports(FacetMap &amp;ret) const;</pre><p>
		Get the facets imported here. The map argument will be cleared and
		refilled with the new values.
		</p><pre class="programlisting">NexusMaker *makeNexusReader(const string &amp;name);
NexusMaker *makeNexusWriter(const string &amp;name);
NexusMaker *makeNexusNoImport(const string &amp;name);</pre><p>
		A convenient way to build the nexuses for export in a chained fashion.
		The name argument is the nexus name. The NexusMaker is an opaque class
		that has the same building methods as a Facet, plus the method
		<code class="computeroutput">complete()</code> that finishes the export. This call sequence is more
		convenient than building a Facet and then exporting it. For example:
		</p><pre class="programlisting">Autoref&lt;Facet&gt; myfacet = ow-&gt;makeNexusReader("my")
  -&gt;addLabel("one", rt1)
  -&gt;addFromLabel("two", lb2)
  -&gt;setContext(new MyFnContext)
  -&gt;setReverse()
  -&gt;complete();</pre><p>
		Only one nexus may be built like this at a time, since there is only
		one instance of NexusMaker per TrieadOwner that gets reused over and
		over. It keeps the Facet instance being built in it. If you don't
		complete the build, that Facet instance will be left sitting around
		until another <code class="computeroutput">makeNexus*()</code> call, when it will get thrown away. But in
		general if you do the calling in the sequence as shown, you can't
		forget to call <code class="computeroutput">complete()</code> at the end, since otherwise the return type
		would not match and the compiler will fail.
		</p><pre class="programlisting">bool flushWriters();</pre><p>
		Flush all the writer facets. Returns true on the successfull
		completion, false if the thread was requested to die, and thus all the
		output was thrown away.
		</p><pre class="programlisting">bool nextXtray(bool wait = true, const struct timespec &amp;abstime =
  *(const struct timespec *)NULL);</pre><p>
		Read and process the next Xtray. Automatically calls the <code class="computeroutput">flushWriters()</code>
		after processing. The rest works in the same way as described in Perl,
		however this is a combination of Perl's <code class="computeroutput">nextXtray()</code>, <code class="computeroutput">nextXtrayNoWait()</code>
		and <code class="computeroutput">nextXtrayTimeLimit()</code> in one method. If <code class="computeroutput">wait</code> is false, this method will never
		wait. If <code class="computeroutput">wait</code> is true and the <code class="computeroutput">abstime</code> reference is not NULL, it might
		wait but not past that absolute time. Otherwise it will wait until the
		data becomes available or the thread is requested to die.
		</p><p>
		Returns true if an Xtray has been processed, false if it wasn't (for
		any reason, a timeout expiring or thread being requested to die).
		</p><pre class="programlisting">bool nextXtrayNoWait();</pre><p>
		A convenience wrapper over <code class="computeroutput">nextXtray(false)</code>.
		</p><pre class="programlisting">bool nextXtrayTimeout(int64_t sec, int32_t nsec);</pre><p>
		Another convenience wrapper over <code class="computeroutput">nextXtray()</code>: read and process an
		Xtray, with a timeout limit. The timeout value consists of the seconds
		and nanoseconds parts.
		</p><pre class="programlisting">void mainLoop();</pre><p>
		Run the main loop, calling <code class="computeroutput">nextXtray()</code> repeatedly until the thread is
		requested to die.
		</p><pre class="programlisting">bool isRqDrain();</pre><p>
		Check if a drain is currently requested by any thread (and applies to
		this thread). In case if an exclusive drain is requested with the
		exclusion of this thread, this method will return false.
		</p><pre class="programlisting">void requestDrainShared();
void requestDrainExclusive();
void waitDrain();
bool isDrained();
void drainShared();
void drainExclusive();
void undrain();</pre><p>
		The drain control, same as in Perl. These methods are really wrappers
		over the corresponding App methods. And generally a better idea is to
		do the scoped drains with AutoDrain rather than to call these methods
		directly.
		</p><p>
		The C++ API provides no methods for the file descriptor tracking as
		such. Instead these methods are implemented in the class FileInterrupt.
		TrieadOwner has a public field
		</p><pre class="programlisting">Autoref&lt;FileInterrupt&gt; fileInterrupt_;</pre><a class="indexterm" name="id575970"></a><a class="indexterm" name="id608951"></a><p>
		to keep an instance of the interruptor. TrieadOwner itself has no use
		for it, nor does any other part of Triceps, it's just a location to
		keep this reference for the convenience of the application developer.
		The Perl API makes use of this location.
		</p><p>
		But how does the thread then get interrupted when it's requested to
		die? The answer is that the TrieadJoin object also has a reference to
		the FileInterrupt object, and even creates that object in its own
		constructor. So when a joiner method is defined for a thread, that
		supplies the App with the access to its interruptor as well. And to put
		the file descriptors into the FileInterrupt object, you can either keep
		a direct reference to it somewhere in your code, or copy that reference
		into the TrieadOwner object.
		</p><p>
		Here is for example how the Perl thread joiner is created for the
		TrieadOwner inside the Perl implementation:
		</p><pre class="programlisting">string tn(tname);
Autoref&lt;TrieadOwner&gt; to = appv-&gt;makeTriead(tn, fragname);
PerlTrieadJoin *tj = new PerlTrieadJoin(appv-&gt;getName(), tname,
  SvIOK(tid)? SvIV(tid): -1,
  SvIOK(handle)? SvIV(handle): 0,
  testfail);
to-&gt;fileInterrupt_ = tj-&gt;fileInterrupt();
appv-&gt;defineJoin(tn, tj);</pre><p>
		This is somewhat cumbersome, but the native C++ programs can create
		their threads using the class BasicPthread that takes care of this and
		more. 
		</p></div><div class="sect1" title="20.38. Nexus reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_nexus"></a>20.38. Nexus reference</h2></div></div></div><a class="indexterm" name="id574672"></a><p>
		The Nexus object is an Mtarget, and safe to access from multiple
		threads. It's defined in <code class="computeroutput">app/Nexus.h</code>. 
		The Nexus class is pretty much opaque. It's created and managed
		entirely inside the App infrastructure from a Facet, and even the
		public API for importing a nexus doesn't deal with the Nexus object
		itself, but only with its name. The only public use of the Nexus object
		is for the introspection and entertainment value, to see what Trieads
		export and import what Nexuses: pretty much the only way to get a Nexus
		reference is by listing the exports or imports of a Triead.
		</p><p>
		The API of a Nexus is very limited:
		</p><pre class="programlisting">const string &amp;getName() const;</pre><p>
		Get the name of the nexus (the short name, inside the Triead).
		</p><pre class="programlisting">const string &amp;getTrieadName() const;</pre><p>
		Get the name of the Triead that exported this nexus.
		</p><pre class="programlisting">bool isReverse() const;</pre><p>
		Check whether the nexus is reverse.
		</p><pre class="programlisting">int queueLimit() const;</pre><p>
		Get the queue limit of the nexus.
		</p></div><div class="sect1" title="20.39. Facet reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_facet"></a>20.39. Facet reference</h2></div></div></div><a class="indexterm" name="id595016"></a><p>
		The general functioning of a facet is the same in C++ as in Perl, so
		please refer to the Perl reference for this information.
		</p><p>
		However the construction of a Facet is different in C++.
		And the export is different:
		first you construct a Facet from scratch and then give it to
		<code class="computeroutput">TrieadOwner::exportNexus()</code> to create a Nexus from it.
		The import is still the same: you call <code class="computeroutput">TrieadOwner::importNexus()</code> method or one of
		its varieties and it returns a Facet.
		</p><p>
		In the C++ API the Facet has a notion of being imported, very much like
		the FnReturn has a notion of being initialized. When a Facet is
		first constructed, it's not imported. Then <code class="computeroutput">exportNexus()</code> creates the
		nexus from the facet, exports it into the App, and also imports the
		nexus information back into the facet, marking the facet as imported.
		It returns back a reference to the exact same Facet object, only now
		that object becomes imported. Obviously, you can use either the
		original or returned reference, they point to the same object. Once a
		Facet has been imported, it cannot be modified any more. The Facet
		object returned by the <code class="computeroutput">importNexus()</code> is also marked as imported, so it
		cannot be modified either. And also an imported facet cannot be
		exported again.
		</p><p>
		However <code class="computeroutput">exportNexus()</code> has an exception. If the export is done with the
		argument <code class="computeroutput">import</code> set to false, the facet object will be left unchanged
		and not marked as imported. A facet that is not marked as imported cannot
		be used to send or receive data. Theoretically, it can be used to
		export another nexus, but practically this would not work because that
		would be an attempt to export another nexus with the same name from the
		same thread. In reality such a Facet can only be thrown away, and there
		is not much use for it. You can read its components and use them to
		construct another Facet but that's about it.
		</p><p>
		It might be more
		convenient to use the <code class="computeroutput">TrieadOwner::makeNexus*()</code> methods to build a
		Facet object rather than building it directly. In either case, the
		methods are the same and accept the same arguments, just the Facet
		methods return a Facet pointer while the NexusMaker methods return a
		NexusMaker pointer.
		</p><p>
		The Facet class is defined in <code class="computeroutput">app/Facet.h</code>. It inherits from Mtarget for
		an obscure reason that has to do with App topology analysis but it's
		intended to be used from one thread only.
		</p><p>
		You don't have to keep your own references to all your Facets. The
		TrieadOwner will keep a reference to all the imported Facets, and they
		will not be destroyed while the TrieadOwner exists (and this applies to
		Perl as well).
		</p><pre class="programlisting">enum {
  DEFAULT_QUEUE_LIMIT = 500,
};</pre><p>
		The default value used for the nexus queue limit (as a count of Xtrays,
		not rowops). Since the reading from the nexus involves
		double-buffering, the real queue size might grow up to twice that
		amount.
		</p><pre class="programlisting">static string buildFullName(const string &amp;tname, const string &amp;nxname);</pre><p>
		Build the full nexus name from its components.
		</p><pre class="programlisting">Facet(Onceref&lt;FnReturn&gt; fret, bool writer);</pre><p>
		Create a Facet, initially non-imported (and non-exported). The FnReturn
		object <code class="computeroutput">fret</code> defines the set of labels in the facet (and nexus), and the
		name of FnReturn also becomes the name of the Facet, and of the Nexus.
		The <code class="computeroutput">writer</code> flag determines whether this facet will become a writer (if
		true) or a reader (if false) when a nexus is created from it. If the
		nexus gets created without importing the facet back, the writer flag
		doesn't matter and can be set either way.
		</p><p>
		The FnReturn should generally be not initialized yet. The Facet
		constructor will check if FnReturn already has the labels <code class="computeroutput">_BEGIN_</code> and
		<code class="computeroutput">_END_</code> defined, and if either is missing, will add it to the FnReturn,
		then initialize it. If both <code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code> are already present, then
		the FnReturn can be used even if it's already initialized. But if any
		of them is missing, FnReturn must be not initialized yet, otherwise the
		Facet constructor will fail to add these labels.
		</p><p>
		The same FnReturn object may be used to create only one Facet object.
		And no, you cannot import a Facet, get an FnReturn from it, then use
		it to create another Facet.
		</p><p>
		If anything goes wrong, the constructor will not throw but will
		remember the error, and later the <code class="computeroutput">exportNexus()</code> will find it and throw
		an Exception from it.
		</p><pre class="programlisting">static Facet *make(Onceref&lt;FnReturn&gt; fret, bool writer);</pre><p>
		Same as the constructor, used for the more convenient operator priority
		for the chained calls.
		</p><pre class="programlisting">static Facet *makeReader(Onceref&lt;FnReturn&gt; fret);
static Facet *makeWriter(Onceref&lt;FnReturn&gt; fret);</pre><p>
		Syntactic sugar around the constructor, hardcoding the writer flag.
		</p><p>
		Normally the facets are constructed and exported with the chained
		calls, like:
		</p><pre class="programlisting">Autoref&lt;Facet&gt; myfacet = to-&gt;exportNexus(
  Facet::makeWriter(FnReturn::make("My")-&gt;...)
  -&gt;setReverse()
  -&gt;exportTableType(Table::make(...)-&gt;...)
);</pre><p>
		Or with a similar chain of calls starting with <code class="computeroutput">TrieadOwner::makeNexus()</code>.
		</p><p>
		Because of this, the methods that are used for post-construction return
		the pointer to the original Facet object. They also almost never throw
		the Exceptions, to prevent the memory leaks through the orphaned Facet
		objects. The only way an Exception might get thrown is on an attempt to
		use these methods on an already imported Facet. Any other errors get
		collected, and eventually <code class="computeroutput">exportNexus()</code> will find them and properly
		throw an Exception, making sure that the Facet object gets properly
		disposed of.
		</p><pre class="programlisting">Facet *exportRowType(const string &amp;name, Onceref&lt;RowType&gt; rtype);</pre><p>
		Add a row type to the Facet. May throw an Exception if the the facet is
		already imported. On other errors remembers them to be thrown on an
		export attempt.
		</p><pre class="programlisting">Facet *exportTableType(const string &amp;name, Autoref&lt;TableType&gt; tt);</pre><p>
		Add a table type to the Facet. May throw an Exception if the the facet
		is already imported. On other errors remembers them to be thrown on an
		export attempt. The table type must also be deep-copyable and contain
		no errors. If the deep copy
		cannot proceed (say, a table type involves a Perl sort condition with
		a direct reference to the compiled Perl code) the <code class="computeroutput">deepCopy()</code> method
		must still return a newly created object but remember the error inside
		it. Later when the table type is initialized, that object's
		initialization must return this error. The <code class="computeroutput">exportTableType()</code> does a
		deep copy then initializes the copied table type. If this detects any
		errors, they get remembered and cause an Exception later in
		<code class="computeroutput">exportNexus()</code>.
		</p><pre class="programlisting">Facet *setReverse(bool on = true);</pre><p>
		Set (or clear) the nexus reverse flag. May throw an Exception if the
		the facet is already imported.
		</p><pre class="programlisting">Facet *setQueueLimit(int limit);</pre><p>
		Set the nexus queue limit. May throw an Exception if the the facet is
		already imported.
		</p><pre class="programlisting">Erref getErrors() const;</pre><p>
		Get the collected errors, so that they can be found without an export attempt.
		</p><pre class="programlisting">bool isImported() const;</pre><p>
		Check whether this facet is imported.
		</p><p>
		The rest of the methods are the same as in Perl. They can be used even
		if the facet is not imported.
		</p><pre class="programlisting">bool isWriter() const;</pre><p>
		Check whether this is a writer facet (or if returns false, a reader facet).
		</p><pre class="programlisting">bool isReverse() const;</pre><p>
		Check whether the underlying nexus is reverse.
		</p><pre class="programlisting">int queueLimit() const;</pre><p>
		Get the queue size limit of the nexus. Until the facet is exported,
		this will always return the last value set by <code class="computeroutput">setQueueLimit()</code>. However
		if the nexus is reverse, on import the value will be changed to a very
		large integer value, currently <code class="computeroutput">INT32_MAX</code>, and on all the following
		calls this value will be returned. Technically speaking, the queue size
		of the reverse nexuses is not unlimited, it's just very large, but in
		practice it amounts to the same thing.
		</p><pre class="programlisting">FnReturn *getFnReturn() const;</pre><p>
		Get the FnReturn object. If you plan to destroy the Facet object soon
		after this method is called, make sure that you put the FnReturn
		pointer into an Autoref first.
		</p><pre class="programlisting">const string &amp;getShortName() const;</pre><p>
		Get the short name, AKA <span class="quote">&#8220;<span class="quote">as-name</span>&#8221;</span>, which is the same as the FnReturn's
		name. Do not destroy the facet while using the returned reference.
		</p><pre class="programlisting">const string &amp;getFullName() const;</pre><p>
		Get the full name of the nexus imported through this facet. If the
		facet is not imported, will return an empty string. Do not destroy the
		facet while using the returned reference.
		</p><pre class="programlisting">typedef map&lt;string, Autoref&lt;RowType&gt; &gt; RowTypeMap;
const RowTypeMap &amp;rowTypes() const;</pre><p>
		Get the map of the defined row types. Returns the reference to the
		Facet's internal map object.
		</p><pre class="programlisting">typedef map&lt;string, Autoref&lt;TableType&gt; &gt; TableTypeMap;
const TableTypeMap &amp;tableTypes() const;</pre><p>
		Get the map of defined table types. Returns the reference to the
		Facet's internal map object.
		</p><pre class="programlisting">RowType *impRowType(const string &amp;name) const;</pre><p>
		Find a single row type by name. If the name is not known, returns NULL.
		</p><pre class="programlisting">TableType *impTableType(const string &amp;name) const;</pre><p>
		Find a single table type by name. If the name is not known, returns
		NULL.
		</p><pre class="programlisting">Nexus *nexus() const;</pre><p>
		Get the nexus of this facet. If the facet is not imported, returns NULL.
		</p><pre class="programlisting">int beginIdx() const;
int endIdx() const;</pre><p>
		Return the indexes (as in <span class="quote">&#8220;<span class="quote">integer offset</span>&#8221;</span>) of the <code class="computeroutput">_BEGIN_</code> and <code class="computeroutput">_END_</code>
		labels in FnReturn.
		</p><pre class="programlisting">bool flushWriter();</pre><p>
		Flush the collected rowops into the nexus as a single Xtray. If there
		is no data collected, does nothing. Returns true on a successful flush
		(even if there was no data collected), false if the Triead was
		requested to die and thus all the data gets thrown away. 
		</p></div><div class="sect1" title="20.40. AutoDrain reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_autodrain"></a>20.40. AutoDrain reference</h2></div></div></div><a class="indexterm" name="id579382"></a><p>
		The scoped drain in C++ has more structure than in Perl. It consists
		of the base class AutoDrain and two subclasses: AutoDrainShared and
		AutoDrainExclusive.  They are all defined in <code class="computeroutput">app/AutoDrain.h</code>.
		They are all Stargets, and can be used in only one thread.
		</p><p>
		The base AutoDrain cannot be created directly but
		is convenient for keeping a reference to any kind of drain:
		</p><pre class="programlisting">Autoref&lt;AutoDrain&gt; drain = new AutoDrainShared(app);</pre><p>
		The constructor of the subclass determines whether the drain is shared
		or exclusive, and the rest of the methods are defined in the base
		class.
		</p><p>
		It's also possible to use the a direct local variable:
		</p><pre class="programlisting">{
  AutoDrainShared drain(app);
  ...
}</pre><p>
		Just remember not to mix the metaphors, if you create a local variable,
		don't try to create the references to it.
		</p><p>
		The constructors are:
		</p><pre class="programlisting">AutoDrainShared(App *app, bool wait = true);
AutoDrainShared(TrieadOwner *to, bool wait = true);</pre><p>
		Create a shared drain from an App or TrieadOwner. The <code class="computeroutput">wait</code> flag
		determines if the constructor will wait for the drain to complete,
		otherwise it will return immediately. Well, usually immediately, if
		there is no other incompatible drain active at the moment.
		The shared drain requests the
		draining of all the Trieads, and multiple threads may have their shared
		drains active at the same time (the release will happen when all these
		drains become released). A shared drain will wait for all the preceding
		exclusive drains to be released before it gets created.
		</p><pre class="programlisting">AutoDrainExclusive(TrieadOwner *to, bool wait = true);</pre><p>
		Create an exclusive drain from a TrieadOwner. The <code class="computeroutput">wait</code> flag makes the
		constructor wait for the completion of the drain. Only one exclusive
		drain at a time may be active, from only one thread. An exclusive drain
		will wait for all the preceding shared and exclusive drains to be
		released before it gets created.
		</p><p>
		The common method is:
		</p><pre class="programlisting">void wait();</pre><p>
		Wait for the drain to complete. Can be called repeatedly. If more data
		has been injected into the model through the excluded Triead, will wait
		for that data to drain.
		</p></div><div class="sect1" title="20.41. Sigusr2 reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_sigusr2"></a>20.41. Sigusr2 reference</h2></div></div></div><a class="indexterm" name="id610187"></a><p>
		When a thread is requested to die, its registered file descriptors
		become revoked, and the signal <code class="computeroutput">SIGUSR2</code> is sent to it to interrupt any
		ongoing system calls. For this to work correctly, there must be a
		signal handler defined on <code class="computeroutput">SIGUSR2</code>, because otherwise the default
		reaction to it is to kill the process. It doesn't matter what signal
		handler, just some handler must be there. The Triceps library defines
		an empty signal handler but you can also define your own instead.
		</p><p>
		In Perl, the empty handler for <code class="computeroutput">SIGUSR2</code> is set when the module
		<code class="computeroutput">Triceps.pm</code> is loaded. You can change it afterwards.
		</p><p>
		In C++ Triceps provides a class Sigusr2, defined in <code class="computeroutput">app/Sigusr2.h</code>, to
		help with this.  All the methods of Sigusr2 are static.  If you use the
		class BasicPthread, you don't need to deal with Sigusr2 directly:
		BasicPthread takes care of it. 
		</p><pre class="programlisting">static void setup();</pre><p>
		Set up an empty handler for <code class="computeroutput">SIGUSR2</code> if it hasn't been done yet. This
		class has a static flag (synchronized by a mutex) showing that the
		handler had been set up. On the first call it sets the handler and sets
		the flag. On the subsequent calls it checks the flag and does nothing.
		</p><pre class="programlisting">static void markDone();</pre><p>
		Just set the flag that the setup has been done. This allows to set your
		own handler instead and still cooperate with the logic of Sigusr2 and
		BasicPthread.
		</p><p>
		If you set your custom handler before any threads have been started,
		then set up your handler and then call <code class="computeroutput">markDone()</code>, telling Sigusr2 that
		there is no need to set the handler any more.
		</p><p>
		If you set your custom handler when the Triceps threads are already
		running (not the best idea but still a possibility), there is a
		possibility of a race with another thread calling <code class="computeroutput">setup()</code>. To work
		around that race, set up your handler, call <code class="computeroutput">markDone()</code>, then set up
		your handler again.
		</p><pre class="programlisting">static void reSetup();</pre><p>
		This allows to replace a custom handler with the empty one. It always
		forcibly sets the empty handler (and also the flag). 
	</p></div><div class="sect1" title="20.42. TrieadJoin reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_triead_join"></a>20.42. TrieadJoin reference</h2></div></div></div><a class="indexterm" name="id608460"></a><p>
		TrieadJoin is the abstract base class that tells the harvester how to
		join a thread after it had finished. Obviously, it's present only in
		the C++ API and not in Perl. It's defined in <code class="computeroutput">app/TrieadJoin.h</code>.
		</p><a class="indexterm" name="id600923"></a><a class="indexterm" name="id581508"></a><p>
		Currently TrieadJoin has two subclasses: PerlTrieadJoin for the Perl
		threads and BasicPthread for the POSIX threads in C++. I won't be
		describing PerlTriedJoin, since it's in the internals of the Perl
		implementation, never intended to be directly used by the application
		developers, and if you're interested, you can always look at its source
		code. BasicPthread is described in 
		<a class="xref" href="#sc_cpp_basic_pthread" title="20.44. BasicPthread reference">Section 20.44: &#8220;BasicPthread reference&#8221; </a>.
		</p><p>
		Well, actually there is not a whole lot of direct use for TrieadJoin
		either: you need to worry about it only if you want to define a joiner
		for some other kind of threads, and this is not very likely.
		</p><p>
		So, if you want to define a joiner for some other kind of  threads, you
		define a subclass of it, with an appropriately defined method <code class="computeroutput">join()</code>.
		</p><p>
		TrieadJoin is an Mtarget, naturally referenced from multiple threads
		(at the very least it's created in the thread to be joined or its
		parent, and then passed to the harvester thread by calling
		<code class="computeroutput">App::defineJoin()</code>). The methods of TrieadJoin are:
		</p><pre class="programlisting">TrieadJoin(const string &amp;name);</pre><p>
		The constructor. The <code class="computeroutput">name</code> is the name of the Triead, used for the error
		messages. Due to the various syncronization reasons, this makes the
		life of the harvester much easier, than trying to look up the name from
		the Triead object.
		</p><pre class="programlisting">virtual void join() = 0;</pre><p>
		<span class="emphasis"><em>The Most Important</em></span> joining method to be defined by the subclass. The
		subclass object must also hold the identity of the thread in it, to
		know which thread to join. The harvester will call this method.
		</p><pre class="programlisting">virtual void interrupt();</pre><a class="indexterm" name="id558862"></a><p>
		The method that interrupts the target thread when it's requested to
		die. It's called in the context of the thread that triggers the App
		shutdown (or otherwise requests the target thread to die). By default
		the TrieadJoin carries a FileInterrupt object in it (it gets created on
		TrieadJoin construction, and then TrieadJoin keeps a reference to it),
		that will get called by this method to revoke the files. But everything
		else is a part of the threading system, and the base class doesn't know
		how to do it, the subclasses must define their own methods, wrapping
		the base class.
		</p><p>
		Both PerlTrieadJoin and BasicPthread add sending the signal <code class="computeroutput">SIGUSR2</code> to
		the target thread. For that they use the same target thread identity
		kept in the object as used by the <code class="computeroutput">join()</code> call.
		</p><pre class="programlisting">FileInterrupt *fileInterrupt() const;</pre><p>
		Get a pointer to the FileInterrupt object defined in the TrieadJoin.
		The most typical use is to pass it to the TrieadOwner object, so that
		it can be easily found later:
		</p><pre class="programlisting">to-&gt;fileInterrupt_ = fileInterrupt();</pre><p>
		Though of course it could be kept in a separate local Autoref instead.
		</p><pre class="programlisting">const string &amp;getName() const;</pre><p>
		Get back the name of the joiner's thread. 
		</p></div><div class="sect1" title="20.43. FileInterrupt reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_file_interrupt"></a>20.43. FileInterrupt reference</h2></div></div></div><a class="indexterm" name="id577147"></a><p>
		FileInterrupt is the class that keeps track of a bunch of file
		descriptors and revokes them on demand, hopefully interrupting any
		ongoing operations on them (and if that doesn't do the job, a
		separately sent signal will). It's not visible in Perl, being
		intergrated into the TrieadOwner methods, but in C++ it's a separate
		class. It's defined in <code class="computeroutput">app/FileInterrupt.h</code>, and is an Mtarget, since
		the descriptors are registered and revoked from different threads.
		</p><pre class="programlisting">FileInterrupt();</pre><a class="indexterm" name="id591053"></a><p>
		The constructor, absolutely plain. Normally you would not want to
		construct it directly but use the object already constructed in
		TrieadJoin. The object keeps the state, whether the interruption had
		happened, and is obviously initialized to the non-interrupted state.
		</p><pre class="programlisting">void trackFd(int fd);</pre><p>
		Add a file descriptor to the tracked interruptable set. If the
		interruption was already done, the descriptor will instead be revoked
		right away by dupping over from <code class="computeroutput">/dev/null</code>. If the attempt to open
		<code class="computeroutput">/dev/null</code> fails, it will throw an Exception.
		</p><pre class="programlisting">void forgetFd(int fd);</pre><p>
		Remove a file descriptor to the tracked interruptable set. You must do
		it before closing the descriptor, or a race leading to the corruption
		of random file descriptors may occur. If this file descriptor was not
		registered, the call will be silently ignored.
		</p><pre class="programlisting">void interrupt();</pre><p>
		Perform the revocation of all the registered file descriptors by
		dupping over them from <code class="computeroutput">/dev/null</code>. If the attempt to open <code class="computeroutput">/dev/null</code>
		fails, it will throw an Exception.
		</p><p>
		This marks the FileInterrupt object state as interrupted, and any
		following <code class="computeroutput">trackFd()</code> calls will lead to the immediate revocation of the
		file descriptors in them, thus preventing any race conditions.
		</p><pre class="programlisting">bool isInterrupted() const;</pre><p>
		Check whether this object has been interrupted. 
		</p></div><div class="sect1" title="20.44. BasicPthread reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_cpp_basic_pthread"></a>20.44. BasicPthread reference</h2></div></div></div><a class="indexterm" name="id603151"></a><p>
		Building a new Triead is
		a serious business, containing many moving part. Doing it every time
		from scratch would be hugely annoying and error prone. The class
		BasicPthread, defined in <code class="computeroutput">app/BasicPthread.h</code>,  takes care of wrapping
		all that complicated logic.
		</p><p>
		It originated as a subclass of pw::pwthread, and even though it ended
		up easier to copy and modify the code (okay, maybe this means that
		pwthread can be made more flexible), the usage is still very similar to
		it. You define a new subclass of BasicPthread, and define the virtual
		function <code class="computeroutput">execute()</code> in it. Then you instantiate the object and call the
		method <code class="computeroutput">start()</code> with the App argument.
		</p><p>
		For a very simple example:
		</p><pre class="programlisting">class MainLoopPthread : public BasicPthread
{
public:
  MainLoopPthread(const string &amp;name):
    BasicPthread(name)
  { }

  // overrides BasicPthread::execute
  virtual void execute(TrieadOwner *to)
  {
    to-&gt;readyReady();
    to-&gt;mainLoop();
  }
};

...

Autoref&lt;MainLoopPthread&gt; pt3 = new MainLoopPthread("t3");
pt3-&gt;start(myapp);</pre><p>
		It will properly create the Triead, TrieadOwner, register the thread
		joiner and start the execution. The TrieadOwner will pass through to
		the <code class="computeroutput">execute()</code> method, and its field <code class="computeroutput">fi_</code> will contain the reference to
		the FileInterrupt object. After <code class="computeroutput">execute()</code> returns, it will take care of
		marking the thread as dead.
		</p><p>
		It also wraps the call of <code class="computeroutput">execute()</code> into a try/catch block, so any
		Exceptions thrown will be caught and cause the App to abort. In short,
		it's very similar to the Triead management in Perl.
		</p><p>
		You don't need to keep the reference to the thread object afterwards,
		you can even do the construction and start in one go:
		</p><pre class="programlisting">(new MainLoopPthread("t3"))-&gt;start(myapp);</pre><p>
		The internals of BasicPthread will make sure that the object will be
		dereferenced (and thus, in the absence of other references, destroyed)
		after the thread gets joined by the harvester.
		</p><p>
		Of course, if you need to pass more arguments to the thread, you can
		define them as fields in your subclass, set them in the constructor (or
		by other means between constructing the object and calling <code class="computeroutput">start()</code>),
		and then <code class="computeroutput">execute()</code> can access them. Remember, <code class="computeroutput">execute()</code> is a method, so
		it receives not only the TrieadObject as an argument but also the
		BasicPthread object as <code class="computeroutput">this</code>.
		</p><p>
		BasicPthread is implemented as a subclass of TrieadJoin, and thus is an
		Mtarget. It provides the concrete implementation of the joiner's
		virtual methods, <code class="computeroutput">join()</code> and <code class="computeroutput">interrupt()</code>. <code class="computeroutput">Interrupt()</code> calls the method
		of the base class, then sends the signal <code class="computeroutput">SIGUSR2</code> to the target thread.
		</p><p>
		And finally the actual reference:
		</p><pre class="programlisting">BasicPthread(const string &amp;name);</pre><p>
		Constructor. The name of the thread is passed through to
		<code class="computeroutput">App::makeTriead()</code>. The Triead will be constructed in <code class="computeroutput">start()</code>, the
		BasicPthread constructor just collects together the arguments.
		</p><pre class="programlisting">void start(Autoref&lt;App&gt; app);</pre><p>
		Construct the Triead, create the POSIX thread, and start the execution
		there.
		</p><pre class="programlisting">void start(Autoref&lt;TrieadOwner&gt; to);</pre><p>
		Similar to the other version of <code class="computeroutput">start()</code> but uses a pre-constructed
		TrieadOwner object. This version is useful mostly for the tests, and
		should not be used much in the real life.
		</p><pre class="programlisting">virtual void execute(TrieadOwner *to);</pre><p>
		Method that must be redefined by the subclass, containing the threads's
		logic.
		</p><pre class="programlisting">virtual void join();
virtual void interrupt();</pre><p>
		Methods inherited from TrieadJoin, providing the proper implementations
		for the POSIX threads.
		</p></div></div><div class="chapter" title="Chapter 21. Release Notes"><div class="titlepage"><div><div><h2 class="title"><a name="ch_relnotes"></a>Chapter 21. Release Notes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sc_notes_2_0_1">21.1. Release 2.0.1</a></span></dt><dt><span class="sect1"><a href="#sc_notes_2_0_0">21.2. Release 2.0.0</a></span></dt><dt><span class="sect1"><a href="#sc_notes_1_0_1">21.3. Release 1.0.1</a></span></dt><dt><span class="sect1"><a href="#sc_notes_1_0_0">21.4. Release 1.0.0</a></span></dt><dt><span class="sect1"><a href="#sc_notes_0.99">21.5. Release 0.99</a></span></dt></dl></div><div class="sect1" title="21.1. Release 2.0.1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_notes_2_0_1"></a>21.1. Release 2.0.1</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Fixed the version information that was left incorrect (at 0.99).
			</li><li class="listitem">
			Used a more generic pattern in tests for Perl error messages that have 
			changed in the more recent versions of Perl (per CPAN report #99268).
			</li><li class="listitem">
			Added the more convenient way to wrap the error reports in Perl,
			<code class="computeroutput">Triceps::nestfess()</code> and <code class="computeroutput">Triceps::wrapfess()</code>.
			</li><li class="listitem">
			Added functions for the nicer printing of auto-generated code,
			<code class="computeroutput">Triceps::alignsrc()</code> and <code class="computeroutput">Triceps::numalign()</code>.
			</li><li class="listitem">
			In the doc chapter on the templates, fixed the output of the examples:
			properly interleaved the inputs and outputs.
			</li></ul></div></div><div class="sect1" title="21.2. Release 2.0.0"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_notes_2_0_0"></a>21.2. Release 2.0.0</h2></div></div></div><p>
		Major:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Documentation for the C++ API.
			</li><li class="listitem">
			Streaming functions.
			</li><li class="listitem">
			Multithreading.
			</li><li class="listitem">
			TQL.
			</li></ul></div><p>
		Minor:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			No more copy trays in the tables, they've got replaced by treating the table
			as a streaming function (the automatically generated FnReturn in a Table).
			</li><li class="listitem">
			When a hashed index type is initialized, its <code class="computeroutput">match()</code> method 
			takes the field name-to-index translation into account, and matches
			even if the key field names are different but translating to the
			same indexes.
			</li><li class="listitem">
			The recusrion is now permitted, and the limits on it can be adjusted
			per-unit (the defaults still forbid it). The labels can be marked
			non-re-entrant to forbid the recursion on them.
			</li><li class="listitem">
			The execution of rowops enqueued by <code class="computeroutput">fork()</code> and <code class="computeroutput">loopAt()</code> has changed:
			now they reuse the parent's stack frame. This changed the looping
			logic: the marks are now set on the current, not parent's frame,
			and the <code class="computeroutput">makeLoop*</code> calls don't need, don't create and don't return
			the begin label.
			</li><li class="listitem">
			The change in the execution of forked rowops led to the different
			trace sequence, and a modified set of TraceWhen states. The 
			<span class="quote">&#8220;<span class="quote">before</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">after</span>&#8221;</span> states now always come in pairs, and there
			are methods to generally differentiate between them.
			</li><li class="listitem">
			The Labels are marked as cleared before their subclass clearing function
			is called, not after it. The repeated calls to clear them are ignored.
			</li><li class="listitem">
			In Table added <code class="computeroutput">clear()</code>, sticky error methods, fixed the handling
			of errors in the index comparators to produce the sticky errors.
			</li><li class="listitem">
			The Unit ignores the attempts to remember, forget or clear labels while
			it's already clearing labels.
			</li><li class="listitem">
			In Unit added <code class="computeroutput">isFrameEmpty</code>, <code class="computeroutput">isInOuterFrame()</code>.
			</li><li class="listitem">
			In Rowop added an optional argument to <code class="computeroutput">printP()</code>.
			</li><li class="listitem">
			Added handling of the broken Perl versions that return spurious errors on
			the command execution.
			</li><li class="listitem">
			Better C++ NameSet constructors.
			</li><li class="listitem">
			The C++ API always throws Exceptions instead of direct <code class="computeroutput">abort()</code>.
			</li><li class="listitem">
			In the C++ API AggregatorType accept the NULL result row type until
			the initialization is completed.
			</li><li class="listitem">
			In the C++ API AggregatorGadget added the <code class="computeroutput">typeAs()</code> template, the
			version of <code class="computeroutput">sendDelayed()</code> that constructs the row from the fields,
			and <code class="computeroutput">getIndexType()</code>.
			</li><li class="listitem">
			In C++ added a Rhref constructor directly from a FdataVec argument.
			</li><li class="listitem">
			In C++ added the method <code class="computeroutput">Label::adopt()</code>, making it easier
			to remember.
			</li><li class="listitem">
			The <code class="computeroutput">Label::adopt()</code> in Perl now allows the cross-unit adoption.
			</li><li class="listitem">
			Out-of-the-box compilation with a wider range of GCC compiler versions.
			</li><li class="listitem">
			The default constructor of Fdata sets the value to NULL.
			</li><li class="listitem">
			In C++ addded the convenience <code class="computeroutput">get*</code> methods on Rowref.
			</li><li class="listitem">
			In C++ addded the <code class="computeroutput">initializeOrThrow()</code>, <code class="computeroutput">checkOrThrow()</code> templates.
			</li><li class="listitem">
			The tables no longer have an enqueuing mode associated with them.
			</li><li class="listitem">
			The potentially reusable examples have been exported in the packages
			under Triceps::X.
			</li><li class="listitem">
			The <code class="computeroutput">Triceps::X::SimpleServer::outBuf()</code> now checks for the client
			disconnection before sending data to it.
			</li><li class="listitem">
			The <span class="quote">&#8220;<span class="quote">dump</span>&#8221;</span> label added to the tables.
			</li><li class="listitem">
			The <code class="computeroutput">chainFront()</code> method added in the Label in the Perl API
			and an extra argument with the same meaning added to <code class="computeroutput">chain</code>
			in the C++ API.
			</li><li class="listitem">
			The <code class="computeroutput">*Safe()</code> methods added to the Perl API.
			</li><li class="listitem">
			Finiding an index by its keys with <code class="computeroutput">TableType::findIndexPathForKeys()</code>.
			</li><li class="listitem">
			Passing through of arbitrary options, and manipulation of the option lists.
			</li><li class="listitem">
			A fast way to check whether a row is empty.
			</li></ul></div></div><div class="sect1" title="21.3. Release 1.0.1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_notes_1_0_1"></a>21.3. Release 1.0.1</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			Fixed the version information that was left incorrect, as 0.99.
			</li><li class="listitem">
			Added the scripts to check the version and Perl MANIFEST before
			doing a release, script to set the version (ckversion, setversion),
			explicit version option -v to mkrelease.
			</li><li class="listitem">
			Added the Release Notes.
			</li></ul></div></div><div class="sect1" title="21.4. Release 1.0.0"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_notes_1_0_0"></a>21.4. Release 1.0.0</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			The first official release with full documentation.
			</li><li class="listitem">
			Many additional examples, code clean-ups and small features
			resulting from the experience of writing the documentation.
			</li></ul></div></div><div class="sect1" title="21.5. Release 0.99"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sc_notes_0.99"></a>21.5. Release 0.99</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
			The first published pre-release. Basic functionality, no documentation.
			</li></ul></div></div></div><div class="bibliography" title="Bibliography"><div class="titlepage"><div><div><h2 class="title"><a name="id497239"></a>Bibliography</h2></div></div></div><fo:block xmlns:fo="http://www.w3.org/1999/XSL/Format" id="id573949"><div class="biblioentry" title="The practice of parallel programming"><a name="Babkin10"></a><p>[Babkin10] <span style="text-transform:uppercase">Babkin</span>, Sergey A. <i>The practice of parallel programming</i>. Createspace, ©2010. ISBN 1-451-53661-5. </p></div><div class="biblioentry" title="Esper Tutorials"><a name="Esper"></a><p>[Esper] <span style="text-transform:uppercase">EsperTech Inc.</span>. <i>Esper Tutorials: 
				<a class="ulink" href="http://esper.codehaus.org/tutorials/tutorials.html" target="_top">http://esper.codehaus.org/tutorials/tutorials.html</a>
			</i>. </p></div><div class="biblioentry" title="Lisp-maailma: Johdatus kieleen ja ohjelmointiin. (Lisp World: Introduction to Language and Programming)."><a name="Hyvonen86"></a><p>[Hyvonen86] <span style="text-transform:uppercase">Hyvönen</span>, Eero and <span style="text-transform:uppercase">Seppänen</span>, Jouko. <i>Lisp-maailma: Johdatus kieleen ja ohjelmointiin. (Lisp World: Introduction to Language and Programming).: 
				<a class="ulink" href="Russia%20Edition:%20Mir%20Lispa" target="_top">Russia Edition: Mir Lispa</a>
			</i>. Kirjayhtymä, ©1986. ISBN 9512627876. </p></div><div class="biblioentry" title="DocBook XSL: The Complete Guide (4th Edition)"><a name="Stayton07"></a><p>[Stayton07] <span style="text-transform:uppercase">Stayton</span>, Bob. <i>DocBook XSL: The Complete Guide (4th Edition): 
				<a class="ulink" href="http://www.sagehill.net/docbookxsl/" target="_top">http://www.sagehill.net/docbookxsl/</a>
			</i>. Sagehill Enterprises, ©2007. ISBN 0-974-15213-7. </p></div><div class="biblioentry" title="StreamBase Documentation"><a name="StreamBase"></a><p>[StreamBase] <span style="text-transform:uppercase">StreamBase Inc.</span>. <i>StreamBase Documentation: 
				<a class="ulink" href="http://docs.streambase.com/" target="_top">http://docs.streambase.com/</a>
			</i>. </p></div><div class="biblioentry" title="Sybase Aleri Streaming Platform 3.2"><a name="Aleri"></a><p>[Aleri] <span style="text-transform:uppercase">Sybase Inc.</span>. <i>Sybase Aleri Streaming Platform 3.2: 
				<a class="ulink" href="http://infocenter.sybase.com/help/index.jsp?docset=/com.sybase.infocenter.help.aleri.3.2/title.htm&amp;docSetID=1733" target="_top">http://infocenter.sybase.com/help/index.jsp?docset=/com.sybase.infocenter.help.aleri.3.2/title.htm&amp;docSetID=1733</a>
			</i>. </p></div><div class="biblioentry" title="Sybase CEP Option R4"><a name="Coral8"></a><p>[Coral8] <span style="text-transform:uppercase">Sybase Inc.</span>. <i>Sybase CEP Option R4: 
				<a class="ulink" href="http://infocenter.sybase.com/help/index.jsp?docset=/com.sybase.infocenter.help.cep.4.0/doc/html/title.html&amp;docSetID=1659" target="_top">http://infocenter.sybase.com/help/index.jsp?docset=/com.sybase.infocenter.help.cep.4.0/doc/html/title.html&amp;docSetID=1659</a>
			</i>. </p></div><div class="biblioentry" title="Sybase Event Stream Processor 5.0"><a name="SybaseR5"></a><p>[SybaseR5] <span style="text-transform:uppercase">Sybase Inc.</span>. <i>Sybase Event Stream Processor 5.0: 
				<a class="ulink" href="http://infocenter.sybase.com/help/index.jsp?docset=/com.sybase.infocenter.help.esp.5.0/doc/html/title.html&amp;docSetID=1788" target="_top">http://infocenter.sybase.com/help/index.jsp?docset=/com.sybase.infocenter.help.esp.5.0/doc/html/title.html&amp;docSetID=1788</a>
			</i>. </p></div><div class="biblioentry" title="DocBook: The Definitive Guide"><a name="Walsh99"></a><p>[Walsh99] <span style="text-transform:uppercase">Walsh</span>, Norman and <span style="text-transform:uppercase">Muellner</span>, Leonard. <i>DocBook: The Definitive Guide: 
				<a class="ulink" href="http://www.oasis-open.org/docbook/documentation/reference/html/" target="_top">http://www.oasis-open.org/docbook/documentation/reference/html/</a>
			</i>. O'Reilly Media, ©1999. ISBN 156592-580-7. </p></div></fo:block></div><div class="index" title="Index"><div class="titlepage"><div><div><h2 class="title"><a name="id416225"></a>Index</h2></div></div></div><div class="index"><div class="indexdiv"><h3>A</h3><dl><dt>abort, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a></dt><dt>AggOp, <a class="indexterm" href="#sc_cpp_aggregator_obj">Aggregator reference</a></dt><dt>aggregation, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a>, <a class="indexterm" href="#sc_table_sorted">Sorted index</a>, <a class="indexterm" href="#sc_aggregation_vwap">The ubiquitous VWAP</a>, <a class="indexterm" href="#sc_time_limited">Time-limited propagation</a>, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a></dt><dd><dl><dt>additive, <a class="indexterm" href="#sc_aggregation_additive">Additive aggregation</a></dt><dt>arguments, <a class="indexterm" href="#sc_aggregation_args">Computation function arguments</a></dt><dt>context, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dt>count, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dt>first, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dt>floating point error, <a class="indexterm" href="#sc_aggregation_additive">Additive aggregation</a>, <a class="indexterm" href="#sc_aggregation_multi_idx">Using multiple indexes</a></dt><dt>helper table, <a class="indexterm" href="#sc_aggregation_manual">Manual aggregation</a>, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dt>initialization, <a class="indexterm" href="#sc_aggregation_optimized">Optimized DELETEs</a></dt><dt>iteration, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dt>last, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dt>manual, <a class="indexterm" href="#sc_table_secondary">Secondary indexes</a>, <a class="indexterm" href="#sc_aggregation_manual">Manual aggregation</a>, <a class="indexterm" href="#sc_time_periodic">Periodic updates</a></dt><dt>multiple indexes, <a class="indexterm" href="#sc_aggregation_multi_idx">Using multiple indexes</a></dt><dt>of DELETEs, <a class="indexterm" href="#sc_aggregation_manual">Manual aggregation</a></dt><dt>opcode, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dt>operation, <a class="indexterm" href="#sc_aggregation_additive">Additive aggregation</a>, <a class="indexterm" href="#sc_cpp_aggregator_obj">Aggregator reference</a></dt><dt>optimization, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a>, <a class="indexterm" href="#sc_aggregation_optimized">Optimized DELETEs</a>, <a class="indexterm" href="#sc_aggregation_additive">Additive aggregation</a></dt><dt>state, <a class="indexterm" href="#sc_aggregation_optimized">Optimized DELETEs</a>, <a class="indexterm" href="#sc_aggregation_additive">Additive aggregation</a></dt></dl></dd><dt>Aggregator, <a class="indexterm" href="#sc_cpp_aggregator_obj">Aggregator reference</a></dt><dd><dl><dt>handler, <a class="indexterm" href="#sc_cpp_idx">Index reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_obj">Aggregator reference</a></dt></dl></dd><dt>AggregatorContext, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a>, <a class="indexterm" href="#sc_ref_aggcontext">AggregatorContext reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_obj">Aggregator reference</a></dt><dt>AggregatorGadget, <a class="indexterm" href="#sc_cpp_aggregator_gadget">AggregatorGadget reference</a></dt><dt>AggregatorType, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a>, <a class="indexterm" href="#sc_ref_agg_type">AggregatorType reference</a>, <a class="indexterm" href="#sc_cpp_tabtype">TableType reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_type">AggregatorType reference</a></dt><dt>Aleri, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a>, <a class="indexterm" href="#sc_Labels">Labels basics</a>, <a class="indexterm" href="#sc_sched_compar">Comparative scheduling in the various CEP systems</a>, <a class="indexterm" href="#sc_sched_tray">Trays</a>, <a class="indexterm" href="#sc_sched_no_bundling">No bundling</a>, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a>, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a>, <a class="indexterm" href="#sc_joins_variety">Joins variety</a>, <a class="indexterm" href="#sc_time_issues">The general issues of time processing</a>, <a class="indexterm" href="#sc_other_diamond">The dreaded diamond</a>, <a class="indexterm" href="#sc_other_collapse">Collapsed updates</a>, <a class="indexterm" href="#sc_cpp_errors">Error reporting and Errors reference</a></dt><dt>alignsrc, <a class="indexterm" href="#sc_ref_code">Code helpers reference</a></dt><dt>AllTypes, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt><dt>App, <a class="indexterm" href="#sc_mt_concepts">Triceps multithreading concepts</a>, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a>, <a class="indexterm" href="#sc_mt_threaded_server">ThreadedServer implementation, and the details of thread harvesting</a>, <a class="indexterm" href="#sc_ref_app">App reference</a>, <a class="indexterm" href="#sc_cpp_app">App reference</a></dt><dt>arrays, <a class="indexterm" href="#sc_RowTypes">Row types</a></dt><dd><dl><dt>empty, <a class="indexterm" href="#sc_RowTypes">Row types</a></dt></dl></dd><dt>AtomicInt, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a></dt><dt>AutoDrain, <a class="indexterm" href="#sc_ref_autodrain">AutoDrain reference</a>, <a class="indexterm" href="#sc_cpp_autodrain">AutoDrain reference</a></dt><dt>AutoFnBind, <a class="indexterm" href="#sc_strf_collapse">Streaming functions by example, another version of Collapse</a>, <a class="indexterm" href="#sc_strf_pipelines">Streaming functions and pipelines</a>, <a class="indexterm" href="#sc_ref_autofnbind">AutoFnBind reference</a>, <a class="indexterm" href="#sc_cpp_autofn">ScopeFnBind and AutoFnBind reference</a></dt><dt>Autoref, <a class="indexterm" href="#sc_memory_fund">Memory management fundamentals</a>, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a>, <a class="indexterm" href="#sc_cpp_errors">Error reporting and Errors reference</a>, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a></dt></dl></div><div class="indexdiv"><h3>B</h3><dl><dt>BasicAggregatorType, <a class="indexterm" href="#sc_cpp_aggregator_type">AggregatorType reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_basic">BasicAggregatorType reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_example">Aggegator example</a></dt><dt>BasicPthread, <a class="indexterm" href="#sc_cpp_triead_join">TrieadJoin reference</a>, <a class="indexterm" href="#sc_cpp_basic_pthread">BasicPthread reference</a></dt><dt>batch, <a class="indexterm" href="#sc_other_collapse">Collapsed updates</a></dt><dt>binding, <a class="indexterm" href="#sc_strf_collapse">Streaming functions by example, another version of Collapse</a></dt><dt>Braced, <a class="indexterm" href="#sc_strf_units">Streaming functions and unit boundaries</a>, <a class="indexterm" href="#sc_ref_braced">Braced reference</a></dt><dt>build, <a class="indexterm" href="#sc_build_basic">The basic build</a></dt><dd><dl><dt>documentation, <a class="indexterm" href="#sc_build_run_doc">Building the documentation</a></dt><dt>environment, <a class="indexterm" href="#sc_build_refenv">The reference environment</a></dt></dl></dd><dt>bundling, <a class="indexterm" href="#sc_sched_no_bundling">No bundling</a>, <a class="indexterm" href="#sc_sched_mainloop">The main loop</a>, <a class="indexterm" href="#sc_table_label">Tables and labels</a>, <a class="indexterm" href="#sc_other_diamond">The dreaded diamond</a></dt></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>C++, <a class="indexterm" href="#sc_api_lang">Languages and layers</a>, <a class="indexterm" href="#sc_cpp_intro">C++ API Introduction</a></dt><dt>call, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a></dt><dt>Carp, <a class="indexterm" href="#sc_confessions">Errors, deaths and confessions</a></dt><dt>case sensitivity, <a class="indexterm" href="#sc_RowTypesEquiv">Row types equivalence</a></dt><dt>CCL, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a>, <a class="indexterm" href="#sc_1950s">We're not in 1950s any more, or are we?</a>, <a class="indexterm" href="#sc_sched_no_bundling">No bundling</a>, <a class="indexterm" href="#sc_template_intro">Comparative modularity</a>, <a class="indexterm" href="#sc_other_diamond">The dreaded diamond</a>, <a class="indexterm" href="#sc_other_collapse">Collapsed updates</a></dt><dt>CEP, <a class="indexterm" href="#sc_what_is_cep">What is the CEP?</a></dt><dt>chat server, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a></dt><dt>chunks, <a class="indexterm" href="#sc_other_chunks_del">Large deletes in small chunks</a></dt><dt>ClearingLabel, <a class="indexterm" href="#sc_clearing_labels">The clearing labels</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a></dt><dt>closure, <a class="indexterm" href="#sc_template_result">Result projection in the templates</a></dt><dt>code, <a class="indexterm" href="#sc_code">Code references and snippets</a>, <a class="indexterm" href="#sc_ref_code">Code helpers reference</a></dt><dt>code generation, <a class="indexterm" href="#sc_table_ordered">Ordered index</a>, <a class="indexterm" href="#sc_template_codegen">Code generation in the templates</a></dt><dt>Collapse, <a class="indexterm" href="#sc_other_collapse">Collapsed updates</a>, <a class="indexterm" href="#sc_strf_collapse">Streaming functions by example, another version of Collapse</a>, <a class="indexterm" href="#sc_strf_keyed_collapse">Collapse with grouping by key with streaming functions</a>, <a class="indexterm" href="#sc_strf_templates">Streaming functions and template results</a>, <a class="indexterm" href="#sc_ref_collapse">Collapse reference</a></dt><dt>collation, <a class="indexterm" href="#sc_mt_main_reorder">The threaded dreaded diamond and data reordering</a></dt><dt>CompactRowType, <a class="indexterm" href="#sc_cpp_rowtype">RowType reference</a></dt><dt>compile, <a class="indexterm" href="#sc_ref_code">Code helpers reference</a></dt><dt>confess, <a class="indexterm" href="#sc_hello_world">Hello, world!</a>, <a class="indexterm" href="#sc_confessions">Errors, deaths and confessions</a>, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a></dt><dt>const, <a class="indexterm" href="#sc_cpp_const">The const-ness in C++</a></dt><dt>constants, <a class="indexterm" href="#sc_constants">Triceps constants</a>, <a class="indexterm" href="#sc_opcodes">Opcodes</a>, <a class="indexterm" href="#sc_sched_tracing">Tracing the execution</a>, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a></dt><dt>const_Autoref, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a></dt><dt>const_iterator, <a class="indexterm" href="#sc_cpp_const">The const-ness in C++</a>, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a></dt><dt>const_Onceref, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a></dt><dt>copy tray, <a class="indexterm" href="#sc_table_copy_tray">The copy tray</a></dt><dt>copying, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a></dt><dt>Coral8, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a>, <a class="indexterm" href="#sc_Labels">Labels basics</a>, <a class="indexterm" href="#sc_sched_compar">Comparative scheduling in the various CEP systems</a>, <a class="indexterm" href="#sc_sched_tray">Trays</a>, <a class="indexterm" href="#sc_sched_no_bundling">No bundling</a>, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a>, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a>, <a class="indexterm" href="#sc_template_intro">Comparative modularity</a>, <a class="indexterm" href="#sc_aggregation_manual">Manual aggregation</a>, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a>, <a class="indexterm" href="#sc_joins_variety">Joins variety</a>, <a class="indexterm" href="#sc_joins_jointwo_override">The override options in JoinTwo</a>, <a class="indexterm" href="#sc_time_issues">The general issues of time processing</a></dt></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>data flow, <a class="indexterm" href="#sc_what_is_cep">What is the CEP?</a>, <a class="indexterm" href="#sc_Labels">Labels basics</a></dt><dt>diamond, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a>, <a class="indexterm" href="#sc_other_diamond">The dreaded diamond</a>, <a class="indexterm" href="#sc_mt_main_reorder">The threaded dreaded diamond and data reordering</a></dt><dt>die, <a class="indexterm" href="#sc_confessions">Errors, deaths and confessions</a></dt><dt>dispatch table, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a></dt><dt>DocBook, <a class="indexterm" href="#sc_build_run_doc">Building the documentation</a></dt><dt>download, <a class="indexterm" href="#sc_build_download">Downloading Triceps</a></dt><dt>drain, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a>, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a></dt><dt>draining, <a class="indexterm" href="#sc_sched_unwind">Error handling during the execution</a>, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a></dt><dt>DumbClient, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a></dt><dt>DummyLabel, <a class="indexterm" href="#sc_Labels">Labels basics</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a>, <a class="indexterm" href="#sc_cpp_label">Label reference</a></dt><dt>dup2, <a class="indexterm" href="#sc_mt_files">Threads and file descriptors</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>EnqMode, <a class="indexterm" href="#sc_cpp_gadget">Gadget reference</a></dt><dt>enqueue, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a></dt><dt>Erref, <a class="indexterm" href="#sc_cpp_errors">Error reporting and Errors reference</a>, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a></dt><dt>error handling, <a class="indexterm" href="#sc_hello_world">Hello, world!</a>, <a class="indexterm" href="#sc_confessions">Errors, deaths and confessions</a>, <a class="indexterm" href="#sc_constants">Triceps constants</a>, <a class="indexterm" href="#sc_Rowop">Row operations</a>, <a class="indexterm" href="#sc_sched_unwind">Error handling during the execution</a>, <a class="indexterm" href="#sc_table_delete">Deleting a row</a>, <a class="indexterm" href="#sc_table_RowHandle">A closer look at the RowHandles</a>, <a class="indexterm" href="#sc_table_sorted">Sorted index</a>, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a>, <a class="indexterm" href="#sc_template_result">Result projection in the templates</a>, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dd><dl><dt>in C++, <a class="indexterm" href="#sc_cpp_errors">Error reporting and Errors reference</a>, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a>, <a class="indexterm" href="#sc_cpp_init">Initialization templates</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt><dt>in templates, <a class="indexterm" href="#sc_template_wrapfess">Error reporting in the templates</a></dt><dt>multithreaded, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a></dt></dl></dd><dt>Errors, <a class="indexterm" href="#sc_cpp_errors">Error reporting and Errors reference</a>, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a></dt><dd><dl><dt>multi-line, <a class="indexterm" href="#sc_cpp_errors">Error reporting and Errors reference</a></dt></dl></dd><dt>ESP, <a class="indexterm" href="#sc_what_is_cep">What is the CEP?</a></dt><dt>Esper, <a class="indexterm" href="#sc_triceps_reasons">What led to it</a>, <a class="indexterm" href="#sc_time_issues">The general issues of time processing</a></dt><dt>examples, <a class="indexterm" href="#sc_build_run_simple">Running the examples and simple programs</a>, <a class="indexterm" href="#sc_perl_libex">The Perl libraries and examples</a></dt><dt>Exception, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a>, <a class="indexterm" href="#sc_cpp_init">Initialization templates</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a>, <a class="indexterm" href="#sc_cpp_tabtype">TableType reference</a>, <a class="indexterm" href="#sc_cpp_idxtype">IndexType reference</a></dt><dd><dl><dt>modes, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a></dt></dl></dd><dt>execution model, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a></dt><dt>execution order, <a class="indexterm" href="#sc_time_issues">The general issues of time processing</a>, <a class="indexterm" href="#sc_other_diamond">The dreaded diamond</a></dt><dt>expect, <a class="indexterm" href="#sc_mt_threaded_client">ThreadedClient, a Triceps Expect</a></dt></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>Facet, <a class="indexterm" href="#sc_mt_concepts">Triceps multithreading concepts</a>, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a>, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a>, <a class="indexterm" href="#sc_mt_main_reorder">The threaded dreaded diamond and data reordering</a>, <a class="indexterm" href="#sc_ref_fnreturn">FnReturn reference</a>, <a class="indexterm" href="#sc_ref_facet">Facet reference</a>, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a>, <a class="indexterm" href="#sc_cpp_fnreturn">FnReturn reference</a>, <a class="indexterm" href="#sc_cpp_facet">Facet reference</a></dt><dt>Fdata, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a></dt><dd><dl><dt>override, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a></dt></dl></dd><dt>FdataVec, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a></dt><dt>Fibonacci, <a class="indexterm" href="#sc_sched_topo_loops">Topological loops</a>, <a class="indexterm" href="#sc_strf_loops">Streaming functions and loops</a></dt><dt>Field, <a class="indexterm" href="#sc_cpp_rowtype">RowType reference</a></dt><dt>Fields, <a class="indexterm" href="#sc_ref_fields">Fields reference</a></dt><dt>FieldVec, <a class="indexterm" href="#sc_cpp_rowtype">RowType reference</a></dt><dt>FIFO, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a></dt><dt>FifoIndexType, <a class="indexterm" href="#sc_cpp_fifoidx">FifoIndexType reference</a></dt><dt>file, <a class="indexterm" href="#sc_mt_files">Threads and file descriptors</a></dt><dt>FileInterrupt, <a class="indexterm" href="#sc_mt_files">Threads and file descriptors</a>, <a class="indexterm" href="#sc_cpp_triead_owner">TrieadOwner reference</a>, <a class="indexterm" href="#sc_cpp_triead_join">TrieadJoin reference</a>, <a class="indexterm" href="#sc_cpp_file_interrupt">FileInterrupt reference</a></dt><dt>filter, <a class="indexterm" href="#sc_joins_lookup_manual">The lookup join, done manually</a>, <a class="indexterm" href="#sc_time_limited">Time-limited propagation</a></dt><dt>Float64Type, <a class="indexterm" href="#sc_cpp_types_simple">Simple types reference</a></dt><dt>FnBinding, <a class="indexterm" href="#sc_strf_collapse">Streaming functions by example, another version of Collapse</a>, <a class="indexterm" href="#sc_strf_keyed_collapse">Collapse with grouping by key with streaming functions</a>, <a class="indexterm" href="#sc_ref_fnbinding">FnBinding reference</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a>, <a class="indexterm" href="#sc_cpp_fnbind">FnBinding reference</a></dt><dt>FnBinding::call, <a class="indexterm" href="#sc_strf_translation">Table-based translation with streaming functions</a>, <a class="indexterm" href="#sc_ref_fnbinding">FnBinding reference</a></dt><dt>FnReturn, <a class="indexterm" href="#sc_strf_collapse">Streaming functions by example, another version of Collapse</a>, <a class="indexterm" href="#sc_ref_fnreturn">FnReturn reference</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a>, <a class="indexterm" href="#sc_cpp_table">Table reference</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a>, <a class="indexterm" href="#sc_cpp_fnreturn">FnReturn reference</a></dt><dd><dl><dt>matching, <a class="indexterm" href="#sc_strf_pipelines">Streaming functions and pipelines</a></dt></dl></dd><dt>fork, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a>, <a class="indexterm" href="#sc_strf_more_recursion">Streaming functions and more recursion</a></dt><dt>fork-join, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a>, <a class="indexterm" href="#sc_other_diamond">The dreaded diamond</a>, <a class="indexterm" href="#sc_mt_main_reorder">The threaded dreaded diamond and data reordering</a></dt><dt>Fortran, <a class="indexterm" href="#sc_1950s">We're not in 1950s any more, or are we?</a></dt><dt>fragment, <a class="indexterm" href="#sc_mt_concepts">Triceps multithreading concepts</a>, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a></dt><dt>frame, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a></dt><dt>frame mark, <a class="indexterm" href="#sc_sched_topo_loops">Topological loops</a>, <a class="indexterm" href="#sc_sched_loop">The gritty details of Triceps loop scheduling</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a>, <a class="indexterm" href="#sc_cpp_framemark">FrameMark reference</a></dt><dt>function, <a class="indexterm" href="#sc_strf_intro">Introduction to streaming functions</a></dt></dl></div><div class="indexdiv"><h3>G</h3><dl><dt>Gadget, <a class="indexterm" href="#sc_cpp_gadget">Gadget reference</a>, <a class="indexterm" href="#sc_cpp_table">Table reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_gadget">AggregatorGadget reference</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a></dt><dt>GOTO, <a class="indexterm" href="#sc_1950s">We're not in 1950s any more, or are we?</a>, <a class="indexterm" href="#sc_hello_world">Hello, world!</a>, <a class="indexterm" href="#sc_Labels">Labels basics</a></dt><dt>GroupHandle, <a class="indexterm" href="#sc_cpp_aggregator_obj">Aggregator reference</a></dt></dl></div><div class="indexdiv"><h3>H</h3><dl><dt>harversting, <a class="indexterm" href="#sc_mt_triead_life">The Triead lifecycle</a>, <a class="indexterm" href="#sc_mt_threaded_server">ThreadedServer implementation, and the details of thread harvesting</a></dt><dt>HashedIndexType, <a class="indexterm" href="#sc_cpp_nameset">NameSet reference</a>, <a class="indexterm" href="#sc_cpp_hashidx">HashedIndexType reference</a></dt><dt>HoldRowTypes, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a>, <a class="indexterm" href="#sc_cpp_tabtype">TableType reference</a></dt></dl></div><div class="indexdiv"><h3>I</h3><dl><dt>index</dt><dd><dl><dt>aggregation, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a></dt><dt>copy, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a></dt><dt>default, <a class="indexterm" href="#sc_table_secondary">Secondary indexes</a>, <a class="indexterm" href="#sc_table_indextree">The index tree</a>, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a></dt><dt>FIFO, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a>, <a class="indexterm" href="#sc_aggregation_window">Tricks with aggregation on a sliding window</a>, <a class="indexterm" href="#sc_aggregation_multi_idx">Using multiple indexes</a></dt><dt>find, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a></dt><dt>group, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a>, <a class="indexterm" href="#sc_table_indextree">The index tree</a></dt><dt>group size, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a></dt><dt>hashed, <a class="indexterm" href="#sc_table_hello">Hello, tables!</a>, <a class="indexterm" href="#sc_table_secondary">Secondary indexes</a>, <a class="indexterm" href="#sc_table_sorted">Sorted index</a>, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a>, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a></dt><dt>initialization, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a></dt><dt>key, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a></dt><dt>leaf, <a class="indexterm" href="#sc_table_indextree">The index tree</a></dt><dt>multimap, <a class="indexterm" href="#sc_aggregation_multi_idx">Using multiple indexes</a></dt><dt>non-leaf, <a class="indexterm" href="#sc_table_indextree">The index tree</a></dt><dt>order, <a class="indexterm" href="#sc_table_secondary">Secondary indexes</a></dt><dt>ordered, <a class="indexterm" href="#sc_table_ordered">Ordered index</a>, <a class="indexterm" href="#sc_aggregation_window">Tricks with aggregation on a sliding window</a>, <a class="indexterm" href="#sc_aggregation_multi_idx">Using multiple indexes</a>, <a class="indexterm" href="#sc_time_limited">Time-limited propagation</a></dt><dt>path, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a></dt><dt>primary, <a class="indexterm" href="#sc_table_secondary">Secondary indexes</a></dt><dt>root, <a class="indexterm" href="#sc_table_indextree">The index tree</a></dt><dt>secondary, <a class="indexterm" href="#sc_table_secondary">Secondary indexes</a></dt><dt>sorted, <a class="indexterm" href="#sc_table_sorted">Sorted index</a>, <a class="indexterm" href="#sc_joins_variety">Joins variety</a>, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a></dt><dt>tree, <a class="indexterm" href="#sc_table_secondary">Secondary indexes</a></dt><dt>type id, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a></dt></dl></dd><dt>Index, <a class="indexterm" href="#sc_cpp_idx">Index reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_obj">Aggregator reference</a></dt><dt>IndexType, <a class="indexterm" href="#sc_ref_index_type">IndexType reference</a>, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a>, <a class="indexterm" href="#sc_cpp_tabtype">TableType reference</a>, <a class="indexterm" href="#sc_cpp_idxtype">IndexType reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_type">AggregatorType reference</a></dt><dd><dl><dt>equals, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a>, <a class="indexterm" href="#sc_ref_agg_type">AggregatorType reference</a></dt><dt>FIFO, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a></dt><dt>match, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a>, <a class="indexterm" href="#sc_ref_agg_type">AggregatorType reference</a></dt></dl></dd><dt>initialization, <a class="indexterm" href="#sc_cpp_init">Initialization templates</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt><dt>initializeOrThrow, <a class="indexterm" href="#sc_cpp_tabtype">TableType reference</a></dt><dt>installation, <a class="indexterm" href="#sc_build_install_perl">Installation of the Perl library</a>, <a class="indexterm" href="#sc_build_install_cpp">Installation of the C++ library</a></dt><dt>Int32Type, <a class="indexterm" href="#sc_cpp_types_simple">Simple types reference</a></dt><dt>Int64Type, <a class="indexterm" href="#sc_cpp_types_simple">Simple types reference</a></dt><dt>ISIN, <a class="indexterm" href="#sc_strf_translation">Table-based translation with streaming functions</a></dt></dl></div><div class="indexdiv"><h3>J</h3><dl><dt>join, <a class="indexterm" href="#sc_joins_variety">Joins variety</a></dt><dd><dl><dt>equi-join, <a class="indexterm" href="#sc_joins_variety">Joins variety</a></dt><dt>filter, <a class="indexterm" href="#sc_joins_lookup_manual">The lookup join, done manually</a></dt><dt>full outer, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a>, <a class="indexterm" href="#sc_joins_jointwo_override">The override options in JoinTwo</a></dt><dt>implicit, <a class="indexterm" href="#sc_strf_translation">Table-based translation with streaming functions</a></dt><dt>inner, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a>, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a></dt><dt>input filtering, <a class="indexterm" href="#sc_joins_jointwo_inputfilter">JoinTwo input event filtering</a></dt><dt>key field duplication, <a class="indexterm" href="#sc_joins_lookupjoin_keys">The key fields of LookupJoin</a>, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a>, <a class="indexterm" href="#sc_joins_jointwo_keys">The key field duplication in JoinTwo</a></dt><dt>key field order, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a></dt><dt>key field types, <a class="indexterm" href="#sc_joins_lookupjoin_keys">The key fields of LookupJoin</a>, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a>, <a class="indexterm" href="#sc_joins_jointwo_override">The override options in JoinTwo</a></dt><dt>left outer, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a>, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a>, <a class="indexterm" href="#sc_joins_jointwo_override">The override options in JoinTwo</a></dt><dt>lookup, <a class="indexterm" href="#sc_joins_variety">Joins variety</a>, <a class="indexterm" href="#sc_joins_hello">Hello, joins!</a>, <a class="indexterm" href="#sc_joins_lookup_manual">The lookup join, done manually</a></dt><dt>manual, <a class="indexterm" href="#sc_joins_self_manual">Self-join done manually</a></dt><dt>manual iteration, <a class="indexterm" href="#sc_joins_lookupjoin_iter">Manual iteration with LookupJoin</a></dt><dt>manual lookup, <a class="indexterm" href="#sc_joins_lookup_manual">The lookup join, done manually</a></dt><dt>no primary key, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a></dt><dt>override, <a class="indexterm" href="#sc_joins_jointwo_override">The override options in JoinTwo</a></dt><dt>right outer, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a>, <a class="indexterm" href="#sc_joins_jointwo_override">The override options in JoinTwo</a></dt><dt>self, <a class="indexterm" href="#sc_joins_variety">Joins variety</a>, <a class="indexterm" href="#sc_joins_self_jointwo">Self-join done with JoinTwo</a>, <a class="indexterm" href="#sc_joins_self_manual">Self-join done manually</a>, <a class="indexterm" href="#sc_joins_self_lookupjoin">Self-join done with a LookupJoin</a></dt><dt>stream-to-window, <a class="indexterm" href="#sc_joins_variety">Joins variety</a></dt><dt>tables, <a class="indexterm" href="#sc_joins_variety">Joins variety</a>, <a class="indexterm" href="#sc_joins_hello">Hello, joins!</a>, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a></dt><dt>to-many, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a></dt><dt>with collapse, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a></dt></dl></dd><dt>JoinTwo, <a class="indexterm" href="#sc_joins_jointwo">JoinTwo joins two tables</a>, <a class="indexterm" href="#sc_joins_self_manual">Self-join done manually</a>, <a class="indexterm" href="#sc_joins_jointwo_glimpse">A glimpse inside JoinTwo and the hidden options of LookupJoin</a>, <a class="indexterm" href="#sc_strf_templates">Streaming functions and template results</a>, <a class="indexterm" href="#sc_ref_jointwo">JoinTwo reference</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt>label, <a class="indexterm" href="#sc_1950s">We're not in 1950s any more, or are we?</a>, <a class="indexterm" href="#sc_hello_world">Hello, world!</a>, <a class="indexterm" href="#sc_memory_fund">Memory management fundamentals</a>, <a class="indexterm" href="#sc_Labels">Labels basics</a>, <a class="indexterm" href="#sc_ref_cycles">Reference cycles</a>, <a class="indexterm" href="#sc_table_label">Tables and labels</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a>, <a class="indexterm" href="#sc_cpp_label">Label reference</a></dt><dd><dl><dt>adoption, <a class="indexterm" href="#sc_Rowop">Row operations</a>, <a class="indexterm" href="#sc_other_chunks_del">Large deletes in small chunks</a></dt><dt>chaining, <a class="indexterm" href="#sc_Labels">Labels basics</a>, <a class="indexterm" href="#sc_Label_construction">Label construction</a>, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a>, <a class="indexterm" href="#sc_memory_labels">Clearing of the labels</a>, <a class="indexterm" href="#sc_other_chunks_del">Large deletes in small chunks</a></dt><dt>clearing, <a class="indexterm" href="#sc_Label_construction">Label construction</a>, <a class="indexterm" href="#sc_sched_unit_basics">Execution unit basics</a>, <a class="indexterm" href="#sc_memory_labels">Clearing of the labels</a>, <a class="indexterm" href="#sc_clearing_labels">The clearing labels</a></dt><dt>dummy, <a class="indexterm" href="#sc_Label_construction">Label construction</a></dt><dt>Perl, <a class="indexterm" href="#sc_Label_construction">Label construction</a>, <a class="indexterm" href="#sc_memory_labels">Clearing of the labels</a></dt><dt>table, <a class="indexterm" href="#sc_table_label">Tables and labels</a></dt></dl></dd><dt>LookupJoin, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a>, <a class="indexterm" href="#sc_joins_lookupjoin_iter">Manual iteration with LookupJoin</a>, <a class="indexterm" href="#sc_joins_self_lookupjoin">Self-join done with a LookupJoin</a>, <a class="indexterm" href="#sc_strf_templates">Streaming functions and template results</a>, <a class="indexterm" href="#sc_ref_lookupjoin">LookupJoin reference</a></dt><dd><dl><dt>code generation, <a class="indexterm" href="#sc_joins_lookupjoin_inside">A peek inside LookupJoin</a></dt><dt>keys, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a>, <a class="indexterm" href="#sc_joins_lookupjoin_keys">The key fields of LookupJoin</a></dt></dl></dd><dt>loop</dt><dd><dl><dt>main, <a class="indexterm" href="#sc_sched_mainloop">The main loop</a>, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a>, <a class="indexterm" href="#sc_tql_intro">Introduction to TQL</a></dt><dt>scheduling, <a class="indexterm" href="#sc_sched_topo_loops">Topological loops</a>, <a class="indexterm" href="#sc_sched_loop">The gritty details of Triceps loop scheduling</a>, <a class="indexterm" href="#sc_table_label">Tables and labels</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a></dt><dt>streaming function, <a class="indexterm" href="#sc_strf_loops">Streaming functions and loops</a></dt><dt>topological, <a class="indexterm" href="#sc_sched_topo_loops">Topological loops</a>, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a>, <a class="indexterm" href="#sc_sched_loop">The gritty details of Triceps loop scheduling</a>, <a class="indexterm" href="#sc_sched_recursion">Recursion control</a>, <a class="indexterm" href="#sc_strf_loops">Streaming functions and loops</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>macro, <a class="indexterm" href="#sc_strf_intro">Introduction to streaming functions</a></dt><dt>main loop, <a class="indexterm" href="#sc_sched_mainloop">The main loop</a>, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a>, <a class="indexterm" href="#sc_mt_main_timeouts">Thread main loop and timeouts in the guts of ThreadedClient</a>, <a class="indexterm" href="#sc_tql_intro">Introduction to TQL</a></dt><dt>materialized view, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a></dt><dt>memory management, <a class="indexterm" href="#sc_memory_fund">Memory management fundamentals</a>, <a class="indexterm" href="#sc_sched_unit_basics">Execution unit basics</a>, <a class="indexterm" href="#sc_ref_cycles">Reference cycles</a>, <a class="indexterm" href="#sc_aggregation_additive">Additive aggregation</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a>, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a>, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a></dt><dt>model, <a class="indexterm" href="#sc_preface_concepts">Some concepts</a>, <a class="indexterm" href="#sc_what_is_cep">What is the CEP?</a>, <a class="indexterm" href="#sc_sched_intro">Introduction to the scheduling</a>, <a class="indexterm" href="#sc_ref_cycles">Reference cycles</a></dt><dt>Mtarget, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a></dt><dt>multithreading, <a class="indexterm" href="#sc_mt_concepts">Triceps multithreading concepts</a>, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a>, <a class="indexterm" href="#sc_mt_files">Threads and file descriptors</a>, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a>, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a>, <a class="indexterm" href="#sc_cpp_perl">Perl wrapping for the C++ objects</a></dt></dl></div><div class="indexdiv"><h3>N</h3><dl><dt>NameSet, <a class="indexterm" href="#sc_cpp_nameset">NameSet reference</a>, <a class="indexterm" href="#sc_cpp_sortidx">SortedIndexType reference</a></dt><dt>nestfess, <a class="indexterm" href="#sc_ref_toplevel">Top-level functions reference</a></dt><dt>Nexus, <a class="indexterm" href="#sc_mt_concepts">Triceps multithreading concepts</a>, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a>, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a>, <a class="indexterm" href="#sc_ref_triead_owner_general">TrieadOwner general methods</a>, <a class="indexterm" href="#sc_ref_nexus">Nexus reference</a>, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a>, <a class="indexterm" href="#sc_cpp_tabtype">TableType reference</a>, <a class="indexterm" href="#sc_cpp_nexus">Nexus reference</a></dt><dd><dl><dt>reverse, <a class="indexterm" href="#sc_mt_concepts">Triceps multithreading concepts</a>, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a></dt></dl></dd><dt>NOINDENT, <a class="indexterm" href="#sc_cpp_string">String utilities</a>, <a class="indexterm" href="#sc_cpp_errors">Error reporting and Errors reference</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt><dt>now, <a class="indexterm" href="#sc_mt_main_timeouts">Thread main loop and timeouts in the guts of ThreadedClient</a>, <a class="indexterm" href="#sc_ref_toplevel">Top-level functions reference</a>, <a class="indexterm" href="#sc_ref_app_start_timeout">App start timeout</a>, <a class="indexterm" href="#sc_ref_triead_owner_general">TrieadOwner general methods</a></dt><dt>NSPR, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a></dt><dt>numalign, <a class="indexterm" href="#sc_template_codegen">Code generation in the templates</a>, <a class="indexterm" href="#sc_ref_code">Code helpers reference</a></dt></dl></div><div class="indexdiv"><h3>O</h3><dl><dt>Onceref, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a></dt><dt>opcode, <a class="indexterm" href="#sc_hello_world">Hello, world!</a>, <a class="indexterm" href="#sc_opcodes">Opcodes</a>, <a class="indexterm" href="#sc_cpp_table_dump">Data dump</a></dt><dt>Opcode, <a class="indexterm" href="#sc_cpp_rowop">Rowop reference</a></dt><dt>operation code, <a class="indexterm" href="#sc_hello_world">Hello, world!</a></dt><dt>Opt, <a class="indexterm" href="#sc_ref_opt">Opt reference</a></dt><dt>override, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>partitioning, <a class="indexterm" href="#sc_mt_main_reorder">The threaded dreaded diamond and data reordering</a></dt><dt>performance, <a class="indexterm" href="#ch_perf">Performance</a></dt><dt>PerlTrieadJoin, <a class="indexterm" href="#sc_cpp_triead_join">TrieadJoin reference</a></dt><dt>persistence, <a class="indexterm" href="#sc_time_issues">The general issues of time processing</a></dt><dt>pipeline, <a class="indexterm" href="#sc_strf_pipelines">Streaming functions and pipelines</a>, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a></dt><dt>print, <a class="indexterm" href="#sc_objprint">Printing the object contents</a>, <a class="indexterm" href="#sc_Rows">Rows</a></dt><dt>printP, <a class="indexterm" href="#sc_objprint">Printing the object contents</a></dt><dt>projection, <a class="indexterm" href="#sc_template_result">Result projection in the templates</a>, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a></dt><dt>protocol, <a class="indexterm" href="#sc_sched_tray">Trays</a></dt></dl></div><div class="indexdiv"><h3>Q</h3><dl><dt>queue, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a></dt></dl></div><div class="indexdiv"><h3>R</h3><dl><dt>recursion, <a class="indexterm" href="#sc_sched_loop">The gritty details of Triceps loop scheduling</a>, <a class="indexterm" href="#sc_sched_recursion">Recursion control</a>, <a class="indexterm" href="#sc_table_label">Tables and labels</a>, <a class="indexterm" href="#sc_strf_keyed_collapse">Collapse with grouping by key with streaming functions</a>, <a class="indexterm" href="#sc_strf_recursion">Streaming functions and recursion</a>, <a class="indexterm" href="#sc_strf_more_recursion">Streaming functions and more recursion</a></dt><dt>reentrance, <a class="indexterm" href="#sc_sched_recursion">Recursion control</a></dt><dt>regular expression, <a class="indexterm" href="#sc_template_result">Result projection in the templates</a></dt><dt>reordering, <a class="indexterm" href="#sc_mt_main_reorder">The threaded dreaded diamond and data reordering</a></dt><dt>restart, <a class="indexterm" href="#sc_time_issues">The general issues of time processing</a></dt><dt>result filtering, <a class="indexterm" href="#sc_template_result">Result projection in the templates</a>, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a></dt><dt>revocation, <a class="indexterm" href="#sc_mt_files">Threads and file descriptors</a></dt><dt>Rhref, <a class="indexterm" href="#sc_cpp_table">Table reference</a>, <a class="indexterm" href="#sc_cpp_rowhandle">RowHandle and Rhref reference</a></dt><dt>RIC, <a class="indexterm" href="#sc_strf_translation">Table-based translation with streaming functions</a></dt><dt>Row, <a class="indexterm" href="#sc_Rows">Rows</a>, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a></dt><dd><dl><dt>override, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a></dt><dt>re-typing, <a class="indexterm" href="#sc_RowTypesEquiv">Row types equivalence</a></dt></dl></dd><dt>row operation, <a class="indexterm" href="#sc_hello_world">Hello, world!</a>, <a class="indexterm" href="#sc_Rowop">Row operations</a>, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a></dt><dt>row type, <a class="indexterm" href="#sc_hello_world">Hello, world!</a></dt><dt>RowHandle, <a class="indexterm" href="#sc_table_hello">Hello, tables!</a>, <a class="indexterm" href="#sc_table_RowHandle">A closer look at the RowHandles</a>, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a>, <a class="indexterm" href="#sc_table_indextree">The index tree</a>, <a class="indexterm" href="#sc_ref_rowhandle">RowHandle reference</a>, <a class="indexterm" href="#sc_cpp_sortidx">SortedIndexType reference</a>, <a class="indexterm" href="#sc_cpp_table">Table reference</a>, <a class="indexterm" href="#sc_cpp_rowhandle">RowHandle and Rhref reference</a></dt><dt>RowHandleType, <a class="indexterm" href="#sc_cpp_tabtype">TableType reference</a>, <a class="indexterm" href="#sc_cpp_table">Table reference</a></dt><dt>Rowop, <a class="indexterm" href="#sc_hello_world">Hello, world!</a>, <a class="indexterm" href="#sc_Rowop">Row operations</a>, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a>, <a class="indexterm" href="#sc_cpp_rowop">Rowop reference</a></dt><dt>Rowref, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a>, <a class="indexterm" href="#sc_cpp_rowhandle">RowHandle and Rhref reference</a></dt><dt>RowSetType, <a class="indexterm" href="#sc_cpp_rowset">RowSetType reference</a></dt><dt>RowType, <a class="indexterm" href="#sc_RowTypes">Row types</a>, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a>, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a>, <a class="indexterm" href="#sc_cpp_rowtype">RowType reference</a>, <a class="indexterm" href="#sc_cpp_row">Row and Rowref reference</a>, <a class="indexterm" href="#sc_cpp_sortidx">SortedIndexType reference</a>, <a class="indexterm" href="#sc_cpp_table">Table reference</a></dt><dd><dl><dt>equals, <a class="indexterm" href="#sc_RowTypesEquiv">Row types equivalence</a></dt><dt>match, <a class="indexterm" href="#sc_RowTypesEquiv">Row types equivalence</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>schedule, <a class="indexterm" href="#sc_sched_mainloop">The main loop</a>, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a></dt><dt>scheduling, <a class="indexterm" href="#sc_sched_intro">Introduction to the scheduling</a>, <a class="indexterm" href="#sc_other_diamond">The dreaded diamond</a></dt><dd><dl><dt>loop, <a class="indexterm" href="#sc_sched_topo_loops">Topological loops</a>, <a class="indexterm" href="#sc_sched_loop">The gritty details of Triceps loop scheduling</a>, <a class="indexterm" href="#sc_table_label">Tables and labels</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a></dt><dt>recursion, <a class="indexterm" href="#sc_sched_loop">The gritty details of Triceps loop scheduling</a>, <a class="indexterm" href="#sc_table_label">Tables and labels</a></dt><dt>streaming function, <a class="indexterm" href="#sc_strf_scheduling">The gritty details of streaming functions scheduling</a></dt></dl></dd><dt>ScopeFnBind, <a class="indexterm" href="#sc_cpp_autofn">ScopeFnBind and AutoFnBind reference</a></dt><dt>sequence number, <a class="indexterm" href="#sc_cpp_sortidx">SortedIndexType reference</a></dt><dt>shutdown, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a></dt><dt>SIGUSR2, <a class="indexterm" href="#sc_mt_files">Threads and file descriptors</a>, <a class="indexterm" href="#sc_cpp_sigusr2">Sigusr2 reference</a></dt><dt>SimpleAggregator, <a class="indexterm" href="#sc_aggregation_vwap">The ubiquitous VWAP</a>, <a class="indexterm" href="#sc_aggregation_simple">SimpleAggregator</a>, <a class="indexterm" href="#sc_aggregation_simple_guts">The guts of SimpleAggregator</a>, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a>, <a class="indexterm" href="#sc_ref_simple_agg">SimpleAggregator reference</a></dt><dt>SimpleOrderedIndex, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a></dt><dt>SimpleServer, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a></dt><dt>SimpleType, <a class="indexterm" href="#sc_cpp_types">Types reference</a>, <a class="indexterm" href="#sc_cpp_types_simple">Simple types reference</a>, <a class="indexterm" href="#sc_cpp_rowtype">RowType reference</a></dt><dt>socket, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a>, <a class="indexterm" href="#sc_mt_files">Threads and file descriptors</a>, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a>, <a class="indexterm" href="#sc_mt_threaded_server">ThreadedServer implementation, and the details of thread harvesting</a></dt><dt>SortedIndexCondition, <a class="indexterm" href="#sc_cpp_sortidx">SortedIndexType reference</a></dt><dt>SortedIndexType, <a class="indexterm" href="#sc_cpp_sortidx">SortedIndexType reference</a>, <a class="indexterm" href="#sc_cpp_aggregator_type">AggregatorType reference</a></dt><dt>SPLASH, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a></dt><dt>spreadsheet, <a class="indexterm" href="#sc_what_is_cep">What is the CEP?</a></dt><dt>SQL, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a>, <a class="indexterm" href="#sc_1950s">We're not in 1950s any more, or are we?</a>, <a class="indexterm" href="#sc_aggregation_proper">Introducing the proper aggregation</a>, <a class="indexterm" href="#sc_aggregation_additive">Additive aggregation</a>, <a class="indexterm" href="#sc_aggregation_simple">SimpleAggregator</a>, <a class="indexterm" href="#sc_joins_hello">Hello, joins!</a></dt><dt>stack, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a></dt><dd><dl><dt>unwinding, <a class="indexterm" href="#sc_sched_unwind">Error handling during the execution</a></dt></dl></dd><dt>stack trace, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a></dt><dt>Starget, <a class="indexterm" href="#sc_cpp_mem">Memory management in the C++ API and the Autoref reference</a></dt><dt>sticky error, <a class="indexterm" href="#sc_table_sorted">Sorted index</a>, <a class="indexterm" href="#sc_ref_table">Table reference</a>, <a class="indexterm" href="#sc_cpp_sortidx">SortedIndexType reference</a>, <a class="indexterm" href="#sc_cpp_table_sticky">Sticky errors</a></dt><dt>StreamBase, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a>, <a class="indexterm" href="#sc_sched_compar">Comparative scheduling in the various CEP systems</a>, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a>, <a class="indexterm" href="#sc_template_intro">Comparative modularity</a>, <a class="indexterm" href="#sc_joins_jointwo_override">The override options in JoinTwo</a>, <a class="indexterm" href="#sc_time_issues">The general issues of time processing</a>, <a class="indexterm" href="#sc_strf_intro">Introduction to streaming functions</a>, <a class="indexterm" href="#sc_strf_units">Streaming functions and unit boundaries</a></dt><dt>streaming function, <a class="indexterm" href="#sc_sched_tray">Trays</a>, <a class="indexterm" href="#sc_sched_recursion">Recursion control</a>, <a class="indexterm" href="#sc_strf_intro">Introduction to streaming functions</a>, <a class="indexterm" href="#sc_strf_collapse">Streaming functions by example, another version of Collapse</a>, <a class="indexterm" href="#sc_strf_keyed_collapse">Collapse with grouping by key with streaming functions</a>, <a class="indexterm" href="#sc_strf_translation">Table-based translation with streaming functions</a>, <a class="indexterm" href="#sc_strf_loops">Streaming functions and loops</a>, <a class="indexterm" href="#sc_strf_pipelines">Streaming functions and pipelines</a>, <a class="indexterm" href="#sc_strf_tables">Streaming functions and tables</a>, <a class="indexterm" href="#sc_strf_templates">Streaming functions and template results</a>, <a class="indexterm" href="#sc_strf_recursion">Streaming functions and recursion</a>, <a class="indexterm" href="#sc_strf_more_recursion">Streaming functions and more recursion</a>, <a class="indexterm" href="#sc_strf_units">Streaming functions and unit boundaries</a>, <a class="indexterm" href="#sc_strf_call">The ways to call a streaming function</a>, <a class="indexterm" href="#sc_strf_scheduling">The gritty details of streaming functions scheduling</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a></dt><dt>StringType, <a class="indexterm" href="#sc_cpp_types_simple">Simple types reference</a></dt><dt>strprintf, <a class="indexterm" href="#sc_cpp_string">String utilities</a></dt><dt>SWIG, <a class="indexterm" href="#sc_api_lang">Languages and layers</a></dt><dt>Sybase, <a class="indexterm" href="#sc_uses_of_cep">The uses of CEP</a>, <a class="indexterm" href="#sc_landscape">Surveying the CEP langscape</a>, <a class="indexterm" href="#sc_sched_compar">Comparative scheduling in the various CEP systems</a>, <a class="indexterm" href="#sc_sched_tray">Trays</a>, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a>, <a class="indexterm" href="#sc_template_intro">Comparative modularity</a>, <a class="indexterm" href="#sc_strf_intro">Introduction to streaming functions</a>, <a class="indexterm" href="#sc_strf_units">Streaming functions and unit boundaries</a></dt></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>table, <a class="indexterm" href="#sc_sched_recursion">Recursion control</a>, <a class="indexterm" href="#sc_table_hello">Hello, tables!</a></dt><dd><dl><dt>dump, <a class="indexterm" href="#sc_strf_tables">Streaming functions and tables</a></dt><dt>execution order, <a class="indexterm" href="#sc_aggregation_args">Computation function arguments</a></dt><dt>find, <a class="indexterm" href="#sc_table_hello">Hello, tables!</a>, <a class="indexterm" href="#sc_table_RowHandle">A closer look at the RowHandles</a>, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a>, <a class="indexterm" href="#sc_table_secondary">Secondary indexes</a>, <a class="indexterm" href="#sc_table_indextree">The index tree</a></dt><dt>FnReturn, <a class="indexterm" href="#sc_strf_tables">Streaming functions and tables</a></dt><dt>insert, <a class="indexterm" href="#sc_table_hello">Hello, tables!</a>, <a class="indexterm" href="#sc_table_RowHandle">A closer look at the RowHandles</a>, <a class="indexterm" href="#sc_table_indextree">The index tree</a></dt><dt>iteration, <a class="indexterm" href="#sc_table_iteration">Basic iteration through the table</a>, <a class="indexterm" href="#sc_table_delete">Deleting a row</a>, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a>, <a class="indexterm" href="#sc_table_indextree">The index tree</a></dt><dt>label API, <a class="indexterm" href="#sc_table_label">Tables and labels</a></dt><dt>procedural API, <a class="indexterm" href="#sc_table_hello">Hello, tables!</a>, <a class="indexterm" href="#sc_table_delete">Deleting a row</a></dt><dt>remove row, <a class="indexterm" href="#sc_table_delete">Deleting a row</a>, <a class="indexterm" href="#sc_aggregation_window">Tricks with aggregation on a sliding window</a>, <a class="indexterm" href="#sc_other_chunks_del">Large deletes in small chunks</a></dt><dt>replacement, <a class="indexterm" href="#sc_table_hello">Hello, tables!</a>, <a class="indexterm" href="#sc_table_label">Tables and labels</a>, <a class="indexterm" href="#sc_table_RowHandle">A closer look at the RowHandles</a>, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a>, <a class="indexterm" href="#sc_table_indextree">The index tree</a></dt></dl></dd><dt>Table, <a class="indexterm" href="#sc_ref_table">Table reference</a>, <a class="indexterm" href="#sc_cpp_sortidx">SortedIndexType reference</a>, <a class="indexterm" href="#sc_cpp_table">Table reference</a>, <a class="indexterm" href="#sc_cpp_rowhandle">RowHandle and Rhref reference</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a></dt><dt>TableType, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a>, <a class="indexterm" href="#sc_ref_table_type">TableType reference</a>, <a class="indexterm" href="#sc_cpp_copy">The many ways to do a copy</a>, <a class="indexterm" href="#sc_cpp_tabtype">TableType reference</a>, <a class="indexterm" href="#sc_cpp_table">Table reference</a></dt><dd><dl><dt>equals, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a></dt><dt>match, <a class="indexterm" href="#sc_table_idx_intro">Table and index type introspection</a></dt></dl></dd><dt>template, <a class="indexterm" href="#sc_table_ordered">Ordered index</a>, <a class="indexterm" href="#sc_template_intro">Comparative modularity</a>, <a class="indexterm" href="#sc_aggregation_simple_guts">The guts of SimpleAggregator</a>, <a class="indexterm" href="#sc_joins_lookupjoin">The LookupJoin template</a>, <a class="indexterm" href="#sc_joins_jointwo_glimpse">A glimpse inside JoinTwo and the hidden options of LookupJoin</a>, <a class="indexterm" href="#sc_strf_intro">Introduction to streaming functions</a>, <a class="indexterm" href="#sc_strf_templates">Streaming functions and template results</a></dt><dd><dl><dt>error reporting, <a class="indexterm" href="#sc_template_wrapfess">Error reporting in the templates</a></dt></dl></dd><dt>TestFeed, <a class="indexterm" href="#sc_perl_libex">The Perl libraries and examples</a>, <a class="indexterm" href="#sc_sched_mainloop_socket">Main loop with a socket</a></dt><dt>ThreadedClient, <a class="indexterm" href="#sc_mt_threaded_client">ThreadedClient, a Triceps Expect</a>, <a class="indexterm" href="#sc_mt_main_timeouts">Thread main loop and timeouts in the guts of ThreadedClient</a></dt><dt>ThreadedServer, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a>, <a class="indexterm" href="#sc_mt_threaded_server">ThreadedServer implementation, and the details of thread harvesting</a></dt><dt>time, <a class="indexterm" href="#sc_SimpleTypes">Simple types</a>, <a class="indexterm" href="#sc_time_limited">Time-limited propagation</a>, <a class="indexterm" href="#sc_time_periodic">Periodic updates</a>, <a class="indexterm" href="#sc_time_issues">The general issues of time processing</a>, <a class="indexterm" href="#sc_mt_main_timeouts">Thread main loop and timeouts in the guts of ThreadedClient</a></dt><dt>time synchronization, <a class="indexterm" href="#sc_time_limited">Time-limited propagation</a></dt><dt>timeout, <a class="indexterm" href="#sc_mt_main_timeouts">Thread main loop and timeouts in the guts of ThreadedClient</a></dt><dt>topological loop, <a class="indexterm" href="#sc_sched_topo_loops">Topological loops</a>, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a>, <a class="indexterm" href="#sc_sched_loop">The gritty details of Triceps loop scheduling</a>, <a class="indexterm" href="#sc_sched_recursion">Recursion control</a>, <a class="indexterm" href="#sc_strf_loops">Streaming functions and loops</a></dt><dt>TQL, <a class="indexterm" href="#sc_strf_units">Streaming functions and unit boundaries</a>, <a class="indexterm" href="#sc_tql_intro">Introduction to TQL</a></dt><dd><dl><dt>multi-threaded, <a class="indexterm" href="#sc_tql_multi">TQL in a multi-threaded server</a></dt><dt>single-threaded, <a class="indexterm" href="#sc_tql_single">TQL in a single-threaded server</a></dt></dl></dd><dt>Tql, <a class="indexterm" href="#sc_ref_braced">Braced reference</a></dt><dt>tracing, <a class="indexterm" href="#sc_sched_tracing">Tracing the execution</a>, <a class="indexterm" href="#sc_table_label">Tables and labels</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a>, <a class="indexterm" href="#sc_cpp_unit_tracer">Unit Tracer reference</a></dt><dt>TrackedFile, <a class="indexterm" href="#sc_mt_files">Threads and file descriptors</a>, <a class="indexterm" href="#sc_ref_triead_owner_tracked_file">TrackedFile</a></dt><dt>traffic accounting, <a class="indexterm" href="#sc_time_limited">Time-limited propagation</a></dt><dt>tray, <a class="indexterm" href="#sc_sched_unit_basics">Execution unit basics</a>, <a class="indexterm" href="#sc_sched_tray">Trays</a>, <a class="indexterm" href="#sc_sched_no_bundling">No bundling</a>, <a class="indexterm" href="#sc_table_copy_tray">The copy tray</a>, <a class="indexterm" href="#sc_strf_loops">Streaming functions and loops</a>, <a class="indexterm" href="#sc_mt_main_reorder">The threaded dreaded diamond and data reordering</a>, <a class="indexterm" href="#sc_cpp_tray">Tray reference</a></dt><dt>Triead, <a class="indexterm" href="#sc_mt_concepts">Triceps multithreading concepts</a>, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a>, <a class="indexterm" href="#sc_ref_triead">Triead reference</a>, <a class="indexterm" href="#sc_ref_triead_owner">TrieadOwner reference</a>, <a class="indexterm" href="#sc_cpp_app">App reference</a>, <a class="indexterm" href="#sc_cpp_triead">Triead reference</a></dt><dd><dl><dt>stages, <a class="indexterm" href="#sc_mt_triead_life">The Triead lifecycle</a>, <a class="indexterm" href="#sc_mt_dynamic_server">Dynamic threads and fragments in a socket server</a></dt></dl></dd><dt>TrieadJoin, <a class="indexterm" href="#sc_cpp_app">App reference</a>, <a class="indexterm" href="#sc_cpp_triead_owner">TrieadOwner reference</a>, <a class="indexterm" href="#sc_cpp_triead_join">TrieadJoin reference</a>, <a class="indexterm" href="#sc_cpp_file_interrupt">FileInterrupt reference</a></dt><dt>TrieadOwner, <a class="indexterm" href="#sc_mt_concepts">Triceps multithreading concepts</a>, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a>, <a class="indexterm" href="#sc_ref_triead_owner">TrieadOwner reference</a>, <a class="indexterm" href="#sc_cpp_triead_owner">TrieadOwner reference</a></dt><dt>trigger, <a class="indexterm" href="#sc_what_is_cep">What is the CEP?</a></dt><dt>type, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt><dd><dl><dt>array, <a class="indexterm" href="#sc_RowTypes">Row types</a></dt><dt>equals, <a class="indexterm" href="#sc_RowTypesEquiv">Row types equivalence</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt><dt>index, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a></dt><dt>match, <a class="indexterm" href="#sc_RowTypesEquiv">Row types equivalence</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt><dt>row, <a class="indexterm" href="#sc_RowTypes">Row types</a></dt><dt>simple, <a class="indexterm" href="#sc_SimpleTypes">Simple types</a></dt><dt>table, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a></dt></dl></dd><dt>Type, <a class="indexterm" href="#sc_cpp_string">String utilities</a>, <a class="indexterm" href="#sc_cpp_types">Types reference</a>, <a class="indexterm" href="#sc_cpp_rowtype">RowType reference</a></dt><dd><dl><dt>all types, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt></dl></dd><dt>TypeId, <a class="indexterm" href="#sc_cpp_types">Types reference</a></dt></dl></div><div class="indexdiv"><h3>U</h3><dl><dt>Uint8Type, <a class="indexterm" href="#sc_cpp_types_simple">Simple types reference</a></dt><dt>unit, <a class="indexterm" href="#sc_hello_world">Hello, world!</a>, <a class="indexterm" href="#sc_sched_unit_basics">Execution unit basics</a>, <a class="indexterm" href="#sc_sched_tracing">Tracing the execution</a>, <a class="indexterm" href="#sc_sched_detail">The gritty details of Triceps scheduling</a>, <a class="indexterm" href="#sc_strf_units">Streaming functions and unit boundaries</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a></dt><dt>Unit, <a class="indexterm" href="#sc_ref_cycles">Reference cycles</a>, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a>, <a class="indexterm" href="#sc_ref_fnbinding">FnBinding reference</a>, <a class="indexterm" href="#sc_cpp_gadget">Gadget reference</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a>, <a class="indexterm" href="#sc_cpp_unit_tracer">Unit Tracer reference</a></dt><dt>UnitClearingTrigger, <a class="indexterm" href="#sc_ref_cycles">Reference cycles</a>, <a class="indexterm" href="#sc_mt_pipeline">Multithreaded pipeline</a>, <a class="indexterm" href="#sc_ref_unit">Unit and FrameMark reference</a>, <a class="indexterm" href="#sc_cpp_unit">Unit reference</a></dt></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>VoidType, <a class="indexterm" href="#sc_cpp_types_simple">Simple types reference</a></dt><dt>vstrprintf, <a class="indexterm" href="#sc_cpp_string">String utilities</a></dt><dt>VWAP, <a class="indexterm" href="#sc_aggregation_vwap">The ubiquitous VWAP</a></dt></dl></div><div class="indexdiv"><h3>W</h3><dl><dt>window, <a class="indexterm" href="#sc_table_fifo">A window is a FIFO</a></dt><dt>wrapfess, <a class="indexterm" href="#sc_template_wrapfess">Error reporting in the templates</a>, <a class="indexterm" href="#sc_ref_toplevel">Top-level functions reference</a></dt><dt>wrapper, <a class="indexterm" href="#sc_memory_fund">Memory management fundamentals</a>, <a class="indexterm" href="#sc_cpp_perl">Perl wrapping for the C++ objects</a></dt></dl></div><div class="indexdiv"><h3>X</h3><dl><dt>X package, <a class="indexterm" href="#sc_perl_libex">The Perl libraries and examples</a></dt><dt>XS, <a class="indexterm" href="#sc_api_lang">Languages and layers</a>, <a class="indexterm" href="#sc_code">Code references and snippets</a>, <a class="indexterm" href="#sc_RowTypesEquiv">Row types equivalence</a>, <a class="indexterm" href="#sc_sched_unwind">Error handling during the execution</a>, <a class="indexterm" href="#sc_mt_objects">Object passing between threads</a>, <a class="indexterm" href="#sc_cpp_perl">Perl wrapping for the C++ objects</a>, <a class="indexterm" href="#sc_cpp_exception">Exception reference</a></dt><dt>Xtray, <a class="indexterm" href="#sc_mt_main_timeouts">Thread main loop and timeouts in the guts of ThreadedClient</a>, <a class="indexterm" href="#sc_ref_triead_owner_general">TrieadOwner general methods</a>, <a class="indexterm" href="#sc_ref_facet">Facet reference</a></dt></dl></div></div></div><div class="colophon"><h2 class="title"><a name="id416227"></a></h2><h2><a name="id416234"></a>Colophon</h2><p>
		This manual has been typeset using the Docbook tools.
		</p></div></div></body></html>
