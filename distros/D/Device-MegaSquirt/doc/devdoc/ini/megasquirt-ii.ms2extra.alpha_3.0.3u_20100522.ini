;-------------------------------------------------------------------------------
; $Id: megasquirt-ii.ms2extra.ini,v 1.15 2010/03/28 17:02:09 racingmini Exp $

; configuration defines
;Normally these next lines should be UNset
;Use TunerStudio to fetch and view tooth/trigger logs

;This enables the "full" CAN/serial commands so this INI can be used anywhere on the CAN network.
#unset CAN_COMMANDS

#unset EXPANDED_CLT_TEMP   ; change this line to SET if you want to use the extended range

#unset EGTFULL ; Defaults to 0-1000 degC change to set to use 0-1250 if you made the alternate circuit

#unset INI_VERSION_2 ; this is set by TunerStudio, but needs to be unset for Megatune to work

#unset MICROSQUIRT_FULL
#unset MICROSQUIRT_MODULE
#unset USE_CRC_DATA_CHECK

#if INI_VERSION_2
; ok
#else
#error Megatune cannot be used with MS2/Extra 3.0.x - please upgrade to TunerStudio
#endif

[MegaTune]
   MTversion      = 2.25 ; MegaTune itself; needs to match exec version.

#if CAN_COMMANDS
   versionInfo    = "r\x00\x0e\x00\x00\x00\x3c"  ; Title bar
   queryCommand   = "r\x00\x0f\x00\x00\x00\x14"  ; Verify against signature.
#else
   versionInfo    = "S"  ; Put this in the title bar.
   queryCommand   = "Q"  ; Verify against signature.
#endif
   signature      = "MS2Extra Rel 3.0.3s" ; MS-II sends a null at 20th byte.
                   ; 123456789.123456789.

;----------------------------------------------------------------------------
; Temperature Limits and Settings Reference
; contributed by Mike Soultanian
;----------------------------------------------------------------------------
;
; Below is a listing of all of the temperature ranges used throughout the INI
; for the MegaSquirt II.
;
; CELSIUS (Expanded/Normal):
;     Low limit: -40C/-40C
;     High limit: 230C/150C
;     Low danger: 65C/10C
;     Low warning: 93C/65C
;     High warning: 162C/93C
;     High danger: 176C/104C
;
; FAHRENHEIT (Expanded/Normal):
;     Low Limit: -40F/-40F
;     High limit: 450F/300F
;     Low danger: 150F/50F
;     Low warning: 200F/150F
;     High warning: 325F/200F
;     High danger: 350F/220F (also used for curve editor limits)
;----------------------------------------------------------------------------

[Constants]

   ;----------------------------------------------------------------------------
   ; Constants Definition
   ; --------------------
   ;
   ; Scalar Values
   ; -------------
   ; The scaling and translation values are used as follows:
   ;    msValue   = userValue / scale - translate
   ;    userValue = (msValue + translate) * scale
   ;
   ; I've got no good way to handle a few of these things yet.
   ;
   ; Temperatures are fine, check out the Fielding IAC example (fastIdleTemp).
   ;
   ; The TPS stuff is a problem, because we have to modify the ini file for
   ; each TPS installation and again whenever we move the TPS...  I figured
   ; out a moderately palatable solution to presenting the frequency
   ; divider in the boost control values, turn it into a bit field and then
   ; enumerate the resulting frequencies.
   ;
   ; Array Values
   ; ------------
   ; Arrays are specified just like scalars, except that they have a "shape"
   ; entry in the fourth parameter.  The shape allows you to define lists or
   ; tables, for example [8] defines a list with eight values and [2x4] defines
   ; a table with eight values (two rows and four columns).  Tables may be
   ; stored in either "X-" or "Y-order."  X-order means that memory is layed
   ; out like.
   ;
   ;     [x1,y1] [x2,y1]...[xn,y1] [x1,y2]...
   ;
   ; Y-order would be
   ;
   ;     [x1,y1] [x1,y2]...[x1,yn] [x2,y1]...
   ;
   ; To use the TableEditor, you must define two lists and a table, and
   ; the lengths of the lists must correspond to the shape of the table.
   ;
   ; Bit Fields
   ; ----------
   ; Bits are numbered 0-7, the rightmost being bit zero.  The basic
   ; data word that stores bit fields must be unsigned.
   ;
   ; You need NOT supply the correct number of labels matching the
   ; number of bits you've specified (one bit requires 2 values, two
   ; bits requires 4 values and so on).  If you neglect to supply enough
   ; labels, they will be synthesized using the sequence "1", "2" and so
   ; on based upon their position in the sequence (the cltType and matType
   ; will end up with identical lists).
   ;
   ;----------------------------------------------------------------------------

   pageActivationDelay = 50 ; Milliseconds delay after burn command.
   blockReadTimeout    = 100 ; Milliseconds total timeout for reading page.
   writeBlocks = 	off  ; from Lance
   interWriteDelay = 	5    ; 5 from Lance

; note page 6, 0xf0 = tooth logger
;      page 7, 0xf1 = trigger logger

   endianness          = big
   nPages              = 6
   pageSize            = 1024,                1024,                1024,                1024,                1024,                1024	
   pageIdentifier      = "\x00\x04",          "\x00\x05",          "\x00\x0a",          "\x00\x08",	         "\x00\x09",	      "\x00\x0b"
   burnCommand         = "b\x00\x04",         "b\x00\x05",         "b\x00\x0a",         "b\x00\x08",         "b\x00\x09",         "b\x00\x0b"
   pageReadCommand     = "r\x00\x04%2o%2c",   "r\x00\x05%2o%2c",   "r\x00\x0a%2o%2c",   "r\x00\x08%2o%2c",   "r\x00\x09%2o%2c",   "r\x00\x0b%2o%2c"
   pageValueWrite      = "w\x00\x04%2o%2c%v", "w\x00\x05%2o%2c%v", "w\x00\x0a%2o%2c%v", "w\x00\x08%2o%2c%v", "w\x00\x09%2o%2c%v", "w\x00\x0b%2o%2c%v"
#if CAN_COMMANDS
; ignore writing chunks
#else
   pageChunkWrite      = "w\x00\x04%2o%2c%v", "w\x00\x05%2o%2c%v", "w\x00\x0a%2o%2c%v", "w\x00\x08%2o%2c%v", "w\x00\x09%2o%2c%v", "w\x00\x0b%2o%2c%v"
#endif
#if USE_CRC_DATA_CHECK
   crc32CheckCommand   = "k\x00\x04\x00\x00\x00\x04",   "k\x00\x05\x00\x00\x00\x04",   "k\x00\x0a\x00\x00\x00\x04",   "k\x00\x08\x00\x00\x00\x04",   "k\x00\x09\x00\x00\x00\x04", "k\x00\x0b\x00\x00\x00\x04"
#endif

;trigger, tooth, composite loggers by special fetches on pages 0xf0, 0xf1, 0xf2, 0xf3

   page = 1
   ;  name            = class,  type, offset,      shape,  units,       scale, translate,    lo,      hi, digits
      nCylinders      = bits,    U08,      0,      [0:4], "INVALID","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID","INVALID"
      no_skip_pulses  = scalar,  U08,      1,             "",         1.00000,   0.00000,  1.00,  255.00,      0 ; * (  1 byte)
      ICIgnCapture    = bits,    U08,      2,      [0:0], "Falling Edge", "Rising Edge"                          ; *
      engineType      = bits,    U08,      2,      [3:3], "Even fire", "Odd fire"
      spkout_hi_lo    = bits,    U08,      2,      [4:4], "Going Low (Normal)", "Going High (Inverted)"          ; *
      injctl          = bits,    U08,      2,      [5:5], "Off","On"
; spare  spkout_hi_lo    = bits  ,  U08,      3,      [0:0], "Going Low (Normal)", "Going High (Inverted)"          ; *
      max_coil_dur    = scalar,  U08,      4,             "ms",       0.0666,   0.00000,  1.00,    8.00,      1 ; * (  1 byte)
      max_spk_dur     = scalar,  U08,      5,             "ms",       0.0666,   0.00000,  0.00,   25.50,      1 ; * (  1 byte)

      dwellAcc        = scalar,  U08,      6,             "ms",       0.0666,   0.00000,  0.00,   25.50,      0 ; * (  1 byte)
      dwellvolts      = array ,  U08,      7,    [    6], "V",        0.10000,   0.00000,6,   18,      1 ; * (  6 bytes)
      dwellcorr       = array ,  U08,     13,    [    6], "%",       2,   0.00000,20,   512,      0 ; * (  6 bytes)
      PredOpt         = bits  ,  U08,     19,      [0:1], "Last Interval", "1st Derivative", "1st High RPM, 2nd Low", "2nd Derivative" ; *
      crankingRPM     = scalar,  S16,     20,             "RPM",      1.00000,   0.00000,  0.00,  3000.0,      0 ; * (  2 bytes)
      cold_adv_table  = array ,  S16,     22,    [   10], "deg",      0.10000,   0.00000,-10.00,   10.00,      1 ; * ( 20 bytes)
      triggerOffset   = scalar,  S16,     42,             "deg",      0.10000,   0.00000, -90.0,  180.00,      2 ; * (  2 bytes)
      TpsBypassCLTRevlim = scalar, S16,   44,             "TPS %",    0.10000,   0.00000, 0,      100,         1 ; * (  2 bytes)
      RevLimRpm2      = scalar,  S16,     46,             "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * (  2 bytes)

#if LAMBDA
      afrTable1       = array ,  U08,     48,    [12x12], "Lambda",  0.006803,   0.00000,  0.00,    2.00,      3 ; * (144 bytes)
      afrTable2       = array ,  U08,    192,    [12x12], "Lambda",  0.006803,   0.00000,  0.00,    2.00,      3 ; * (144 bytes)
#else
      afrTable1       = array ,  U08,     48,    [12x12], "AFR",      0.10000,   0.00000,  9.00,   20.00,      1
      afrTable2       = array ,  U08,    192,    [12x12], "AFR",      0.10000,   0.00000,  9.00,   20.00,      1
#endif
      wueBins         = array ,  U08,    336,    [   10], "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * ( 10 bytes)
      taeBins         = array ,  U08,    346,    [    4], "ms",       0.10000,   0.00000,  0.00,   25.50,      1 ; * (  4 bytes)
      maeBins         = array ,  U08,    350,    [    4], "ms",       0.10000,   0.00000,  0.00,   25.50,      1 ; * (  4 bytes)

      iacstepTable    = array ,  S16,    354,    [   10], "steps",    1.00000,   0.00000,  0.00,  500.00,      0 ; * ( 20 bytes)

      arpm_table1     = array ,  U16,    374,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      arpm_table2     = array ,  U16,    398,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      amap_table1     = array ,  S16,    422,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      amap_table2     = array ,  S16,    446,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)

#if CELSIUS
	#if EXPANDED_CLT_TEMP
      tempTable       = array ,  S16,    470,    [   10], "°C",       0.05555,  -320.000,-40.00,  230.00,      1 ; * ( 20 bytes) Temperature bins for cranking, cold AE and WUE
	#else
      tempTable       = array ,  S16,    470,    [   10], "°C",       0.05555,  -320.000,-40.00,  150.00,      1 ; * ( 20 bytes) Temperature bins for cranking, cold AE and WUE
	#endif
  #else
	#if EXPANDED_CLT_TEMP
      tempTable       = array ,  S16,    470,    [   10], "°F",       0.10000,   0.00000,-40.00,  450.00,      1
	#else
      tempTable       = array ,  S16,    470,    [   10], "°F",       0.10000,   0.00000,-40.00,  300.00,      1
	#endif
  #endif
      taeRates        = array ,  S16,    490,    [    4], "%/s",      0.10000,   0.00000,  0.00, 2000.00,      1 ; * (  8 bytes) tpsDot bins used for AE: x for TAE interpolation
      maeRates        = array ,  S16,    498,    [    4], "kPa/s",    1.00000,   0.00000,  0.00, 32767.0,      0 ; * (  8 bytes) mapDot bins used for AE: x for MAE

      map0            = scalar,  S16,    506,             "%",      0.10000,   0.00000, -100.0, 3276.7,      1 ; * (  2 bytes)
      mapmax          = scalar,  S16,    508,             "%",      0.10000,   0.00000, -100.0, 3276.7,      1 ; * (  2 bytes)
#if CELSIUS
      clt0            = scalar,  S16,    510,             "°C",       0.05555,  -320.000, -100.0,  500.0,      1 ; * (  2 bytes)
      cltmult         = scalar,  S16,    512,             "%",        1.00000,   0.00000, -200.0,  200.0,      0 ; * (  2 bytes)
      mat0            = scalar,  S16,    514,             "°C",       0.05555,  -320.000, -100.0,  500.0,      1 ; * (  2 bytes)
#else
      clt0            = scalar,  S16,    510,             "°F",       0.10000,   0.00000, -100.0,  500.0,      1
      cltmult         = scalar,  S16,    512,             "%",        1.00000,   0.00000, -200.0,  200.0,      0
      mat0            = scalar,  S16,    514,             "°F",       0.10000,   0.00000, -100.0,  500.0,      1
#endif
      matmult         = scalar,  S16,    516,             "%",        1.00000,   0.00000, -200.0,  200.0,      0 ; * (  2 bytes)

      tpsMin          = scalar,  S16,    518,             "ADC",      1.00000,   0.00000,    0.0, 1023.0,      0 ; * (  2 bytes)
      tpsMax          = scalar,  S16,    520,             "ADC",      1.00000,   0.00000,    0.0, 1023.0,      0 ; * (  2 bytes)
      batt0           = scalar,  S16,    522,             "V",        0.10000,   0.00000,    0.0, 3276.7,      1 ;   (  2 bytes)
      battmax         = scalar,  S16,    524,             "V",        0.10000,   0.00000,-3276.8, 3276.7,      1 ;   (  2 bytes)
      ego0            = scalar,  S16,    526,             "afr",      0.10000,   0.00000,-3276.8, 3276.7,      1 ;   (  2 bytes)
      egomult         = scalar,  S16,    528,             "%",        1.00000,   0.00000, -200.0,  200.0,      0 ;   (  2 bytes)

      baro0           = scalar,  S16,    530,             "kPa",      0.10000,   0.00000,-3276.8, 3276.7,      1 ; * (  2 bytes)
      baromax         = scalar,  S16,    532,             "kPa",      0.10000,   0.00000,-3276.8, 3276.7,      1 ; * (  2 bytes)
      bcor0           = scalar,  S16,    534,             "%",        1.00000,   0.00000,-3276.8, 3276.7,      1 ; * (  2 bytes)
      bcormult        = scalar,  S16,    536,             "%",        1.00000,   0.00000, -200.0,  200.0,      0 ; * (  2 bytes)
;      knock0          = scalar,  S16,    538,             "V",        0.01000,   0.00000,    0.0,    5.0,      1 ; * (  2 bytes)
;      knockmax        = scalar,  S16,    540,             "V",        0.01000,   0.00000,    0.0,    5.0,      1 ; * (  2 bytes)
      Dtpred_Gain     = scalar,  S16,    542,             "%",        1.00000,   0.00000, -200.0,  200.0,      0 ; * (  2 bytes)
      crankTolerance  = scalar,  U08,    544,             "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      asTolerance     = scalar,  U08,    545,             "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      pulseTolerance  = scalar,  U08,    546,             "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
#if MICROSQUIRT_FULL
      IdleCtl         = bits  ,  U08,    547,      [0:3], "None", "On/Off valve", "INVALID", "INVALID", "PWM Warmup", "INVALID", "PWM Closed-loop", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID" ; *
#else
      IdleCtl         = bits  ,  U08,    547,      [0:3], "None", "On/Off valve", "IAC Stepper Moving Only", "IAC Stepper Always On", "PWM Warmup", "15-Minute IAC", "PWM Closed-loop", "IAC Closed-loop moving only", "IAC Closed-loop always-on", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID" ; *
#endif
      IACtstep        = scalar,  U08,    548,             "ms",       0.128,   0.00000,  0.00,   25.50,      1 ; * (  1 byte) changed to be 0.128 ticks
      IAC_tinitial_step      = scalar,  U08,    549,             "ms",  0.128,   0.00000,  0.00,   25.50,      1 ; * (  1 byte)
      IACminstep      = scalar,  U08,    550,             "steps",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      dwellduty       = scalar,  U08,    551,             "%",        0.39,      0.0,      0,     100,0
      IACStart        = scalar, S16,     552,             "",         1.00000, 0.00000, 0.00, 4000.00,    0
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      IdleHyst        = scalar,  S16,    554,             "°C",       0.05555,   0.00000, -40.0,  230.0,       1 ; * (  2 bytes)
	#else
      IdleHyst        = scalar,  S16,    554,             "°C",       0.05555,   0.00000, -40.0,  150.0,       1 ; * (  2 bytes)
	#endif
#else
	#if EXPANDED_CLT_TEMP
      IdleHyst        = scalar,  S16,    554,             "°F",       0.10000,   0.00000, -40.0,  450.0,       1
	#else
      IdleHyst        = scalar,  S16,    554,             "°F",       0.10000,   0.00000, -40.0,  300.0,       1
	#endif
#endif
      IACcrankxt      = scalar,  S16,    558,             "sec",      1.00000,   0.00000,  0.00,32767.00,      0 ; * (  2 bytes)
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      IACcoldtmp      = scalar,  S16,    560,             "°C",       0.05555,  -320.000, -40.0,  230.0,       1 ; * (  2 bytes)
	#else
      IACcoldtmp      = scalar,  S16,    560,             "°C",       0.05555,  -320.000, -40.0,  150.0,       1 ; * (  2 bytes)
	#endif
#else
	#if EXPANDED_CLT_TEMP
      IACcoldtmp      = scalar,  S16,    560,             "°F",       0.10000,   0.00000,-40.00,  450.00,      1
	#else
      IACcoldtmp      = scalar,  S16,    560,             "°F",       0.10000,   0.00000,-40.00,  300.00,      1
	#endif
#endif
      IACcoldpos      = scalar,  S16,    562,             "steps",    1.00000,   0.00000,  0.00, 4000.00,      0 ; * (  2 bytes)
      IACcoldxt       = scalar,  S16,    564,             "sec",      1.00000,   0.00000,  0.00,32767.00,      0 ; * (  2 bytes)
      injOpen         = scalar,  U16,    566,             "ms",       0.001,   0.00000,  0.00,   25.50,      3 ; * (  1 byte)
      battFac         = scalar,  U16,    568,             "ms/v",     0.000166667,       0.0,   0.0,     1.0,      3 ; * (  1 byte)
      OverBoostOption = bits,    U08,    570,     [0:1],  "None",    "Fuel Cut", "Spark Cut", "Both"
      OverBoostKpa    = scalar,  S16,    571,             "kPa",      0.10000,   0.00000,  0.00,  1000,        1
      OverBoostHyst   = scalar,  S16,    573,             "kPa",      0.10000,   0.00000,  0.00,  100,         1
      overboostcutx   = scalar,  U08,    575,             "",         1, 0, 0, 255, 0
      overboostcuty   = scalar,  U08,    576,             "",         1, 0, 0, 255, 0 
      secondtrigopts  = bits,    U08,    577,     [0:0],  "Off", "On"
      secondtrigopts1 = bits,    U08,    577,     [1:1],  "Off", "On"
      secondtrigopts2 = bits,    U08,    577,     [2:2],  "Off", "On"
      secondtrigopts3 = bits,    U08,    577,     [3:3],  "Off", "On"
      tpsThresh       = scalar,  S16,    578,             "%/s",      0.10000,   0.00000,  0.00,  1000.0,      1 ; * (  2 byte)
      mapThresh       = scalar,  S16,    580,             "kPa/s",    1.00000,   0.00000,  0.00,  1000.0,      0 ; * (  2 byte) threshold for MAE
      taeColdA        = scalar,  U08,    582,             "ms",       0.10000,   0.00000,  0.00,  25.500,      1 ; * (  1 byte)
      taeColdM        = scalar,  U08,    583,             "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      mapsample_angle = scalar,  S16,    584,             "deg",      0.10000,   0.00000,  -360,  360,         1
      taeTime         = scalar,  U08,    586,             "s",        0.10000,   0.00000,  0.00,   25.50,      1 ; * (  1 byte)
      tdePct          = scalar,  U08,    587,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      floodClear      = scalar,  S16,    588,             "%",        0.10000,   0.00000,  0.00,  100.00,      1 ; * (  2 bytes)
      TPSOXLimit      = scalar,  S16,    590,             "%",        0.10000,   0.00000,  0.00,  300.00,      1 ; * (  2 bytes)
      tpsProportion   = scalar,  U08,    592,             "%",        1.00000,   0.00000,  0.00,  100.00,      0 ; * (  1 byte)
      baroCorr        = bits  ,  U08,    593,      [0:1], "None", "Initial MAP Reading", "Two Independent Sensors", "INVALID"        ; *
      egoType         = bits  ,  U08,    594,      [0:2], "Disabled", "Narrow Band", "Dual Narrow Band", "Single Wide Band", "Dual Wide Band", "INVALID", "INVALID", "INVALID" ; *
      egoCount        = scalar,  U08,    595,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      egoDelta        = scalar,  U08,    596,             "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      oldegoLimit        = scalar,  U08,    597,             "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
#if   NARROW_BAND_EGO
      egoTarget       = scalar,  U08,    598,             "v",       0.10000,  0.00000,  ,    ,      4 ; * (  1 byte)
#elif LAMBDA
      AFRTarget       = scalar,  U08,    598,             "Lambda",  0.006803,   0.00000,  0.00,    2.00,      3
#else
      AFRTarget       = scalar,  U08,    598,             "AFR",      0.10000,   0.00000,  0.00,   25.50,      1
#endif
      tempUnits       = bits  ,  U08,    599,      [0:0], "Coolant/MAT Tables in °F", "Coolant/MAT Tables in °C" ; * (  1 byte)
      MAFOption       = bits  ,  U08,    600,      [4:5], "Off", "AD7", "AD6"  ;   (  1 byte)
     ;pad             = scalar,  U08,    601,
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      fastIdleT       = scalar,  S16,    602,             "°C",       0.05555,  -320.000,-40.00,  230.00,      1 ; * (  2 bytes)
      egoTemp         = scalar,  S16,    604,             "°C",       0.05555,  -320.000,-40.00,  230.00,      1 ; * (  2 bytes)
	#else
      fastIdleT       = scalar,  S16,    602,             "°C",       0.05555,  -320.000,-40.00,  150.00,      1 ; * (  2 bytes)
      egoTemp         = scalar,  S16,    604,             "°C",       0.05555,  -320.000,-40.00,  150.00,      1 ; * (  2 bytes)
	#endif	  
#else
	#if EXPANDED_CLT_TEMP
      fastIdleT       = scalar,  S16,    602,             "°F",       0.10000,   0.00000,-40.00,  450.00,      1
      egoTemp         = scalar,  S16,    604,             "°F",       0.10000,   0.00000,-40.00,  450.00,      1
	#else
      fastIdleT       = scalar,  S16,    602,             "°F",       0.10000,   0.00000,-40.00,  300.00,      1
      egoTemp         = scalar,  S16,    604,             "°F",       0.10000,   0.00000,-40.00,  300.00,      1
	#endif
#endif
      egoRPM          = scalar,  S16,    606,             "RPM",      1.00000,   0.00000,  0.00, 15000.0,      0 ; * (  2 bytes)
      reqFuel         = scalar,  U16,    608,             "ms",       0.00100,   0.00000,  0.00,  65.536,      2 ; * (  2 bytes)
      divider         = scalar,  U08,    610,             "",         1.00000,   0.00000,  0.00,     255,      0 ; * (  1 byte)
      alternate       = bits,    U08,    611,      [0:0], "Simultaneous", "Alternating"                          ; * (  1 byte)
      altcrank       = bits,    U08,    611,      [1:1], "Every event", "Alternate events"
      injPwmT         = scalar,  U08,    613,             "ms",       0.12800,   0.128,  0.00,   32.64,      1 ; * (  1 byte)
      injPwmPd        = scalar,  U08,    614,             "us",       1.00000,   0.00000, 40.00,  100.00,      0 ; * (  1 byte)
      injPwmP         = scalar,  U08,    615,             "%",        1.00000,   0.00000,  0.00,  100.00,      0 ; * (  1 byte)
      twoStroke       = bits,    U08,    617,      [0:0], "Four-stroke",    "Two-stroke"                         ; *
      injType         = bits,    U08,    618,      [0:0], "Port Injection", "Throttle Body"                      ; *
      nInjectors      = bits,    U08,    619,      [0:3], "INVALID"                                              ; *
      OddFireang      = scalar,  U16,    620,             "",         0.10000,   0.00000,  0.00,  720.00,      0 ; * (  2 byte)
      rpmLF           = scalar,  U08,    622,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      mapLF           = scalar,  U08,    623,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      tpsLF           = scalar,  U08,    624,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      egoLF           = scalar,  U08,    625,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      adcLF           = scalar,  U08,    626,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
;      knkLF           = scalar,  U08,    627,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; * (  1 byte)
      AMCOption       = bits,    U08,    628,      [0:1], "Disabled", "RAM Update", "FLASH Update", "INVALID"    ; * (  1 byte)
      dualTable       = bits,    U08,    629,      [0:0], "Single Table", "Dual Table"                           ; *
      algorithm       = bits,    U08,    630,      [0:2], "INVALID", "Speed Density", "Percent Baro", "Alpha-N", "MAFMAP", "MAF", "ITB", "INVALID" ; * 
      algorithm2      = bits,    U08,    630,      [4:6], "Disabled", "Speed Density", "Percent Baro", "Alpha-N", "MAFMAP", "MAF", "ITB", "INVALID"
      IgnAlgorithm    = bits,    U08,    631,      [0:2], "INVALID", "Speed Density", "Percent Baro", "Alpha-N", "MAFMAP", "INVALID", "ITB", "INVALID"
      IgnAlgorithm2   = bits,    U08,    631,      [4:6], "Disabled", "Speed Density", "Percent Baro", "Alpha-N", "MAFMAP", "INVALID", "ITB", "INVALID"
      AfrAlgorithm        = scalar,  U08,    632,             "",         1.00000,   0.00000,  0.00,  255.00,      0 ; U (  1 byte) UNUSED
      dwelltime       = scalar,  U08,    633,             "ms",       0.0666,       0,        0.1,     25.5, 1
      trigret_ang     = scalar,  U16,    634,    "deg", 0.1, 0, 5, 180,1
      RevLimOption    = bits  ,  U08,    636,      [0:2], "None", "Spark Retard", "Fuel Cut", "Spk retard, fuel cut", "INVALID", "Spark retard/cut","INVALID","Fuel&spark cut"         ; * (  1 byte)
      RevLimCLTbased  = bits,    U08,    636,      [3:3], "Normal", "CLT based"
      RevLimMaxRtd    = scalar,  S08,    637,             "deg",      0.10000,   0.00000,-12.80,   12.70,      0 ; * (  1 byte)
      injPwmT2        = scalar,  U08,    638,             "ms",       0.12800,   0.12800,  0.00,   32.64,      1 ; * (  1 byte)
      injPwmPd2       = scalar,  U08,    639,             "us",       1.00000,   0.00000, 40.00,  100.00,      0 ; * (  1 byte)
      injPwmP2        = scalar,  U08,    640,             "%",        1.00000,   0.00000,  0.00,  100.00,      0 ; * (  1 byte)
      injOpen2        = scalar,  U16,    641,             "ms",       0.001,   0.00000,  0.00,   25.50,      3 ; * (  1 byte)
      battFac2        = scalar,  U16,    643,             "ms/v",     0.000166667,       0.0,   0.0,     1.0,      3 ; * (  1 byte)
      ; spare 645
      baro_upper      = scalar,  S16,    646,             "kPa",      0.10000,   0.00000,  0.00,  400.00,      1 ;
      baro_lower      = scalar,  S16,    648,             "kPa",      0.10000,   0.00000,  0.00,  400.00,      1 ;
      baro_default    = scalar,  S16,    650,             "kPa",      0.10000,   0.00000,  0.00,  400.00,      1 ;
      RevLimTPSbypassRPM = scalar, S16,  652,             "RPM",      1.00000,   0.00000,  0.00,  16000,       0 ;
      RevLimNormal1 =   scalar,  S16,    654,             "RPM",      1.00000,   0.00000,  0.00,  16000,       0 ;
      RevLimNormal2 =   scalar,  S16,    656,             "RPM",      1.00000,   0.00000,  0.00,  16500,       0 ;
      TC5_required_width = scalar, U16,  658,             "uSec",     0.66667,   0.00000,  0.00,  5000,        0 ;
      egoLimit =        scalar,  S16,    660,             "%",        0.10000,   0.00000,  0.00,  100,         0 ;
      stoich =          scalar,  S16,    662,             "AFR",      0.10000,   0.00000,  0.00,  25.5,        1 ;
	  enable_pollADC =  bits,    U08,    664,      [0:0], "Disable", "Enable"
	  enable_pollPWM =  bits,    U08,    664,      [1:1], "Disable", "Enable"
	  enable_pollports = bits,   U08,    664,      [2:2], "Disable", "Enable"
	  poll_tableADC =   scalar,  U08,    665,             "",         1.00000,   0.00000,     0,     15,       0 ; * (  1 byte)
	  poll_tablePWM =   scalar,  U08,    666,             "",         1.00000,   0.00000,     0,     15,       0 ; * (  1 byte)
	  poll_tableports = scalar,  U08,    667,             "",         1.00000,   0.00000,     0,     15,       0 ; * (  1 byte)
	  poll_offsetADC =  scalar,  S16,    668,             "bytes",    1.00000,   0.00000,     0,   4095,       0 ;
	  poll_offsetPWM =  scalar,  S16,    670,             "bytes",    1.00000,   0.00000,     0,   4095,       0 ;
	  poll_offsetports = scalar, S16,    672,             "bytes",    1.00000,   0.00000,     0,   4095,       0 ;
	  ports_dir =       bits,    U08,    674,      [0:2], "3 Inputs", "2 Inputs, 1 Output", "INVALID", "1 Input, 2 Outputs", "INVALID", "INVALID", "INVALID", "3 Outputs"
	  port1_type =      bits,    U08,    674,      [4:4], "Digital (8 signals)", "Single value (one signal)"
	  port2_type =      bits,    U08,    674,      [5:5], "Digital (8 signals)", "Single value (one signal)"
	  port3_type =      bits,    U08,    674,      [6:6], "Digital (8 signals)", "Single value (one signal)"
	  port_generic =    bits,    U08,    675,      [0:1], "Disabled", "Remote Port 1", "Remote Port 2", "Remote Port 3"
          CID           =   scalar,  U16,    676,    "ci",   1.00000,    0.00000,     0,   1000,    0

          remotePWMfreq     =   scalar,  U08,    678,    "MHz",  1.00000,    0.00000,     1,     50,    0
          remotePWMprescale =   scalar,  U08,    679,       "",  1.00000,    0.00000,     1,    255,    0

      ; dummys 56 bytes
      hw_latency      = scalar,  U08,    732,      "usec", 0.66667, 0.00000, 0.00, 170, 0
      loadCombine     = bits,    U08,    733,      [0:0], "additive", "multiplicitive"
      loadMult	      = bits,    U08,    733,      [2:2], "don't multiply", "multiply"
      loadStoich      = bits,    U08,    733,      [3:3], "don't include AFRtarget", "include AFRtarget"



      baud            = scalar,  U32,    734,             "",         1.00000,   0.00000,9600.0,115200.0,      0 ; x (  4 bytes)
      MAPOXLimit      = scalar,  S16,    738,             "kPa",      0.10000,   0.00000,  0.00,  300.00,      2 ; * (  2 bytes)

      board_type      = bits ,  U08,    740,            [0:7],       "INVALID", "MS2", "Router", "GPIO"
      mycan_id        = scalar ,  U08,    741,            "",        1.00000,   0.00000,  0.00,  255,      0
; 4 words in here that _DO_NOT_ align correctly with where GPIO wants to clobber
      mapsample_window = scalar, U08,    750,            "deg",       1.00000,   0.00000,  0.00,  50,       0
      can_poll        = bits,     U08,    751,           [0:3], "Disabled", "GPIO", "MS2/Extra slave", "Generic Board" ; can add other types here and write firmware to poll them 
      can_poll_id     = bits,     U08,    752,           [0:3], "Disabled", "1", "2", "3", "4", "5", "6", "7"
      can_poll_slave  = bits,     U08,    752,           [7:7], "Master", "Slave"
      MAPOXMin        = scalar,   S16,    753,             "kPa",      0.10000,   0.00000,  0.00,  300.00,      2 ; * (  2 bytes)

      ; Port Settings constants
      psEnabled       = array ,  U08,    756,    [    7], "on/off",   1.00000,   0.00000,   0.00,    1.00,     0 ; * (  2 bytes)
      psCondition     = array ,  U08,    763,    [  7x2], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      psConnector     = array ,  U08,    777,    [    7], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      psInitValue     = array ,  U08,    784,    [    7], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      psPortValue     = array ,  U08,    791,    [    7], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      psOutSize       = array ,  U08,    798,    [  7x2], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      psOutOffset     = array ,  U16,    812,    [  7x2], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      psThreshold     = array ,  U16,    840,    [  7x2], "",         1.00000,   0.00000,-32768.0,32767.0,     0 ; * (  4 bytes)
      psHysteresis    = array ,  U16,    868,    [  7x2], "",         1.00000,   0.00000,-32768.0,32767.0,     0 ; * (  4 bytes)

      aeTaperTime     = scalar,  U08,    896,             "s",        0.10000,   0.00000,  0.00,   25.50,      1 ; * (  1 byte)
     ;pad             = scalar,  U08,    897,
      aeEndPW         = scalar,  S16,    898,             "ms",       0.10000,   0.00000,  0.00, 1000.00,      1 ; *

      egoAlgorithm    = bits  ,  U08,    900,      [0:1], "Simple", "INVALID", "PID", "INVALID" ; * (  1 byte)
      egoKP           = scalar,  U08,    901,             "%",        1.00000,   0.00000,  0.00,  200.00,      0 ; * (  1 byte)
      egoKI           = scalar,  U08,    902,             "%",        1.00000,   0.00000,  0.00,  200.00,      0 ; * (  1 byte)
      egoKD           = scalar,  U08,    903,             "%",        1.00000,   0.00000,  0.00,  200.00,      0 ; * (  1 byte)
      egoKdelay1      = scalar,  U16,    904,             "ms",       1.00000,   0.00000,  0.00,   65535,      0 ; * (  2 bytes)
      egoKdelay2      = scalar,  U16,    906,             "revs",     1.00000,   0.00000,  0.00,   65535,      0 ; * (  2 bytes)

      flexFuel        = bits  ,  U08,    908,      [0:0], "Disabled", "Enabled"                                  ; * (  1 byte)
      flexFuelRemote  = bits  ,  U08,    908,      [1:1], "Local", "Remote"                                      ; * (  1 byte)
      fuelFreq        = array ,  U08,    909,    [    2], "Hz",       1.00000,   0.00000,  0.00,     255,      0 ; * (  2 bytes)
         fuelFreq0    = scalar,  U08,    909,             "Hz",       1.00000,   0.00000,  0.00,     255,      0
         fuelFreq1    = scalar,  U08,    910,             "Hz",       1.00000,   0.00000,  0.00,     255,      0
      fuelCorr        = array ,  U08,    911,    [    2], "%",        1.00000,   0.00000,  0.00,     255,      0 ; * (  2 bytes)
         fuelCorr0    = scalar,  U08,    911,             "%",        1.00000,   0.00000,  0.00,     255,      0
         fuelCorr1    = scalar,  U08,    912,             "%",        1.00000,   0.00000,  0.00,     255,      0

      dwellmode       = bits  ,  U08,    913,  [0:1], "Standard Dwell", "Fixed Duty", "Time after Spark", "Charge at Trigger"

      AMCstep         = scalar,  U08,    914,             "%",        1.00000,   0.00000,  0.00,     255,      0 ; * (  2 bytes)
      AMCdve          = scalar,  U08,    915,             "%",        1.00000,   0.00000,  0.00,     255,      0 ; * (  2 bytes)
      AMCve_rpm       = scalar,  U16,    916,             "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * (  2 bytes)
      AMCve_map       = scalar,  U16,    918,             "kPa",      0.10000,   0.00000,  0.00,  300.00,      2 ; * (  2 bytes)
      AMCramve_dt     = scalar,  U16,    920,             "sec",      1.0,       0.0,      0.0,   300.0,       0 ; * (  2 bytes)
      AMCT_thresh     = scalar,  U16,    922,             "sec",      1.0,       0.0,      0.0,   300.0,       0 ; * (  2 bytes)
      AMCupdate_thresh= scalar,  U16,    924,             "events",   1.0,       0.0,      0.0, 30000.0,       0 ; * (  2 bytes)

      knk_option      = bits  ,  U08,    927,      [0:1], "Disabled", "Safe Mode", "Aggressive Mode", "INVALID"  ; * (  1 byte )
      knkport         = bits,    U08,    927,      [2:2], "MS2 AD7/JS4", "MS2 AD6/JS5" 
      knk_remote      = bits,    U08,    927,      [3:3], "Local", "Remote" 
      knkDirection    = bits  ,  U08,    927,      [4:4], "Low Input", "High Input"                   ; *
      knkpull         = bits  ,  U08,    927,      [5:6], "Same as knock", "None", "Pull up", "Pull down"                   ; *

      knk_maxrtd      = scalar,  U08,    928,             "deg",      0.1,       0.0,      0.0,    25.5,       1 ; * (  1 byte )
      knk_step1       = scalar,  U08,    929,             "deg",      0.1,       0.0,      0.0,    25.5,       1 ; * (  1 byte )
      knk_step2       = scalar,  U08,    930,             "deg",      0.1,       0.0,      0.0,    25.5,       1 ; * (  1 byte )
      knk_trtd        = scalar,  U08,    931,             "sec",      0.1,       0.0,      0.0,    25.5,       1 ; * (  1 byte )
      knk_tadv        = scalar,  U08,    932,             "sec",      0.1,       0.0,      0.0,    25.5,       1 ; * (  1 byte )
      knk_dtble_adv   = scalar,  U08,    933,             "deg",      0.1,       0.0,      0.0,    25.5,       1 ; * (  1 byte )
      knk_ndet        = scalar,  U08,    934,             "knocks",   1.0,       0.0,      0.0,     255,       0 ; * (  1 byte )
      EAEOption      = bits  ,  U08,    935,      [0:1], "Off", "ON", "INVALID", "ON with lag compensation"      ; * (  1 byte )
      knk_maxmap      = scalar,  U16,    936,             "kPa",      0.1,       0.0,      0.0,   300.0,       1 ; * (  2 bytes)
      knk_lorpm       = scalar,  U16,    938,             "rpm",      1.0,       0.0,      0.0,   10000,       0 ; * (  2 bytes)
      knk_hirpm       = scalar,  U16,    940,             "rpm",      1.0,       0.0,      0.0,   10000,       0 ; * (  2 bytes)
;      knk_rpm         = array ,  U16,    942,    [    6], "rpm",      1.0,       0.0,      0.0,    6000,       0 ; * (  2 bytes)
;      knk_thresh      = array ,  U16,    954,    [    6], "v",        0.01,      0.0,      0.0,    5.00,       2 ; * (  2 bytes)

      triggerTeeth    = scalar,  U16,    966,             "teeth",    1.0,       0.0,      0.0,     512,       0 ; * (  2 bytes)
      No_Miss_Teeth   = scalar,  U08,    968,             "teeth",    1.0,       0.0,      0.0,     255,       0 ; * (  1 byte )
      Miss_ang        = scalar,  U16,    969,             "deg BTDC",    0.1,       0.0,      0.0,     360,       1 ; * (  2 bytes )

      ICISR_tmask     = scalar,  U08,    971,             "ms",       0.1,       0.0,      0.0,    25.5,       1 ; * (  1 byte )
      ICISR_pmask     = scalar,  U08,    972,             "%",        1.0,       0.0,      0.0,     90,       0 ; * (  1 byte )

      knkport_remote  = bits,    U08,    973,      [0:2], "Remote Port3 Bit 0", "Remote Port3 Bit 1", "Remote Port3 Bit 2", "Remote Port3 Bit 3", "Remote Port3 Bit 4", "Remote Port3 Bit 5", "Remote Port3 Bit 6", "Remote Port3 Bit 7" 

      ae_lorpm        = scalar,  U16,    974,             "rpm",      1.0,       0.0,      0.0,   10000,       0 ; * (  2 bytes)
      ae_hirpm        = scalar,  U16,    976,             "rpm",      1.0,       0.0,      0.0,   10000,       0 ; * (  2 bytes)

      fuelSpkDel      = array ,  S16,    978,    [    2], "deg",      0.10000,   0.00000,-45.00,   45.00,      1 ; * (  4 bytes)
         fuelSpkDel0  = scalar,  S16,    978,             "deg",      0.10000,   0.00000,-45.00,   45.00,      1
         fuelSpkDel1  = scalar,  S16,    980,             "deg",      0.10000,   0.00000,-45.00,   45.00,      1

      IC2ISR_tmask     = scalar,  U08,    982,             "ms",       0.1,       0.0,      0.0,    25.5,       1 ; * (  1 byte )
      IC2ISR_pmask     = scalar,  U08,    983,             "%",        1.0,       0.0,      0.0,     90,       0 ; * (  1 byte )
      NoiseFilterOpts = bits, U08, 984, [0:0], "Off", "On"
      NoiseFilterOpts1 = bits, U08, 984, [1:1], "Off", "On"
      NoiseFilterOpts2 = bits, U08, 984, [2:2], "Off", "On"
      NoiseFilterOpts3 = bits, U08, 984, [3:3], "Off", "On"
      afrload = bits, U08, 985, [0:2], "Use primary load (Algorithm)", "MAP", "% baro", "TPS", "MAFMAP", "INVALID", "ITB", "INVALID" 
      eaeload = bits, U08, 985, [4:6], "Use primary load (Algorithm)", "MAP", "% baro", "TPS", "MAFMAP", "INVALID", "ITB", "INVALID" 
; 2 spare
      spk_conf2_gm    = bits  ,  U08,    987,      [0:0], "Off", "GM Bypass on D16"
      spk_conf2_tfi   = bits  ,  U08,    987,      [1:2], "Off", "TFI Non-signature", "INVALID", "TFI Signature PIP"
      spk_conf2_cam   = bits  ,  U08,    987,      [3:3], "Off", "On"
      spk_conf2_oddodd= bits  ,  U08,    987,      [4:4], "Alternate", "Paired"
      spk_conf2_ngc   = bits  ,  U08,    236,      [6:6], "Off", "Alternate"

;spk_config
      spk_config_spka = bits  ,  U08,    988,      [0:0], "JS10", "D14"                                            ;   (  1 byte )
      spk_config_camcrank = bits, U08,   988,      [1:1], "Crank wheel", "Cam wheel"
      spk_config_trig2 =bits,    U08,    988,      [2:3], "INVALID", "Single wheel with missing tooth", "Dual wheel", "Dual wheel with missing tooth"
      spk_config_trig2l =bits,   U08,    988,      [4:5], "INVALID", "Rising edge", "Falling edge", "Rising and falling"
      spk_config_resetcam = bits, U08,   988,      [6:7], "Cam", "Crank", "Every cylinder", "INVALID"

 ; invalids in next line are spare and should be used
      spk_mode0       = bits  ,  U08,    989,      [0:5], "EDIS", "EDIS Multispk", "Basic trigger", "Trigger return",  "Toothed wheel", "420A/Neon", "36-2+2", "36-2-2-2", "Subaru 6/7", "Miata 99-00", "6g72", "IAW Weber", "CAS 4/1", "4G63", "Twin trigger", "Chrysler 2.2/2.5", "Renix 44-2-2", "Suzuki Swift", "Suzuki Vitara 2.0", "Daihatsu 3cyl", "Daihatsu 4cyl", "VTR1000", "Rover#1", "Rover#2", "Rover#3", "GM 7X", "Log crank", "Log crank&cam", "QR25DE", "Honda RC51", "INVALID", "Fuel Only", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID","LS1", "YZF1000", "INVALID", "INVALID","INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID","INVALID", "INVALID", "INVALID", "INVALID","INVALID", "INVALID", "INVALID", "INVALID","INVALID", "INVALID", "INVALID", "INVALID"
      spk_mode3       = bits,    U08,    989,      [6:7], "Single coil", "Wasted spark", "Coil on plug", "Dual dizzy" ;  (1 byte )

;      userlevel byte 990 . Use top type bits now so can add finer grained control if required
      userlevel       = scalar,  U08,    990,    "level",    1,       0,      0,   255,0
      userlevelbits   = bits,    U08,    990,      [6:7], "Fuel only", "Fuel+Spark", "Extended", "Advanced" ;  (1 byte )
#if MICROSQUIRT_FULL
      rtbaroport      = bits,    U08,    991,      [0:3], "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "SPAREADC", "INVALID", "Remote ADC0", "Remote ADC1", "Remote ADC2", "Remote ADC3", "Remote ADC4", "Remote ADC5", "Remote ADC6", "Remote ADC7" ;  (1 byte )
      ego2port        = bits,    U08,    992,      [0:3], "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "SPAREADC", "INVALID", "Remote ADC0", "Remote ADC1", "Remote ADC2", "Remote ADC3", "Remote ADC4", "Remote ADC5", "Remote ADC6", "Remote ADC7"  ;  (1 byte )
      flexport        = bits,    U08,    994,      [0:0], "FLEX", "INVALID";  (1 byte )
#else
#if MICROSQUIRT_MODULE
      rtbaroport      = bits,    U08,    991,      [0:3], "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "SPAREADC", "SPAREADC2", "Remote ADC0", "Remote ADC1", "Remote ADC2", "Remote ADC3", "Remote ADC4", "Remote ADC5", "Remote ADC6", "Remote ADC7" ;  (1 byte )
      ego2port        = bits,    U08,    992,      [0:3], "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "SPAREADC", "SPAREADC2", "Remote ADC0", "Remote ADC1", "Remote ADC2", "Remote ADC3", "Remote ADC4", "Remote ADC5", "Remote ADC6", "Remote ADC7"  ;  (1 byte )
      flexport        = bits,    U08,    994,      [0:0], "FLEX", "PA0";  (1 byte )
#else

      rtbaroport      = bits,    U08,    991,      [0:3], "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "MS2 AD6/JS5", "MS2 AD7/JS4", "Remote ADC0", "Remote ADC1", "Remote ADC2", "Remote ADC3", "Remote ADC4", "Remote ADC5", "Remote ADC6", "Remote ADC7" ;  (1 byte )
      ego2port        = bits,    U08,    992,      [0:3], "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "MS2 AD6/JS5", "MS2 AD7/JS4", "Remote ADC0", "Remote ADC1", "Remote ADC2", "Remote ADC3", "Remote ADC4", "Remote ADC5", "Remote ADC6", "Remote ADC7"  ;  (1 byte )
      flexport        = bits,    U08,    994,      [0:0], "PE0/JS7", "JS11";  (1 byte )
#endif
#endif
      flexportRemote  = bits,    U08,    994,      [1:2], "PWM0", "PWM1", "PWM2", "PWM3";  (1 byte )
      RevLimcutx      = scalar,  U08,    995,  "",     1, 0, 0, 255, 0
      RevLimcuty      = scalar,  U08,    996,  "",     1, 0, 0, 255, 0
;      feature4_0ftrig  = bits,   U08,    997,      [0:0], "Simple", "Advanced"
      feature4_0igntrig= bits,   U08,    997,      [1:1], "Off", "Ignition trigger indicator"
      feature4_0VEtblsize=bits,  U08,    997,      [2:2], "16x16","12x12"
      feature4_0maxdwl = bits,   U08,    997,      [3:3], "Off", "On"
      feature4_0ftrig = bits,    U08,    997,      [4:5], "Off", "INVALID", "Simple", "Advanced"
      feature4_0mindwl = bits,   U08,    997,      [6:6], "Off", "On"
      feature4_0vanos = bits,    U08,    997,      [7:7], "Off", "Logged"
      ipwmTable       = array ,  S16,    998,    [   10], "%",        0.39063,   0.00000,  0.00,  100.00,      1
      timing_flags    = bits,    U08,   1018,	 [0:0], "Use Table", "Fixed timing";
      use_prediction  = bits,    U08,   1018,    [1:1], "No Prediction", "1st Deriv Prediction";
      crank_dwell     = scalar,  U08,   1019,     "ms", 0.0666,0.00000,1.00,8.00,1 ; * (  1 byte);
      crank_timing    = scalar,  S16,   1020,     "degrees", 0.10000,0.00000,-10.00,90.00,1;
      fixed_timing    = scalar,  S16,   1022,	  "degrees", 0.10000,0.00000,-10.00,90.00,1;

   page = 2
      pwmidle_target_rpms = array, U16, 0,    [ 8 ], "rpms",      1, 0.00000, 0.00, 2000, 0;
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      pwmidle_clt_temps = array,  S16, 16,   [8],  "°C",   0.05555,  -320.000,-40.00,  230.00,      1 ;
	#else
      pwmidle_clt_temps = array,  S16, 16,   [8],  "°C",   0.05555,  -320.000,-40.00,  150.00,      1 ;
	#endif
#else
	#if EXPANDED_CLT_TEMP
      pwmidle_clt_temps = array,  S16, 16,   [8],  "°F",       0.10000,  0.00000,-40.00,  450.00,      1
	#else
      pwmidle_clt_temps = array,  S16, 16,   [8],  "°F",       0.10000,  0.00000,-40.00,  300.00,      1
	#endif
#endif
      pwmidle_ms = scalar, U16, 32, "ms", 1, 0.00000, 50, 500, 0
      pwmidle_close_delay = scalar, U08, 34, "sec", 1, 0.00000, 0, 10, 0
      pwmidle_open_duty = scalar, U08, 35, "%", 0.39063, 0.00000, 0, 100, 1
      pwmidle_open_steps = scalar, U08, 35, "steps", 1.00000, 0.00000, 0, 255, 0
      pwmidle_closed_duty = scalar, U08, 36, "%", 0.39063, 0.00000, 0, 100, 1
      pwmidle_closed_steps = scalar, U08, 36, "steps", 1.00000, 0.00000, 0, 255, 0
      pwmidle_pid_wait_timer = scalar, U08, 37, "sec", 1, 0.00000, 2, 10, 0
      pwmidle_min_duty = scalar, U08, 38, "%", 0.39063, 0.00000, 0, 255, 1
      pwmidle_min_steps = scalar, U08, 38, "steps", 1.00000, 0.00000, 0, 255, 0
      pwmidle_engage_rpm_adder = scalar, U16, 39, "rpm", 1, 0.00000, 0, 32000, 0
      pwmidle_tps_threshold = scalar, U16, 41, "%", 0.1, 0.00000, 0, 1000, 1
      pwmidle_dp_adder = scalar, U08, 43, "%", 0.39063, 0.00000, 0, 20, 1
      pwmidle_dp_adder_steps = scalar, U08, 43, "steps", 1.00000, 0.00000, 0, 20, 0
      pwmidle_rpmdot_threshold = scalar, U16, 44, "rpm/sec", 10.0, 0.00000, 0, 1000, 0
      pwmidle_decelload_threshold = scalar, U16, 46, "%", 0.1, 0.00000, 0, 100, 1
      pwmidle_Kp = scalar, U16, 48, "%", 0.10000, 0.00000, 0, 200, 1
      pwmidle_Ki = scalar, U16, 50, "%", 0.10000, 0.00000, 0, 200, 1
      pwmidle_Kd = scalar, U16, 52, "%", 0.10000, 0.00000, 0, 200, 1
      pwmidle_freq = scalar, U08, 54, "", 1, 0.00000, 0, 15, 0 
      pwmidle_min_rpm = scalar, U16, 55, "rpm", 1, 0.00000, 0, 2000, 0
      pwmidle_max_rpm = scalar, U16, 57, "rpm", 1, 0.00000, 0, 4000, 0
      pwmidle_targ_ramptime = scalar, U08, 59, "sec", 1, 0.00000, 2, 10, 0
      pwmidle_rpmdot_disablepid = scalar, S16, 60, "", 10, 0, 100, 1000, 0
      pwmidle_port = bits, U08, 62, [0:1], "Local", "Remote Port 1", "Remote Port 2", "Remote Port 3"
      boost_ctl_settings_freq = bits, U08, 67, [0:2], "INVALID", "78Hz", "39Hz", "26Hz", "19.5Hz", "15.6Hz", "13Hz", "11.1Hz"
      boost_ctl_settings_on = bits, U08, 67, [3:3], "Off","On"
      boost_ctl_settings_cl = bits, U08, 67, [4:4], "Open-loop", "Closed-loop"
      boost_ctl_settings_invert = bits, U08, 67, [5:5], "Normal", "Inverted"
      boost_ctl_settings_remote = bits, U08, 67, [6:6], "Local", "Remote"
#if MICROSQUIRT_FULL
      boost_ctl_pins = bits, U08, 68, [0:3], "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "Fidle", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID","INVALID"
#else
#if MICROSQUIRT_MODULE
      boost_ctl_pins = bits, U08, 68, [0:3], "INVALID", "PT7", "PT6", "INVALID", "PA0", "INVALID", "INVALID", "INVALID", "Fidle", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID","INVALID"
#else
      boost_ctl_pins = bits, U08, 68, [0:3], "INVALID", "IAC1", "IAC2", "INVALID", "JS11", "INVALID", "INVALID", "INVALID", "Fidle", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID","INVALID"
#endif
#endif
      boost_ctl_remote = bits, U08, 68, [4:5], "INVALID", "Port 1", "Port 2", "Port 3"
      boost_ctl_Kp = scalar, U08, 69, "%", 1, 0.00000, 0, 200, 0
      boost_ctl_Ki = scalar, U08, 70, "%", 1, 0.00000, 0, 200, 0
      boost_ctl_Kd = scalar, U08, 71, "%", 1, 0.00000, 0, 200, 0
      boost_ctl_closeduty = scalar, U08, 72, "%", 1, 0.00000, 0, 100, 0
      boost_ctl_openduty = scalar, U08, 73, "%", 1, 0.00000, 0, 100, 0
      boost_ctl_ms = scalar, U16, 74, "ms", 1, 0.00000, 10, 500, 0
      boost_ctl_load_targets = array, S16, 76, [8x8], "%", 0.1, 0, 0, 400, 1
      boost_ctl_loadtarg_tps_bins = array, S16, 204, [8], "%", 0.1, 0, 0, 100, 1
      boost_ctl_loadtarg_rpm_bins = array, U16, 220, [8], "rpm", 1, 0, 0, 25500, 0
      boost_ctl_pwm_targets = array, U08, 236, [8x8], "%", 1, 0, 0, 100, 0
      boost_ctl_pwmtarg_tps_bins = array, S16, 300, [8], "%", 0.1, 0, 0, 100, 1
      boost_ctl_pwmtarg_rpm_bins = array, U16, 316, [8], "rpm", 1, 0, 0, 25500, 0
      pwmidle_crank_dutyorsteps_duty = array, U16, 332, [4], "%", 0.39063, 0.00000, 0, 100, 1 
      pwmidle_crank_dutyorsteps_steps = array, U16, 332, [4], "steps", 1, 0, 0, 512, 0
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      pwmidle_crank_clt_temps = array, S16, 340, [4], "°C", 0.05555,  -320.000,-40.00,  230.00,      1
	#else
      pwmidle_crank_clt_temps = array, S16, 340, [4], "°C", 0.05555,  -320.000,-40.00,  150.00,      1
	#endif
#else
	#if EXPANDED_CLT_TEMP
      pwmidle_crank_clt_temps = array, S16, 340, [4], "°F",       0.10000,   0.00000,-40.00,  450.00,      1
	#else
      pwmidle_crank_clt_temps = array, S16, 340, [4], "°F",       0.10000,   0.00000,-40.00,  300.00,      1	
	#endif
#endif
      injadvTable3    = array ,  S16,    348,    [  6x6], "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * ( 72 bytes)	
      srpm_injadv3    = array ,  U16,    420,    [    6], "RPM",      1.00000,   0.00000,    0.00,15000.00,      0 ; * ( 12 bytes)	
      smap_injadv3    = array ,  S16,    432,    [    6],   "%",      0.10000,   0.00000,    0.00,  400.00,      1 ; * ( 12 bytes)	
 
      primePWTable    = array ,  S16,    444,    [   10], "ms",       0.10000,   0.00000,  0.00,   65.00,      1 ; * ( 20 bytes)
      crankPctTable   = array ,  U16,    464,    [   10], "%",       1,   1,  1,   10000,      0 ; * ( 20 bytes)
      asePctTable     = array ,  S16,    484,    [   10], "%",        1.00000,   0.00000,  0.00,  400.00,      0 ; * (  2 bytes)
      aseCntTable     = array ,  S16,    504,    [   10], "cycles",   1.00000,   0.00000,  0.00, 2500.00,      0 ; * (  2 bytes)

#if CELSIUS
      matTemps        = array ,  S16,    524,    [    6], "°C",       0.05555,  -320.000,-40.00,  150.00,      1 ; * ( 12 bytes)
#else
      matTemps        = array ,  S16,    524,    [    6], "°F",       0.10000,   0.00000,-40.00,  300.00,      1
#endif
      matRetard       = array ,  U08,    536,    [    6], "deg",      0.10000,   0.00000,  0.00,    25.5,      1 ; * (  6 bytes)

      EAEAWCRPMbins   = array,   U16,    542,    [   12], "rpm",      1.00000,   0.00000,0,       25500,       0 ; * (24 bytes)
      EAESOCRPMbins   = array,   U16,    566,    [   12], "rpm",      1.00000,   0.00000,0,	  25500,       0 ; * (24 bytes)
      EAEAWCKPAbins   = array,   U16,    590,    [   12], "kpa",      0.10000,   0.00000,0,       255,         0 ; * (24 bytes)
      EAESOCKPAbins   = array,   U16,    614,    [   12], "kpa",      0.10000,   0.00000,0,       255,         0 ; * (24 bytes)
      EAEBAWC	      = array,   U08,    638,    [   12], "%",        1.00000,   0.00000,0,       100,         0 ; * (12 bytes)
      EAEBSOC	      = array,   U08,    650,    [   12], "%",        0.10000,   0.00000,0,       25.5,         1 ; * (12 bytes)
      EAEAWN	      = array,   U08,    662,    [   12], "%",        1.00000,   0.00000,0,       200,         0 ; * (12 bytes)
      EAESON	      = array,   U08,    674,    [   12], "%",        1.00000,   0.00000,0,	  200,         0 ; * (12 bytes)
      EAEAWW	      = array,   U08,    686,    [   12], "%",        1.00000,   0.00000,0,	  200,         0
      EAESOW	      = array,   U08,    698,    [   12], "%",        1.00000,   0.00000,0,	  200,         0
      ; Supplemental corrections for barometer and MAT.
      baroCorrVals    = array ,  S16,    710,    [    6], "kPa",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
#if CELSIUS
      matCorrTemps    = array ,  S16,    722,    [    6], "°C",       0.05555,  -320.000,-40.00,  150.00,      1 ; * ( 12 bytes)
#else
      matCorrTemps    = array ,  S16,    722,    [    6], "°F",       0.10000,   0.00000,-40.00,  300.00,      1
#endif
      baroCorrDelta   = array ,  S08,    734,    [    6], "%",        1.00000,   0.00000,-120.0,   120.0,      1 ; * (  6 bytes)
      matCorrDelta    = array ,  S08,    740,    [    6], "%",        1.00000,   0.00000,-120.0,   120.0,      1 ; * (  6 bytes)
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      temp_table_p5   = array,  S16,     746,    [   10], "°C",	      0.05555,   -320.000, -40.00, 230.00,     0
	#else
      temp_table_p5   = array,  S16,     746,    [   10], "°C",	      0.05555,   -320.000, -40.00, 150.00,     0
	#endif
#else
	#if EXPANDED_CLT_TEMP
      temp_table_p5   = array,  S16,     746,    [   10], "°F",       0.10000,   0.000,-40.00, 450.00,      1
	#else
      temp_table_p5   = array,  S16,     746,    [   10], "°F",       0.10000,   0.000,-40.00, 300.00,      1
	#endif
#endif
      tsf_rpm          = scalar,   U16,    766, "rpm", 1, 0, 0, 15000, 0
      tsf_kpa          = scalar,   S16,    768, "kPa", 0.1, 0, 0, 400, 1
      tsf_tps          = scalar,   S16,    770, "%", 0.10000,   0.00000,  0.00,  100.00,      1;
      tss_rpm          = scalar,   U16,    772, "rpm", 1, 0, 0, 15000, 0
      tss_kpa          = scalar,   S16,    774, "kPa", 0.1, 0, 0, 400, 1
      tss_tps          = scalar,   S16,    776, "%", 0.10000,   0.00000,  0.00,  100.00,      1;
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      EAEAWWCLTbins   = array,  S16,     778,    [   12], "deg",       0.05555,   -320.000, -40.00, 230.00,     0
      EAESOWCLTbins   = array,  S16,     802,    [   12], "deg",       0.05555,   -320.000, -40.00, 230.00,     0
	#else
      EAEAWWCLTbins   = array,  S16,     778,    [   12], "deg",       0.05555,   -320.000, -40.00, 150.00,     0
      EAESOWCLTbins   = array,  S16,     802,    [   12], "deg",       0.05555,   -320.000, -40.00, 150.00,     0
	#endif
#else
	#if EXPANDED_CLT_TEMP
      EAEAWWCLTbins   = array,  S16,     778,    [   12], "deg",       0.10000,   0.000,-40.00, 450.00,      1
      EAESOWCLTbins   = array,  S16,     802,    [   12], "deg",       0.10000,   0.000,-40.00, 450.00,      1
	#else
      EAEAWWCLTbins   = array,  S16,     778,    [   12], "deg",       0.10000,   0.000,-40.00, 300.00,      1
      EAESOWCLTbins   = array,  S16,     802,    [   12], "deg",       0.10000,   0.000,-40.00, 300.00,      1
	#endif
#endif

      airden_scaling  = scalar, U08,     826, "%", 1,   0.00000,  50,  150.00,      0
      tsf_remote     = bits  ,  U08,      827,      [0:0], "Local", "Remote"
      tsf_remote_port = bits  , U08,      827,      [1:3], "Remote Port3 Bit 0", "Remote Port3 Bit 1", "Remote Port3 Bit 2", "Remote Port3 Bit 3", "Remote Port3 Bit 4", "Remote Port3 Bit 5", "Remote Port3 Bit 6", "Remote Port3 Bit 7"
      tss_remote     = bits  ,  U08,      827,      [4:4], "Local", "Remote"
      tss_remote_port = bits  , U08,      827,      [5:7], "Remote Port3 Bit 0", "Remote Port3 Bit 1", "Remote Port3 Bit 2", "Remote Port3 Bit 3", "Remote Port3 Bit 4", "Remote Port3 Bit 5", "Remote Port3 Bit 6", "Remote Port3 Bit 7"
;      feature5_0                          828 was 1000
      OvrRunC       = bits  ,  U08,       828,      [0:0], "Off", "On"          ; * (  1 byte)
      f5_0_tsf       = bits  ,  U08,      828,      [1:1], "Off", "On"
;until we redfine the pin on MICROSQUIRT then hardware table switching cannot be used
#if MICROSQUIRT_FULL
      f5_0_tsf_opt   = bits  ,  U08,      828,      [2:3], "INVALID", "rpm", "kPa", "TPS"
      f5_0_tss_opt   = bits  ,  U08,      828,      [5:6], "INVALID", "rpm", "kPa", "TPS"
#else ; including the microsquirt_module
      f5_0_tsf_opt   = bits  ,  U08,      828,      [2:3], "Hardware", "rpm", "kPa", "TPS"
      f5_0_tss_opt   = bits  ,  U08,      828,      [5:6], "Hardware", "rpm", "kPa", "TPS"
#endif
      f5_0_tss       = bits  ,  U08,      828,      [4:4], "Off", "On"

      pwmidlecranktaper= scalar,  U08,     831,     "s",        1.00000,   0.00000,  0.00,  100.00,      0
      pwmidleset_hz   = bits,     U08,     832, [0:0], "78Hz", "156Hz"
      pwmidleset_inv  = bits,     U08,     832, [1:1], "Normal, 0%=off", "Inverted, 100%=off"
      fc_rpm          = scalar,   U16,     833, "rpm", 1, 0, 0, 15000, 0
      fc_kpa          = scalar,   S16,     835, "kPa", 0.1, 0, 0, 400, 1
      fc_tps          = scalar,   S16,     837, "%", 0.10000,   0.00000,  0.00,  100.00,      1;
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      fc_clt          = scalar,   S16,     839,  "°C",       0.05555,  -320.000, -40.0,  230.0,      1 ; * (  2 bytes)
	#else
      fc_clt          = scalar,   S16,     839,  "°C",       0.05555,  -320.000, -40.0,  150.0,      1 ; * (  2 bytes)
	#endif
#else
	#if EXPANDED_CLT_TEMP
      fc_clt          = scalar,   S16,     839,  "°F",       0.10000,   0.00000, -40.0,  450.0,      1
	#else
      fc_clt          = scalar,   S16,     839,  "°F",       0.10000,   0.00000, -40.0,  300.0,      1
	#endif
#endif
      fc_delay        = scalar,   U08,     841,  "s",        0.1, 0, 0, 25.5, 1

      tacho_opt80     = bits,     U08,     842, [7:7], "Off", "On"
      tacho_opt40     = bits,     U08,     842, [6:6], "Normal", "Half speed"
#if MICROSQUIRT_FULL
      tacho_opt3f     = bits,     U08,     842, [0:3], "IGN", "INVALID", "INVALID", "INVALID", "FIDLE", "TACHOUT", "ALED", "WLED", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID"
#else
#if MICROSQUIRT_MODULE
      tacho_opt3f     = bits,     U08,     842, [0:3], "IGN", "PT7", "PT6", "PA0", "FIDLE", "TACHOUT", "ALED", "WLED", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID"
#else
      tacho_opt3f     = bits,     U08,     842, [0:3], "IGN (JS10)", "IAC1", "IAC2", "JS11", "FIDLE", "D14", "D16", "D15", "AD06/JS5", "AD07/JS4", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID" 
#endif
#endif
      EAElagsource    = bits,     U08,     843, [0:0], "TPSdot", "MAPdot"
      EAElagthresh    = scalar,   S16,     844, "unit/sec",  1, 0, 0.00, 1000, 0
      EAElagRPMmax    = scalar,   U16,     846, "rpms", 1, 0, 0.00, 65535, 0
      fc_ego_delay    = scalar,   U08,     848, "seconds", 1, 0, 0.00, 10, 0
;morepage5[15]
      ; Port Settings constants
      rmt_psEnabled       = array ,  U08,    864,    [    8], "on/off",   1.00000,   0.00000,   0.00,    1.00,     0 ; * (  2 bytes)
      rmt_psCondition     = array ,  U08,    872,    [  8x2], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      rmt_psConnector     = array ,  U08,    888,    [    8], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      rmt_psInitValue     = array ,  U08,    896,    [    8], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      rmt_psPortValue     = array ,  U08,    904,    [    8], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      rmt_psOutSize       = array ,  U08,    912,    [  8x2], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      rmt_psOutOffset     = array ,  U16,    928,    [  8x2], "",         1.00000,   0.00000,-128.00,  127.00,     0 ; * (  2 bytes)
      rmt_psThreshold     = array ,  U16,    960,    [  8x2], "",         1.00000,   0.00000,-32768.0,32767.0,     0 ; * (  4 bytes)
      rmt_psHysteresis    = array ,  U16,    992,    [  8x2], "",         1.00000,   0.00000,-32768.0,32767.0,     0 ; * (  4 bytes)

page = 3
      advanceTable1   = array ,  S16,    000,    [12x12], "deg",      0.10000,   0.00000,-10.00,   90.00,      1 ; * (288 bytes)
      advanceTable2   = array ,  S16,    288,    [12x12], "deg",      0.10000,   0.00000,-10.00,   90.00,      1 ; * (288 bytes)
      srpm_table1     = array ,  U16,    576,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      srpm_table2     = array ,  U16,    600,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      smap_table1     = array ,  S16,    624,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      smap_table2     = array ,  S16,    648,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
;      feature3_0      = bits,    U08,    672,       [0:0], "C", "ASM"
      feature3_1      = bits,    U08,    672,      [1:1], "Off", "On"
      feature3_3      = bits,    U08,    672,      [3:3], "Off", "On"
      launch_opt_on   = bits,    U08,    673,      [6:7], "Off", "Launch","INVALID","Launch/Flatshift"
#if MICROSQUIRT_FULL
      launch_opt_pins = bits,    U08,    673,      [0:3], "FLEX", "INVALID", "INVALID", "INVALID", "SPAREADC", "INVALID", "Remote Port3 Bit 0", "Remote Port3 Bit 1", "Remote Port3 Bit 2", "Remote Port3 Bit 3", "Remote Port3 Bit 4", "Remote Port3 Bit 5", "Remote Port3 Bit 6", "Remote Port3 Bit 7", "INVALID" "INVALID"
#else
#if MICROSQUIRT_MODULE
      launch_opt_pins = bits,    U08,    673,      [0:3], "FLEX", "PE1", "INVALID", "PA0", "SPAREADC", "SPAREADC2", "Remote Port3 Bit 0", "Remote Port3 Bit 1", "Remote Port3 Bit 2", "Remote Port3 Bit 3", "Remote Port3 Bit 4", "Remote Port3 Bit 5", "Remote Port3 Bit 6", "Remote Port3 Bit 7", "INVALID" "INVALID"
#else
      launch_opt_pins = bits,    U08,    673,      [0:3], "PE0/JS7", "PE1", "JS10", "JS11", "JS5", "JS4", "Remote Port3 Bit 0", "Remote Port3 Bit 1", "Remote Port3 Bit 2", "Remote Port3 Bit 3", "Remote Port3 Bit 4", "Remote Port3 Bit 5", "Remote Port3 Bit 6", "Remote Port3 Bit 7", "INVALID" "INVALID"
#endif
#endif
      launch_sft_lim  = scalar,  S16,    674,      "RPM",      1.00000,   0.00000,  0.00,  15000.0,      0 ; * (  2 bytes)
      launch_sft_deg  = scalar,  S16,    676,             "deg",      0.10000,   0.00000, -90.0,  180.00,      2 ; * (  2 bytes)
      launch_hrd_lim  = scalar,  S16,    678,             "RPM",      1.00000,   0.00000,  0.00,  15000.0,      0 ; * (  2 bytes)
      launch_tps      = scalar,  S16,    680,  "%",       0.10000,   0.00000,   0.0,  100.00,      0 ;
      launchlimopt    = bits  ,  U08,    682,      [0:1], "None", "Spark Cut", "Fuel Cut", "Spark and fuel"         ; * (  1 byte)
      launchcutx      = scalar,  U08,    683,  "",     1, 0, 0, 255, 0
      launchcuty      = scalar,  U08,    684,  "",     1, 0, 0, 255, 0
      flats_arm       = scalar,  S16,    685,      "RPM",      1.00000,   0.00000,  0.00,  5000.0,      0
      flats_sft       = scalar,  S16,    687,      "RPM",      1.00000,   0.00000,  0.00,  15000.0,      0 ; * (  2 bytes)
      flats_deg       = scalar,  S16,    689,      "deg",      0.10000,   0.00000, -90.0,  180.00,      2 ; * (  2 bytes)
      flats_hrd       = scalar,  S16,    691,      "RPM",      1.00000,   0.00000,  0.00,  15000.0,      0 ; * (  2 bytes)
      staged_pri_size = scalar,  U16,    693,      "cc",       1.00000, 0.00000, 0.0000, 15000.0,      0 ; * ( 2 bytes)
      staged_sec_size = scalar,  U16,    695,      "cc",       1.00000, 0.00000, 0.0000, 15000.0,      0 ; * ( 2 bytes)
      staged_first_param = bits, U08,   697,   [0:2], "Off", "RPM", "MAP", "TPS", "Duty", "Table", "INVALID", "INVALID"
      staged_second_param = bits, U08, 697,    [3:5], "Off", "RPM", "MAP", "TPS", "Duty", "INVALID", "INVALID", "INVALID"
      staged_transition_on = bits, U08, 697,   [6:6], "Off", "On"
      staged_second_logic = bits, U08, 697,   [7:7], "OR", "AND"
      staged_transition_events = scalar, U08, 698, "ign events", 1.00000, 0.00000, 0.00, 255.0,  0
      staged_param_1 = scalar, U16, 699, "units", 1.00000, 0.00000, 0.00, 25500.0, 0
      staged_param_2 = scalar, U16, 701, "units", 1.00000, 0.00000, 0.00, 25500.0, 0
      staged_hyst_1 = scalar, U16, 703, "units", 1.00000, 0.00000, 0.00, 25500.0, 0
      staged_hyst_2 = scalar, U16, 705, "units", 1.00000, 0.00000, 0.00, 25500.0, 0

; Nitrous System
      N2Oopt_01   = bits,   U08, 707,[0:1],"INVALID","Bank1", "Bank2", "Both"
      N2Oopt_2    = bits,   U08, 707,[2:2], "Off", "On"
      N2Oopt_3    = bits,   U08, 707,[3:3], "Off", "On"
#if MICROSQUIRT_FULL
      N2Oopt_pins = bits,   U08, 707,[4:6], "Flex", "INVALID", "INVALID", "INVALID", "SpareADC", "INVALID", "INVALID" "INVALID"
      N2Oopt_pins2 = bits,   U08, 707,[7:7], "INVALID", "FIDLE+WLED"
#else
#if MICROSQUIRT_MODULE
      N2Oopt_pins = bits,   U08, 707,[4:6], "Flex", "PE1", "INVALID", "PA0", "SpareADC", "SPAREADC2", "INVALID" "INVALID"
      N2Oopt_pins2 = bits,   U08, 707,[7:7], "PT7+6", "FIDLE+WLED"
#else
      N2Oopt_pins = bits,   U08, 707,[4:6], "PE0/JS7", "PE1", "JS10", "JS11", "JS5", "JS4", "INVALID" "INVALID"
      N2Oopt_pins2 = bits,   U08, 707,[7:7], "IAC1+2", "FIDLE+D15"
#endif
#endif
      N2ORpm        = scalar, U16, 708, "RPM",   1, 0, 1000, 25000, 0
      N2ORpmMax     = scalar, U16, 710, "RPM",   1, 0, 1000, 25000, 0
      N2OTps        = scalar, S16, 712, "%", 0.10000,   0.00000,  0.00,  100.00,      1;
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      N2OClt        = scalar, S16, 714,             "°C",       0.05555,  -320.000, -40.0,  230.0,      1 ; * (  2 bytes)
	#else
      N2OClt        = scalar, S16, 714,             "°C",       0.05555,  -320.000, -40.0,  150.0,      1 ; * (  2 bytes)
	#endif
#else
	#if EXPANDED_CLT_TEMP
      N2OClt        = scalar, S16, 714,             "°F",       0.10000,   0.00000, -40.0,  450.0,      1
	#else
      N2OClt        = scalar, S16, 714,             "°F",       0.10000,   0.00000, -40.0,  300.0,      1
	#endif
#endif
      N2OAngle      = scalar, S16, 716,             "deg",      0.10000,   0.00000, 0,  50,      2 ; * (  2 bytes)

      N2OPWLo       = scalar, U16, 718, "ms",  0.001, 0, 0, 25, 3
      N2OPWHi       = scalar, U16, 720, "ms",  0.001, 0, 0, 25, 3

;nitrous/launch
      N2Odel_launch = scalar, U08,   722,       "s",         0.01, 0, 0, 2.55, 2
      N2Odel_flat   = scalar, U08,   723,       "s",         0.01, 0, 0, 2.55, 2
      N2Oholdon     = scalar, U08,   724,       "s",         0.01, 0, 0, 2.55, 2

;nitrous stage 2
; Nitrous System
      N2O2Rpm       = scalar, U16, 725, "RPM",   1, 0, 1000, 25000, 0
      N2O2RpmMax    = scalar, U16, 727, "RPM",   1, 0, 1000, 25000, 0
      N2O2delay     = scalar, U08, 729, "s", 0.01, 0, 0, 2.55,2
      N2O2Angle     = scalar, S16, 730,             "deg",      0.10000,   0.00000, 0,  50,      2 ; * (  2 bytes)
      N2O2PWLo      = scalar, U16, 732, "ms",  0.000666, 0, 0, 25, 3
      N2O2PWHi      = scalar, U16, 734, "ms",  0.000666, 0, 0, 25, 3

;user defined
; these are not used by the code and are provided for users to use and learn from
; if you want to add more... you also have to make matching changes in ms2_extra.h
; and ms2_extra_main.c
; note that it you add an 'int' that two bytes are consumed and two of the following
; spare array will need to be removed!
    user_value1      = scalar, U16, 736, "",   1, 0, 0, 65535, 0
    user_value2      = scalar, U16, 738, "",   1, 0, 0, 65535, 0
    user_conf0       = bits, U08, 740, [0:0], "Off", "On"
    user_conf1       = bits, U08, 740, [1:2], "Mode 0", "Mode 1", "Mode 2", "Mode 3"
;end user defined
    staged_secondary_enrichment = scalar, U16, 741, "ms", 0.001, 0, 0, 10, 3
    staged_percents = array, U08, 743, [6x6], "%", 1, 0, 0, 100, 0
    staged_rpms = array, U16, 779, [6], "rpm", 1, 0, 0, 16000, 0
    staged_loads = array, S16, 791, [6], "%", 0.1000, 0, 0, 250, 0
    N20remote_input  = bits, U08, 803, [0:0], "Local", "Remote"
    N20remote_output = bits, U08, 803, [1:1], "Local", "Remote"
    N20remote_inport = bits, U08, 803, [2:4], "Remote Port3 Bit 0", "Remote Port3 Bit 1", "Remote Port3 Bit 2", "Remote Port3 Bit 3", "Remote Port3 Bit 4", "Remote Port3 Bit 5", "Remote Port3 Bit 6", "Remote Port3 Bit 7"
    N20remote_outport = bits, U08, 803, [5:7], "Remote Port1 Bits 0+1", "Remote Port1 Bits 1+2", "Remote Port1 Bits 2+3", "Remote Port1 Bits 3+4", "Remote Port1 Bits 4+5", "Remote Port1 Bits 5+6", "Remote Port1 Bits 6+7", "INVALID"
 
;doubt the "anti-lag" nitrous will be implemented

;gaps
      RotarySplitTable = array, S16,  807,    [8x8], "deg",  0.10000, 0.00000, -20, 20, 1
      RotarySplitLoad = array, U16,   935, [ 8 ], "%", 0.10000, 0.00000, 0, 65535, 0
      RotarySplitRPM = array, U16,  951, [ 8 ], "RPM", 1, 0.00000, 0, 65535, 0
      RotarySplitModeFD = bits, U08, 967, [0:0], "FC mode", "FD mode"
      RotarySplitModeNeg = bits, U08, 967, [1:1], "Not Allowed", "Allowed"
      RotarySplitModeRX8 = bits, U08, 967, [2:2], "Disabled", "RX8 mode"
      RotarySplitModeOn  = bits, U08, 967, [5:5], "Rotary off", "Rotary on"
      NoiseFilterRpm = array, U16, 968, [  4], "RPM",      1, 0.00000, 0.00, 65535,  0
      NoiseFilterLen = array, U16, 976, [  4], "usec",     0.66667, 0.00000, 0.00, 43000, 1
     
      staged_primary_delay = scalar, U08, 985, "ign events", 1, 0, 0, 30, 0
      VariableLagTPSBins = array,  U08,  986, [4], "%/sec", 1, 0.000000, 0.00, 255.00, 0
      VariableLagMapLags = array,  U08,  990, [4], "Lag", 1, 0.000000, 0.00, 255.00, 0
      trig_init      = scalar, U08, 1003, "", 1,0,0,255,0
      inj_time_mask  = scalar, U08, 1004, "", 1,0,0,100,0

page = 4
      testmodelock = scalar, U16, 0, "", 1,0,0,65535,0, noLocalUpdate
#if MICROSQUIRT_FULL
      testop_coil = bits, U08, 2, [0:2], "CoilA", "CoilB", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID"
#else
#if MICROSQUIRT_MODULE
      testop_coil = bits, U08, 2, [0:2], "CoilA", "CoilB", "CoilC", "CoilD", "INVALID", "INVALID", "INVALID", "INVALID"
#else
      testop_coil = bits, U08, 2, [0:2], "CoilA", "CoilB", "CoilC", "CoilD", "CoilE", "CoilF", "INVALID", "INVALID"
#endif
#endif
      testop_fp   = bits, U08, 2, [4:4], "Off", "On"
      testop_inj  = bits, U08, 2, [5:6], "Neither", "Inj1", "Inj2", "Both"
      testop_pwm  = bits, U08, 2, [7:7], "Standard", "As below"

      testdwell    = scalar, U08, 3, "ms", 0.1,0,0,25.5,0
      testint      = scalar, U16, 4, "ms", 0.128,0,0,8388,1
      testmode     = bits,   U08, 6, [0:1],  "Off", "Coils", "Injectors", "INVALID"
      test_addinj  = bits,   U08, 6, [4:5],  "Neither", "Inj3", "Inj4", "Both"
      testpw       = scalar, U16, 7,             "ms",       0.0006660,   0.00000,  0,   43,      3 ; * (  1 byte)
      testinjcnt   = scalar, U16, 9, "", 1,0,0,65535,0
      advanceTable3   = array ,  S16,    011,    [12x12], "deg",      0.10000,   0.00000,-10.00,   90.00,      1 ; * (288 bytes)
      srpm_table3     = array ,  U16,    299,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      smap_table3     = array ,  S16,    323,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      testinjPwmT     = scalar,  U08,    347,             "ms",       0.12800,   0.12800,  0.00,   32.64,      1 ; * (  1 byte)
      testinjPwmPd    = scalar,  U08,    348,             "us",       1.00000,   0.00000, 40.00,  100.00,      0 ; * (  1 byte)
      testinjPwmP     = scalar,  U08,    349,             "%",        1.00000,   0.00000,  0.00,  100.00,      0 ; * (  1 byte)
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      RevLimLookup    = array ,  S16,    350,    [    8], "°C",       0.05555,  -320.000,-40.00,  230.00,      1 ; * ( 16 bytes) 
	#else
      RevLimLookup    = array ,  S16,    350,    [    8], "°C",       0.05555,  -320.000,-40.00,  150.00,      1 ; * ( 16 bytes)
	#endif
#else
	#if EXPANDED_CLT_TEMP
      RevLimLookup    = array ,  S16,    350,    [    8], "°F",       0.10000,   0.00000,-40.00,  450.00,      1 ; * ( 16 bytes) 
	#else
      RevLimLookup    = array ,  S16,    350,    [    8], "°F",       0.10000,   0.00000,-40.00,  300.00,      1 ; * ( 16 bytes) 
	#endif
#endif
      RevLimRpm1      = array ,  U16,    366,    [    8], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 16 bytes)
      iacpostest     = scalar, U16, 382, "steps", 1,0,0,65535,0
      iachometest      = scalar, U16, 384, "steps", 1,0,0,65535,0
      iactest         = bits, U08, 386, [0:0], "run", "home" ; // home the valve
      iactestlock     = bits, U08, 386, [1:1], "Off", "On" ; // Enable
      idleadvance_on  = bits, U08, 387, [0:0], "Off", "On" ;
      idleadvance_tps = scalar, S16, 388, "%", 0.1, 0, 0, 100, 1
      idleadvance_rpm = scalar, S16, 390, "rpm", 1, 0, 0, 3000, 0
      idleadvance_load = scalar, S16, 392, "%", 0.1, 0, 0, 100, 0
#if CELSIUS
	#if EXPANDED_CLT_TEMP
      idleadvance_clt = scalar, S16, 394, "°C", 0.05555, -320, -40, 230.00, 1
	#else
      idleadvance_clt = scalar, S16, 394, "°C", 0.05555, -320, -40, 150.00, 1
	#endif
#else
	#if EXPANDED_CLT_TEMP
      idleadvance_clt = scalar, S16, 394, "°F", 0.10000, 0.00000, -40, 450, 1
	#else
      idleadvance_clt = scalar, S16, 394, "°F", 0.10000, 0.00000, -40, 300, 1
	#endif
#endif
      idleadvance_delay = scalar, U08, 396, "sec", 1, 0, 0, 5, 0
      idleadvance_curve = array, S16, 397, [ 4 ],  "deg", 0.10000, 0.00000, -10.00, 90.00, 1 
      idleadvance_loads = array, S16, 405, [ 4 ],  "%", 0.10000, 0.00000, 0, 100, 1
;      feature413_dbg = bits, U08, 413, [0:0], "Off", "On"
;      feature413_missdbg = bits, U08, 413, [1:1], "Off", "On"
      
;      seq_inj         = bits, U08, 415, [0:1], "Untimed injection", "INVALID", "Semi-sequential Siamese", "INVALID" ;	
      seq_inj         = bits, U08, 415, [0:1], "Untimed injection", "Sequential/Semi-sequential", "Semi-sequential Siamese", "Sequential Siamese" ;	
;      seq_inj         = bits, U08, 415, [0:1], "Untimed injection", "INVALID", "Semi-sequential Siamese", "Sequential Siamese" ;	
#if MICROSQUIRT_FULL
      extrainj        = bits, U08, 415, [2:2], "Standard drivers", "INVALID" ;	
#else ;inckuding the Microsquirt module
      extrainj        = bits, U08, 415, [2:2], "Standard drivers", "Additional drivers" ;	
#endif
      injdualvalue    = bits, U08, 415, [3:3], "Single value", "Dual values" ;	
      usevetrim       = bits, U08, 415, [4:4], "Don't use VE Trim Tables", "Use VE Trim Tables" ;	
      injusetable    = bits, U08, 415, [5:5], "Fixed Timing", "Use table" ;	
      injtimingmode   = bits, U08, 415, [6:7], "Start-of-pulse", "Mid-pulse", "End-of-pulse", "INVALID" ;	
      injadv1         = scalar,  S16,    416,             "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * (  2 bytes)	
      injadv2         = scalar,  S16,    418,             "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * (  2 bytes)	
      injadv3         = scalar,  S16,    420,             "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * (  2 bytes)	
      injstagedadv1   = scalar,  S16,    422,             "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * (  2 bytes)	
      injstagedadv2   = scalar,  S16,    424,             "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * (  2 bytes)	
      injstagedadv3   = scalar,  S16,    426,             "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * (  2 bytes)	
      injadvTable1    = array ,  S16,    428,    [  6x6], "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * ( 72 bytes)	
      injadvTable2    = array ,  S16,    500,    [  6x6], "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * ( 72 bytes)	
      srpm_injadv1    = array ,  U16,    572,    [    6], "RPM",      1.00000,   0.00000,    0.00,15000.00,      0 ; * ( 12 bytes)	
      srpm_injadv2    = array ,  U16,    584,    [    6], "RPM",      1.00000,   0.00000,    0.00,15000.00,      0 ; * ( 12 bytes)	
      smap_injadv1    = array ,  S16,    596,    [    6],   "%",      0.10000,   0.00000,    0.00,  400.00,      1 ; * ( 12 bytes)	
      smap_injadv2    = array ,  S16,    608,    [    6],   "%",      0.10000,   0.00000,    0.00,  400.00,      1 ; * ( 12 bytes)	
      injcrankadv1    = scalar,  S16,    620,             "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * (  2 bytes)	
      injcrankadv2    = scalar,  S16,    622,             "deg",      0.10000,   0.00000, -360.00,  720.00,      1 ; * (  2 bytes)	
      hybrid_rpm      = scalar,  U16,    624,             "RPM",      1.00000,   0.00000,    0.00,15000.00,      0 ; * (  2 bytes)	
      hybrid_hyst     = scalar,  U16,    626,             "RPM",      1.00000,   0.00000,    0.00,15000.00,      0 ; * (  2 bytes)	
      injOpen3        = scalar,  U16,    628,             "ms",       0.001,   0.00000,  0.00,   25.50,      3 ; * (  1 byte)
      battFac3        = scalar,  U16,    630,             "ms/v",     0.000166667,       0.0,   0.0,     1.0,      3 ; * (  1 byte)
      injOpen4        = scalar,  U16,    632,             "ms",       0.001,   0.00000,  0.00,   25.50,      3 ; * (  1 byte)
      battFac4        = scalar,  U16,    634,             "ms/v",     0.000166667,       0.0,   0.0,     1.0,      3 ; * (  1 byte)
      veTrim1         = array ,  S08,    636,      [16x16], "%",   0.0976562500, 1024.0000,   87.60,  112.40,      1 ; * (256 bytes)
      frpm_trim1      = array ,  U16,    892,      [   16], "RPM",      1.00000,   0.00000,    0.00,15000.00,      0 ; * ( 32 bytes)
      fmap_trim1      = array ,  S16,    924,      [   16], "%",        0.10000,   0.00000,    0.00,  400.00,      1 ; * ( 32 bytes)

      veTrim1dozen    = array ,  S08,    636,      [12x12], "%",   0.0976562500, 1024.0000,   87.60,  112.40,      1 ; * (144 bytes)
      frpm_trim1doz   = array ,  U16,    892,      [   12], "RPM",      1.00000,   0.00000,    0.00,15000.00,      0 ; * ( 24 bytes)
      fmap_trim1doz   = array ,  S16,    924,      [   12], "%",        0.10000,   0.00000,    0.00,  400.00,      1 ; * ( 24 bytes)

      ; The following is presently only used by TunerStudio

      ; Used to store sensor calibration settings last written to the controller
      sen_calib_table_id = array,  U08, 968, [   2],   "id",   1.0,  0.0,   0,    255, 0 ; (2 bytes)
      sen_calib_units       = array,  U08, 970, [   2],   "id",   1.0,  0.0,   0,    255, 0 ; (2 bytes)
      sen_calib_bias     = array,  U32, 972, [   2], "ohms",     1,    0,   0, 100000, 0 ; (8 bytes)
      sen_calib_temp     = array,  S16, 980, [ 2x3],  "deg",   0.1,    0, -40,    400, 1 ; (12 bytes)
      sen_calib_res1     = array,  U32, 992, [ 2x3], "ohms",     1,    0,   0, 100000, 0 ; (24 bytes )

      ; The index of the selected EGO sensor as defined in the solutions section of the 
      ; ReferenceTable section of the ini, this may also be found in the ms2ReferenceTables.ini 
      ; file found in the inc dir of your TunerStudio installation.
      ego_calib_selection= scalar, U08, 1016,          "index",  1.0,  0.0, 0.0,  255, 0 ; * (  1 byte)
      ego_calib_volts    = array,  U08, 1017, [   3],  "Volts",  0.1,  0.0, 0.0,  5.0, 1 ; (3 bytes)
      ego_calib_afrs     = array,  U08, 1020, [   3],  "AFR",    0.1,  0.0, 5.0, 25.0, 1 ; (3 bytes)
      
page = 5
      veTable1        = array ,  U08,      0,      [16x16], "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * (144 bytes)
      veTable2	      = array ,  U08,      256,    [16x16], "%",        1.00000,   0.00000,  0.00,  255.00,      0 ;
      veTable3	      = array ,  U08,      512,    [16x16], "%",        1.00000,   0.00000,  0.00,  255.00,      0 ;

      frpm_table1     = array ,  U16,    768,    [   16], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      frpm_table2     = array ,  U16,    800,    [   16], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      frpm_table3     = array ,  U16,    832,    [   16], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      fmap_table1     = array ,  S16,    864,    [   16], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      fmap_table2     = array ,  S16,    896,    [   16], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      fmap_table3     = array ,  S16,    928,    [   16], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)

;same tables again but smaller - start in different places to 16x16
      veTable1dozen   = array ,  U08,      0,      [12x12], "%",        1.00000,   0.00000,  0.00,  255.00,      0 ; * (144 bytes)
      veTable2dozen   = array ,  U08,      144,    [12x12], "%",        1.00000,   0.00000,  0.00,  255.00,      0 ;
      veTable3dozen   = array ,  U08,      288,    [12x12], "%",        1.00000,   0.00000,  0.00,  255.00,      0 ;
      frpm_table1doz  = array ,  U16,    768,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      frpm_table2doz  = array ,  U16,    792,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      frpm_table3doz  = array ,  U16,    816,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      fmap_table1doz  = array ,  S16,    864,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      fmap_table2doz  = array ,  S16,    888,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      fmap_table3doz  = array ,  S16,    912,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      MAFFlow       = array, U16,    960,  [12], "g/sec", 0.01000,   0.00000,  0.00,   650.0,      1
      MAFCor        = array, U08,    984,  [12], "%", 1.00000,   0.00000,  0.00,   255.0,      0

page = 6
      veTrim2         = array ,  S08,      0,      [16x16], "%",   0.0976562500, 1024.0000,   87.60,  112.40,    1 ; * (256 bytes)
      veTrim3         = array ,  S08,      256,    [16x16], "%",   0.0976562500, 1024.0000,   87.60,  112.40,    1 ;
      veTrim4         = array ,  S08,      512,    [16x16], "%",   0.0976562500, 1024.0000,   87.60,  112.40,    1 ;

      frpm_trim2      = array ,  U16,    768,    [   16], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 32 bytes)
      frpm_trim3      = array ,  U16,    800,    [   16], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 32 bytes)
      frpm_trim4      = array ,  U16,    832,    [   16], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 32 bytes)
      fmap_trim2      = array ,  S16,    864,    [   16], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 32 bytes)
      fmap_trim3      = array ,  S16,    896,    [   16], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 32 bytes)
      fmap_trim4      = array ,  S16,    928,    [   16], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 32 bytes)

;same tables again but smaller - start in different places to 16x16
      veTrim2dozen    = array ,  S08,      0,      [12x12], "%",   0.0976562500, 1024.0000,   87.60,  112.40,    1 ; * (144 bytes)
      veTrim3dozen    = array ,  S08,      144,    [12x12], "%",   0.0976562500, 1024.0000,   87.60,  112.40,    1 ;
      veTrim4dozen    = array ,  S08,      288,    [12x12], "%",   0.0976562500, 1024.0000,   87.60,  112.40,    1 ;
      frpm_trim2doz   = array ,  U16,    768,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      frpm_trim3doz   = array ,  U16,    792,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      frpm_trim4doz   = array ,  U16,    816,    [   12], "RPM",      1.00000,   0.00000,  0.00,15000.00,      0 ; * ( 24 bytes)
      fmap_trim2doz   = array ,  S16,    864,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      fmap_trim3doz   = array ,  S16,    888,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      fmap_trim4doz   = array ,  S16,    912,    [   12], "%",      0.10000,   0.00000,  0.00,  400.00,      1 ; * ( 24 bytes)
      ITB_load_loadvals= array,  S16,     960,    [   10], "%",         0.10000,   0.000, 0,     100.00,      1
      ITB_load_switchpoints = array,S16,  980,    [   10], "%",         0.10000,   0.000, 0,     100.00,      1
      ITB_load_rpms = array,     U16,     1000,   [   10], "rpm",       1.0000,    0.000, 0,     16000,       0


[Menu]

   ;----------------------------------------------------------------------------
   ;  There are five pre-defined values that may be used to define your menus.
   ;  The first four allow access to the "standard" dialog boxes, the last one
   ;  merely draws a separator (horizontal line) in the menu.
   ;
   ;     std_constants
   ;     std_enrichments
   ;     std_realtime
   ;     std_warmup
   ;     std_accel
   ;
   ;     std_separator
   ;
   ;  Additionally, to support MegaSquirt-II firmware, there are two standard
   ;  dialogs to generate its three embedded tables.  The first of these acts
   ;  like Roger Enns' EasyTherm, but only works for MS-II.  The second one
   ;  generates the internal AFR table required for proper closed loop operation
   ;  in MS-II.  Use these without page numbers, as they will just be ignored
   ;  in any case.
   ;
   ;     std_ms2gentherm
   ;     std_ms2geno2
   ;
   ;  If you use any of the std_constants, std_enrichments or std_warmup
   ;  editors, they may be optionally suffixed with a page number (only
   ;  useful for multi-page code variants), which causes them to edit the
   ;  specified page.  If you leave off the page specifier, they edit logical
   ;  page one as specified in the Constants section.
   ;
   ;  There are four special menu names, which when used append to the standard
   ;  menus of the same name instead of creating a new one.  The menu names
   ;  are "File", "Communications", "Tools" and "Help".
   ;
   ;----------------------------------------------------------------------------

   menuDialog = main
      menu = "&Basic setup"
        subMenu = std_injection,   "Engine constants"
	subMenu = secondaryLoad,   "More Engine constants"
        subMenu = ITB_load_switchpoint_curve, "ITB load switchpoints", 0, { algorithm == 6 || algorithm2 == 6 || IgnAlgorithm == 6 || IgnAlgorithm2 == 6 || afrload == 6 || eaeload == 6 }
        subMenu = ITB_load_loadvals_curve, "ITB loads at switchpoints", 0, { algorithm == 6 || algorithm2 == 6 || IgnAlgorithm == 6 || IgnAlgorithm2 == 6 || afrload == 6 || eaeload == 6 }
        subMenu = injChars,        "I&njector Characteristics"
        subMenu = std_separator    ;----------------------------------------------
        subMenu = ignitionOptions, "Tach input/&Ignition settings", 0
	    subMenu = moreIgnitionOptions, "More Ignition Settings", 0, { spk_mode0 != 31 }
        subMenu = advign,          "Noise Filtering - EDIS", 0, { spk_mode0 < 2 }
        subMenu = noisefiltering,  "Noise Filtering", 0, {spk_mode0 > 1} 
        subMenu = NoiseFiltercurve, "Noise Filter Curve", 0, { NoiseFilterOpts & 1 }
        subMenu = triggerWheel,    "&Trigger Wheel Settings", 0, { (userlevel > 127) && (spk_mode0 == 4) }
        subMenu = RotaryTrailingSettings, "Rotary Settings", 0, { (spk_mode0 != 31) }
        subMenu = RotarySplitTbl,  "Rotary Split Table", 0, { RotarySplitModeOn && (spk_mode0 != 31) }
        subMenu = std_separator
        subMenu = veTable1Tbl,     "Fuel VE Table &1", 0,{ (feature4_0VEtblsize==0) }
        subMenu = veTable1Tbldoz,  "Fuel VE Table &1",0, { feature4_0VEtblsize }
        subMenu = afrTable1Tbl,    "A&FR Table 1",         0
        subMenu = ignitionTbl1,     "&Ignition Table1", 0, { (userlevel > 63) && (spk_mode0 != 31) }

        subMenu = veTable2Tbl,     "Fuel VE Table &2",          0, { ((dualTable && userlevel > 127) || (algorithm2 != 0)) && (feature4_0VEtblsize==0) }
        subMenu = veTable2Tbldoz,     "Fuel VE Table &2",          0, { ((dualTable && userlevel > 127) || (algorithm2 != 0)) && (feature4_0VEtblsize) }
        subMenu = afrTable2Tbl,    "AF&R Table 2",         0, { dualTable && userlevel > 127}
        subMenu = ignitionTbl2,     "Ignition Table2", 0, { (userlevel > 127) && (IgnAlgorithm2 !=0) && (spk_mode0 != 31)}
        subMenu = std_separator    ;----------------------------------------------
        subMenu = generalSettings, "&General, lags"
        subMenu = revlimiter, "Rev Limiter"
        subMenu = revlimiterBins, "CLT-Based Rev Limit", 0, { (RevLimCLTbased & 1) }
        subMenu = std_separator    ;----------------------------------------------
        subMenu = egoControl,      "&EGO Control"
        subMenu = userlevel, "Basic/Advanced user"

      menu = "&Startup/idle"
        subMenu = crsettings,      "Cranking settings",  0
        subMenu = primingPW,       "Pri&ming Pulse",       0
        subMenu = crankingPW,      "Cra&nking Pulse",      0
        subMenu = asePct,          "A&SE Percentage",      0
        subMenu = aseTaper,        "AS&E Taper",           0
        subMenu = idleControl,     "I&dle Control"
        subMenu = pwmidle_crank_dutyorsteps_dutycurve, "PWM idle cranking duty", 0, {IdleCtl == 4 || IdleCtl == 6}
        subMenu = pwmidle_crank_dutyorsteps_stepscurve, "IAC idle cranking steps", 0, {IdleCtl == 2 || IdleCtl == 3 || IdleCtl == 5 || IdleCtl == 7 || IdleCtl == 8}
        subMenu = iacBins,         "I&dle Steps",          0, { IdleCtl == 2 || IdleCtl == 3 || IdleCtl == 5 }
        subMenu = ipwset,         "Idle &PWM Settings",   0, { IdleCtl == 4 || IdleCtl == 6 }
        subMenu = ipwBins,         "I&dle PWM duty Table",0, { IdleCtl == 4 }
        subMenu = pwmidle_closedloop, "Closed-loop idle valve settings", 0, { IdleCtl == 6 || IdleCtl == 7 || IdleCtl == 8 }
	subMenu = pwmidle_PID, "Closed-loop idle PID settings", 0, { IdleCtl == 6 || IdleCtl == 7 || IdleCtl == 8 }
        subMenu = pwmidle_target_curve, "Closed-loop idle target rpm curve", 0, { IdleCtl == 6 || IdleCtl == 7 || IdleCtl == 8 }
        subMenu = warmup_curve,      "&Warmup Enrichment",       0


      menu = "Accel Enrich", { userlevel > 127 }
         subMenu = accelsettings,   "Accel Enrich settings"
         subMenu = std_accel,       "&Acceleration Wizard", 0
         subMenu = EAEBAWCcurve,   "EAE Adhere-to-walls constant", 0, {      EAEOption > 0 }
	 subMenu = EAEBSOCcurve,   "EAE Sucked-from-walls constant", 0, {EAEOption > 0}
	 subMenu = EAEAWNcurve,   "EAE Adhere-to-walls rpm correction", 0, {EAEOption > 0}
	 subMenu = EAESONcurve,   "EAE Sucked-from-walls rpm correction", 0, {EAEOption > 0}
         subMenu = EAEAWWcurve,   "EAE Adhere-to-walls CLT correction", 0, {EAEOption > 0}
         subMenu = EAESOWcurve,   "EAE Sucked-from-walls CLT correction", 0, {EAEOption > 0}
	 subMenu = EAElagcomp,    "EAE lag compensation settings", 0, {EAEOption == 3}

      menu = "&Extended", { userlevel > 127 }
         subMenu = std_port_edit,   "&Output port Settings"
         subMenu = barometerCorr,   "Barometric Correction"
         subMenu = coldAdvance,     "&Cold Advance", 0, { spk_mode0 != 31 }
         subMenu = matBasedRetard,  "MAT-&Based Timing Retard", 0, { spk_mode0 != 31 }
         subMenu = manifoldTempCorr,"MAT Correction table", 0
         subMenu = MATCorrval,      "MAT Correction value", 0
         subMenu = flexFuelSettings,"&Flex Fuel"
         subMenu = knockSettings,   "&Knock Sensor Settings"
         subMenu = overrun,        "Over Run Fuel cut"
	 subMenu = staging,        "Staged Injection"
         subMenu = stagedTable,    "Staged Injection Table", 0, { ((staged_first_param & 0x7) == 5) }
         subMenu = tacho,          "Tacho output"
         subMenu = launch,          "Launch Control"
         subMenu = tablesw,         "Table Switching control"
         subMenu = veTable3Tbl,     "Fuel VE Table 3", 0, {(feature4_0VEtblsize==0) && ((f5_0_tsf>0) || (seq_inj == 3)) && (userlevel > 127) }
         subMenu = veTable3Tbldoz,  "Fuel VE Table 3", 0, {(feature4_0VEtblsize==1) && ((f5_0_tsf>0) || (seq_inj == 3)) && (userlevel > 127) }
         subMenu = ignitionTbl3,     "Ignition Table3", 0, {(f5_0_tss>0) && (userlevel > 127)}
         subMenu = N2OSystem,    "&Nitrous System"
         subMenu = N2OSystem2,   "&Nitrous Stage 2",              0, { N2Oopt_2 && N2Oopt_3 }
	 subMenu = overboost,    "Overboost Protection"
         subMenu = idleAdvance,  "Idle Advance Settings"
         subMenu = idleAdvance_curve, "Idle Advance Timing",  0, { idleadvance_on }

      menu = "&Advanced", {userlevel > 191 }
         subMenu = dwellSettings,   "D&well battery correction", 0, { spk_mode0 != 31 }
;         subMenu = amcSettings,     "Automatic &Mixture Control", 0, { 1 == 0 } ; disabled
	 subMenu = boostctlSettings, "Boost Control Settings"
	 subMenu = boostctlDutys, "Boost Control Duty Table", 0, { (boost_ctl_settings_on) && (!boost_ctl_settings_cl) }
	 subMenu = boostctlTargs, "Boost Control Target Table", 0, { (boost_ctl_settings_on == 1) && (boost_ctl_settings_cl == 1) }
         subMenu = canparams, "CAN parameters"
         subMenu = rmt_port_edit,   "Remote Output port Settings", 0, { (can_poll == 3) && (enable_pollports) && (ports_dir) && (port_generic) }
         subMenu = std_separator    ;----------------------------------------------
         subMenu = experimental, "Experimental"
         subMenu = outputtest, "Output test mode"
         subMenu = iactest, "Idle valve test"
         subMenu = injseq, "Injector Sequence"
;      subMenu = userdefined, "User defined menu" ; uncomment this line to enable
         subMenu = std_separator    ;----------------------------------------------
         subMenu = mafdialog, "MAF Options", 0, { algorithm == 5 || algorithm2 == 5 }
         subMenu = MAFtable1, "MAF correction curve", 0, { algorithm == 5 || algorithm2 == 5 }
         subMenu = std_separator
         subMenu = seq_injection, "Sequential injection"
         subMenu = injTiming1Tbl, "Injection Timing Table 1", 0, { (seq_inj) && (injusetable) }
         subMenu = injTiming2Tbl, "Injection Timing Table 2", 0, { (seq_inj == 3) && (injusetable) && (injdualvalue) }
         subMenu = injTiming3Tbl, "Injection Timing Table 3", 0, { (seq_inj == 3) && (injusetable) }
#if INI_VERSION_2
         subMenu = veTrim1Tbl,     "Fuel VE Trim Table 1", 0,{ (feature4_0VEtblsize==0) && usevetrim }
         subMenu = veTrim1Tbldoz,  "Fuel VE Trim Table 1",0, { feature4_0VEtblsize && usevetrim }
         subMenu = veTrim2Tbl,     "Fuel VE Trim Table 2", 0,{ (feature4_0VEtblsize==0) && usevetrim }
         subMenu = veTrim2Tbldoz,  "Fuel VE Trim Table 2",0, { feature4_0VEtblsize && usevetrim }
         subMenu = veTrim3Tbl,     "Fuel VE Trim Table 3", 0,{ (feature4_0VEtblsize==0) && usevetrim && extrainj }
         subMenu = veTrim3Tbldoz,  "Fuel VE Trim Table 3",0, { feature4_0VEtblsize && usevetrim && extrainj }
         subMenu = veTrim4Tbl,     "Fuel VE Trim Table 4", 0,{ (feature4_0VEtblsize==0) && usevetrim && extrainj }
         subMenu = veTrim4Tbldoz,  "Fuel VE Trim Table 4",0, { feature4_0VEtblsize && usevetrim && extrainj }
#endif

   menuDialog = main
      menu = "&Tuning"
         subMenu = std_realtime,    "&Realtime Display"
         subMenu = std_separator    ;----------------------------------------------
         subMenu = std_accel,       "&Acceleration Wizard", 0
;16x16
         subMenu = veTable1Map,     "Fuel VE Table &1",0 { (feature4_0VEtblsize==0) }
         subMenu = veTable2Map,     "Fuel VE Table &2",  0, { ((dualTable && (userlevel > 127)) || (algorithm2 != 0)) && (feature4_0VEtblsize==0) }
         subMenu = veTable3Map,     "Fuel VE Table &3",  0, { (userlevel > 127) && (f5_0_tsf || (seq_inj == 3)) && (feature4_0VEtblsize==0) }
#if INI_VERSION_2
         subMenu = veTrim1Map,      "Fuel VE Trim Table 1",0 { (feature4_0VEtblsize==0) && usevetrim }
         subMenu = veTrim2Map,      "Fuel VE Trim Table 2",0 { (feature4_0VEtblsize==0) && usevetrim }
         subMenu = veTrim3Map,      "Fuel VE Trim Table 3",0 { (feature4_0VEtblsize==0) && usevetrim && extrainj }
         subMenu = veTrim4Map,      "Fuel VE Trim Table 4",0 { (feature4_0VEtblsize==0) && usevetrim && extrainj }
#endif
;12x12
         subMenu = veTable1Mapdoz,     "Fuel VE Table &1",0, { (feature4_0VEtblsize==1) }
         subMenu = veTable2Mapdoz,     "Fuel VE Table &2",0, { ((dualTable && (userlevel > 127)) || (algorithm2 != 0)) && (feature4_0VEtblsize==1) }
         subMenu = veTable3Mapdoz,     "Fuel VE Table &3",          0, { (userlevel > 127) && (f5_0_tsf || (seq_inj == 3)) && (feature4_0VEtblsize==1) }
#if INI_VERSION_2
         subMenu = veTrim1Mapdoz,      "Fuel VE Trim Table 1",0, { (feature4_0VEtblsize==1) && usevetrim }
         subMenu = veTrim2Mapdoz,      "Fuel VE Trim Table 2",0, { (feature4_0VEtblsize==1) && usevetrim }
         subMenu = veTrim3Mapdoz,      "Fuel VE Trim Table 3",0, { (feature4_0VEtblsize==1) && usevetrim && extrainj }
         subMenu = veTrim4Mapdoz,      "Fuel VE Trim Table 4",0, { (feature4_0VEtblsize==1) && usevetrim && extrainj }
#endif
         subMenu = afrTable1Map,    "A&FR Table 1",         0, { egoType >= 3              }
         subMenu = afrTable2Map,    "AF&R Table 2",         0, { egoType >= 3 && dualTable && (userlevel > 127) }
         subMenu = std_separator    ;----------------------------------------------
         subMenu = ignitionMap1,     "&Ignition Map1", 0, {(userlevel > 63) && (spk_mode0 != 31)}
         subMenu = ignitionMap2,     "&Ignition Map2", 0, {(userlevel > 127) && ((IgnAlgorithm2 != 0) || f5_0_tss) && (spk_mode0 != 31)}
	 subMenu = RotarySplitMap,   "Rotary Split Map", 0, {RotarySplitModeOn && (spk_mode0 != 31)}
	 subMenu = std_separator    ;----------------------------------------------
	 subMenu = boostctlDtyMap,   "Boost Control Duty Map", 0, {boost_ctl_settings_on && boost_ctl_settings_cl == 0}
	 subMenu = boostctlTargMap,  "Boost Control Target Map", 0, {boost_ctl_settings_on && boost_ctl_settings_cl}
	 subMenu = std_separator    ;----------------------------------------------
	 subMenu = injTiming1Map,   "Injection Timing Map 1", 0, { (seq_inj) && (injusetable) }
	 subMenu = injTiming2Map,   "Injection Timing Map 2", 0, { (seq_inj == 3) && (injusetable) && (injdualvalue) }
	 subMenu = injTiming3Map,   "Injection Timing Map 3", 0, { (seq_inj == 3) && (injusetable) }

   menuDialog = main
      menu = "Tools"
         subMenu = std_ms2gentherm, "Calibrate T&hermistor Tables..."
         subMenu = std_ms2geno2,    "Calibrate &AFR Table..."
         subMenu = sensorCal,       "&Sensor Calibration..."
         subMenu = std_trigwiz,     "Tri&gger Wizard...", 0,{ (spk_mode0 != 31) && (spk_mode0 != 4) }

      menu = "Communications"
         subMenu = setbaud, "Megasquirt baud rate", 0, { userlevel > 191}

      menu = "Help"
         subMenu = helpGeneral,     "MS-II Info"
         subMenu = sensorHelp,      "Sensor Calibration"


;-------------------------------------------------------------------------------

[UserDefined]

   dialog = mafdialog, "MAF Settings"
         field = "MAF port", MAFOption
         field = "Engine size", CID

   dialog = MATCorrval, "MAT correction value"
      field = "This value allows you to scale down the built in air"
      field = "density (MAT) correction. "
      field = "100% means that the PV=nRT ideal gas law is followed."
      field = "Lower values give less aggressive correction."
      field = "0% is not allowed as it ignores the physics completely."
      field = "(0% is interpreted as 100% for backwards compatability)"
      field = "This value and the table are used at the same time"
      field = "MAT correction scaling",              airden_scaling

   dialog = N2OSystem, "Nitrous System"
      field =   "Nitrous Control",                   N2Oopt_2
      field =   "Turn N2O on when above",            N2ORpm,        { N2Oopt_2 }
      field =   "And Coolant Temp above",            N2OClt,        { N2Oopt_2 }
      field =   "And TPS >",                         N2OTps,        { N2Oopt_2 }
      field = "Input location",                      N20remote_input, { N2Oopt_2 }
      field = "Enable input on:",                    N2Oopt_pins,   { N2Oopt_2 && !N20remote_input }
      field = "Enable input on:",                    N20remote_inport, { N2Oopt_2 && N20remote_input }
      field = "Output location",                     N20remote_output, { N2Oopt_2 }
      field = "Output pins for stage 1+2",           N2Oopt_pins2,  { N2Oopt_2 && !N20remote_output }
      field = "Output pins for stage 1+2",           N20remote_outport, { N2Oopt_2 && N20remote_output }
    ; field =   ""
      field =   "Additional Fuel PW @ N2O min rpm",  N2OPWLo,       { N2Oopt_2 }
      field =   "Max RPM",                           N2ORpmMax,     { N2Oopt_2 }
      field =   "Additional Fuel PW @ N2O Max RPM",  N2OPWHi,       { N2Oopt_2 }
      field =   "Enrich which bank in DualTable",    N2Oopt_01,     { N2Oopt_2 && dualTable }
    ; field =   ""
      field =   "If ST2 off Retard Ignition by"      N2OAngle,      { N2Oopt_2}
    ; field =   ""
      field =   "Nitrous delay after launch",        N2Odel_launch, { N2Oopt_2 && launch_opt_on    }
      field =   "Nitrous delay after flat shift",    N2Odel_flat,   { N2Oopt_2 && launch_opt_on    }
;not yet implemented field = "Nitrous fuel hold on", N2Oholdon,     { N2Oopt_2 }
      field =   ""

      field =   "Nitrous stage 2",                  N2Oopt_3,     { N2Oopt_2 }

   dialog = N2OSystem2, "Nitrous System stage 2"
      field = "Enable stage 2 above",             N2O2Rpm
      field = "Max RPM",                          N2O2RpmMax
      field = "delay after stage1",               N2O2delay
      field = "Retard Ignition by",               N2O2Angle
      field = "Additional Fuel PW @ N2O min rpm", N2O2PWLo
      field = "Additional Fuel PW @ N2O Max RPM", N2O2PWHi

    dialog = boostctlSettings, "Boost Control Settings"
      field = "Boost control Enabled",		  boost_ctl_settings_on
      field = "Solenoid Frequency",		  boost_ctl_settings_freq, { boost_ctl_settings_on && !boost_ctl_settings_remote }
      field = "Control Interval",                 boost_ctl_ms, {boost_ctl_settings_on}
      field = ""
      field = "Boost Control Location",           boost_ctl_settings_remote, { (boost_ctl_settings_on) && (can_poll == 3) && (enable_pollports) && (ports_dir) }
      field = "Boost Control Pin",                boost_ctl_pins, { boost_ctl_settings_on && !boost_ctl_settings_remote }
      field = "Boost Control Remote Port",        boost_ctl_remote, { boost_ctl_settings_on && boost_ctl_settings_remote }
      field = "Output polarity",                  boost_ctl_settings_invert, {boost_ctl_settings_on}
      field = "Closed Duty",                      boost_ctl_closeduty, {boost_ctl_settings_on}
      field = "Open Duty",                        boost_ctl_openduty, {boost_ctl_settings_on}
      field = ""
      field = "Algorithm",			  boost_ctl_settings_cl, {boost_ctl_settings_on}
      field = "Proportional Gain",                boost_ctl_Kp, {boost_ctl_settings_cl}
      field = "Integral Gain",                    boost_ctl_Ki, {boost_ctl_settings_cl}
      field = "Differential Gain",                boost_ctl_Kd, {boost_ctl_settings_cl}

      dialog = canparams,  "CAN Parameters"
       topicHelp = canhelp
       field = "See F1 help"
       field = "Board Type (not used)", board_type
       field = "My CAN ID",  mycan_id
       field = "(See help)"
       field = "Poll remote:", can_poll, {(mycan_id == 0) && (board_type == 1)}
       field = "Remote CAN ID", can_poll_id, {(mycan_id == 0) && (board_type == 1) && (can_poll > 0)}
       field = "CAN Polling Master/Slave", can_poll_slave, {(mycan_id == 0) && (board_type == 1) && (can_poll > 0)}
	   field = "Enable ADC polling", enable_pollADC, { (can_poll == 3) }
	   field = "Remote table number for ADC data", poll_tableADC, { (can_poll == 3) && (enable_pollADC) && !(can_poll_slave) }
	   field = "Remote table offset for ADC data", poll_offsetADC, { (can_poll == 3) && (enable_pollADC) && !(can_poll_slave) }
	   field = "Enable PWM polling", enable_pollPWM, { (can_poll == 3) }
	   field = "Remote table number for PWM data", poll_tablePWM, { (can_poll == 3) && (enable_pollPWM) && !(can_poll_slave) }
	   field = "Remote table offset for PWM data", poll_offsetPWM, { (can_poll == 3) && (enable_pollPWM) && !(can_poll_slave) }
	   field = "Remote PWM clock frequency", remotePWMfreq, { (can_poll == 3) && (enable_pollPWM) }
	   field = "Remote PWM clock prescale", remotePWMprescale, { (can_poll == 3) && (enable_pollPWM) }
	   field = "Enable ports polling", enable_pollports, { (can_poll == 3) }
	   field = "Remote table number for ports data", poll_tableports, { (can_poll == 3) && (enable_pollports) && !(can_poll_slave) }
	   field = "Remote table offset for ports data", poll_offsetports, { (can_poll == 3) && (enable_pollports) && !(can_poll_slave) }
	   field = "Remote ports direction", ports_dir, { (can_poll == 3) && (enable_pollports) }
	   field = "Remote port 1 type", port1_type, { (can_poll == 3) && (enable_pollports) }
	   field = "Remote port 2 type", port2_type, { (can_poll == 3) && (enable_pollports) }
	   field = "Remote port 3 type", port3_type, { (can_poll == 3) && (enable_pollports) }
	   field = "Use for generic remote spare port", port_generic, { (can_poll == 3) && (enable_pollports) && (ports_dir) }
       
      dialog = injseq, "Injector Sequence"
       field = "!FOR EXPERT USE ONLY"
       field = ""
       field = "Enable initial values", feature3_3
       field = "Injector sequence start", trig_init, {feature3_3 }
       field = "Injector time mask", inj_time_mask, {feature3_3 }

      dialog = seq_injection, "Sequential Injection"
       field = "!Sequential injection", seq_inj
       field = "Timing trigger", injtimingmode, {seq_inj }
       field = "Fixed timing or table", injusetable, {seq_inj }
       field = "Number of timing values", injdualvalue, { (seq_inj == 3) }
       field = "Fixed injection timing 1", injadv1, {(seq_inj) && (injusetable == 0) }
       field = "Fixed injection timing 2", injadv2, {(seq_inj == 3) && (injusetable == 0) && (injdualvalue) }
       field = "Fixed injection timing 1 when staging on", injstagedadv1, {(seq_inj) && (injusetable == 0) && (staged_first_param) }
       field = "Fixed injection timing 2 when staging on", injstagedadv2, {(seq_inj == 3) && (injusetable == 0) && (injdualvalue) && (staged_first_param) }
       field = "Cranking injection timing 1", injcrankadv1, {seq_inj }
       field = "Cranking injection timing 2", injcrankadv2, {(seq_inj == 3) && (injdualvalue) }
       field = "VE trim tables", usevetrim, { seq_inj }
	   field = ""
       field = "!Injector drivers", extrainj
       field = "Bank 3"
       field = "Injector3 Open Time",        injOpen3, { injctl && extrainj }
       field = "Battery Voltage Corr.",      battFac3, { injctl && extrainj }
       field = "Bank 4"
       field = "Injector4 Open Time",        injOpen4, { injctl && extrainj }
       field = "Battery Voltage Corr.",      battFac4, { injctl && extrainj }
	   field = ""
	   field = "!Sequential Siamese Hybrid Mode"
	   field = "!Single pulse activation RPM", hybrid_rpm, {(seq_inj == 3) }
	   field = "!Hysteresis on single pulse activation RPM", hybrid_hyst, {(seq_inj == 3) }
       field = "Fixed injection timing 3", injadv3, {(seq_inj == 3) && (injusetable == 0) }
       field = "Fixed injection timing 3 when staging on", injstagedadv3, {(seq_inj == 3) && (injusetable == 0) && (staged_first_param) }

      dialog = tablesw, "Table Switching"
      field = "Fuel Table Switching",         f5_0_tsf
      field = "Switch source",        f5_0_tsf_opt,  { f5_0_tsf }
      field = "Switch location",        tsf_remote,  { f5_0_tsf && !f5_0_tsf_opt }
      field = "Remote port",        tsf_remote_port,  { f5_0_tsf && !f5_0_tsf_opt && tsf_remote }
      field = "rpm greater than",     tsf_rpm,  { f5_0_tsf && f5_0_tsf_opt == 1 }
      field = "kPa greater than",    tsf_kpa,  { f5_0_tsf && f5_0_tsf_opt == 2 }
      field = "TPS greater than",    tsf_tps,  { f5_0_tsf && f5_0_tsf_opt == 3 }
      field = ""
      field = "Spark Table Switching",         f5_0_tss
      field = "Switch source",        f5_0_tss_opt,  { f5_0_tss }
      field = "Switch location",        tss_remote,  { f5_0_tss && !f5_0_tss_opt }
      field = "Remote port",        tss_remote_port,  { f5_0_tss && !f5_0_tss_opt && tss_remote }
      field = "rpm greater than",     tss_rpm,  { f5_0_tss && f5_0_tss_opt == 1 }
      field = "kPa greater than",    tss_kpa,  { f5_0_tss && f5_0_tss_opt == 2 }
      field = "TPS greater than",    tss_tps,  { f5_0_tss && f5_0_tss_opt == 3 }

      dialog = experimental, "Experimental settings"
       field = "Vanos cam position debugging", feature4_0vanos
       field = "Enable status4 for tooth"
       field = "and status5 for time after tooth"

      dialog = outputtest, "Output test modes"
       field = "Enter 12345 and hit Burn", testmodelock
       field = ""
       field = "Fuel pump", testop_fp
       field = "Test mode", testmode
       field = "Output interval", testint
       field = "Coil output to test", testop_coil, { testmode == 1 }
       field = "Dwell", testdwell, { testmode == 1 }
       field = "Injector channel to test", testop_inj, { testmode == 2 }
       field = "Additional Injector channel to test", test_addinj, { (testmode == 2) && extrainj }
       field = "Pulsewidth", testpw, { testmode == 2 }
       field = "Injector PWM parameters", testop_pwm, { testmode == 2 && !extrainj}
       field = "PWM Current Limit",          testinjPwmP, { testmode == 2 && testop_pwm && !extrainj}
       field = "PWM Time Threshold",         testinjPwmT, { testmode == 2 && testop_pwm && !extrainj}
       field = "Injector PWM Period",       testinjPwmPd , { testmode == 2 && testop_pwm && !extrainj}
       field = "Total number of injections", testinjcnt

      dialog = iactest, "Idle valve test"
       field = "Idle testing enable", iactestlock
       field = ""
       field = "Move to home position", iactest, {iactestlock}
       field = "iac home step", iachometest, {iactestlock}
       field = "iac step", iacpostest
       field = "Set the steps before enabling testing"
       field = "For PWM valves enter 0-100, for stepper use 0-255"

      dialog = EAElagcomp, "EAE lag compensation"
       field = "Source",  EAElagsource
       field = "Threshold", EAElagthresh
       field = "Max RPM", EAElagRPMmax


      dialog = RotaryTrailingSettings, "Rotary Settings"
      field = "Enable Rotary Mode", RotarySplitModeOn
      field = "See also Rotary Split Table"
      field = "Output mode", RotarySplitModeFD, { RotarySplitModeOn }
      field = "RX8 mode", RotarySplitModeRX8, { RotarySplitModeOn }
      field = "Allow negative split?", RotarySplitModeNeg, { RotarySplitModeOn }

      dialog = advign, "Noise filtering"
;not used      field = "Predictor Gain",                Dtpred_Gain
      field = "False trigger method",          feature4_0ftrig, {(spk_mode0 < 4)}
      field = "Time Mask",                     ICISR_tmask, {(feature4_0ftrig == 3) && (spk_mode0 < 4)}
      field = "Percentage Mask",               ICISR_pmask, {(feature4_0ftrig == 3) && (spk_mode0 < 4)}
      field = "#Next-Pulse Tolerance"
      field = "   Cranking",                   crankTolerance, {spk_mode0 < 2}
      field = "   After-start",                asTolerance, {spk_mode0 < 2}
      field = "   Normal Running",             pulseTolerance, {spk_mode0 < 2}

      dialog = noisefiltering, "Noise filtering"
      field = "See the web help for more information about noise filtering"
; note that use of this depends on whether the wheel is single/double edged
      field = "!PRIMARY TACH (crank)"
      field = "Noise Filter Enabled", NoiseFilterOpts
      field = "Use noise filter curve to tune"
      field = "Tach period rejection", NoiseFilterOpts1
      field = "Tach interrupt masking", NoiseFilterOpts2, {NoiseFilterOpts == 0}
      field = "Time",                     ICISR_tmask, {NoiseFilterOpts1 || NoiseFilterOpts2}
      field = "Percentage",               ICISR_pmask, {NoiseFilterOpts1 || NoiseFilterOpts2}
      field = "Polarity checking", NoiseFilterOpts3, {NoiseFilterOpts == 0}

; note that use of this depends on whether the wheel uses a cam and/or if it is single/double edged
      field = "!SECONDARY TACH (cam)"
      field = "Noise Filter Enabled",    secondtrigopts;
      field = "Noise Filter Time Period",      TC5_required_width, { secondtrigopts & 0x1 }
      field = "Tach period rejection", secondtrigopts1
      field = "Tach interrupt masking", secondtrigopts2, { secondtrigopts == 0 }
      field = "Time",                     IC2ISR_tmask, {secondtrigopts1 || secondtrigopts2}
      field = "Percentage",               IC2ISR_pmask, {secondtrigopts1 || secondtrigopts2}
      field = "Polarity checking", secondtrigopts3, { secondtrigopts == 0 }

      field = "Note, a power cycle is required after enabling/disabling"
      field = " the noise filters"

      dialog = launch, "Launch Control"
      field = "Launch control option:",        launch_opt_on
      field = ""
      field = "Input on:",  launch_opt_pins, { launch_opt_on >0 }
      field = "Launch retard above", launch_sft_lim, {launch_opt_on >0}
      field = "Retard to", launch_sft_deg, {launch_opt_on >0}
      field = "Enable Launch when TPS above  ", launch_tps, { launch_opt_on >0}
      field = "Launch hard limit", launch_hrd_lim, { launch_opt_on >0}
      field = "Limiter method", launchlimopt, { launch_opt_on >0}
      field = "Cut X sparks", launchcutx, { (launchlimopt & 1) && (launch_opt_on >0) }
      field = "from Y events", launchcuty, { (launchlimopt & 1) && (launch_opt_on >0) }
      field = "Flat shift arming rpm",          flats_arm,   { launch_opt_on >1 }
      field = "Flat shift mode retard above",   flats_sft,   { launch_opt_on >1 }
      field = "Retard to :  ",                  flats_deg,   { launch_opt_on >1 }
      field = "Flat shift hard rev limit",      flats_hrd,   { launch_opt_on >1 }

      dialog = tacho, "Tachometer output"
      topicHelp = tachohelp
      field = "Tacho output enabled",         tacho_opt80
      field = ""
      field = "Output on:",  tacho_opt3f, { tacho_opt80 }
      field = "Speed", tacho_opt40, { tacho_opt80 }
      field = ""
      field = "Caution.. be sure nothing else is using this output"
      field = "Press F1 for more pin information"

      dialog = overrun, "Over Run Fuel Cut"
      topicHelp = Chelp8
      field = "Over Run Fuel Cut",         OvrRunC
      field = "Cut fuel when:"
      field = "RPM greater than:",         fc_rpm,  { OvrRunC }
      field = "and KPa lower than:  ",     fc_kpa,  { OvrRunC }
      field = "and TPS lower than:  ",     fc_tps,  { OvrRunC }
      field = "and coolant greater than:", fc_clt,  { OvrRunC }
      field = "after delay",              fc_delay, { OvrRunC }
      field = ""
      field = "Delay EGO after fuel return:", fc_ego_delay, { OvrRunC }

      dialog = staging, "Staged Injection"
      field = "!Staged injection first parameter", staged_first_param
      field = "!Primary injector size",     staged_pri_size, { staged_first_param }
      field = "!Secondary injector size",   staged_sec_size, { staged_first_param }
      field = ""
      field = "Staging gradual transition", staged_transition_on, { staged_first_param && (staged_first_param  & 0x7) != 5 }
      field = "Staging transition events", staged_transition_events, { staged_first_param && staged_transition_on && ((staged_first_param & 0x7) != 5) }
      field = "Staging primary reduction delay", staged_primary_delay, { staged_first_param && staged_transition_on && ((staged_first_param & 0x7) != 5) }
      field = "Staging secondary enrichment", staged_secondary_enrichment, { staged_first_param && staged_transition_on && ((staged_first_param & 0x7) != 5) }
      field = ""
      field = "Primary staging threshold", staged_param_1, { staged_first_param && ((staged_first_param & 0x7) != 5) }
      field = "Primary staging hysteresis", staged_hyst_1, { staged_first_param && ((staged_first_param & 0x7) != 5) }
      field = ""
      field = "Staged injection second parameter", staged_second_param, { staged_first_param && ((staged_first_param & 0x7) != 5) }
      field = "Secondary staging threshold", staged_param_2, { staged_second_param && ((staged_first_param & 0x7) != 5) }
      field = "Secondary staging hysteresis", staged_hyst_2, { staged_second_param && ((staged_first_param & 0x7) != 5) }
      field = "Secondary staging logic", staged_second_logic, { staged_second_param && ((staged_first_param & 0x7) != 5) }

      dialog = secondaryLoad, "Secondary load parameters"
      field = "Secondary Fuel Load",      algorithm2, { dualTable == 0 }
      field = "Secondary Fuel",		  loadCombine, {algorithm2 != 0 }
      field = "Multiply MAP",    loadMult
      field = ""
      field = "Incorporate AFRTarget", loadStoich
      field = "Stoichiometric AFR", stoich, { loadStoich }
      field = ""
      field = "Primary Ignition Load",    IgnAlgorithm
      field = "Secondary Ignition Load",  IgnAlgorithm2
      field = "NOTE: secondary ignition table is always additive"
      field = ""
      field = "AFR table load", afrload
      field = "EAE curve load", eaeload

   dialog = overboost, "Overboost Protection"
   field = "Overboost protection", OverBoostOption
   field = "Maximum Boost",   OverBoostKpa, { OverBoostOption > 0 }
   field = "Hysteresis",      OverBoostHyst, { OverBoostOption > 0 }
   field = ""
   field = "Cut X sparks",    overboostcutx, { OverBoostOption > 1 }
   field = "From Y events",   overboostcuty, { OverBoostOption > 1 }


   dialog = ipwset, "PWM idle settings"
      field = "Warmup only mode"
      field = "Set duty vs. temp in the duty table"
      field = "Crank-to-Run Taper Time", pwmidlecranktaper, { IdleCtl != 6 && IdleCtl != 7 }
      field = ""
      field = "Valve mode",      pwmidleset_inv
	  field = "PWM idle port", pwmidle_port
      field = "Valve frequency 30.5 Hz * this setting", pwmidle_freq, { !pwmidle_port }
      field = "@ 156Hz the valve works in 2% steps"

   dialog = userlevel, "Basic/ Intermediate/ Extended/ Advanced user"
      field = "User level", userlevelbits
      field = ""
      field = "Use this to enable or disable more advanced features"
      field = "New users are advised to start with basic as the more"
      field = "complex features will be turned off, protecting you"
      field = "from potential mistaken settings"

   dialog = crsettings, "Cranking settings"
      field = "Cranking RPM",          crankingRPM
      field = ""
      field = "Flood clear TPS", floodClear
      field = "Above this throttle no fuel is injected"
      field = "Cranking fuel pulse rate ", altcrank
      field = ""
      field = "Engines with lots of cylinders such as V12 may find"
      field = "that the injecting fuel on every tach event gives"
      field = "difficult hot starting. This option allows the fuel"
      field = "to be injected on alternate events (with twice the"
      field = "pulse width)"


   dialog = generalSettings, "General Settings"
      topicHelp = "http://www.megasquirt.info/megatune.htm#sg"
;     field = "#System"
;        field = "Temperature Units", tempUnits ; !

;     field = "#EFI"
         field = "Dual Table Use",        dualTable
         field = "Barometric Correction", baroCorr
         field = "Realtime baro port",    rtbaroport, {baroCorr == 2}
         field = "Upper limit", baro_upper, {baroCorr == 1}
         field = "Lower limit", baro_lower, {baroCorr == 1}
         field = "Default baro", baro_default, {baroCorr < 2}

      field = "#Input Smoothing Lag Factors"
         field = "MAP Averaging Lag Factor",    mapLF
         field = "RPM Averaging Lag Factor",    rpmLF
         field = "TPS Averaging Lag Factor",    tpsLF
         field = "Lambda Averaging Lag Factor", egoLF
         field = "CLT/MAT/Battery Lag Factor",  adcLF
	 field = ""
	 field = "NOTE: MAP sample percent mask will cause"
	 field = "      MAP to be sampled a certain percentage between"
	 field = "      tach events. 50% will sample halfway between tach events."
	 field = "MAP sample window",     mapsample_window
         field = "MAP sample angle", mapsample_angle
         field = ""
         field = "Fuel table size", feature4_0VEtblsize
         field = "Note: Export your fuel tables before changing, then import"


   dialog = revlimiter, "Rev Limiter"
         field = "Algorithm",             RevLimOption
	 field = "Rev Limiter CLT based", RevLimCLTbased 
         field = "Maximum Retard",        RevLimMaxRtd, { RevLimOption & 1 }
	 field = "Soft Rev Limit",        RevLimNormal1, { RevLimCLTbased == 0 }
	 field = "Hard Rev Limit",        RevLimNormal2, { RevLimCLTbased == 0 }
         field = "Rev Limit Adder",       RevLimRpm2, { RevLimCLTbased & 1 }
	 field = "Rev Limit TPS bypass",  TpsBypassCLTRevlim, { RevLimCLTbased & 1 }
	 field = "RPM when in TPS bypass", RevLimTPSbypassRPM, { RevLimCLTbased & 1 }
         field = "Cut X sparks",    RevLimcutx, { RevLimOption & 4 }
         field = "from Y events",         RevLimcuty, { RevLimOption & 4 }

   dialog = flexFuelSettings, "Flex Fuel Settings"
      topicHelp = "http://www.megasquirt.info/flexfuel.htm"
      field = "Flex Fuel Sensor",         flexFuel
      field = "Flex Fuel port location",  flexFuelRemote, { can_poll && enable_pollPWM }
      field = "Sensor port",              flexport,       { (flexFuel > 0) && !flexFuelRemote }
      field = "Remote sensor port",       flexportRemote, { (flexFuel > 0) && flexFuelRemote }
      field = "Frequency (low)",          fuelFreq0,      { flexFuel > 0 }
      field = "Fuel Correction (low)",    fuelCorr0,      { flexFuel > 0 }
      field = "Timing Correction (low)",  fuelSpkDel0,    { flexFuel > 0 }
      field = "Frequency (high)",         fuelFreq1,      { flexFuel > 0 }
      field = "Fuel Correction (high)",   fuelCorr1,      { flexFuel > 0 }
      field = "Timing Correction (high)", fuelSpkDel1,    { flexFuel > 0 }

 
  dialog = accelsettings, "Accel enrich settings"
      field = "#AE RPM Scaling"
      field = "Low RPM Threshold",       ae_lorpm
      field = "High RPM Threshold",      ae_hirpm
      field = ""
      field = "Enhanced Accel Enrichment",            EAEOption

   dialog = injChars, "Injector Characteristics"
      topicHelp = "http://www.megasquirt.info/megatune.htm#sn"
      field = "Bank 1"
      field = "Injector Open Time",         injOpen
      field = "Battery Voltage Correction", battFac
      field = "PWM Current Limit",          injPwmP, { !extrainj }
      field = "PWM Time Threshold",         injPwmT, { !extrainj }
      field = "Injector PWM Period",       injPwmPd, { !extrainj }
      field = "Bank 2"
      field = "Specific bank 2 setting",    injctl
      field = "Injector2 Open Time",        injOpen2, { injctl } ; crashes Megatune
      field = "Battery Voltage Corr.",      battFac2, { injctl }
      field = "PWM Current Limit",          injPwmP2, { injctl && !extrainj }
      field = "PWM Time Threshold",         injPwmT2, { injctl && !extrainj }
      field = "Injector PWM Period",       injPwmPd2, { injctl && !extrainj }

   dialog = egoControl, "EGO Control"
      field = "EGO Sensor Type",           egoType
      field = "2nd EGO sensor port",       ego2port,     { egoType == 2 || egoType == 4}
      field = "Ignition Events per Step",  egoCount,     { egoType > 0 }
;these seem to break MT
      field = "Controller Step Size",      egoDelta,     { egoAlgorithm == 0 }
      field = "Controller Auth +/-",    egoLimit,     { egoType >  0 }
      field = "Active Above Coolant", egoTemp,      { egoType >  0 }
      field = "Active Above RPM",          egoRPM,       { egoType >  0 }
      field = "Active Below TPS",          TPSOXLimit,   { egoType >  0 }
      field = "Active Below MAP",          MAPOXLimit,   { egoType >  0 }
      field = "Active Above MAP",          MAPOXMin,     { egoType >  0 }

      field = "#WB Controller Settings"
         field = "Algorithm",              egoAlgorithm, { egoType >  0 }
         field = "PID Proportional Gain",  egoKP,        { egoType >  0 && egoAlgorithm > 1 }
         field = "PID Integral",           egoKI,        { egoType >  0 && egoAlgorithm > 1 }
         field = "PID Derivative",         egoKD,        { egoType >  0 && egoAlgorithm > 1 }

   dialog = ignitionOptions, "Ignition Options"
      topicHelp = "http://www.megasquirt.info/megatune.htm#si"
      field = "#General Ignition"
      field = "!Spark mode(dizzy, EDIS,wheel)",                   spk_mode0  ; !
      field = "Trigger Angle/Offset",                triggerOffset, { (spk_mode0 != 31) && (spk_mode0 != 4)}
      ;, {spk_mode0 ==2 || spk_mode0 ==3 || spk_mode0 ==12 || spk_mode0 ==14}
      field = "Angle between main and return", trigret_ang, { spk_mode0 ==12}
      field = "Oddfire small angle",           OddFireang, { (engineType == 1)};
      field = "GM HEI/DIS options",     spk_conf2_gm, {spk_mode0 ==2}
;      field = "Ford TFI options",              spk_conf2_tfi, {spk_mode0 ==3}
      field = "420A/NGC alternate cam",     spk_conf2_ngc, {(spk_mode0==6) && (nCylinders==4)}
      field = "Use cam signal if available*",     spk_conf2_cam, {spk_mode0 > 4}
      field = "Oddfire phasing", spk_conf2_oddodd, { (engineType == 1) && (spk_mode0==4)}
      field = "Skip Pulses",                   no_skip_pulses
      field = "!Ignition Input Capture",       ICIgnCapture  ; !
      field = "!Spark Output",                 spkout_hi_lo, {spk_mode0 != 31} ; 
      field = "Number of coils", spk_mode3, { (spk_mode0 > 1) }
#if MICROSQUIRT_FULL
#else
#if MICROSQUIRT_MODULE
#else
      field = "Spark A output pin (D14 preferred)", spk_config_spka, { (spk_mode0 > 1) && (spk_mode0 != 31) }
#endif
#endif
  dialog = moreIgnitionOptions, "More Ignition Options"
      field = "Fixed Advance",		       timing_flags
;      field = "Use Prediction",                use_prediction, {spk_mode0 == 2}  ; only works for dizzy
      field = "Use Prediction",                use_prediction
      field = "Timing for Fixed Advance",      fixed_timing, { timing_flags == 1 };
      field = "Cranking Dwell",		       crank_dwell
      field = "Cranking Advance",	       crank_timing, {!(spk_mode0 == 2 && triggerOffset < 20) }
      field = ""
      field = "Dwell type",                    dwellmode
      field = "Maximum Dwell Duration",        max_coil_dur, {(spk_mode0 >1) && (dwellmode==0) }
      field = "Acceleration Compensation",     dwellAcc, {(spk_mode0 >1) && (dwellmode==0)}
      field = "Maximum Spark Duration",        max_spk_dur, {(spk_mode0 >1) && (dwellmode==0) }
      field = "Dwell time",                    dwelltime, {(spk_mode0 >1) && (dwellmode==2) }
      field = "Dwell duty",                    dwellduty, {(spk_mode0 >1) && (dwellmode==1) }
      field = "NOTE: Spark hardware latency should ONLY be used if"
      field = "you notice spark retard with increasing rpms."
      field = "Spark Hardware Latency",               hw_latency
      field = "middle LED indicator",          feature4_0igntrig, { (spk_mode0 == 3) }
      field = "Overdwell protection",          feature4_0maxdwl
      field = "Underdwell protection",         feature4_0mindwl

  dialog = triggerWheel, "Trigger Wheel Settings"
      topicHelp = trighelp
      field = "Trigger wheel arrangement",     spk_config_trig2
      field = "!Trigger Wheel Teeth",          triggerTeeth
      field = "!Missing Teeth",                No_Miss_Teeth, {spk_config_trig2 != 2}
      field = "!Tooth #1 Angle",     Miss_ang
      field = "!Wheel speed",                   spk_config_camcrank
      field = "!Second trigger active on",      spk_config_trig2l, {spk_config_trig2 & 0x2}

      field = "!and every rotation of..", spk_config_resetcam, {(spk_config_trig2 & 0x3) == 0x2}
      field = "(see F1 help)"   
      field = "!Red settings require an MS-II reboot!"

   dialog = idleControl, "Idle Control"
      topicHelp = "http://www.megasquirt.info/megatune.htm#sd"
      field = "Algorithm",                     IdleCtl
      field = "Fast Idle Temperature",         fastIdleT,    { IdleCtl == 1 }
      field = "Time Step Size",                IACtstep,     { IdleCtl == 2 || IdleCtl == 3 || IdleCtl == 5 || IdleCtl == 7 || IdleCtl == 8 }
      field = "Initial Time Step Size",        IAC_tinitial_step,   { IdleCtl == 2 || IdleCtl == 7 }
      field = "Minimum # steps to move",       IACminstep,  { IdleCtl == 2 || IdleCtl == 3 || IdleCtl == 5 || IdleCtl == 7 || IdleCtl == 8 }
      field = "!Start Value",                  IACStart,     { IdleCtl > 1 && IdleCtl != 4 && IdleCtl != 6} ; !
      field = "Crank-to-Run Taper Time",       IACcrankxt,   { IdleCtl > 1 && IdleCtl != 4 && IdleCtl != 6 && IdleCtl != 7 && IdleCtl != 8 }
      field = "Hysteresis",                    IdleHyst,     { IdleCtl > 0 && IdleCtl != 4 && IdleCtl != 6 && IdleCtl != 7 && IdleCtl != 8 }
      field = "#Time-Based After Start"
      field = "   Cold Temperature",           IACcoldtmp,   { IdleCtl > 1 && IdleCtl != 4 && IdleCtl != 6 && IdleCtl != 7 && IdleCtl != 8 }
      field = "   Cold Position",              IACcoldpos,   { IdleCtl > 1 && IdleCtl != 4 && IdleCtl != 6 && IdleCtl != 7 && IdleCtl != 8 }
      field = "   Cold Taper Time",            IACcoldxt,    { IdleCtl > 1 && IdleCtl != 4 && IdleCtl != 6 && IdleCtl != 7 && IdleCtl != 8 }
      field = "!Red settings require an MS-II reboot!"

   dialog = pwmidle_closedloop, "Closed Loop Idle Valve Settings"
      field = "Idle Open Duty",                  pwmidle_open_duty, { IdleCtl == 6 }
      field = "Idle Open Steps",	         pwmidle_open_steps, { IdleCtl == 7 || IdleCtl == 8 } 
      field = "Idle Valve Closed Duty",          pwmidle_closed_duty, { IdleCtl == 6 }
      field = "Idle Valve Closed Steps",         pwmidle_closed_steps, { IdleCtl == 7 || IdleCtl == 8 }
      field = "Idle Activation RPM adder",       pwmidle_engage_rpm_adder
      field = "Idle Activation TPS threshold",   pwmidle_tps_threshold
      field = "Dashpot adder",  pwmidle_dp_adder, { IdleCtl == 6 }
      field = "Dashpot adder",  pwmidle_dp_adder_steps, { IdleCtl == 7 || IdleCtl == 8 }
      field = "NOTE: Close delay of 0 means do not close"
      field = "Close delay", pwmidle_close_delay
      
      
   dialog = pwmidle_PID, "Closed Loop Idle PID Settings"
      field = "Min Duty for PID",     pwmidle_min_duty, { IdleCtl == 6 }
      field = "Min Steps for PID",    pwmidle_min_steps,  { IdleCtl == 7 || IdleCtl == 8 }
      field = "RPM with valve closed", pwmidle_min_rpm
      field = "RPM with valve open",   pwmidle_max_rpm
      field = "PID delay",            pwmidle_pid_wait_timer
      field = "Crank to run taper",   pwmidlecranktaper 
      field = "PID ramp to target time", pwmidle_targ_ramptime
      field = "PID Control Interval", pwmidle_ms
      field = ""
      field = "PID Controller Gains"
      field = "Proportional Gain",    pwmidle_Kp
      field = "Integral Gain",        pwmidle_Ki
      field = "Derivative Gain",      pwmidle_Kd
      field = ""
      field = "PID lockout detection"
      field = "PID lockout rpmDOT threshold", pwmidle_rpmdot_threshold
      field = "PID lockout max decel load", pwmidle_decelload_threshold
      field = ""
      field = "PID disable params"
      field = "Use so that engaging clutch without throttle"
      field = "Does not leave PID running"
      field = "PID disable RPMdot", pwmidle_rpmdot_disablepid

   dialog = sensorCal, "Sensor Calibration"
      topicHelp = sensorHelp
#if INI_VERSION_2
      settingSelector = "Common Sensors"
         settingOption = "MPX4115",  map0=10.6, mapmax=121.7, baro0=10.6, baromax=121.7
         settingOption = "MPX4250",  map0=10,   mapmax=260,   baro0=10,   baromax=260
         settingOption = "MPXH6300", map0=1.1,  mapmax=315.5, baro0=1.1,  baromax=315.5
         settingOption = "GM 3-BAR", map0=1.1,  mapmax=315.5, baro0=1.1,  baromax=315.5
         settingOption = "MPXH6400", map0=3.5,  mapmax=416.5, baro0=3.5,  baromax=416.5
#endif
      field = "#MAP Sensor (F1 for common values)"
      field =    "Value at 0.0 volts",   map0
      field =    "Value at 5.0 volts",   mapmax
      field = "#Barometer Sensor (usually identical to MAP)"
      field =    "Value at 0.0 volts",   baro0
      field =    "Value at 5.0 volts",   baromax
      field = "#Barometric Correction"
      field =    "At total vacuum ",     bcor0
      field =    "Rate",                 bcormult


   dialog = knockSettings, "Knock Sensor Settings"
      field = "Knock Control",        knk_option
      field = "Knock input location", knk_remote, { knk_option && enable_pollports }
      field = "Knock input pin",      knkport, { (knk_option >0) && !knk_remote }
      field = "Remote Knock input",   knkport_remote, { (knk_option >0) && knk_remote }
      field = "#Detection"
      field = "Knock indicated by:",  knkDirection,   { knk_option > 0 }
      field = "Pullup/down on input",  knkpull,   { knk_option > 0 }
      field = "Knock Count",          knk_ndet,       { knk_option > 0 }
      field = "Knock Ignored Above MAP",   knk_maxmap,     { knk_option > 0 }
      field = "RPM window low",   knk_lorpm,      { knk_option > 0 }
      field = "RPM window high",   knk_hirpm,      { knk_option > 0 }
      field = "#Retarding"
      field = "Maximum Retard",       knk_maxrtd,     { knk_option > 0 }
      field = "Retard Check Time",    knk_trtd,       { knk_option > 0 }
      field = "Retard Step Size",     knk_step1,      { knk_option > 0 }
      field = "#Recovery"
      field = "Advance Check Time",   knk_tadv,       { knk_option > 0 }
      field = "Advance Step Size",    knk_step2,      { knk_option > 0 }
      field = "Recovery Advance",     knk_dtble_adv,  { knk_option == 1 }

    dialog = idleAdvance, "Idle Advance Settings"
      field = "Idle advance on", idleadvance_on
      field = "Go to idle advance when:"
      field = "TPS is below:", idleadvance_tps, { idleadvance_on }
      field = "and RPM is below:", idleadvance_rpm, { idleadvance_on }
      field = "and load is above:", idleadvance_load, { idleadvance_on }
      field = "and CLT is above:", idleadvance_clt, { idleadvance_on }
      field = "and after delay:", idleadvance_delay, { idleadvance_on }

dialog = setbaud, "Megasquirt baud rate"
      field = "#Advanced users only."
      field = "Adjust MT rate to match and reset MS."
      field = "Megasquirt baud rate", baud

dialog = userdefined, "user defined menu"
      field = "Feature enabled", user_conf0
      field = "Mode", user_conf1, { user_conf0 }  ; <---- this bit here greys the control out if the bit isn't set
      field = "Value 1", user_value1, { user_conf0 }
      field = "Value 2", user_value2, { user_conf0 }


   help = trighelp, "Trigger wheel settings"
   text = "Choose from a"
   text = "<br>-single wheel with missing teeth"
   text = "<br>-a wheel with missing teeth and a cam wheel"
   text = "<br>Dual wheel -a non missing main wheel and a second wheel"
   text = "<br>"
   text = "For missing tooth wheels, the trigger wheel teeth is the number of theoretical teeth"
   text = "i.e. a wheel called '60-2' has 60 theoretical teeth although it physically has two missing and you"
   text = "will count 58"
   text = "<br>For non-missing tooth wheels count every tooth (whether on crank or cam)"
   text = "<br>e.g. Nippondenso wheels have 24 teeth, as does LS1"
   text = "<br>Tooth #1 Angle is necessary to achieve correct timing."
   text = "<br>Wheel speed is related to how you wheel is physically mounted on the engine."
   text = "A typical CAS (like the Nippondenso one) runs at cam speed. A normal single wheel like 60-2 will almost always be mounted to the"
   text = "front pulley/damper assembly and run at crank speed"
   text = "<br>The second trigger active on setting refers to the electrical wiring of your input. For VR type sensors this must correspond to the"
   text = "zero crossing point of your input.  LS1 type engines can use 'rising and falling' as the cam signal changes polarity on each crank rotation"
   text = "The next setting specifies how often the second trigger signal happens (if used). On Nippondenso CAS and LS1 this is every crank rotation, on"
   text = "Installs with a single pulse per cam rotation this will be set to 'cam'"


   help = canhelp, "CAN parameters help"
   text = "In a CAN setup each board must have a different CAN ID"
   text = "<br>For simplicity consider that the serial cable, computer and Megatune are connected to the MS2"
   text = "<br>"
   text = "<br>Board type should be MS2 (this isn't actually used by the code)"
   text = "<br>The master board is CAN ID 0"
   text = "<br>Poll remote determines whether we should get data from a remote board or not."
   text = "<br>Supported boards at this time are GPIO (1.041 doesn't return any data by default) or MS2/Extra in slave mode"
   text = "<br>The first remote board is typically CAN ID 1, but you MUST set this on the remote board"
   text = "<br>"
   text = "<br>To set an MS2 running MS2/Extra to be in slave mode and transmit data to a master MS2"
   text = "<br>Connect the serial cable to the slave board and set its CAN ID to 1."
   text = "<br>(If you change the CAN id of the MS2 you will need to change your tuning software to match it. If you simply change the CANid"
   text = "and then reboot the MS2 you will suddenly lose communications - this isn't a bug - fix your ini! A reflash the code is a lazy way of"
   text = "returning the unit to standard"
   text = "<br>Connect the serial cable to the master board, set its CAN ID to 0 and 'poll remote' to 'MS2/Extra slave'"
   text = "<br>Make the physical CAN connection between the boards"
   text = "<br>After a reset you can then see the ADC ports from the slave MS2 displayed in Megatune connected to the master MS2"
   text = "via the gauges GPIOADCgauge etc."
   text = "<br>"
   text = "<br>Presently this can be used to log 8 additional ADC channels and/or to support realtime baro, knock and dual wideband."

   help = tachohelp, "Tacho output pin info"
   text = "V2.2 / V3.0 cross reference"
   text = "<br>V2.2 - V3.0"
   text = "<br>X2 - JS0"
   text = "<br>X3 - JS1"
   text = "<br>X4 - JS2"
   text = "<br>X5 - JS3"
   text = "<br>X6 - JS4"
   text = "<br>X7 - JS5"
   text = "<br>CPU Pin 6 - JS6"
   text = "<br>CPU Pin 10 - JS7"
   text = "<br>CPU Pin 11 - JS8"
   text = "<br>JP1 Pin 6 - JS9"
   text = "<br>JP1 Pin 5 - JS10"
   text = "<br>JP1 Pin 4 - JS11"

   help = sensorHelp, "Sensor Calibration"
      webHelp = "http://www.megasquirt.info/megatune.htm#os"
      text = "MAP Sensor Calibration<br>"
      text = "<br>"
      text = "For the\tMPX4115   use\t10.6 and \t121.7<br>"
      text = "\tMPX4250\t\t10.0\t260.0<br>"
      text = "\tMPXH6300\t1.1\t315.5<br>"
      text = "\tGM 3-BAR\t1.1\t315.5<br>"
      text = "\tMPXH6400\t3.5\t416.5<br>"
      text = "<br>"
      text = "(GM 3-bar data from Dave Hartnell, http://www.not2fast.com/electronics/component_docs/MAP_12223861.pdf)<br>"
      text = "<br>"
      text = "\tSensor type\tvLo\tpLo\tvHi\tpHi\tvRef<br>"
      text = "\tMPX4115 \t0.204 v\t15 kPa\t4.794 v\t115 kPa\t5.100 v<br>"
      text = "\tMPX4250 \t0.204 v\t20 kPa\t4.896 v\t250 kPa\t5.100 v<br>"
      text = "\tMPXH6300\t0.306 v\t20 kPa\t4.913 v\t304 kPa\t5.100 v<br>"
      text = "\tGM 3-BAR\t0.631 v\t40 kPa\t4.914 v\t304 kPa\t5.100 v<br>"
      text = "\tMPXH6400\t0.200 v\t20 kPa\t4.800 v\t400 kPa\t5.000 v<br>"
      text = "<br>"
      text = "In general, use values derived from these equations:<br>"
      text = "<br>"
      text = "\tm = (pHi-pLo)/(vHi-vLo)<br>"
      text = "\tpv1 = pLo - m * vLo<br>"
      text = "\tpv2 = pv1 + m * vRef<br>"
      text = "<br>"
      text = "References:<br>"
      text = "\thttp://www.freescale.com/files/sensors/doc/data_sheet/MPX4115A.pdf<br>"
      text = "\thttp://www.freescale.com/files/sensors/doc/data_sheet/MPX4250A.pdf<br>"
      text = "\thttp://www.freescale.com/files/sensors/doc/data_sheet/MPXH6300A.pdf<br>"
      text = "\thttp://www.freescale.com/files/sensors/doc/data_sheet/MPXH6400A.pdf<br>"
      text = "<br>"
      text = "Barometer Sensor Calibration<br>"
      text = "<br>"
      text = "If your system has an external barometer sensor, separate from the MAP"
      text = "sensor, then use these values to calibrate it properly.  If you have"
      text = "a standard MS installation, then copy your MAP sensor values here.<br>"
      text = "<br>"
      text = "Barometric Correction Calibration<br>"
      text = "<br>"
      text = "Correction for barometric effects is performed using the linear function below.<br>"
      text = "<br>"
      text = "\tcorrection = correction_0 + (rate * barometer) / 100<br>"
      text = "<br>"
      text = "'At total vacuum' contains the total correction at a barometer reading"
      text = "of 0 kPa (you are on the moon).  The 'Rate' contains the percentage per 100"
      text = "kPa to scale the barometer value.  Using the default values of 147 and -47,"
      text = "we see that for a barometer of 100 kPa, we have 100% correction.<br>"
      text = "<br>"
      text = "\tcorrection = 147 + (-47*100) / 100 = 100%"


   help = helpGeneral, "MS-II General Help"
      webHelp = "http://www.megasquirt.info/ms2/"
      text = "Al Grippo and Bruce Bowling have created MegaSquirt-II, which"
      text = "is a plug-in daughter card that replaces the 8-bit MC68HC908GP32"
      text = "with a 16-bit MC9S12C32 processor.  MegaSquirt-II is an intermediate"
      text = "step from the original MegaSquirt towards UltraMegaSquirt.<br>"
      text = "<br>"
      text = "It is basically a plug-in processor card that has the MC9S12C32"
      text = "processor plus support hardware as well as a stepper motor chip,"
      text = "and an ignition module controller.  The embedded code is written"
      text = "in C, rather than assembly language, so it should be more accessible"
      text = "to more programmers (Stephane Carrez has ported GCC to the HC12"
      text = "processor so, although it doesn't use the full 9S12 instruction"
      text = "set, we are able to use his version to write code for the MS-II).<br>"
      text = "<br>"
      text = "For current documentation, click the Web Help button below, or for"
      text = "support questions visit http://www.msefi.com/."

;-------------------------------------------------------------------------------

#if TUNERSTUDIO
#if INI_VERSION_2
[PortEditor]
    ; map the arrays and supply the labels. 
    ; all arrays are expected to be the same length in the first dimension
    ; thus a [ 7] array will be 7 ports in length and expect 7 labels
    ; The second dimension will drive the number of conditions per array.
    ; thus a [7x2] array will have 2 conditions joined by the conditionRelationship.
    ; a [7x3] will have up to 3 conditions.
    portEditor = rmt_port_edit, "Remote Output port Settings"
;        topicHelp = "http://www.megamanual.com/mt28.htm#sp"
        ; 1st the array constant, then the labels in the index order. 
        enabledPorts = rmt_psEnabled, "Remote Port Channel 1", "Remote Port Channel 2", "Remote Port Channel 3", "Remote Port Channel 4", "Remote Port Channel 5", "Remote Port Channel 6", "Remote Port Channel 7", "Remote Port Channel 8"
        outputOffset = rmt_psOutOffset 
        outputSize   = rmt_psOutSize 
        operators    = rmt_psCondition, "<", "=", ">" ; the actual ASCII value of the operator will be sent to the controller
        threshold    = rmt_psThreshold
        hysteresis   = rmt_psHysteresis
        powerOnValue = rmt_psInitValue
        triggerValue = rmt_psPortValue
        conditionRelationship = rmt_psConnector, " ", "|", "&"
#endif
#endif
;-------------------------------------------------------------------------------

[CurveEditor]
   curve = MAFtable1, "MAF Correction Table (to alter default MAF curve)"
      columnLabel = "MAF Flow", "Correction"
      xAxis       =  0, 300, 11
      yAxis       =  0, 255, 11
      xBins       = MAFFlow, maf
      yBins       = MAFCor
      gauge       = mafGauge
 
   curve = dwellSettings, "Dwell Battery Adjustment"
      columnLabel = "Voltage", "%age"
      xAxis       = 6, 16, 6
      yAxis       = 0, 500, 6
      xBins       = dwellvolts
      yBins       = dwellcorr

   curve = coldAdvance, "Cold Ignition Advance Offset"
      topicHelp   = "http://www.megasquirt.info/megatune.htm#ac"
      columnLabel = "Coolant", "Offset"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 9
	#else
      xAxis       = -40, 220, 9
	#endif
      yAxis       = -10,  10, 5
      xBins       = tempTable, coolant
      yBins       = cold_adv_table
      gauge       = cltGauge

   curve = iacBins, "IAC Step Bins"
      topicHelp   = "http://www.megasquirt.info/megatune.htm#ad"
      columnLabel = "Coolant", "IAC Steps"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 9
	#else
      xAxis       = -40, 220, 9
	#endif
      yAxis       =   0, 300, 7
      xBins       = tempTable, coolant
      yBins       = iacstepTable
      gauge       = cltGauge

   curve = ipwBins, "PWM Idle Duty Cycle"
      topicHelp   = "http://www.megasquirt.info/megatune.htm#ap"
      columnLabel = "Coolant", "Idle PWM duty"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 9
	#else
      xAxis       = -40, 220, 9
	#endif
      yAxis       =   0, 100, 6
      xBins       = tempTable, coolant
      yBins       = ipwmTable
      gauge       = cltGauge

   curve = primingPW, "Priming Pulsewidth"
;     topicHelp   = "http://www.megasquirt.info/xxx"
      columnLabel = "Coolant", "Prime PW"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 9
	#else
      xAxis       = -40, 220, 9
	#endif
      yAxis       =   0,  20, 5
      xBins       = temp_table_p5, coolant
      yBins       = primePWTable
      gauge       = cltGauge

   curve = crankingPW, "Cranking Pulsewidth%"
;     topicHelp   = "http://www.megasquirt.info/xxx"
      columnLabel = "Coolant", "Cranking PW%"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 9
	#else
      xAxis       = -40, 220, 9
	#endif
      yAxis       =   0,  500, 6
      xBins       = temp_table_p5, coolant
      yBins       = crankPctTable
      gauge       = cltGauge

   curve = asePct, "Afterstart Enrichment Percentage"
;     topicHelp   = "http://www.megasquirt.info/xxx"
      columnLabel = "Coolant", "Afterstart"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 9
	#else
      xAxis       = -40, 220, 9
	#endif
      yAxis       =   0, 100, 6
      xBins       = temp_table_p5, coolant
      yBins       = asePctTable
      gauge       = cltGauge

   curve = aseTaper, "Afterstart Enrichment Taper"
;     topicHelp   = "http://www.megasquirt.info/xxx"
      columnLabel = "Coolant", "Taper"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 9
	#else
      xAxis       = -40, 220, 9
	#endif
      yAxis       =   0, 500, 6
      xBins       = temp_table_p5, coolant
      yBins       = aseCntTable
      gauge       = cltGauge

   curve = matBasedRetard, "MAT-Based Timing Retard"
;     topicHelp   = "http://www.megasquirt.info/xxx"
      columnLabel = "MAT", "Retard"
;upper limits too high, but have to leave them there so data is visible in TS.
#if CELSIUS
      xAxis       = -40, 300, 9
#else
      xAxis       = -40, 300, 9
#endif
      yAxis       =   0,  15, 7
      xBins       = matTemps, mat
      yBins       = matRetard
      gauge       = matGauge

;   curve = knockThreshold, "Knock Threshold"
;;     topicHelp   = "http://www.megasquirt.info/xxx"
;      columnLabel = "RPM", "Threshold"
;      xAxis       =   0, 6000, 7
;      yAxis       =   0,  5.0, 6
;      xBins       = knk_rpm, rpm
;      yBins       = knk_thresh
;      gauge       = tachometer

   curve = barometerCorr, "Non-Linear Barometric Correction"
;     topicHelp   = "http://www.megasquirt.info/xxx"
      columnLabel = "Barometer", "Correction"
      xAxis       =  60, 120, 7
      yAxis       = -30,  30, 7
      xBins       = baroCorrVals, barometer
      yBins       = baroCorrDelta
      gauge       = barometerGauge

   curve = manifoldTempCorr, "Non-Linear MAT Correction"
;     topicHelp   = "http://www.megasquirt.info/xxx"
      columnLabel = "MAT", "Correction"
      xAxis       =  -40, 200, 9
      yAxis       =  -30,  30, 7
      xBins       = matCorrTemps, mat
      yBins       = matCorrDelta
      gauge       = matGauge

   curve = EAEBAWCcurve, "Enhanced Accel Enrichment Added-to-Walls constant"
      columnLabel = "%", "Correction"
      xAxis	  = 0, 255, 12
      yAxis       = 0, 100, 12
      xBins	  = EAEAWCKPAbins, eaeload
      yBins	  = EAEBAWC
      gauge	  = EAEGauge1

   curve = EAEBSOCcurve, "Enhanced Accel Enrichment Sucked-from-Walls constant"
      columnLabel = "%", "Correction"
      xAxis	  = 0, 255, 12
      yAxis	  = 0, 25.5, 12
      xBins	  = EAESOCKPAbins, eaeload
      yBins	  = EAEBSOC
      gauge	  = EAEGauge1

   curve = EAEAWNcurve, "Enhanced Accel Enrichment AWC RPM %"
      columnLabel = "RPM", "Correction"
      xAxis	  = 0, 8000, 12
      yAxis	  = 0, 200, 12
      xBins 	  = EAEAWCRPMbins, rpm
      yBins	  = EAEAWN
      gauge	  = EAEGauge1

   curve = EAESONcurve, "Enhanced Accel Enrichment SOC RPM %"
      columnLabel = "RPM", "Correction"
      xAxis       = 0, 8000, 12
      yAxis       = 0, 200, 12
      xBins	  = EAESOCRPMbins, rpm
      yBins       = EAESON
      gauge	  = EAEGauge1

   curve = EAESOWcurve, "Enhanced Accel Enrichment SOW CLT %"
      columnLabel = "CLT", "Correction"
	#if EXPANDED_CLT_TEMP
      xAxis       = 0, 350, 12
	#else
      xAxis       = 0, 220, 12	
	#endif
      yAxis       = 0, 200, 12
      xBins	  = EAESOWCLTbins, coolant
      yBins       = EAESOW
      gauge	  = EAEGauge1

   curve = EAEAWWcurve, "Enhanced Accel Enrichment AWW CLT %"
      columnLabel = "CLT", "Correction"
	#if EXPANDED_CLT_TEMP
      xAxis       = 0, 350, 12
	#else
      xAxis       = 0, 220, 12
	#endif
      yAxis       = 0, 200, 12
      xBins	  = EAEAWWCLTbins, coolant
      yBins       = EAEAWW
      gauge	  = EAEGauge1

   curve = NoiseFiltercurve, "Noise filter curve"
      columnLabel = "RPMS", "usec"
      xAxis	  = 0, 10000, 4
      yAxis	  = 0, 2000, 4
      xBins	  = NoiseFilterRpm
      yBins	  = NoiseFilterLen

   curve = warmup_curve, "Warmup Enrichment Curve"
      columnLabel = "Coolant", "WUE %"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 9
	#else
      xAxis       = -40, 220, 9
	#endif
      yAxis       =   0,  500, 6
      xBins       = tempTable, coolant
      yBins       = wueBins
      gauge       = cltGauge

   curve = idleAdvance_curve, "Idle Advance Timing"
      columnLabel = "Load %", "deg"
      xAxis = 0, 100, 4
      yAxis = -10, 90, 4
      xBins = idleadvance_loads, fuelload
      yBins = idleadvance_curve

   curve = pwmidle_target_curve, "Closed loop idle target rpms"
      columnLabel = "CLT", "RPM"
      xAxis       = 0, 255, 8
      yAxis	  = 0, 2000, 8
      xBins	  = pwmidle_clt_temps, coolant
      yBins       = pwmidle_target_rpms

   curve = revlimiterBins, "Coolant Based Rev Limit" 
      topicHelp   = "http://www.megasquirt.info/megatune.htm#ap" 
      columnLabel = "Coolant", "Rev limit" 
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 8
	#else
      xAxis       = -40, 220, 8
	#endif
      yAxis		  =   0, 8000, 8 
      xBins       = RevLimLookup, coolant 
      yBins       = RevLimRpm1 
      gauge       = cltGauge

   curve = pwmidle_crank_dutyorsteps_dutycurve, "Coolant-based crank duty"
      columnLabel = "Coolant", "Duty %"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 4
	#else
      xAxis       = -40, 220, 4
	#endif
      yAxis       = 0, 100, 4
      xBins       = pwmidle_crank_clt_temps
      yBins       = pwmidle_crank_dutyorsteps_duty
      gauge       = cltGauge

   curve = pwmidle_crank_dutyorsteps_stepscurve, "Coolant-based crank steps"
      columnLabel = "Coolant", "Steps"
	#if EXPANDED_CLT_TEMP
      xAxis       = -40, 350, 4
	#else
      xAxis       = -40, 220, 4
	#endif
      yAxis       = 0, 512, 4
      xBins       = pwmidle_crank_clt_temps
      yBins       = pwmidle_crank_dutyorsteps_steps
      gauge       = cltGauge

   curve = ITB_load_loadvals_curve, "ITB load at TPS switchpoint"
      columnLabel = "RPM", "Load"
      xAxis       = 0, 9000, 12
      yAxis       = 0, 100, 12
      xBins       = ITB_load_rpms, rpm
      yBins       = ITB_load_loadvals

    curve = ITB_load_switchpoint_curve, "ITB load TPS switchpoints"
      columnLabel = "RPM", "TPS %"
      xAxis       = 0, 9000, 12
      yAxis       = 0, 100, 12
      xBins       = ITB_load_rpms, rpm
      yBins       = ITB_load_switchpoints
       

[TableEditor]
   ;       table_id,    map3d_id,    "title",      page
;std 16x16
   table = veTable1Tbl, veTable1Map, "VE Table 1", 5
      ;             constant,   variable
      xBins       = frpm_table1, rpm
      yBins       = fmap_table1, fuelload
      zBins       = veTable1

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

   table = veTable2Tbl, veTable2Map, "VE Table 2", 5
      xBins       = frpm_table2, rpm
      yBins       = fmap_table2, fuelload2
      zBins       = veTable2

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340

   table = veTable3Tbl, veTable3Map, "VE Table 3", 5
      ;             constant,   variable
      xBins       = frpm_table3, rpm
      yBins       = fmap_table3, fuelload
      zBins       = veTable3

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

    table = stagedTable, stagedMap, "Staged Injection table", 3
      xBins       = staged_rpms, rpm
      yBins       = staged_loads, fuelload
      zBins       = staged_percents

      upDownLabel = "MORE", "LESS"
      gridHeight  = 2.0
      gridOrient = 250, 0, 340

;same again but 12x12
   table = veTable1Tbldoz, veTable1Mapdoz, "VE Table 1", 5
      ;             constant,   variable
      xBins       = frpm_table1doz, rpm
      yBins       = fmap_table1doz, fuelload
      zBins       = veTable1dozen

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

   table = veTable2Tbldoz, veTable2Mapdoz, "VE Table 2", 5
      xBins       = frpm_table2doz, rpm
      yBins       = fmap_table2doz, fuelload2
      zBins       = veTable2dozen

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340

   table = veTable3Tbldoz, veTable3Mapdoz, "VE Table 3", 5
      ;             constant,   variable
      xBins       = frpm_table3doz, rpm
      yBins       = fmap_table3doz, fuelload
      zBins       = veTable3dozen

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.


#if LAMBDA
   table = afrTable1Tbl, afrTable1Map, "Lambda Table 1", 1
      gridHeight  = 3.0
#else
   table = afrTable1Tbl, afrTable1Map, "AFR Table 1", 1
      gridHeight  = 1.0
#endif
      xBins       = arpm_table1, rpm
      yBins       = amap_table1, afrload
      zBins       = afrTable1
      upDownLabel = "LEANER", "RICHER"
      gridOrient  = 250,   0, 340

#if LAMBDA
   table = afrTable2Tbl, afrTable2Map, "Lambda Table 2", 1
      gridHeight  = 3.0
#else
   table = afrTable2Tbl, afrTable2Map, "AFR Table 2", 1
      gridHeight  = 1.0
#endif
      xBins       = arpm_table2, rpm
      yBins       = amap_table2, afrload
      zBins       = afrTable2
      upDownLabel = "LEANER", "RICHER"
      gridOrient  = 250,   0, 340

   table = ignitionTbl1, ignitionMap1, "Spark Advance Table1", 3
      xBins       = srpm_table1, rpm
      yBins       = smap_table1, ignload
      zBins       = advanceTable1
      upDownLabel = "ADVANCING", "RETARDING"
      gridHeight  = 3.0
      gridOrient  = 250,   0, 340

   table = ignitionTbl2, ignitionMap2, "Spark Advance Table2", 3
      xBins       = srpm_table2, rpm
      yBins       = smap_table2, ignload2
      zBins       = advanceTable2
      upDownLabel = "ADVANCING", "RETARDING"
      gridHeight  = 3.0
      gridOrient  = 250,   0, 340

   table = ignitionTbl3, ignitionMap3, "Spark Advance Table1", 4
      xBins       = srpm_table3, rpm
      yBins       = smap_table3, ignload
      zBins       = advanceTable3
      upDownLabel = "ADVANCING", "RETARDING"
      gridHeight  = 3.0
      gridOrient  = 250,   0, 340

   table = RotarySplitTbl, RotarySplitMap, "Rotary Split Table", 3
      xBins	  = RotarySplitRPM, rpm
      yBins       = RotarySplitLoad, ignload
      zBins	  = RotarySplitTable
      upDownLabel = "ADVANCING", "RETARDING"
      gridHeight = 3.0
      gridOrient = 250, 0, 340

   table = injTiming1Tbl, injTiming1Map, "Injection Timing Table1", 4
      xBins	  = srpm_injadv1, rpm
      yBins   = smap_injadv1, fuelload
      zBins	  = injadvTable1
      upDownLabel = "ADVANCING", "RETARDING"
      gridHeight = 3.0
      gridOrient = 250, 0, 340

   table = injTiming2Tbl, injTiming2Map, "Injection Timing Table2", 4
      xBins	  = srpm_injadv2, rpm
      yBins   = smap_injadv2, fuelload
      zBins	  = injadvTable2
      upDownLabel = "ADVANCING", "RETARDING"
      gridHeight = 3.0
      gridOrient = 250, 0, 340

   table = injTiming3Tbl, injTiming3Map, "Injection Timing Table3", 2
      xBins	  = srpm_injadv3, rpm
      yBins   = smap_injadv3, fuelload
      zBins	  = injadvTable3
      upDownLabel = "ADVANCING", "RETARDING"
      gridHeight = 3.0
      gridOrient = 250, 0, 340

;std 16x16
#if INI_VERSION_2
   table = veTrim1Tbl, veTrim1Map, "VE Trim Table 1", 4
      ;             constant,   variable
      xBins       = frpm_trim1, rpm
      yBins       = fmap_trim1, fuelload
      zBins       = veTrim1

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

   table = veTrim2Tbl, veTrim2Map, "VE Trim Table 2", 6
      ;             constant,   variable
      xBins       = frpm_trim2, rpm
      yBins       = fmap_trim2, fuelload
      zBins       = veTrim2

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

   table = veTrim3Tbl, veTrim3Map, "VE Trim Table 3", 6
      ;             constant,   variable
      xBins       = frpm_trim3, rpm
      yBins       = fmap_trim3, fuelload
      zBins       = veTrim3

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

   table = veTrim4Tbl, veTrim4Map, "VE Trim Table 4", 6
      ;             constant,   variable
      xBins       = frpm_trim4, rpm
      yBins       = fmap_trim4, fuelload
      zBins       = veTrim4

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

;same again but 12x12
   table = veTrim1Tbldoz, veTrim1Mapdoz, "VE Trim Table 1", 4
      ;             constant,   variable
      xBins       = frpm_trim1doz, rpm
      yBins       = fmap_trim1doz, fuelload
      zBins       = veTrim1dozen

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

   table = veTrim2Tbldoz, veTrim2Mapdoz, "VE Trim Table 2", 6
      ;             constant,   variable
      xBins       = frpm_trim2doz, rpm
      yBins       = fmap_trim2doz, fuelload
      zBins       = veTrim2dozen

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

   table = veTrim3Tbldoz, veTrim3Mapdoz, "VE Trim Table 3", 6
      ;             constant,   variable
      xBins       = frpm_trim3doz, rpm
      yBins       = fmap_trim3doz, fuelload
      zBins       = veTrim3dozen

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.

   table = veTrim4Tbldoz, veTrim4Mapdoz, "VE Trim Table 4", 6
      ;             constant,   variable
      xBins       = frpm_trim4doz, rpm
      yBins       = fmap_trim4doz, fuelload
      zBins       = veTrim4dozen

      upDownLabel = "RICHER", "LEANER"
      gridHeight  = 2.0
      gridOrient  = 250,   0, 340 ; Space 123 rotation of grid in degrees.
#endif

   table = boostctlDutys, boostctlDtyMap, "Boost Control Duty", 2
      xBins       = boost_ctl_pwmtarg_rpm_bins, rpm
      yBins	  = boost_ctl_pwmtarg_tps_bins, throttle
      zBins       = boost_ctl_pwm_targets
      upDownLabel = "HIGHER", "LOWER"
      gridHeight = 2.0
      gridOrient = 250, 0, 340

   table = boostctlTargs, boostctlTargMap, "Boost Control Targets", 2
      xBins       = boost_ctl_loadtarg_rpm_bins, rpm
      yBins       = boost_ctl_loadtarg_tps_bins, throttle
      zBins       = boost_ctl_load_targets
      upDownLabel = "HIGHER", "LOWER"
      gridHeight  = 2.0
      gridOrient  = 250, 0, 340


;-------------------------------------------------------------------------------

[GaugeConfigurations]

   ;-------------------------------------------------------------------------------
   ;  Notes on some of the gauges.
   ;
   ;  The accelEnrichGauge is now a composite of both acceleration enrichment
   ;  and deceleration enleanment numbers.  See the definition of the variable
   ;  accDecEnrich in the OutputChannels section.
   ;
   ;  David Hooke contributed the lambda gauge and associated transfer
   ;  function files.
   ;
   ;  The lambda gauge is the best way (my opinion) to report data from a
   ;  wide band EGO gauge, it standardizes the output irrespective of fuel
   ;  or mix of fuels, so you needn't do any brainwork to know if your 75%
   ;  gasoline and 25% methanol is rich at 10:1 or not.
   ;
   ;  Use the file WBlambda100AVR.inc, if using a standard ADC (e.g., AVR cpu).
   ;  Use the file WBlambda100MOT.inc, if using a biased ADC (e.g., MOT cpu).
   ;-------------------------------------------------------------------------------
   ; Define a gauge's characteristics here, then go to a specific layout
   ; block (Tuning or FrontPage) and use the name you've defined here to
   ; display that gauge in a particular position.
   ;
   ; Name  = Case-sensitive, user-defined name for this gauge configuration.
   ; Var   = Case-sensitive name of variable to be displayed, see the
   ;         OutputChannels block in this file for possible values.
   ; Title = Title displayed at the top of the gauge.
   ; Units = Units displayed below value on gauge.
   ; Lo    = Lower scale limit of gauge.
   ; Hi    = Upper scale limit of gauge.
   ; LoD   = Lower limit at which danger color is used for gauge background.
   ; LoW   = Lower limit at which warning color is used.
   ; HiW   = Upper limit at which warning color is used.
   ; HiD   = Upper limit at which danger color is used.
   ; vd    = Decimal places in displayed value
   ; ld    = Label decimal places for display of Lo and Hi, above.

   ;Name               Var            Title                 Units     Lo     Hi     LoD    LoW   HiW   HiD vd ld

   advBucketGauge    = veTuneValue,   "Advance Bucket",     "degrees", 0,    55,    -1,     -1,  999,  999, 1, 1
   advdegGauge       = advance,       "Ignition Advance",   "degrees", 0,    50,    -1,     -1,  999,  999, 1, 1

   IACgauge          = iacstep,       "IAC position",       "steps",   0,   255,    -1,     -1,  999,  999, 0, 0
   dwellGauge        = dwell,         "Dwell",              "mSec",    0,    10,   0.5,    1.0,  6.0,  8.0, 1, 1
;  IAC step == idle pwm, when using pwm idle control.
   PWMIdlegauge      = idleDC,        "Idle PWM%",          "%",       0,   100,    -1,     -1,  999,   90, 1, 1

   accelEnrichGauge  = accDecEnrich,  "Accel Enrich",       "%",      50,   150,     -1,    -1,  999,  999, 0, 0
   afr1Gauge         = afr1,          "Air:Fuel Ratio",     "",       10,  19.4,     12,    13,   15,   16, 2, 2
   afr2Gauge         = afr2,          "Air:Fuel Ratio2",     "",       10,  19.4,     12,    13,   15,   16, 2, 2
   clockGauge        = seconds,       "Clock",              "Seconds", 0,  65535,     10,    10,  65535,  65535, 0, 0
   deadGauge         = deadValue,     "---",                "",        0,     1,     -1,    -1,    2,    2, 0, 0
   dutyCycle1Gauge   = dutyCycle1,    "Duty Cycle 1",       "%",       0,   100,     -1,    -1,   85,   90, 1, 1
   dutyCycle2Gauge   = dutyCycle2,    "Duty Cycle 2",       "%",       0,   100,     -1,    -1,   85,   90, 1, 1
   egoCorrGauge      = egoCorrection, "EGO Correction",     "%",      50,   150,     90,    99,  101,  110, 1, 1
   egoCorrGauge1     = egoCorrection1,"EGO Correction 1",   "%",      50,   150,     90,    99,  101,  110, 1, 1
   egoCorrGauge2     = egoCorrection2,"EGO Correction 2",   "%",      50,   150,     90,    99,  101,  110, 1, 1
   egoGauge          = egoVoltage,    "Exhaust Gas Oxygen", "volts",   0,   1.0,    0.2,   0.3,  0.7,  0.8, 2, 2
   egoVGauge          = egoV,    "Exhaust Gas Oxygen", "volts",   0,   5,    5,   5,  5,  5, 5, 2
   egoV2Gauge         = egoV2,    "Exhaust Gas Oxygen2", "volts",   0,   5,    5,   5,  5,  5, 5, 2
   knockGauge        = knockRetard    "Knock Retard",       "deg",     0,  25.0,     -1,    -1,  5.0, 10.0, 1, 1
   lambda1Gauge      = lambda1,       "Lambda",             "",      0.5,   1.5,    0.5,   0.7,    2,  1.1, 2, 2
   lambda2Gauge      = lambda2,       "Lambda",             "",      0.5,   1.5,    0.5,   0.7,    2,  1.1, 2, 2

   gammaEnrichGauge  = gammaEnrich,   "Gamma Enrichment",   "%",      50,   150,     -1,    -1,  151,  151, 0, 0
   mapGauge          = map,           "Engine MAP",         "kPa",     0,   255,      0,    20,  200,  245, 1, 0
   barometerGauge    = barometer,     "Barometer",          "kPa",    60,   120,      0,    20,  200,  245, 1, 0
   fuelloadGauge      = fuelload,     "Fuel Load",          "%",     0,   255,      0,    20,  200,  245, 1, 0
   fuelload2Gauge    = fuelload2,     "Secondary Fuel Load", "%",    0,   255,      0,    20,  200,  245, 1, 0
   ignloadGauge      = ignload,       "Ign Load",           "%",     0,   255,      0,    20,  200,  245, 1, 0
   ignload2Gauge     = ignload2,      "Secondary Ign Load", "%",     0,   255,      0,    20,  200,  245, 1, 0
   eaeloadGauge      = eaeload,       "EAE load",           "%",     0,   255,      0,    20,  200,  245, 1, 0
   afrloadGauge      = afrload,       "AFR load",           "%",     0,   255,      0,    20,  200,  245, 1, 0
   pulseWidth1Gauge  = pulseWidth1,   "Pulse Width 1",      "mSec",    0,  25.5,    1.0,   1.2,   20,   25, 3, 1
   pulseWidth2Gauge  = pulseWidth2,   "Pulse Width 2",      "mSec",    0,  25.5,    1.0,   1.2,   20,   25, 3, 1
   tachometer        = rpm,           "Engine Speed",       "RPM",     0,  8000,    300,   600, 3000, 5000, 0, 0
   throttleGauge     = throttle,      "Throttle Position",  "%",       0,   100,     -1,     1,   90,  100, 0, 0
   veBucketGauge     = veTuneValue,   "VE Value",           "%",       0,   120,     -1,    -1,  999,  999, 0, 0
   veGauge1          = veCurr1,       "VE Current1",         "%",       0,   120,     -1,    -1,  999,  999, 1, 1
   veGauge2          = veCurr2,       "VE2 Current",         "%",       0,   120,     -1,    -1,  999,  999, 1, 1
   voltMeter         = batteryVoltage,"Battery Voltage",    "volts",   7,    21,      8,     9,   15,   16, 2, 2
   warmupEnrichGauge = warmupEnrich,  "Warmup Enrichment",  "%",     100,   150,     -1,    -1,  101,  105, 0, 0

   ;Name               Var            Title                 Units     Lo     Hi     LoD    LoW   HiW   HiD vd ld

#if CELSIUS
	#if EXPANDED_CLT_TEMP
	  cltGauge          = coolant,       "Coolant Temp",       "°C",    -40,   230,    -100,     -100,   170,  200, 0, 0
	#else
	  cltGauge          = coolant,       "Coolant Temp",       "°C",    -40,   150,    -100,     -100,   95,  105, 0, 0
	#endif
   matGauge          = mat,           "Manifold Air Temp",  "°C",    -40,   110,    -15,     0,   95,  100, 0, 0
    #if EGTFULL
   egtGauge6          = egt6temp,           "EGT",                   "C",    0,  1250, 0, 0,     1250,   1250, 1, 1
   egtGauge7          = egt7temp,           "EGT" ,                   "C",    0,  1250, 0, 0,     1250,   1250, 1, 1
    #else
   egtGauge6          = egt6temp,           "EGT",                   "C",    0,  1000, 0, 0,     1000,   1000, 1, 1
   egtGauge7          = egt7temp,           "EGT" ,                   "C",    0,  1000, 0, 0,     1000,   1000, 1, 1
    #endif
#else
	#if EXPANDED_CLT_TEMP
	  cltGauge          = coolant,       "Coolant Temp",       "°F",    -40,   450,      -100,    -100,  350,  400, 0, 0
	#else
	  cltGauge          = coolant,       "Coolant Temp",       "°F",    -40,   300,      -100,    -100,  200,  220, 0, 0
	#endif
   matGauge          = mat,           "Manifold Air Temp",  "°F",    -40,   215,      0,    30,  200,  210, 0, 0
    #if EGTFULL
   egtGauge6          = egt6temp,           "EGT",                   "F",    0,  2280, 0, 0,     2280,   2280, 1, 1
   egtGauge7          = egt7temp,           "EGT",                   "F",    0,  2280, 0, 0,     2280,   2280, 1, 1
    #else
   egtGauge6          = egt6temp,           "EGT",                   "F",    0,  1830, 0, 0,     1830,   1830, 1, 1
   egtGauge7          = egt7temp,           "EGT",                   "F",    0,  1830, 0, 0,     1830,   1830, 1, 1
    #endif
#endif
; for diagnotics
   status1Gauge  = status1,   "Status 1",      "",    0,  255,    255, 255,  255,   255, 0, 0
   status2Gauge  = status2,   "Status 2",      "",    0,  255,    255, 255,  255,   255, 0, 0
   status3Gauge  = status3,   "Status 3",      "",    0,  255,    255, 255,  255,   255, 0, 0
   status4Gauge  = status4,   "Status 4",      "",    0,  255,    255, 255,  255,   255, 0, 0
   status5Gauge  = status5,   "Status 5",      "",    0,  65535,    65535, 65535,  65535,   65535,0, 0
   looptimeGauge = looptime,   "Mainloop time",      "us",    0,  65535,    255, 255,  255,   255, 0, 0
   WFGauge1 = wallfuel1, "Fuel on the walls 1", "", 0, 40000000, 0, 0, 40000000, 40000000, 0, 0
   WFGauge2 = wallfuel2, "Fuel on the walls 2", "", 0, 40000000, 0, 0, 40000000, 40000000, 0, 0
   EAEGauge1 = EAEFuelCorr1, "EAE Fuel Correction 1", "%",       0,   200,     40,    70,  130,  160, 0, 0
   EAEGauge2 = EAEFuelCorr2, "EAE Fuel Correction 2", "%",       0,   200,     40,    70,  130,  160, 0, 0
   adc6Gauge  = adc6,   "ADC 6",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   adc7Gauge  = adc7,   "ADC 7",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   gpioadc0Gauge  = gpioadc0,   "GPIO ADC 0",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   gpioadc1Gauge  = gpioadc1,   "GPIO ADC 1",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   gpioadc2Gauge  = gpioadc2,   "GPIO ADC 2",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   gpioadc3Gauge  = gpioadc3,   "GPIO ADC 3",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   gpioadc4Gauge  = gpioadc4,   "GPIO ADC 4",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   gpioadc5Gauge  = gpioadc5,   "GPIO ADC 5",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   gpioadc6Gauge  = gpioadc6,   "GPIO ADC 6",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0
   gpioadc7Gauge  = gpioadc7,   "GPIO ADC 7",      "",    0,  1023,    1023, 1023,  1023,   1023,0, 0

   timingerrGauge = timing_err, "Timing pred err", "%", -12.7, 12.7, 255,255,255,0,1
   boostdutyGauge    = boostduty,     "Boost Duty",         "%",       0,    100,   -1,     -1,  100,  100, 1, 1
   lostsyncGauge = synccnt, "Lost sync counter", "", 0, 255, 255, 255, 255, 255, 0, 0
   syncreasonGauge = syncreason, "Lost sync reason", "", 0, 255, 255, 255, 255, 255, 0, 0
   injadv1Gauge = inj_adv1,       "Injection Timing 1",   "degrees", -360,   360,    -999,     -999,  999,  999, 1, 1
   injadv2Gauge = inj_adv2,       "Injection Timing 2",   "degrees", -360,   360,    -999,     -999,  999,  999, 1, 1
   pulseWidth3Gauge  = pulseWidth3,   "Pulse Width 3",      "mSec",    0,  25.5,    1.0,   1.2,   20,   25, 3, 1
   pulseWidth4Gauge  = pulseWidth4,   "Pulse Width 4",      "mSec",    0,  25.5,    1.0,   1.2,   20,   25, 3, 1
   vetrimGauge1   = vetrim1curr,       "VE Trim 1",         "%",        87,  113,     -999,    -999,  999,  999, 1, 1
   vetrimGauge2   = vetrim2curr,       "VE Trim 2",         "%",        87,  113,     -999,    -999,  999,  999, 1, 1
   vetrimGauge3   = vetrim3curr,       "VE Trim 3",         "%",        87,  113,     -999,    -999,  999,  999, 1, 1
   vetrimGauge4   = vetrim4curr,       "VE Trim 4",         "%",        87,  113,     -999,    -999,  999,  999, 1, 1
   user0Gauge = user0, "User defined", "", 0, 65535, 65535, 65535, 65535, 65535, 0, 0
   mafGauge = maf,  "Mass Air Flow", "g/sec",   0,   650,      0,   200,  480,  550, 0, 0
   mafMapGauge = mafmap, "MAFMAP", "kPa",       0,   400,      -1,  -1,   999,  999, 0, 0
   rpmdot = rpmdot, "rpmdot", "rpm/sec", -15000, 15000, 65535, 65535, 65535, 65535, 0, 0
   tpsdot = tpsDOT, "tpsdot", "%/sec", -15000, 15000, 65535, 65535, 65535, 65535, 0, 0
   mapdot = mapDOT, "mapdot", "kPa/sec", -15000, 15000, 65535, 65535, 65535, 65535, 0, 0
;------------------------------------------------------------------------------

[FrontPage]
#if   NARROW_BAND_EGO
   egoLEDs         =  0.0, 1.0,  0.5 ; Voltage settings.
#elif LAMBDA
   egoLEDs         =  1.5, 0.5,  1.0 ; Lambda settings.
#else
   egoLEDs         = 19.7, 9.7, 14.7 ; Afr settings.
#endif

   ; Gauges are numbered left to right, top to bottom.
   ;
   ;    1  2  3  4
   ;    5  6  7  8

   gauge1 = tachometer
   gauge2 = EAEGauge1
;   gauge2 = lostsyncGauge
   gauge3 = pulseWidth1Gauge
   gauge4 = pulseWidth2Gauge
;   gauge4 = cltGauge
   gauge5 = advdegGauge
   gauge6 = fuelloadGauge
   gauge7 = injadv1Gauge
;   gauge7 = afr1Gauge
;   gauge7 = dwellGauge
;   gauge8 = matGauge
   gauge8 = injadv2Gauge

   ;----------------------------------------------------------------------------
   ; Indicators
   ;               expr         off-label          on-label, off-bg, off-fg, on-bg, on-fg
   ;   indicator = { tpsaen }, "Not Accelerating", "AE",     cyan,   white,  red,   black
   ;
   ; Look in the new colors24b.ini for the basic ones, add more or tell me what to add.

   indicator = { ready              }, "Not Ready",    "Ready",       white, black, green, black
   indicator = { crank              }, "Not Cranking", "Cranking",    white, black, red,   black
   indicator = { startw             }, "ASE OFF",      "ASE",         white, black, red,   black
   indicator = { warmup             }, "WUE OFF",      "WUE",         white, black, green, black
   indicator = { tpsaccaen          }, "TPS Accel Enrich",    "TPS Accel Enrich",   white, black, green, black
   indicator = { mapaccaen          }, "MAP Accel Enrich",    "MAP Accel Enrich",   white, black, green, black
   indicator = { tpsaccden          }, "TPS Decel", "TPS Decel", white, black, green, black
   indicator = { mapaccden          }, "MAP Decel", "MAP Decel", white, black, green, black
;   indicator = { tps > floodClear && crank }, "", "FLOOD CLEAR", white, black, red,   black
;   indicator = { port0              }, "Port 0 Off",   "Port 0 On",   white, black, red,   black
   indicator = { status1 & 0b00000100}, "-",   "Config Error",   white, black, red,   black
   indicator = { status1 & 0b00000001}, "-",   "Need Burn",   white, black, red,   black
   indicator = { status1 & 0b00000010}, "-",   "Lost Data",   white, black, red,   black
   indicator = { status1 & 0b00001000}, "Not synced", "Synced", red, black, green, black
;optional ones
   indicator = { status2 & 0b10000000}, "-", "CL idle", white, black, green, black
   indicator = { status1 & 0b00100000}, "-", "Fuel Tbl sw", white, black, green, black
   indicator = { status1 & 0b01000000}, "-", "Spk Tbl sw", white, black, green, black
   indicator = { status2 & 0b00000001}, "-", "N2O 1", white, black, green, black
   indicator = { status2 & 0b00000010}, "-", "N2O 2", white, black, green, black
   indicator = { status2 & 0b00000100}, "-", "Hard limit", white, black, red, black
   indicator = { status2 & 0b00001000}, "-", "Launch", white, black, green, black
   indicator = { status2 & 0b00010000}, "-", "Flat shift", white, black, green, black
   indicator = { status2 & 0b00100000}, "-", "Spark cut", white, black, red, black
   indicator = { status2 & 0b01000000}, "-", "Over boost", white, black, red, black
   indicator = { knock },               "-", "Knock", white, black, red, black
   indicator = { status3 & 0b00000010}, "-", "T-log", white, black, red, black


;-------------------------------------------------------------------------------

[RunTime]
   barHysteresis = 2.5 ; Seconds
#if CELSIUS
	#if EXPANDED_CLT_TEMP
	  coolantBar    = -40,  230
	#else
	  coolantBar    = -40,  150
	#endif
   matBar        = -40,  100
#else
	#if EXPANDED_CLT_TEMP
	  coolantBar    = -40,  450
	#else
	  coolantBar    = -40,  300
	#endif
   matBar        = -40,  215
#endif

   batteryBar    =   6,   15
   dutyCycleBar  =   0,  100
#if   NARROW_BAND_EGO
   egoBar        = 0.0 ,  1.0
#elif LAMBDA
   egoBar        = 0.5,   1.5
#else
   egoBar        = 9.7,  19.7
#endif
   gammaEBar     =   0,  200
   mapBar        =   0,  255
   pulseWidthBar =   0,   25.5
   rpmBar        =   0, 8000
   throttleBar   =   0,  100

   egoCorrBar    =   0,  200
   baroCorrBar   =   0,  200
   warmupCorrBar =   0,  200
   airdenCorrBar =   0,  200
   veCorrBar     =   0,  200
   accCorrBar    =   0,  100

;-------------------------------------------------------------------------------

[Tuning]
#if   NARROW_BAND_EGO
   egoLEDs         =  0.0, 1.0,  0.5 ; Voltage settings.
#elif LAMBDA
   egoLEDs         =  1.5, 0.5,  1.0 ; Lambda settings.
#else
   egoLEDs         = 19.7, 9.7, 14.7 ; Afr settings.
#endif

;  font            = "Lucida Console", 12
;  font            = "Courier", 14
   spotDepth       =   2 ; 0 = no indicators, 1 = Z only, 2 = XYZ indicators.
   cursorDepth     =   2 ; Same as spot depth.

   ; The four radio buttons on the tuning screen select a "page" of six
   ; gauges.  The gauge numbering is the same as the front page, across
   ; then down.
   ;             1  2
   ;             3  4
   ;             5  6
   ;
   ; gaugeColumns allows you to hide or show gauges in column 2 (i.e.,
   ; gauges 2, 4 and 6).

   gaugeColumns = 2 ; Only 1 or 2 are valid.

   ;              Page 1            Page 2             Page 3            Page 4
   pageButtons  = "&EGO",           "&WUE",            "PW&1",           "PW&2"
   gauge1       = tachometer,       tachometer,        tachometer,       tachometer
   gauge2       = mapGauge,         mapGauge,          mapGauge,         mapGauge
#if   NARROW_BAND_EGO
   gauge3       = egoGauge,         egoGauge,          egoGauge,         egoGauge
#elif LAMBDA
   gauge3       = lambda1Gauge,     lambda1Gauge,      lambda1Gauge,     lambda1Gauge
#else
   gauge3       = afr1Gauge,        afr1Gauge,         afr1Gauge,        afr1Gauge
#endif
   gauge4       = egoCorrGauge,     warmupEnrichGauge, pulseWidth1Gauge, pulseWidth2Gauge
   gauge5       = veBucketGauge,    veBucketGauge,     veBucketGauge,    veBucketGauge
   gauge6       = accelEnrichGauge, accelEnrichGauge,  dutyCycle1Gauge,  dutyCycle2Gauge

;-------------------------------------------------------------------------------

[AccelerationWizard]
   tpsDotBar = 0, 800
   mapDotBar = 0, 700

;-------------------------------------------------------------------------------

[BurstMode]
;   getCommand       = "a\x00\x06"
   getCommand       = "A"

[OutputChannels]
   deadValue        = { 0 } ; Convenient unchanging value.

#if CAN_COMMANDS
;full version that works anywhere
   ochGetCommand    = "r\x00\x07\x00\x00\x00\xA9"
#else
; fast get via serial
   ochGetCommand       = "A"
; was one byte longer for checksum
#endif
   ochBlockSize     = 169  ; without checksum byte

   seconds          = scalar, U16,    0, "s",   1.000, 0.0
   secl = { seconds % 256 }, "s" ; For runtime screen.
   pulseWidth1      = scalar, U16,    2, "s",   0.000666, 0.0
   pulseWidth2      = scalar, U16,    4, "s",   0.000666, 0.0
   pulseWidth       = { pulseWidth1 }, "s" ; For runtime screen.

   rpm              = scalar, U16,    6, "RPM", 1.000, 0.0
   advance          = scalar, S16,    8, "deg", 0.100, 0.0

   ; unsigned char squirt,engine,afrtgt1,afrtgt2;    // afrtgt in afr x 10
   squirt           = scalar, U08,   10, "bit", 1.000, 0.0
   ; Squirt Event Scheduling Variables - bit fields for "squirt" variable above
   ; inj1:    equ    3       ; 0 = no squirt         1 = squirt
   ; inj2:    equ    5       ; 0 = no squirt         1 = squirt
   ; sched1:  equ    2       ; 0 = nothing scheduled 1 = scheduled to squirt
   ; firing1: equ    0       ; 0 = not squirting     1 = squirting
   ; sched2:  equ    4
   ; firing2: equ    1
   firing1          = bits,   U08,   10, [0:0]
   firing2          = bits,   U08,   10, [1:1]
   sched1           = bits,   U08,   10, [2:2]
   inj1             = bits,   U08,   10, [3:3]
   sched2           = bits,   U08,   10, [4:4]
   inj2             = bits,   U08,   10, [5:5]

   engine           = scalar, U08,   11, "bit", 1.000, 0.0
   ; Engine Operating/Status variables - bit fields for "engine" variable above
   ; ready:  equ     0       ; 0 = engine not ready 1 = ready to run
   ; crank:  equ     1       ; 0 = engine not cranking 1 = engine cranking
   ; startw: equ     2       ; 0 = not in startup warmup 1 = in warmup enrichment
   ; warmup: equ     3       ; 0 = not in warmup 1 = in warmup
   ; tpsaen: equ     4       ; 0 = not in TPS acceleration mode 1 = TPS acceleration mode
   ; tpsden: equ     5       ; 0 = not in deacceleration mode 1 = in deacceleration mode
   ready            = bits,   U08,   11, [0:0]
   crank            = bits,   U08,   11, [1:1]
   startw           = bits,   U08,   11, [2:2]
   warmup           = bits,   U08,   11, [3:3]
   tpsaccaen        = bits,   U08,   11, [4:4]
   tpsaccden        = bits,   U08,   11, [5:5]
   mapaccaen	  = bits,   U08,   11, [6:6]
   mapaccden        = bits,   U08,   11, [7:7]

   afrtgt1          = scalar, U08,   12, "AFR", 10.00, 0.0
   afrtgt2          = scalar, U08,   13, "AFR", 10.00, 0.0

   ; unsigned char wbo2_en1,wbo2_en2; // from wbo2 - indicates whether wb afr valid
   wbo2_en1         = scalar, U08,   14, "",    1.000, 0.0
   wbo2_en2         = scalar, U08,   15, "",    1.000, 0.0

   ; int baro,map,mat,clt,tps,batt,ego1,ego2,knock, // baro   - kpa x 10
   ;                                                // map    - kpa x 10
   ;                                                // mat, clt deg(C/F)x 10
   ;                                                // tps    - % x 10
   ;                                                // batt   - vlts x 10
   ;                                                // ego1,2 - afr x 10
   ;                                                // knock  - volts x 10
   barometer        = scalar, S16,   16, "kPa", 0.100, 0.0
   map              = scalar, S16,   18, "kPa", 0.100, 0.0
#if CELSIUS
   mat              = scalar, S16,   20, "°C",  0.05555, -320.0
   coolant          = scalar, S16,   22, "°C",  0.05555, -320.0
#else
   mat              = scalar, S16,   20, "°F",  0.100, 0.0
   coolant          = scalar, S16,   22, "°F",  0.100, 0.0
#endif
   tps              = scalar, S16,   24, "%",   0.100, 0.0
;   tpsADC           = { tps*10.23 }, "ADC" ; Fake for calibrator and file indexing.
   throttle         = { tps }, "%"
   batteryVoltage   = scalar, S16,   26, "v",   0.100, 0.0
   afr1             = scalar, S16,   28, "AFR", 0.100, 0.0
   afr2             = scalar, S16,   30, "AFR", 0.100, 0.0
   lambda1          = { afr1 / 14.7 }, "Lambda"
   lambda2          = { afr2 / 14.7 }, "Lambda"
   knock            = scalar, S16,   32, "v",   0.100, 0.0

   ; egocor1,egocor2,aircor,warmcor,     // all in %
   egoCorrection1   = scalar, S16,   34, "%",   0.1000, 0.0
   egoCorrection = { ( egoCorrection1 + egoCorrection2) / 2 }, "%" ; Alias for old gauges.
   egoCorrection2   = scalar, S16,   36, "%",   0.1000, 0.0
   airCorrection    = scalar, S16,   38, "%",   1.000, 0.0
   warmupEnrich     = scalar, S16,   40, "%",   1.000, 0.0

   ; tpsaccel,tpsfuelcut,barocor,gammae, // tpsaccel - acc enrich(.1 ms units)
   ;                                     // tpsfuelcut - %
   ;                                     // barcor,gammae - %
   accelEnrich      = scalar, S16,   42, "ms", 0.100, 0.0
   tpsfuelcut       = scalar, S16,   44, "%",   1.000, 0.0
   baroCorrection   = scalar, S16,   46, "%",   1.000, 0.0
   gammaEnrich      = scalar, S16,   48, "%",   1.000, 0.0

   ;  vecurr1,vecurr2,iacstep,cold_adv_deg;           // vecurr - %
   ;                                                  // iacstep - steps
   ;                                                  // cold_adv_deg - deg x 10
   veCurr1          = scalar, S16,   50, "%",   0.1000, 0.0
   veCurr2          = scalar, S16,   52, "%",   0.1000, 0.0
   veCurr           = { veCurr1 }, "%" ; For runtime display.
   iacstep          = scalar, S16,   54, "",    1.000, 0.0
   idleDC           = scalar, S16,   54, "",    0.39063, 0.0
   coldAdvDeg       = scalar, S16,   56, "deg", 0.100, 0.0
   tpsDOT           = scalar, S16,   58, "%/s",   0.100, 0.0
   mapDOT           = scalar, S16,   60, "kPa/s", 1.000, 0.0
   dwell            = scalar, U16,   62, "ms",    0.0666, 0.0
   mafmap           = scalar, S16,   64, "?",     1.000, 0.0
   fuelload         = scalar, S16,   66, "%",   0.100, 0.0 ; Blend of MAP and TPS, depends on algorithm
   fuelCorrection   = scalar, S16,   68, "%",     1.000, 0.0 ; Percent alcohol in fuel.

   portStatus       = scalar, U08,   70, "bit",   1.000, 0.0 ; Spare port status bits
   port0            = bits,   U08,   70, [0:0]
   port1            = bits,   U08,   70, [1:1]
   port2            = bits,   U08,   70, [2:2]
   port3            = bits,   U08,   70, [3:3]
   port4            = bits,   U08,   70, [4:4]
   port5            = bits,   U08,   70, [5:5]
   port6            = bits,   U08,   70, [6:6]

   knockRetard      = scalar, U08,   71, "deg",     0.1, 0.0
   EAEFuelCorr1	    = scalar, U16,   72, "%",  1.0, 0.0
   egoV             = scalar, S16,   74, "V", 0.01, 0.0 ; was omitted
   egoV2            = scalar, S16,   76, "V", 0.01, 0.0 ; was omitted
   status1          = scalar, U08,   78, "", 1.0, 0.0 ; status1
   status2          = scalar, U08,   79, "", 1.0, 0.0 ; status2
   status3          = scalar, U08,   80, "", 1.0, 0.0 ; status3
   status4          = scalar, U08,   81, "", 1.0, 0.0 ; status4
   looptime         = scalar, U16,   82, "us", 0.6667, 0.0
   status5          = scalar, U16,   84, "us", 1, 0 ; istatus5
   tpsADC           = scalar, U16,   86, "ADC", 1, 0 ; REAL for calibrator and file indexing.
   fuelload2	    = scalar, S16,   88, "%",    0.100, 0.0
   ignload	    = scalar, S16,   90, "%",    0.100, 0.0
   ignload2	    = scalar, S16,   92, "%",    0.100, 0.0
;spare[5] were in here - removed
   synccnt         = scalar,  U08,     94, "", 1, 0
   timing_err       = scalar, S08,   95, "%", 0.1, 0 ; accuracy of timing prediction
   deltaT           = scalar, S32,  96, "uS",    1.000, 0.0 ; Normalized time between trigger pulses,
                                                             ; "fills in" missing teeth (only used with EDIS)
   wallfuel1	    = scalar, U32,  100, "uS",    1.000, 0.0

   gpioadc0	    = scalar, U16,  104, "",   1.000, 0.0
   gpioadc1     = scalar, U16,  106, "",   1.000, 0.0
   gpioadc2	    = scalar, U16,  108, "",   1.000, 0.0
   gpioadc3	    = scalar, U16,  110, "",   1.000, 0.0
   gpioadc4	    = scalar, U16,  112, "",   1.000, 0.0
   gpioadc5	    = scalar, U16,  114, "",   1.000, 0.0
   gpioadc6	    = scalar, U16,  116, "",   1.000, 0.0
   gpioadc7	    = scalar, U16,  118, "",   1.000, 0.0

   gpiopwmin0	    = scalar, U16,  120, "",   1.000, 0.0
   gpiopwmin1	    = scalar, U16,  122, "",   1.000, 0.0
   gpiopwmin2	    = scalar, U16,  124, "",   1.000, 0.0
   gpiopwmin3	    = scalar, U16,  126, "",   1.000, 0.0
;the following re-arrange for RC2 to ensure safe alignment for CAN-passthrough
   adc6 	    = scalar, U16,  128, "",   1, 0.0
   adc7 	    = scalar, U16,  130, "",   1, 0.0
   wallfuel2	    = scalar, U32,  132, "uS", 1.000, 0.0
   EAEFuelCorr2	    = scalar, U16,  136 , "%",  1.0, 0.0
   boostduty	    = scalar, U08,  138 , "%",  1.0, 0.0
   syncreason       = scalar, U08,  139,  "", 1.0, 0.0
   user0            = scalar, U16,  140,  "", 1.0, 0.0

   inj_adv1     = scalar, S16,  142, "deg", 0.100, 0.0
   inj_adv2     = scalar, S16,  144, "deg", 0.100, 0.0
   pulseWidth3  = scalar, U16,  146, "s",   0.000666, 0.0
   pulseWidth4  = scalar, U16,  148, "s",   0.000666, 0.0
   vetrim1curr  = scalar, S16,   150, "%",   0.00976562500, 10240.0
   vetrim2curr  = scalar, S16,   152, "%",   0.00976562500, 10240.0
   vetrim3curr  = scalar, S16,   154, "%",   0.00976562500, 10240.0
   vetrim4curr  = scalar, S16,   156, "%",   0.00976562500, 10240.0
   maf          = scalar, U16,   158, "g/sec", 0.010,  0.0
   eaeload      = scalar, S16,   160, "%", 0.1, 0.0
   afrload      = scalar, S16,   162, "%", 0.1, 0.0
   rpmdot       = scalar, S16,   164, "rpm/sec", 10, 0.0

   gpioport0	    = scalar, U08,  166, "",   1.000, 0.0 was 142
   gpioport1	    = scalar, U08,  167, "",   1.000, 0.0 was 143
   gpioport2	    = scalar, U08,  168, "",   1.000, 0.0 was 144

; checksum scrapped for now to always enable speedup code for realtime data
   accDecEnrich     = { accelEnrich + (tpsaccden ? tpsfuelcut : 100)      }, "%"
   time             = { timeNow                                        }, "s"
   rpm100           = { rpm / 100.0                                    }

   altDiv1          = { alternate ? 2 : 1                              }
   altDiv2          = { alternate ? 2 : 1                              }

   cycleTime1       = { 60000.0 / rpm * (2.0-twoStroke)                }, "ms"
   nSquirts1        = { nCylinders/divider                             }
   dutyCycle1       = { 100.0*nSquirts1/altDiv1*pulseWidth1/cycleTime1 }, "%"

   cycleTime2       = { 60000.0 / rpm * (2.0-twoStroke)                }, "ms"
   nSquirts2        = { nCylinders/divider                             }
   dutyCycle2       = { 100.0*nSquirts2/altDiv2*pulseWidth2/cycleTime2 }, "%"

#if   NARROW_BAND_EGO
   egoVoltage = { 1.0-(afr1*0.04883) }, "V"      ; For LED bars...
#elif LAMBDA
   egoVoltage = { lambda1          }, "Lambda" ; For LED bars...
#else
   egoVoltage = { afr1             }, "AFR"    ; For LED bars...
#endif

; note these conversions are based on the AD595CQ datasheet for ANSI thermocouples.
; European thermocouples may require a different calculation
; The K type thermocouple output is not precisely linear, so these
; calculations are an approximation.
; 0degC is close enough to 0V
; With the 15K/10K circuit. 1250degC would apply 5.01V to the adc and result in '1025ADC counts' if that was possible
; So temp = adc/1025 * 1250 or adc * 1.222 
#if EGTFULL
#if CELSIUS
   egt6temp          = { adc6 * 1.222 }                              ; Setup for converting 0-5.01V = 0 - 1250C
   egt7temp          = { adc7 * 1.222 }                              ; Setup for converting 0-5.01V = 0 - 1250C
#else
   egt6temp          = { (adc6 * 2.200)+32 }                             ; Setup for converting 0-5.01V = 32 - 2282F
   egt7temp          = { (adc7 * 2.200)+32 }                             ; Setup for converting 0-5.01V = 32 - 2282F
#endif
#else ; normal 0-1000 range
; With the 10K/10K circuit. 1000degC would apply 5.10V to the adc and result in '1044ADC counts' if that was possible
#if CELSIUS
   egt6temp          = { adc6 * 0.956 }                              ; Setup for converting 0-5.10V = 0 - 1000C
   egt7temp          = { adc7 * 0.956 }                              ; Setup for converting 0-5.10V = 0 - 1000C
#else
   egt6temp          = { (adc6 * 1.721) + 32 }                             ; Setup for converting 0-5.10V = 32 - 1832F
   egt7temp          = { (adc7 * 1.721) + 32 }                             ; Setup for converting 0-5.10V = 32 - 1832F
#endif
#endif

;-------------------------------------------------------------------------------
;--  The entries are saved in the datalog file in the order in which they     --
;--  appear in the list below.                                                --
;--                                                                           --
;--   Channel - Case sensitive name of output channel to be logged.           --
;--   Label   - String written to header line of log.  Be careful             --
;--             about changing these, as programs like MSLVV and              --
;--             MSTweak key off specific column names.                        --
;--   Type    - Data type of output, converted before writing.                --
;--   Format  - C-style output format of data.                                --

[Datalog]
   ;       Channel          Label          Type    Format
   ;       --------------   ----------     -----   ------
   entry = time,            "Time",        float,  "%.3f"
   entry = seconds,         "SecL",        int,    "%d"
   entry = rpm,             "RPM",         int,    "%d"
   entry = map,             "MAP",         float,  "%.1f"
   entry = throttle,        "TP",          int,    "%d"
#if   NARROW_BAND_EGO
   entry = egoVoltage,      "O2",          float,  "%.3f"
#elif LAMBDA
   entry = lambda1,         "Lambda",      float,  "%.3f"
#else
   entry = afr1,            "AFR",         float,  "%.2f"
#endif
   entry = mat,             "MAT",         float,  "%.1f"
   entry = coolant,         "CLT",         float,  "%.1f"
   entry = engine,          "Engine",      int,    "%d"

   entry = egoCorrection,   "Gego",        int,    "%d"
   entry = airCorrection,   "Gair",        int,    "%d"
   entry = warmupEnrich,    "Gwarm",       int,    "%d"
   entry = baroCorrection,  "Gbaro",       int,    "%d"
   entry = gammaEnrich,     "Gammae",      int,    "%d"
   entry = accDecEnrich,    "TPSacc",      int,    "%d"

   entry = veCurr1,         "Gve",         int,    "%d"
   entry = pulseWidth1,     "PW",          float,  "%.3f"
   entry = dutyCycle1,      "DutyCycle1",  float,  "%.1f"

   entry = veCurr2,         "Gve2",        int,    "%d"
   entry = pulseWidth2,     "PW2",         float,  "%.3f"
   entry = dutyCycle2,      "DutyCycle2",  float,  "%.1f"

   entry = advance,         "SparkAdv",    float,  "%.1f"
   entry = knockRetard,     "knockRet",    float,  "%.1f"
   entry = coldAdvDeg,      "ColdAdv",     float,  "%.1f"
   entry = dwell,           "Dwell",       float,  "%.2f"
   entry = tpsDOT,          "tpsDOT",      float,  "%.1f"
   entry = mapDOT,          "mapDOT",      float,  "%.1f"
   entry = iacstep,         "IACstep",     int,    "%d"

   entry = batteryVoltage,  "Batt V",      float,  "%.1f"

   entry = deltaT,          "deltaT",      float,  "%.0f"
   entry = wallfuel1,        "WallFuel1",    int,    "%d"
   entry = wallfuel2,        "WallFuel2",   int,     "%d"
   entry = EAEFuelCorr1,     "EAE1 %",       int,    "%d"
   entry = EAEFuelCorr2,     "EAE2 %",      int, "%d"
   entry = fuelload,         "Load",        float,  "%.1f"
   entry = fuelload2,        "Secondary Load", float, "%.1f"
   entry = ignload,          "Ign load",   float,    "%.1f"
   entry = ignload2,         "Secondary Ign Load", float, "%.1f"
   entry = eaeload,          "EAE Load", float, "%.1f"
   entry = afrload,          "AFR Load", float, "%.1f"
   entry = egt6temp,         "EGT 6 temp", int, "%d"
   entry = egt7temp,         "EGT 7 temp", int, "%d"

   entry = gpioadc0, "gpioadc0", int, "%d"
   entry = gpioadc1, "gpioadc1", int, "%d"
   entry = gpioadc2, "gpioadc2", int, "%d"
   entry = gpioadc3, "gpioadc3", int, "%d"

   entry = status1, "status1", int, "%d"
   entry = status2, "status2", int, "%d"
   entry = status3, "status3", int, "%d"
   entry = status4, "status4", int, "%d"
   entry = status5, "status5", int, "%d"
   entry = timing_err, "timing err%", float, "%.1f"
   entry = afrtgt1,    "AFR Target 1", float, "%.1f"
   entry = boostduty,  "Boost Duty", int, "%d"
   entry = idleDC, "PWM Idle Duty", float, "%.1f"
   entry = synccnt, "Lost sync count", int, "%d"
   entry = syncreason, "Lost sync reason", int, "%d"

   entry = inj_adv1,       "InjTiming1",    float,  "%.1f"
   entry = inj_adv2,       "InjTiming2",    float,  "%.1f"
   entry = pulseWidth3,     "PW3",         float,  "%.3f"
   entry = pulseWidth4,     "PW4",         float,  "%.3f"
   entry = vetrim1curr,         "VE Trim 1",         float,    "%.1f"
   entry = vetrim2curr,         "VE Trim 2",         float,    "%.1f"
   entry = vetrim3curr,         "VE Trim 3",         float,    "%.1f"
   entry = vetrim4curr,         "VE Trim 4",         float,    "%.1f"
   entry = rpmdot,              "RPMdot",            int,      "%d"

;-------------------------------------------------------------------------------
