# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Controller {
  version_from Mojolicious;
  
  use Digest::SHA;
  use Mojo::ByteStream;
  use Mojo::URL;
  use Mojo::Util;
  use Mojolicious::Routes::Match;
  use Mojolicious;
  use Mojo::Transaction;
  use Mojo::Message::Request;
  use Mojo::Message::Response;
  use Mojo::Log;
  
  our $ABSOLUTE : string;
  INIT {
    $ABSOLUTE = "^(?:[^:/?#]+:|//|#)";
  }
  
  has app : rw Mojolicious
    set {
      $self->{app} = $_;
      weaken $self->{app};
    }
  ;
  
  has tx : rw Mojo::Transaction
    set {
      $self->{tx} = $_;
      weaken $self->{tx};
    }
  ;
  
  has match : rw Mojolicious::Routes::Match
    get {
      unless (exists $self->{match}) {
        my $match = Mojolicious::Routes::Match->new;
        
        $match->set_root($self->app->routes);
        
        $self->{match} = $match;
      }
      
      return $self->{match};
    }
  ;
  
  has stash : rw Hash;
  
  has active_session : rw int;
  
  has session : rw Hash;
  
  # Fields that is originally stash mojo.xxx
  has log : rw Mojo::Log
    get {
      unless (exists $self->{log}) {
        $self->{log} = $self->app->log->context("[" . $self->req->request_id . "]");
      }
      
      return $self->{log};
    }
  ;
  
  has captures : rw Hash;
  
  has rendered : rw byte;
  
  static method new : Mojolicious::Controller () {
    
    my $self = new Mojolicious::Controller;
    
    return $self;
  }
  
  # Instance Methods
  method req : Mojo::Message::Request () {
    
    my $tx = $self->tx;
    
    unless ($tx) {
      die "Transaction already destroyed";
    }
    
    return $tx->req;
  }
  
  method res : Mojo::Message::Response () {
    
    my $tx = $self->tx;
    
    unless ($tx) {
      die "Transaction already destroyed";
    }
    
    return $tx->res;
  }
  
  method cookie : string ($name : string) {
    
    # Request cookies
    my $cookie = $self->req->cookie($name);
    unless ($cookie) {
      return undef;
    }
    
    return $cookie->value;
  }
  
  method set_cookie : void ($name : string, $value : string, $attrs : object[] = undef) {
    
    # Response cookie
    # Cookie too big
    my $cookie = Mojo::Cookie::Response->new(Fn->merge_options({name => $name, value => $value}, $attrs));
    
    if (length $cookie->value > 4096) {
      $self->log->error("Cookie '$name' is bigger than 4KiB") ;
    }
    
    $self->res->set_cookies($name, [$cookie]);
  }
  
  method every_cookie : string[] ($name : string) {
    
    my $every_cookies = $self->req->every_cookie($name);
    
    my $every_cookies_length = @$every_cookies;
    
    my $values = new string[$every_cookies_length];
    
    for (my $i = 0; $i < $every_cookies_length; $i++) {
      $values->[$i] = $every_cookies->[$i]->value;
    }
    
    return $values;
  }
  
  method every_param : string[] ($name : string) {
    
    # Captured unreserved values
    my $captures = $self->{captures} //= Hash->new;
    
    if ($captures->exists($name) && !$self->app->routes->is_reserved($name)) {
      my $value = $captures->get("$name");
      
      return $value isa string[] ? (string[])$value : [(string)$value];
    }
    
    # Uploads or param values
    my $req     = $self->req;
    
    return $req->every_param($name);
  }
  
  method every_upload : Mojo::Upload[] ($name : string) {
    
    my $uploads = $self->req->every_upload($name);
    
    return $uploads;
  }

  method signed_cookie : string ($name : string) {

=pod

    # Request cookie
    return $self->every_signed_cookie($name)->[-1] unless defined $value;

    # Response cookie
    my $sum = Digest::SHA::hmac_sha256_hex("$name=$value", $self->app->secrets->[0]);
    return $self->cookie($name, "$value--$sum", $options);

=cut

  }
  
  method render : string ($template : string, $options : object[] = undef) {

=pod

    # Template may be first argument
    my ($template, $args) = (@_ % 2 ? shift : undef, {@_});
    $args->{template} = $template if $template;
    my $app     = $self->app;
    my $plugins = $app->plugins->emit_hook(before_render => $self, $args);

    # Localize "extends" and "layout" to allow argument overrides
    my ($maybe, $ts) = @{$args}{"mojo.maybe", "mojo.string"};
    my $stash = $self->stash;
    local $stash->{layout}  = $stash->{layout}  if exists $stash->{layout};
    local $stash->{extends} = $stash->{extends} if exists $stash->{extends};

    # Rendering to string
    local @{$stash}{keys %$args}         if $ts || $maybe;
    delete @{$stash}{qw(layout extends)} if $ts;

    # All other arguments just become part of the stash
    @$stash{keys %$args} = values %$args;
    my $renderer = $app->renderer;
    my ($output, $format) = $renderer->render($self);

    # Maybe no 404
    return defined $output ? Mojo::ByteStream->new($output) : undef if $ts;
    return $maybe          ? undef : Carp::croak("Could not render a response") unless defined $output;

    $plugins->emit_hook(after_render => $self, \$output, $format);
    return $renderer->respond($self, $output, $format, $stash->{status});

=cut

  }

=pod

  method every_signed_cookie {
    my ($self, $name) = @_;

    my $secrets = $self->app->secrets;
    my @results;
    for my $value (@{$self->every_cookie($name)}) {

      # Check signature with rotating secrets
      if ($value =~ s/--([^\-]+)$//) {
        my $signature = $1;

        my $valid;
        for my $secret (@$secrets) {
          my $check = Digest::SHA::hmac_sha256_hex("$name=$value", $secret);
          ++$valid and last if Mojo::Util::secure_compare($signature, $check);
        }
        if ($valid) { push @results, $value }

        else { $self->log->trace(qq{Cookie "$name" has bad signature}) }
      }

      else { $self->log->trace(qq{Cookie "$name" is not signed}) }
    }

    return \@results;
  }

  method finish {
    my $self = shift;

    # WebSocket
    my $tx = $self->tx || Carp::croak "Transaction already destroyed";
    $tx->finish(@_) and return $tx->established ? $self : $self->rendered(101) if $tx->is_websocket;

    # Chunked stream
    return @_ ? $self->write_chunk(@_)->write_chunk("") : $self->write_chunk("") if $tx->res->content->is_chunked;

    # Normal stream
    return @_ ? $self->write(@_)->write("") : $self->write("");
  }

  method helpers { $_[0]->app->renderer->get_helper("")->($_[0]) }

  method on {
    my ($self, $name, $cb) = @_;
    my $tx = $self->tx || Carp::croak "Transaction already destroyed";
    $self->rendered(101) if $tx->is_websocket && !$tx->established;
    return $tx->on($name => method { shift; $self->$cb(@_) });
  }

  method param {
    my ($self, $name) = (shift, shift);
    return $self->every_param($name)->[-1] unless @_;
    $self->stash->{"mojo.captures"}{$name} = @_ > 1 ? [@_] : $_[0];
    return $self;
  }

  method render_later { shift->stash("mojo.rendered" => 1) }

  method render_to_string { shift->render(@_, "mojo.string" => 1) }

  method rendered {
    my ($self, $status) = @_;

    # Make sure we have a status
    $self->res->code($status) if $status;

    # Finish transaction
    my $stash = $self->stash;
    if (!$stash->{"mojo.finished"} && ++$stash->{"mojo.finished"}) {
      my $res = $self->res;
      $res->code(200) if !$status && !$res->code;

      # Disable auto rendering and stop timer
      my $app = $self->render_later->app;
      $self->log->trace(method {
        my $timing  = $self->helpers->timing;
        my $elapsed = $timing->elapsed("mojo.timer") // 0;
        my $rps     = $timing->rps($elapsed)         // "??";
        my $code    = $res->code;
        my $msg     = $res->message || $res->default_message($code);
        return "$code $msg (${elapsed}s, $rps/s)";
      }) unless $stash->{"mojo.static"};

      $app->plugins->emit_hook_reverse(after_dispatch => $self);
      $app->sessions->store($self);
    }
    $self->tx->resume;
    return $self;
  }

  method req { (shift->tx || Carp::croak "Transaction already destroyed")->req }
  method res { (shift->tx || Carp::croak "Transaction already destroyed")->res }

  method send {
    my ($self, $msg, $cb) = @_;
    my $tx = $self->tx || Carp::croak "Transaction already destroyed";
    Carp::croak "No WebSocket connection to send message to" unless $tx->is_websocket;
    $tx->send($msg, $cb ? method { shift; $self->$cb(@_) } : ());
    return $tx->established ? $self : $self->rendered(101);
  }

  method session {
    my $self = shift;

    my $stash = $self->stash;
    $self->app->sessions->load($self) unless exists $stash->{"mojo.active_session"};

    # Hash
    my $session = $stash->{"mojo.session"} //= {};
    return $session unless @_;

    # Get
    return $session->{$_[0]} unless @_ > 1 || ref $_[0];

    # Set
    my $values = ref $_[0] ? $_[0] : {@_};
    @$session{keys %$values} = values %$values;

    return $self;
  }

  method stash { Mojo::Util::_stash(stash => @_) }

  method url_for {
    my ($self, $target) = (shift, shift // "");

    # Absolute URL
    return $target                 if Scalar::Util::blessed $target && $target->isa("Mojo::URL");
    return Mojo::URL->new($target) if $target =~ $ABSOLUTE;

    # Base
    my $url  = Mojo::URL->new;
    my $req  = $self->req;
    my $base = $url->base($req->url->base->clone)->base->userinfo(undef);

    # Relative URL
    my $path = $url->path;
    if ($target =~ m!^/!) {
      if (defined(my $prefix = $self->stash->{path})) {
        my $real = $req->url->path->to_route;
        $real =~ s!/?\Q$prefix\E$!$target!;
        $target = $real;
      }
      $url->parse($target);
    }

    # Route
    else {
      my $generated = $self->match->path_for($target, @_);
      $path->parse($generated->{path})                         if $generated->{path};
      $base->scheme($base->protocol eq "https" ? "wss" : "ws") if $generated->{websocket};
    }

    # Make path absolute
    my $base_path = $base->path;
    unshift @{$path->parts}, @{$base_path->parts};
    $base_path->parts([])->trailing_slash(0);

    return $url;
  }

  method url_for_asset {
    my ($self, $asset) = @_;
    return $self->url_for($asset =~ $ABSOLUTE ? $asset : $self->app->static->asset_path($asset));
  }

  method url_for_file {
    my ($self, $file) = @_;
    return $self->url_for($file =~ $ABSOLUTE ? $file : $self->app->static->file_path($file));
  }

  method write {
    my ($self, $chunk, $cb) = @_;
    $self->res->content->write($chunk, $cb ? method { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }

  method write_chunk {
    my ($self, $chunk, $cb) = @_;
    $self->res->content->write_chunk($chunk, $cb ? method { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }

  method write_sse {
    my ($self, $event, $cb) = @_;
    $self->res->content->write_sse($event, $cb ? method { shift; $self->$cb(@_) } : ());
    return $self->rendered;
  }


=cut

=pod TODO

  method encrypted_cookie {
    my ($self, $name, $value, $options) = @_;

    # Request cookie
    return $self->every_encrypted_cookie($name)->[-1] unless defined $value;

    # Response cookie
    my $app     = $self->app;
    my $secret  = $app->secrets->[0];
    my $moniker = $app->moniker;
    return $self->cookie($name, Mojo::Util::encrypt_cookie($value, $secret, $moniker), $options);
  }

  method every_encrypted_cookie {
    my ($self, $name) = @_;

    my $app     = $self->app;
    my $secrets = $app->secrets;
    my $moniker = $app->moniker;
    my @results;
    for my $value (@{$self->every_cookie($name)}) {
      my $decrypted;
      for my $secret (@$secrets) {
        last if defined($decrypted = Mojo::Util::decrypt_cookie($value, $secret, $moniker));
      }
      if (defined $decrypted) { push @results, $decrypted }

      else { $self->log->trace(qq{Cookie "$name" is not encrypted}) }
    }

    return \@results;
  }

=cut

  method reply : Mojolicious::Helper::Reply () {
    
    my $reply = Mojolicious::Helper::Reply->new;
    $reply->set_controller($self);
    
    return $reply;
  }
  
}
