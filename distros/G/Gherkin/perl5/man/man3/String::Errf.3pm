.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "String::Errf 3pm"
.TH String::Errf 3pm "2016-07-04" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
String::Errf \- a simple sprintf\-like dialect
.SH "VERSION"
.IX Header "VERSION"
version 0.008
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use String::Errf qw(errf);
\&
\&  print errf "This process was started at %{start}t with %{args;argument}n.\en",
\&    { start => $^T, args => 0 + @ARGV };
.Ve
.PP
\&...might print something like:
.PP
.Vb 1
\&  This process was started at 2010\-10\-17 14:05:29 with 0 arguments.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
String::Errf provides \f(CW\*(C`errf\*(C'\fR, a simple string formatter that works something
like \f(CW\*(C`sprintf\*(C'\fR.  It is implemented using
String::Formatter and Sub::Exporter.  Their documentation may be useful
in understanding or extending String::Errf.  The \f(CW\*(C`errf\*(C'\fR subroutine is only
available when imported.  Calling String::Errf::errf will not do what you
want.
.SH "DIFFERENCES FROM SPRINTF"
.IX Header "DIFFERENCES FROM SPRINTF"
The data passed to \f(CW\*(C`errf\*(C'\fR should be organized in a single hashref, not a list.
.PP
Formatting codes require named parameters, and the available codes are
different.  See \*(L"\s-1FORMATTING CODES\*(R"\s0 below.
.PP
As with most String::Formatter formatters, \f(CW\*(C`%\*(C'\fR is not a format code.  If you
want a literal \f(CW\*(C`%\*(C'\fR, do not put anything between the two percent signs, just
write \f(CW\*(C`%%\*(C'\fR.
.SS "\s-1UNDEF HANDLING\s0"
.IX Subsection "UNDEF HANDLING"
By default, formatting codes tend to treat \f(CW\*(C`undef\*(C'\fR like Perl does: coercing it
to an empty string or zero.  This was a bad initial decision and will probably
change.  A \f(CW\*(C`on_undef\*(C'\fR handler can be provided when importing \f(CW\*(C`errf\*(C'\fR to setup
a callback for how undefs should be handled.  These two possibilities seem
useful:
.PP
.Vb 2
\&  # Very lax; undefs always turn into the same string:
\&  use String::Errf errf => { on_undef => sub { \*(Aq(undef)\*(Aq } };
\&
\&  # Strict; undefs are never valid:
\&  use String::Errf errf => { on_undef => sub {
\&    Carp::croak("undef passed to $_[1]{literal}") } };
\&  } };
.Ve
.SS "\s-1FORMATTING CODES\s0"
.IX Subsection "FORMATTING CODES"
\&\f(CW\*(C`errf\*(C'\fR formatting codes \fIrequire\fR a set of arguments between the \f(CW\*(C`%\*(C'\fR and the
formatting code letter.  These arguments are placed in curly braces and
separated by semicolons.  The first argument is the name of the data to look
for in the format data.  For example, this is a valid use of \f(CW\*(C`errf\*(C'\fR:
.PP
.Vb 4
\&  errf "The current time in %{tz}s is %{now;local}t.", {
\&    tz  => $ENV{TZ},
\&    now => time,
\&  };
.Ve
.PP
The second argument, if present, may be a compact form for multiple named
arguments.  The rest of the arguments will be named values in the form
\&\f(CW\*(C`name=value\*(C'\fR.  The examples below should help clarify how arguments are
passed.  When an argument appears in both a compact and named form, the named
form trumps the compact form.
.PP
The specific codes and their arguments are:
.PP
\fIs for string\fR
.IX Subsection "s for string"
.PP
The \f(CW\*(C`s\*(C'\fR format code is for any string, and takes no arguments.  It just
includes the named item from the input data.
.PP
.Vb 1
\&  errf "%{name}s", { name => \*(AqJohn Smith\*(Aq }; # returns "John Smith"
.Ve
.PP
Remember, \f(CW\*(C`errf\*(C'\fR does \fInot\fR have any of the left\- or right-padding formatting
that \f(CW\*(C`sprintf\*(C'\fR provides.  It is not meant for building tables, only strings.
.PP
\fIi for integer\fR
.IX Subsection "i for integer"
.PP
The \f(CW\*(C`i\*(C'\fR format code is used for integers.  It takes one optional argument,
\&\f(CW\*(C`prefix\*(C'\fR, which defaults to the empty string.  \f(CW\*(C`prefix\*(C'\fR may be given as the
compact argument, standing alone.  \f(CW\*(C`prefix\*(C'\fR is used to prefix non-negative
integers.  It may only be a plus sign.
.PP
.Vb 2
\&  errf "%{x}i",    { x => 10 }; # returns "10"
\&  errf "%{x;+}i",  { x => 10 }; # returns "+10"
\&
\&  errf "%{x;prefix=+}i",  { x => 10 }; # returns "+10"
.Ve
.PP
The rounding behavior for non-integer values \fIis not currently specified\fR.
.PP
\fIf for float (or fractional)\fR
.IX Subsection "f for float (or fractional)"
.PP
The \f(CW\*(C`f\*(C'\fR format code is for numbers with sub-integer precision.  It works just
like \f(CW\*(C`i\*(C'\fR, but adds a \f(CW\*(C`precision\*(C'\fR argument which specifies how many decimal
places of precision to display.  The compact argument may be just the prefix or
the prefix followed by a period followed by the precision.
.PP
.Vb 2
\&  errf "%{x}f",     { x => 10.1234 }; # returns "10";
\&  errf "%{x;+}f",   { x => 10.1234 }; # returns "+10";
\&
\&  errf "%{x;.2}f",  { x => 10.1234 }; # returns  "10.12";
\&  errf "%{x;+.2}f", { x => 10.1234 }; # returns "+10.12";
\&
\&  errf "%{x;precision=.2}f",          { x => 10.1234 }; # returns  "10.12";
\&  errf "%{x;prefix=+;precision=.2}f", { x => 10.1234 }; # returns "+10.12";
.Ve
.PP
\fIt for time\fR
.IX Subsection "t for time"
.PP
The \f(CW\*(C`t\*(C'\fR format code is used to format timestamps provided in epoch seconds.
It can be given two arguments: \f(CW\*(C`type\*(C'\fR and \f(CW\*(C`tz\*(C'\fR.
.PP
\&\f(CW\*(C`type\*(C'\fR can be either date, time, or datetime, and indicates what part of the
timestamp should be displayed.  The default is datetime.  \f(CW\*(C`tz\*(C'\fR requests that
the timestamp be displayed in either \s-1UTC\s0 or the local time zone.  The default
is local.
.PP
The compact form is just \f(CW\*(C`type\*(C'\fR alone.
.PP
.Vb 1
\&  # Assuming our local time zone is America/New_York...
\&
\&  errf "%{x}t",               { x => 1280530906 }; # "2010\-07\-30 19:01:46"
\&  errf "%{x;type=date}t",     { x => 1280530906 }; # "2010\-07\-30"
\&  errf "%{x;type=time}t",     { x => 1280530906 }; # "19:01:46"
\&  errf "%{x;type=datetime}t", { x => 1280530906 }; # "2010\-07\-30 19:01:46"
\&
\&  errf "%{x;tz=UTC}t",               { x => 1280530906 }; # "2010\-07\-30 23:01:46 UTC"
\&  errf "%{x;tz=UTC;type=date}t",     { x => 1280530906 }; # "2010\-07\-30 UTC"
\&  errf "%{x;tz=UTC;type=time}t",     { x => 1280530906 }; # "23:01:46 UTC"
\&  errf "%{x;tz=UTC;type=datetime}t", { x => 1280530906 }; # "2010\-07\-30 23:01:46 UTC"
.Ve
.PP
\fIn and N for numbered\fR
.IX Subsection "n and N for numbered"
.PP
The \f(CW\*(C`n\*(C'\fR and \f(CW\*(C`N\*(C'\fR format codes are for picking words based on number.  It takes
two of its own arguments, \f(CW\*(C`singular\*(C'\fR and \f(CW\*(C`plural\*(C'\fR, as well as \f(CW\*(C`prefix\*(C'\fR and
\&\f(CW\*(C`precision\*(C'\fR which may be used for formatting the number itself.
.PP
If the value being formatted is 1, the singular word is used.  Otherwise, the
plural form is used.
.PP
.Vb 3
\&  errf "%{x;singular=dog;plural=dogs}n", { x => 0 }; # 0 dogs
\&  errf "%{x;singular=dog;plural=dogs}n", { x => 1 }; # 1 dog
\&  errf "%{x;singular=dog;plural=dogs}n", { x => 2 }; # 2 dogs
\&
\&  errf "%{x;singular=dog;plural=dogs}n", { x => 1.4 }; # 1.4 dogs
\&  errf "%{x;singular=dog;plural=dogs;precision=1}n", { x => 1.4 }; # 1.4 dogs
\&  errf "%{x;singular=dog;plural=dogs;precision=0}n", { x => 1.4 }; # 1 dog
.Ve
.PP
If \f(CW\*(C`N\*(C'\fR is used instead of \f(CW\*(C`n\*(C'\fR, the number will not be included, only the
chosen word.
.PP
.Vb 3
\&  errf "%{x;singular=is;plural=are}N", { x => 0 }; # are
\&  errf "%{x;singular=is;plural=are}N", { x => 1 }; # is
\&  errf "%{x;singular=is;plural=are}N", { x => 2 }; # are
\&
\&  errf "%{x;singular=is;plural=are}N", { x => 1.4 }; # 1.4 are
\&  errf "%{x;singular=is;plural=are;precision=1}N", { x => 1.4 }; # 1.4 are
\&  errf "%{x;singular=is;plural=are;precision=0}N", { x => 1.4 }; # 1 is
.Ve
.PP
The compact form may take any of the following forms:
.PP
.Vb 1
\&  word          \- equivalent to singular=word
\&
\&  word+suffix   \- equivalent to singular=word;plural=wordsuffix
\&
\&  word1/word2   \- equivalent to singular=word;plural=word2
.Ve
.PP
If no singular form is given, an exception is thrown.  If no plural form is
given, one will be generated according to some basic rules of English
noun orthography.
.PP
\fI\fR
.IX Subsection ""
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Pedro Melo <melo@simplicidade.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2016 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
