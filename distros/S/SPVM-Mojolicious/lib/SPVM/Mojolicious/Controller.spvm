# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Controller {
  version_from Mojolicious;
  
  use Digest::SHA;
  use Mojo::ByteStream;
  use Mojo::URL;
  use Mojo::Util;
  use Mojolicious::Routes::Match;
  use Mojolicious;
  use Mojo::Transaction;
  use Mojo::Message::Request;
  use Mojo::Message::Response;
  use Mojo::Log;
  use Mojo::Callback;
  use Mojo::UserAgent;
  use Mojo::ByteStream;
  use Mojo::Collection;
  use Mojolicious::Helper::Timing;
  use Mojolicious::Helper::Reply;
  
  our $ABSOLUTE : string;
  INIT {
    $ABSOLUTE = "^(?:[^:/?#]+:|//|#)";
  }
  
  has app : rw Mojolicious
    set {
      $self->{app} = $_;
      weaken $self->{app};
    }
  ;
  
  has tx : rw Mojo::Transaction
    set {
      $self->{tx} = $_;
      weaken $self->{tx};
    }
  ;
  
  has match : rw Mojolicious::Routes::Match
    get {
      unless (exists $self->{match}) {
        my $match = Mojolicious::Routes::Match->new;
        
        $match->set_root($self->app->routes);
        
        $self->{match} = $match;
      }
      
      return $self->{match};
    }
  ;
  
  has stash_h : rw Hash;
  
  has shared_stash_h : rw Hash;
  
  has session_h : virtual ro Hash
    get {
      unless ($self->mojo_active_session) {
        $self->app->sessions->load($self);
      }
      
      unless (exists $self->{mojo_session}) {
        $self->{mojo_session} = Hash->new;
      }
      
      return $self->{mojo_session};
    }
  ;
  
  # Fields that is originally stash mojo.xxx
  has log : rw Mojo::Log
    get {
      unless (exists $self->{log}) {
        $self->{log} = $self->app->log->context("[" . $self->req->request_id . "]");
      }
      
      return $self->{log};
    }
  ;
  
  has exception_format : rw string
    get {
      
      unless (exists $self->{exception_format}) {
        $self->{exception_format} = $self->app->exception_format;
      }
      
      return $self->{exception_format};
    }
    
    set {
      $self->{exception_format} = $_;
    }
  ;
  
  # Internal fields
  has mojo_captures : rw Hash;
  
  has mojo_static : rw byte;
  
  has mojo_active_session : rw int;
  
  has mojo_session : rw Hash;
  
  # Finish header data building
  has mojo_finished : rw byte;
  
  # Finish header and body data building
  has mojo_respond : rw byte;
  
  # Class Methods
  static method new : Mojolicious::Controller () {
    
    my $self = new Mojolicious::Controller;
    
    $self->{stash_h} = Hash->new;
    
    $self->{shared_stash_h} = Hash->new;
    
    return $self;
  }
  
  # Instance Methods
  method req : Mojo::Message::Request () {
    
    my $tx = $self->tx;
    
    unless ($tx) {
      die "Transaction already destroyed";
    }
    
    return $tx->req;
  }
  
  method res : Mojo::Message::Response () {
    
    my $tx = $self->tx;
    
    unless ($tx) {
      die "Transaction already destroyed";
    }
    
    return $tx->res;
  }
  
  method cookie : string ($name : string) {
    
    # Request cookies
    my $cookie = $self->req->cookie($name);
    unless ($cookie) {
      return undef;
    }
    
    return $cookie->value;
  }
  
  method set_cookie : void ($name : string, $value : string, $attrs : object[] = undef) {
    
    # Response cookie
    # Cookie too big
    my $cookie = Mojo::Cookie::Response->new(Fn->merge_options({name => $name, value => $value}, $attrs));
    
    if (length $cookie->value > 4096) {
      $self->log->error("Cookie '$name' is bigger than 4KiB") ;
    }
    
    $self->res->set_cookies($name, [$cookie]);
  }
  
  method every_cookie : string[] ($name : string) {
    
    my $every_cookies = $self->req->every_cookie($name);
    
    my $every_cookies_length = @$every_cookies;
    
    my $values = new string[$every_cookies_length];
    
    for (my $i = 0; $i < $every_cookies_length; $i++) {
      $values->[$i] = $every_cookies->[$i]->value;
    }
    
    return $values;
  }
  
  method every_param : string[] ($name : string) {
    
    # Captured unreserved values
    $self->set_mojo_captures($self->mojo_captures // Hash->new);
    
    my $captures = $self->mojo_captures;
    
    if ($captures->exists($name) && !$self->app->routes->is_reserved($name)) {
      my $value = $captures->get("$name");
      
      return $value isa string[] ? (string[])$value : [(string)$value];
    }
    
    my $req = $self->req;
    
    return $req->every_param($name);
  }
  
  method every_upload : Mojo::Upload[] ($name : string) {
    
    my $uploads = $self->req->every_upload($name);
    
    return $uploads;
  }
  
  method upload : Mojo::Upload ($name : string) {
    
    my $every_upload = $self->every_upload($name);
    
    my $upload = @$every_upload ? $self->every_upload($name)->[-1] : undef;
    
    return $upload;
  }
  
  method signed_cookie : string ($name : string) {
    
    # Request cookie
    my $every_signed_cookie = $self->every_signed_cookie($name);
    
    my $value = @$every_signed_cookie ? $every_signed_cookie->[-1] : undef;
    
    return $value;
  }
  
  method set_signed_cookie : string ($name : string, $value : string = undef, $options : object[] = undef) {
    
    # Response cookie
    my $sum = Digest::SHA->hmac_sha256_hex("$name=$value", $self->app->secrets->[0]);
    
    $self->set_cookie($name, "$value--$sum", $options);
  }
  
  method every_signed_cookie : string[] ($name : string) {
    
    my $secrets = $self->app->secrets;
    my $results = StringList->new;
    for my $value (@{$self->every_cookie($name)}) {
      
      unless (is_read_only $value) {
        $value = copy $value;
      }
      
      # Check signature with rotating secrets
      if (my $rep = Re->s((mutable string)$value, "--([^\-]+)$", "")) {
        my $signature = $rep->match->cap1;
        
        my $valid = 0;
        for my $secret (@$secrets) {
          my $check = Digest::SHA->hmac_sha256_hex("$name=$value", $secret);
          if (Mojo::Util->secure_compare($signature, $check)) {
            $valid = 1;
            last;
          }
        }
        if ($valid) {
          $results->push($value);
        }
        else {
          $self->log->trace("Cookie \"$name\" has bad signature.");
        }
      }
      
      else {
        $self->log->trace("Cookie \"$name\" is not signed.");
      }
    }
    
    return $results->get_array;
  }
  
  method finish : void ($code : int = 0, $reason : string = undef) {
    
    my $tx = $self->tx;
    unless ($tx) {
      die "Transaction already destroyed";
    }
    
    # WebSocket
    if ($tx->is_websocket) {
      $tx->(Mojo::Transaction::WebSocket)->finish($code, $reason);
      unless ($tx->(Mojo::Transaction::WebSocket)->established) {
        $self->rendered(101);
      }
    }
    else {
      die "finish method is only for WebSocket. Use finish_stream method for long polling stream.";
    }
  }
  
  method finish_stream : void ($chunk : string = undef) {
    
    my $tx = $self->tx;
    unless ($tx) {
      die "Transaction already destroyed.";
    }
    
    # Chunked stream
    if ($tx->res->content->is_chunked) {
      if ($chunk) {
        $self->write_chunk($chunk);
      }
      $self->write_chunk("");
    }
    # Normal stream
    else {
      if ($chunk) {
        $self->write($chunk);
      }
      $self->write("");
    }
  }
  
  method param : string ($name : string) {
    
    my $every_param = $self->every_param($name);
    
    my $value = @$every_param ? $self->every_param($name)->[-1] : undef;
    
    return $value;
  }
  
  method set_param : void ($name : string, $value : string|string[]) {
    
    my $value_ = (string|string[])undef;
    if ($value) {
      if ($value isa string) {
        $value_ = (string)$value;
      }
      elsif ($value isa string[]) {
        $value_ = (string[])$value;
      }
      else {
        die "The type of the value \$value must be string or string[]";
      }
    }
    
    $self->mojo_captures->{$name} = $value_;
  }
  
  method render : Mojo::ByteStream ($template : string|Hash|object[] = undef, $options : Hash|object[] = undef) {
    
    my $options_ = Hash->new;
    my $template_ = (string)undef;
    if ($template isa string) {
      $template_ = $template->(string);
    }
    else {
      $options_->merge(Fn->to_hash($template));
      $template = undef;
    }
    
    $options_->merge(Fn->to_hash($options));
    
    my $options = $options_;
    
    if ($template_) {
      $options->{"template"} = $template_;
    }
    
    my $app = $self->app;
    my $plugins = $app->plugins;
    my $render_to_string = $options->delete("mojo.string")->(int);
    
    unless ($render_to_string) {
      $plugins->emit_hook(before_render => $self, $options);
    }
    
    my $renderer = $app->renderer;
    my $_ = $renderer->render($self, $options);
    my $output = $_->[0];
    my $format = $_->[1];
    
    if ($render_to_string) {
      return $output ? Mojo::ByteStream->new($output) : undef;
    }
    
    $plugins->emit_hook(after_render => $self, my $_ = [$output], $format);
    $output = $_->[0];
    
    unless ($output) {
      die "Rendering output must be define.";
    }
    
    $renderer->respond($self, $output, $format, $options->{"status"});
  }
  
  method render_to_string : Mojo::ByteStream ($template : string|Hash|object[] = undef, $options : Hash|object[] = undef) {
    
    my $options = Fn->to_hash($options);
    $options->merge_options({"mojo.string" => 1});
    
    my $string = $self->render($template, $options);
    
    return $string;
  }
  
  method rendered : void ($status : int = 0) {
    
    # Make sure we have a status
    if ($status) {
      $self->res->set_code($status);
    }
    
    # Finish transaction
    if (!$self->{mojo_finished}) {
      $self->{mojo_finished} = 1;
      
      my $res = $self->res;
      if (!$status && !$res->code) {
        $res->set_code(200) ;
      }
      
      my $app = $self->app;
      $app->plugins->emit_hook_reverse(after_dispatch => $self);
      
      $app->sessions->store($self);
    }
  }
  
  method send : void ($msg : string|object[]|Mojo::WebSocket::Frame, $cb : Mojo::Callback = undef) {
    my $tx = $self->tx;
    
    unless ($tx) {
      die "Transaction already destroyed.";
    }
    
    unless ($tx->is_websocket) {
      die "No WebSocket connection to send message to.";
    }
    
    my $cb_with_instance = (Mojo::Callback)undef;
    if ($cb) {
      $cb_with_instance = [$self : Mojolicious::Controller, $cb : Mojo::Callback] method : void ($that : object, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
        $cb->($self, $arg1, $arg2, $arg3);
      };
    }
    
    $tx->(Mojo::Transaction::WebSocket)->send($msg);
    
    unless ($tx->(Mojo::Transaction::WebSocket)->established) {
      $self->rendered(101);
    }
  }
  
  method session : object ($name : string) {
    
    return $self->session_h->{$name};
  }
  
  method set_session : void ($name : string, $value : object) {
    
    $self->session_h->{$name} = $value;
  }
  
  method stash : object ($name : string) {
    return $self->{stash_h}{$name};
  }
  
  method set_stash : void ($name : string, $value : object) {
    $self->{stash_h}{$name} = $value;
  }
  
  method shared_stash : object ($name : string) {
    return $self->{shared_stash_h}{$name};
  }
  
  method set_shared_stash : void ($name : string, $value : object) {
    $self->{shared_stash_h}{$name} = $value;
  }
  
  method url_for : Mojo::URL ($target : string|Mojo::URL)  {
    
    # Absolute URL
    if ($target isa Mojo::URL) {
      return $target->(Mojo::URL);
    }
    
    my $target = (string)$target;
    
    if (Re->m($target, $ABSOLUTE)) {
      return Mojo::URL->new($target);
    }
    
    # Base
    my $url  = Mojo::URL->new;
    my $req  = $self->req;
    $url->set_base($req->url->base->clone);
    my $base = $url->base;
    $base->set_userinfo(undef);
    
    # Relative URL
    my $path = $url->path;
    if (Re->m($target, "^/")) {
      if (my $prefix = $self->stash_h->{"path"}->(string)) {
        my $real = $req->url->path->to_route;
        Re->s((mutable string)$real, "/?\Q$prefix\E$", "$target");
        $target = $real;
      }
      $url->parse($target);
    }
    
    # Make path absolute
    my $base_path = $base->path;
    StringList->new_ref($path->parts)->unshift_($base_path->parts);
    $base_path->set_parts(new string[0]);
    $base_path->set_trailing_slash(0);
    
    return $url;
  }
  
  method url_for_asset : Mojo::URL ($target : string) {
    
    unless (Re->m($target, $ABSOLUTE)) {
      $target = $self->app->static->asset_path($target);
    }
    
    return $self->url_for($target);
  }

  method url_for_file : Mojo::URL ($target : string) {
    
    unless (Re->m($target, $ABSOLUTE)) {
      $target = $self->app->static->file_path($target);
    }
    
    return $self->url_for($target);
  }

  method write : void ($chunk : string) {
    
    $self->res->content->write($chunk);
  }
  
  method write_chunk : void ($chunk : string) {
    
    $self->res->content->write_chunk($chunk);
  }
  
  method write_sse : void ($event : Mojo::SSE::Event) {
    
    $self->res->content->write_sse($event);
  }
  
  method reply : Mojolicious::Helper::Reply () {
    
    my $reply = my $_ = Mojolicious::Helper::Reply->new;
    $_->set_controller($self);
    
    return $reply;
  }
  
  method timing : Mojolicious::Helper::Timing () {
    
    my $timing = my $_ = Mojolicious::Helper::Timing->new;
    $_->set_controller($self);
    
    return $timing;
  }
  
  method include : Mojo::ByteStream ($template_name : string, $options : Hash|object[] = undef) {
    
    return $self->render_to_string($template_name, $options);
  }
  
  method content : Mojo::ByteStream ($name : string = undef) {
    
    unless ($name) {
      $name = "content";
    }
    
    my $hash = $self->stash_h->{"mojo.content"}->(Hash) // Hash->new;
    
    my $content = $hash->{$name}->(string);
    
    return Mojo::ByteStream->new($content // "");
  }
  
  method flash : object ($name : string) {
    
    # Check old flash
    my $session = $self->session_h;
    
    return $session->{"flash"} ? $session->{"flash"}->(Hash)->{$name}->(object) : undef;
  }
  
  method set_flash : void ($name : string, $value : object) {
    
    my $session = $self->session_h;
    
    unless ($session->{"new_flash"}) {
      $session->{"new_flash"} = Hash->new;
    }
    
    $session->{"new_flash"}->(Hash)->{$name} = $value;
  }
  
  method ua : Mojo::UserAgent () {
    return $self->app->ua;
  }
  
  method config : object ($name : string) {
    return $self->app->config($name);
  }
  
  method c : Mojo::Collection ($array : object[] = undef) {
    return Mojo::Collection->new($array);
  }
  
  method b : Mojo::ByteStream ($bytes : string) {
    return Mojo::ByteStream->new($bytes);
  }
  
  method layout : string () {
    $self->stash("layout")->(string);
  }
  
  method set_layout : void ($layout : string) {
    $self->set_stash(layout => $layout);
  }
  
  method title : string () {
    $self->stash("title")->(string);
  }
  
  method set_title : void ($title : string) {
    $self->set_stash(title => $title);
  }
  
  method accepts : string[] ($preferences : string[] = undef) {
    $self->app->renderer->accepts($self, $preferences);
  }
  
  method csrf_token : string () {
    
    unless ($self->session_h->exists("csrf_token")) {
      $self->session_h->{"csrf_token"} = Mojo::Util->hmac_sha1_sum(Sys->process_id . Mojo::Util->steady_time . Sys->rand, $self->app->secrets->[0]);
    }
    
    return $self->session_h->{"csrf_token"}->(string);
  }
  
  method is_current_route : int ($name : string) {
    
    my $route = $self->match->endpoint;
    
    unless ($route) {
      return 0;
    }
    
    return $route->name eq $name;
  }

  method current_route : string () {
    
    my $route = $self->match->endpoint;
    
    unless ($route) {
      return "";
    }
    
    return $route->name;
  }
  
  method set_inactivity_timeout  : void ($timeout : double){
  
    my $connection = $self->tx->connection;
    if ($connection) {
      $connection->set_timeout($timeout);
    }
  }
  
  method is_fresh : int ($options : Hash|object[] = undef) {
    
    return $self->app->static->is_fresh($self, $options);
  }
  
  method redirect_to : void ($path : string)  {
    
    # Don't override 3xx status
    my $res = $self->res;
    $res->headers->set_location($self->url_for($path));
    
    $self->rendered($res->is_redirect ? 0 : 302);
  }
  
  method respond_to : void ($options : Hash|object[] = undef) {
    
    my $options = Fn->to_hash($options);
    
    # Find target
    my $target = (object)undef;
    my $renderer = $self->app->renderer;
    my $formats  = Array->copy_string($renderer->accepts($self));
    unless (@$formats) {
      $formats = [$renderer->default_format];
    }
    for my $format (@$formats) {
      $target = $options->{$format};
      unless ($target) {
        next;
      }
      $self->stash_h->{"format"} = $format;
      last;
    }
    
    # Fallback
    unless ($target) {
      $target = $options->{"any"};
      unless ($target) {
        $self->rendered(204);
        return;
      }
      $self->stash_h->delete("format");
    }
    
    # Dispatch
    if ($target isa Mojolicious::Callback) {
      $target->(Mojolicious::Callback)->($self);
    }
    else {
      $self->render($target->(object[]));
    }
  }
  
  method url_with : Mojo::URL ($path : string) {
    
    my $url = $self->url_for($path);
    $url->set_query($self->req->url->query->clone);
    
    return $url;
  }
  
  method render_later : void () {
    $self->rendered;
  }
  
}
