.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Dispatch 3pm"
.TH Log::Dispatch 3pm "2020-07-20" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Dispatch \- Dispatches messages to one or more outputs
.SH "VERSION"
.IX Header "VERSION"
version 2.70
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Log::Dispatch;
\&
\&  # Simple API
\&  #
\&  my $log = Log::Dispatch\->new(
\&      outputs => [
\&          [ \*(AqFile\*(Aq,   min_level => \*(Aqdebug\*(Aq, filename => \*(Aqlogfile\*(Aq ],
\&          [ \*(AqScreen\*(Aq, min_level => \*(Aqwarning\*(Aq ],
\&      ],
\&  );
\&
\&  $log\->info(\*(AqBlah, blah\*(Aq);
\&
\&  # More verbose API
\&  #
\&  my $log = Log::Dispatch\->new();
\&  $log\->add(
\&      Log::Dispatch::File\->new(
\&          name      => \*(Aqfile1\*(Aq,
\&          min_level => \*(Aqdebug\*(Aq,
\&          filename  => \*(Aqlogfile\*(Aq
\&      )
\&  );
\&  $log\->add(
\&      Log::Dispatch::Screen\->new(
\&          name      => \*(Aqscreen\*(Aq,
\&          min_level => \*(Aqwarning\*(Aq,
\&      )
\&  );
\&
\&  $log\->log( level => \*(Aqinfo\*(Aq, message => \*(AqBlah, blah\*(Aq );
\&
\&  my $sub = sub { my %p = @_; return reverse $p{message}; };
\&  my $reversing_dispatcher = Log::Dispatch\->new( callbacks => $sub );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module manages a set of Log::Dispatch::* output objects that can be
logged to via a unified interface.
.PP
The idea is that you create a Log::Dispatch object and then add various
logging objects to it (such as a file logger or screen logger). Then you
call the \f(CW\*(C`log\*(C'\fR method of the dispatch object, which passes the message to
each of the objects, which in turn decide whether or not to accept the
message and what to do with it.
.PP
This makes it possible to call single method and send a message to a
log file, via email, to the screen, and anywhere else, all with very
little code needed on your part, once the dispatching object has been
created.
.SH "METHODS"
.IX Header "METHODS"
This class provides the following methods:
.SS "Log::Dispatch\->new(...)"
.IX Subsection "Log::Dispatch->new(...)"
This method takes the following parameters:
.IP "\(bu" 4
outputs( [ [ class, params, ... ], [ class, params, ... ], ... ] )
.Sp
This parameter is a reference to a list of lists. Each inner list consists of
a class name and a set of constructor params. The class is automatically
prefixed with 'Log::Dispatch::' unless it begins with '+', in which case the
string following '+' is taken to be a full classname. e.g.
.Sp
.Vb 2
\&    outputs => [ [ \*(AqFile\*(Aq,          min_level => \*(Aqdebug\*(Aq, filename => \*(Aqlogfile\*(Aq ],
\&                 [ \*(Aq+My::Dispatch\*(Aq, min_level => \*(Aqinfo\*(Aq ] ]
.Ve
.Sp
For each inner list, a new output object is created and added to the
dispatcher (via the \f(CW\*(C`add()\*(C'\fR method).
.Sp
See \*(L"\s-1OUTPUT CLASSES\*(R"\s0 for the parameters that can be used when creating an
output object.
.IP "\(bu" 4
callbacks( \e& or [ \e&, \e&, ... ] )
.Sp
This parameter may be a single subroutine reference or an array
reference of subroutine references. These callbacks will be called in
the order they are given and passed a hash containing the following keys:
.Sp
.Vb 1
\& ( message => $log_message, level => $log_level )
.Ve
.Sp
In addition, any key/value pairs passed to a logging method will be
passed onto your callback.
.Sp
The callbacks are expected to modify the message and then return a
single scalar containing that modified message. These callbacks will
be called when either the \f(CW\*(C`log\*(C'\fR or \f(CW\*(C`log_to\*(C'\fR methods are called and
will only be applied to a given message once. If they do not return
the message then you will get no output. Make sure to return the
message!
.ie n .SS "$dispatch\->\fBclone()\fP"
.el .SS "\f(CW$dispatch\fP\->\fBclone()\fP"
.IX Subsection "$dispatch->clone()"
This returns a \fIshallow\fR clone of the original object. The underlying output
objects and callbacks are shared between the two objects. However any changes
made to the outputs or callbacks that the object contains are not shared.
.ie n .SS "$dispatch\->log( level => $, message => $ or \e& )"
.el .SS "\f(CW$dispatch\fP\->log( level => $, message => $ or \e& )"
.IX Subsection "$dispatch->log( level => $, message => $ or & )"
Sends the message (at the appropriate level) to all the output objects that
the dispatcher contains (by calling the \f(CW\*(C`log_to\*(C'\fR method repeatedly).
.PP
The level can be specified by name or by an integer from 0 (debug) to 7
(emergency).
.PP
This method also accepts a subroutine reference as the message
argument. This reference will be called only if there is an output
that will accept a message of the specified level.
.ie n .SS "$dispatch\->debug (message), info (message), ..."
.el .SS "\f(CW$dispatch\fP\->debug (message), info (message), ..."
.IX Subsection "$dispatch->debug (message), info (message), ..."
You may call any valid log level (including valid abbreviations) as a method
with a single argument that is the message to be logged. This is converted
into a call to the \f(CW\*(C`log\*(C'\fR method with the appropriate level.
.PP
For example:
.PP
.Vb 1
\& $log\->alert(\*(AqStrange data in incoming request\*(Aq);
.Ve
.PP
translates to:
.PP
.Vb 1
\& $log\->log( level => \*(Aqalert\*(Aq, message => \*(AqStrange data in incoming request\*(Aq );
.Ve
.PP
If you pass an array to these methods, it will be stringified as is:
.PP
.Vb 2
\& my @array = (\*(AqSomething\*(Aq, \*(Aqbad\*(Aq, \*(Aqis\*(Aq, \*(Aqhere\*(Aq);
\& $log\->alert(@array);
\&
\& # is equivalent to
\&
\& $log\->alert("@array");
.Ve
.PP
You can also pass a subroutine reference, just like passing one to the
\&\f(CW\*(C`log()\*(C'\fR method.
.ie n .SS "$dispatch\->log_and_die( level => $, message => $ or \e& )"
.el .SS "\f(CW$dispatch\fP\->log_and_die( level => $, message => $ or \e& )"
.IX Subsection "$dispatch->log_and_die( level => $, message => $ or & )"
Has the same behavior as calling \f(CW\*(C`log()\*(C'\fR but calls
\&\f(CW\*(C`_die_with_message()\*(C'\fR at the end.
.PP
You can throw exception objects by subclassing this method.
.PP
If the \f(CW\*(C`carp_level\*(C'\fR parameter is present its value will be added to
the current value of \f(CW$Carp::CarpLevel\fR.
.ie n .SS "$dispatch\->log_and_croak( level => $, message => $ or \e& )"
.el .SS "\f(CW$dispatch\fP\->log_and_croak( level => $, message => $ or \e& )"
.IX Subsection "$dispatch->log_and_croak( level => $, message => $ or & )"
A synonym for \f(CW\*(C`$dispatch\-\*(C'\fR\fBlog_and_die()\fR>.
.ie n .SS "$dispatch\->log_to( name => $, level => $, message => $ )"
.el .SS "\f(CW$dispatch\fP\->log_to( name => $, level => $, message => $ )"
.IX Subsection "$dispatch->log_to( name => $, level => $, message => $ )"
Sends the message only to the named object. Note: this will not properly
handle a subroutine reference as the message.
.ie n .SS "$dispatch\->add_callback( $code )"
.el .SS "\f(CW$dispatch\fP\->add_callback( \f(CW$code\fP )"
.IX Subsection "$dispatch->add_callback( $code )"
Adds a callback (like those given during construction). It is added to the end
of the list of callbacks. Note that this can also be called on individual
output objects.
.ie n .SS "$dispatch\->remove_callback( $code )"
.el .SS "\f(CW$dispatch\fP\->remove_callback( \f(CW$code\fP )"
.IX Subsection "$dispatch->remove_callback( $code )"
Remove the given callback from the list of callbacks. Note that this can also
be called on individual output objects.
.ie n .SS "$dispatch\->\fBcallbacks()\fP"
.el .SS "\f(CW$dispatch\fP\->\fBcallbacks()\fP"
.IX Subsection "$dispatch->callbacks()"
Returns a list of the callbacks in a given output.
.ie n .SS "$dispatch\->level_is_valid( $string )"
.el .SS "\f(CW$dispatch\fP\->level_is_valid( \f(CW$string\fP )"
.IX Subsection "$dispatch->level_is_valid( $string )"
Returns true or false to indicate whether or not the given string is a
valid log level. Can be called as either a class or object method.
.ie n .SS "$dispatch\->would_log( $string )"
.el .SS "\f(CW$dispatch\fP\->would_log( \f(CW$string\fP )"
.IX Subsection "$dispatch->would_log( $string )"
Given a log level, returns true or false to indicate whether or not
anything would be logged for that log level.
.ie n .SS "$dispatch\->is_$level"
.el .SS "\f(CW$dispatch\fP\->is_\f(CW$level\fP"
.IX Subsection "$dispatch->is_$level"
There are methods for every log level: \f(CW\*(C`is_debug()\*(C'\fR, \f(CW\*(C`is_warning()\*(C'\fR, etc.
.PP
This returns true if the logger will log a message at the given level.
.ie n .SS "$dispatch\->add( Log::Dispatch::* \s-1OBJECT\s0 )"
.el .SS "\f(CW$dispatch\fP\->add( Log::Dispatch::* \s-1OBJECT\s0 )"
.IX Subsection "$dispatch->add( Log::Dispatch::* OBJECT )"
Adds a new output object to the dispatcher. If an object
of the same name already exists, then that object is replaced, with
a warning if \f(CW$^W\fR is true.
.ie n .SS "$dispatch\->remove($)"
.el .SS "\f(CW$dispatch\fP\->remove($)"
.IX Subsection "$dispatch->remove($)"
Removes the output object that matches the name given to the remove method.
The return value is the object being removed or undef if no object
matched this.
.ie n .SS "$dispatch\->\fBoutputs()\fP"
.el .SS "\f(CW$dispatch\fP\->\fBoutputs()\fP"
.IX Subsection "$dispatch->outputs()"
Returns a list of output objects.
.ie n .SS "$dispatch\->output( $name )"
.el .SS "\f(CW$dispatch\fP\->output( \f(CW$name\fP )"
.IX Subsection "$dispatch->output( $name )"
Returns the output object of the given name. Returns undef or an empty
list, depending on context, if the given output does not exist.
.ie n .SS "$dispatch\->_die_with_message( message => $, carp_level => $ )"
.el .SS "\f(CW$dispatch\fP\->_die_with_message( message => $, carp_level => $ )"
.IX Subsection "$dispatch->_die_with_message( message => $, carp_level => $ )"
This method is used by \f(CW\*(C`log_and_die\*(C'\fR and will either \fBdie()\fR or \fBcroak()\fR
depending on the value of \f(CW\*(C`message\*(C'\fR: if it's a reference or it ends
with a new line then a plain die will be used, otherwise it will
croak.
.SH "OUTPUT CLASSES"
.IX Header "OUTPUT CLASSES"
An output class \- e.g. Log::Dispatch::File or
Log::Dispatch::Screen \- implements a particular way
of dispatching logs. Many output classes come with this distribution,
and others are available separately on \s-1CPAN.\s0
.PP
The following common parameters can be used when creating an output class.
All are optional. Most output classes will have additional parameters beyond
these, see their documentation for details.
.IP "\(bu" 4
name ($)
.Sp
A name for the object (not the filename!). This is useful if you want to
refer to the object later, e.g. to log specifically to it or remove it.
.Sp
By default a unique name will be generated. You should not depend on the
form of generated names, as they may change.
.IP "\(bu" 4
min_level ($)
.Sp
The minimum logging level this object will accept. Required.
.IP "\(bu" 4
max_level ($)
.Sp
The maximum logging level this object will accept. By default
the maximum is the highest possible level (which means functionally that the
object has no maximum).
.IP "\(bu" 4
callbacks( \e& or [ \e&, \e&, ... ] )
.Sp
This parameter may be a single subroutine reference or an array
reference of subroutine references. These callbacks will be called in
the order they are given and passed a hash containing the following keys:
.Sp
.Vb 1
\& ( message => $log_message, level => $log_level )
.Ve
.Sp
The callbacks are expected to modify the message and then return a
single scalar containing that modified message. These callbacks will
be called when either the \f(CW\*(C`log\*(C'\fR or \f(CW\*(C`log_to\*(C'\fR methods are called and
will only be applied to a given message once. If they do not return
the message then you will get no output. Make sure to return the
message!
.IP "\(bu" 4
newline (0|1)
.Sp
If true, a callback will be added to the end of the callbacks list that adds
a newline to the end of each message. Default is false, but some
output classes may decide to make the default true.
.SH "LOG LEVELS"
.IX Header "LOG LEVELS"
The log levels that Log::Dispatch uses are taken directly from the
syslog man pages (except that I expanded them to full words). Valid
levels are:
.IP "debug" 4
.IX Item "debug"
.PD 0
.IP "info" 4
.IX Item "info"
.IP "notice" 4
.IX Item "notice"
.IP "warning" 4
.IX Item "warning"
.IP "error" 4
.IX Item "error"
.IP "critical" 4
.IX Item "critical"
.IP "alert" 4
.IX Item "alert"
.IP "emergency" 4
.IX Item "emergency"
.PD
.PP
Alternately, the numbers 0 through 7 may be used (debug is 0 and emergency is
7). The syslog standard of 'err', 'crit', and 'emerg' is also acceptable. We
also allow 'warn' as a synonym for 'warning'.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
This module was designed to be easy to subclass. If you want to handle
messaging in a way not implemented in this package, you should be able to add
this with minimal effort. It is generally as simple as subclassing
Log::Dispatch::Output and overriding the \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`log_message\*(C'\fR
methods. See the Log::Dispatch::Output docs for more details.
.PP
If you would like to create your own subclass for sending email then
it is even simpler. Simply subclass Log::Dispatch::Email and
override the \f(CW\*(C`send_email\*(C'\fR method. See the Log::Dispatch::Email
docs for more details.
.PP
The logging levels that Log::Dispatch uses are borrowed from the standard
\&\s-1UNIX\s0 syslog levels, except that where syslog uses partial words (\*(L"err\*(R")
Log::Dispatch also allows the use of the full word as well (\*(L"error\*(R").
.SH "RELATED MODULES"
.IX Header "RELATED MODULES"
.SS "Log::Dispatch::DBI"
.IX Subsection "Log::Dispatch::DBI"
Written by Tatsuhiko Miyagawa. Log output to a database table.
.SS "Log::Dispatch::FileRotate"
.IX Subsection "Log::Dispatch::FileRotate"
Written by Mark Pfeiffer. Rotates log files periodically as part of
its usage.
.SS "Log::Dispatch::File::Stamped"
.IX Subsection "Log::Dispatch::File::Stamped"
Written by Eric Cholet. Stamps log files with date and time
information.
.SS "Log::Dispatch::Jabber"
.IX Subsection "Log::Dispatch::Jabber"
Written by Aaron Straup Cope. Logs messages via Jabber.
.SS "Log::Dispatch::Tk"
.IX Subsection "Log::Dispatch::Tk"
Written by Dominique Dumont. Logs messages to a Tk window.
.SS "Log::Dispatch::Win32EventLog"
.IX Subsection "Log::Dispatch::Win32EventLog"
Written by Arthur Bergman. Logs messages to the Windows event log.
.SS "Log::Log4perl"
.IX Subsection "Log::Log4perl"
An implementation of Java's log4j \s-1API\s0 in Perl. Log messages can be limited by
fine-grained controls, and if they end up being logged, both native Log4perl
and Log::Dispatch appenders can be used to perform the actual logging
job. Created by Mike Schilli and Kevin Goess.
.SS "Log::Dispatch::Config"
.IX Subsection "Log::Dispatch::Config"
Written by Tatsuhiko Miyagawa. Allows configuration of logging via a
text file similar (or so I'm told) to how it is done with log4j.
Simpler than Log::Log4perl.
.SS "Log::Agent"
.IX Subsection "Log::Agent"
A very different \s-1API\s0 for doing many of the same things that
Log::Dispatch does. Originally written by Raphael Manfredi.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Log::Dispatch::ApacheLog, Log::Dispatch::Email,
Log::Dispatch::Email::MailSend, Log::Dispatch::Email::MailSender,
Log::Dispatch::Email::MailSendmail, Log::Dispatch::Email::MIMELite,
Log::Dispatch::File, Log::Dispatch::File::Locked,
Log::Dispatch::Handle, Log::Dispatch::Output, Log::Dispatch::Screen,
Log::Dispatch::Syslog
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted at <https://github.com/houseabsolute/Log\-Dispatch/issues>.
.PP
I am also usually active on \s-1IRC\s0 as 'autarch' on \f(CW\*(C`irc://irc.perl.org\*(C'\fR.
.SH "SOURCE"
.IX Header "SOURCE"
The source code repository for Log-Dispatch can be found at <https://github.com/houseabsolute/Log\-Dispatch>.
.SH "DONATIONS"
.IX Header "DONATIONS"
If you'd like to thank me for the work I've done on this module, please
consider making a \*(L"donation\*(R" to me via PayPal. I spend a lot of free time
creating free software, and would appreciate any support you'd care to offer.
.PP
Please note that \fBI am not suggesting that you must do this\fR in order for me
to continue working on this particular software. I will continue to do so,
inasmuch as I have in the past, for as long as it interests me.
.PP
Similarly, a donation made in this way will probably not make me work on this
software much more, unless I get so many donations that I can consider working
on free software full time (let's all have a chuckle at that together).
.PP
To donate, log into PayPal and send money to autarch@urth.org, or use the
button at <https://www.urth.org/fs\-donation.html>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky <autarch@urth.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Anirvan Chatterjee <anirvan@users.noreply.github.com>
.IP "\(bu" 4
Carsten Grohmann <mail@carstengrohmann.de>
.IP "\(bu" 4
Doug Bell <doug@preaction.me>
.IP "\(bu" 4
Graham Knop <haarg@haarg.org>
.IP "\(bu" 4
Graham Ollis <plicease@cpan.org>
.IP "\(bu" 4
Gregory Oschwald <goschwald@maxmind.com>
.IP "\(bu" 4
hartzell <hartzell@alerce.com>
.IP "\(bu" 4
Joelle Maslak <jmaslak@antelope.net>
.IP "\(bu" 4
Johann Rolschewski <jorol@cpan.org>
.IP "\(bu" 4
Jonathan Swartz <swartz@pobox.com>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Kerin Millar <kfm@plushkava.net>
.IP "\(bu" 4
Kivanc Yazan <kivancyazan@gmail.com>
.IP "\(bu" 4
Konrad Bucheli <kb@open.ch>
.IP "\(bu" 4
Michael Schout <mschout@gkg.net>
.IP "\(bu" 4
Olaf Alders <olaf@wundersolutions.com>
.IP "\(bu" 4
Olivier Mengué <dolmen@cpan.org>
.IP "\(bu" 4
Rohan Carly <se456@rohan.id.au>
.IP "\(bu" 4
Ross Attrill <ross.attrill@gmail.com>
.IP "\(bu" 4
Salvador Fandiño <sfandino@yahoo.com>
.IP "\(bu" 4
Sergey Leschenko <sergle.ua@gmail.com>
.IP "\(bu" 4
Slaven Rezic <srezic@cpan.org>
.IP "\(bu" 4
Steve Bertrand <steveb@cpan.org>
.IP "\(bu" 4
Whitney Jackson <whitney.jackson@baml.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by Dave Rolsky.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
.PP
The full text of the license can be found in the
\&\fI\s-1LICENSE\s0\fR file included with this distribution.
