.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Section 3pm"
.TH Data::Section 3pm "2017-07-07" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Section \- read multiple hunks of data out of your DATA section
.SH "VERSION"
.IX Header "VERSION"
version 0.200007
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Letter::Resignation;
\&  use Data::Section \-setup;
\&
\&  sub quit {
\&    my ($class, $angry, %arg) = @_;
\&
\&    my $template = $self\->section_data(
\&      ($angry ? "angry_" : "professional_") . "letter"
\&    );
\&
\&    return fill_in($$template, \e%arg);
\&  }
\&
\&  _\|_DATA_\|_
\&  _\|_[ angry_letter ]_\|_
\&  Dear jerks,
\&
\&    I quit!
\&
\&  \-\- 
\&  {{ $name }}
\&  _\|_[ professional_letter ]_\|_
\&  Dear {{ $boss }},
\&
\&    I quit, jerks!
\&
\&
\&  \-\- 
\&  {{ $name }}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data::Section provides an easy way to access multiple named chunks of
line-oriented data in your module's \s-1DATA\s0 section.  It was written to allow
modules to store their own templates, but probably has other uses.
.SH "WARNING"
.IX Header "WARNING"
You will need to use \f(CW\*(C`_\|_DATA_\|_\*(C'\fR sections and not \f(CW\*(C`_\|_END_\|_\*(C'\fR sections.  Yes, it
matters.  Who knew!
.SH "EXPORTS"
.IX Header "EXPORTS"
To get the methods exported by Data::Section, you must import like this:
.PP
.Vb 1
\&  use Data::Section \-setup;
.Ve
.PP
Optional arguments may be given to Data::Section like this:
.PP
.Vb 1
\&  use Data::Section \-setup => { ... };
.Ve
.PP
Valid arguments are:
.PP
.Vb 2
\&  encoding     \- if given, gives the encoding needed to decode bytes in
\&                 data sections; default; UTF\-8
\&
\&                 the special value "bytes" will leave the bytes in the string
\&                 verbatim
\&
\&  inherit      \- if true, allow packages to inherit the data of the packages
\&                 from which they inherit; default: true
\&
\&  header_re    \- if given, changes the regex used to find section headers
\&                 in the data section; it should leave the section name in $1
\&
\&  default_name \- if given, allows the first section to has no header and set
\&                 its name
.Ve
.PP
Three methods are exported by Data::Section:
.SS "section_data"
.IX Subsection "section_data"
.Vb 1
\&  my $string_ref = $pkg\->section_data($name);
.Ve
.PP
This method returns a reference to a string containing the data from the name
section, either in the invocant's \f(CW\*(C`DATA\*(C'\fR section or in that of one of its
ancestors.  (The ancestor must also derive from the class that imported
Data::Section.)
.PP
By default, named sections are delimited by lines that look like this:
.PP
.Vb 1
\&  _\|_[ name ]_\|_
.Ve
.PP
You can use as many underscores as you want, and the space around the name is
optional.  This pattern can be configured with the \f(CW\*(C`header_re\*(C'\fR option (see
above).  If present, a single leading \f(CW\*(C`\e\*(C'\fR is removed, so that sections can
encode lines that look like section delimiters.
.PP
When a line containing only \f(CW\*(C`_\|_END_\|_\*(C'\fR is reached, all processing of sections
ends.
.SS "section_data_names"
.IX Subsection "section_data_names"
.Vb 1
\&  my @names = $pkg\->section_data_names;
.Ve
.PP
This returns a list of all the names that will be recognized by the
\&\f(CW\*(C`section_data\*(C'\fR method.
.SS "merged_section_data"
.IX Subsection "merged_section_data"
.Vb 1
\&  my $data = $pkg\->merged_section_data;
.Ve
.PP
This method returns a hashref containing all the data extracted from the
package data for all the classes from which the invocant inherits \*(-- as long as
those classes also inherit from the package into which Data::Section was
imported.
.PP
In other words, given this inheritance tree:
.PP
.Vb 5
\&  A
\&   \e
\&    B   C
\&     \e /
\&      D
.Ve
.PP
\&...if Data::Section was imported by A, then when D's \f(CW\*(C`merged_section_data\*(C'\fR is
invoked, C's data section will not be considered.  (This prevents the read
position of C's data handle from being altered unexpectedly.)
.PP
The keys in the returned hashref are the section names, and the values are
\&\fBreferences to\fR the strings extracted from the data sections.
.SS "merged_section_data_names"
.IX Subsection "merged_section_data_names"
.Vb 1
\&  my @names = $pkg\->merged_section_data_names;
.Ve
.PP
This returns a list of all the names that will be recognized by the
\&\f(CW\*(C`merged_section_data\*(C'\fR method.
.SS "local_section_data"
.IX Subsection "local_section_data"
.Vb 1
\&  my $data = $pkg\->local_section_data;
.Ve
.PP
This method returns a hashref containing all the data extracted from the
package on which the method was invoked.  If called on an object, it will
operate on the package into which the object was blessed.
.PP
This method needs to be used carefully, because it's weird.  It returns only
the data for the package on which it was invoked.  If the package on which it
was invoked has no data sections, it returns an empty hashref.
.SS "local_section_data_names"
.IX Subsection "local_section_data_names"
.Vb 1
\&  my @names = $pkg\->local_section_data_names;
.Ve
.PP
This returns a list of all the names that will be recognized by the
\&\f(CW\*(C`local_section_data\*(C'\fR method.
.SH "TIPS AND TRICKS"
.IX Header "TIPS AND TRICKS"
.SS "MooseX::Declare and namespace::autoclean"
.IX Subsection "MooseX::Declare and namespace::autoclean"
The namespace::autoclean library automatically cleans
foreign routines from a class, including those imported by Data::Section.
.PP
MooseX::Declare does the same thing, and can also cause your
\&\f(CW\*(C`_\|_DATA_\|_\*(C'\fR section to appear outside your class's package.
.PP
These are easy to address.  The
Sub::Exporter::ForMethods library provides an
installer that will cause installed methods to appear to come from the class
and avoid autocleaning.  Using an explicit \f(CW\*(C`package\*(C'\fR statement will keep the
data section in the correct package.
.PP
.Vb 1
\&   package Foo;
\&
\&   use MooseX::Declare;
\&   class Foo {
\&
\&     # Utility to tell Sub::Exporter modules to export methods.
\&     use Sub::Exporter::ForMethods qw( method_installer );
\&
\&     # method_installer returns a sub.
\&     use Data::Section { installer => method_installer }, \-setup;
\&
\&     method my_method {
\&        my $content_ref = $self\->section_data(\*(AqSectionA\*(Aq);
\&
\&        print $$content_ref;
\&     }
\&   }
\&
\&   _\|_DATA_\|_
\&   _\|_[ SectionA ]_\|_
\&   Hello, world.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
article for \s-1RJBS\s0 Advent 2009 <http://advent.rjbs.manxome.org/2009/2009-12-09.html>
.IP "\(bu" 4
Inline::Files does something that is at first look similar,
.Sp
but it works with source filters, and contains the warning:
.Sp
.Vb 3
\&  It is possible that this module may overwrite the source code in files that
\&  use it. To protect yourself against this possibility, you are strongly
\&  advised to use the \-backup option described in "Safety first".
.Ve
.Sp
Enough said.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo \s-1SIGNES\s0 <rjbs@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Christian Walde <walde.christian@googlemail.com>
.IP "\(bu" 4
Dan Kogai <dankogai+github@gmail.com>
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.IP "\(bu" 4
David Steinbrunner <dsteinbrunner@pobox.com>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
Kenichi Ishigaki <ishigaki@cpan.org>
.IP "\(bu" 4
kentfredric <kentfredric+gravitar@gmail.com>
.IP "\(bu" 4
Tatsuhiko Miyagawa <miyagawa@bulknews.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2008 by Ricardo \s-1SIGNES.\s0
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
