# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Mojo::Message extends Mojo::EventEmitter {
  
  version_from Mojolicious;
  
  use Mojo::Headers;
  use Mojo::Upload;
  use Mojo::Asset::Memory;
  use Mojo::Content::Single;
  use Mojo::Parameters;
  use Mojo::Upload;
  use Mojo::Content::MultiPart;
  use Hash;
  use JSON;
  use StringBuffer;
  
  # Interfaces
  interface Stringable;
  
  # Fields
  has content : rw Mojo::Content;
  
  has max_line_size : rw int;
  
  has max_message_size : rw int;
  
  has version : rw string;
  
  # Undocumented Fields
  has state : string;
  
  has finished : byte;
  
  has fix : byte;
  
  has body_params : Mojo::Parameters;
  
  has limit : byte;
  
  has json : object;
  
  has raw_size : int;
  
  has buffer : StringBuffer;
  
  has _caches_all_h : Hash of Hash;
  
  # Old Fields
  has content_buffer : rw StringBuffer;
  
  # Instance Methods
  protected method init : void () {
    
    $self->{_caches_all_h} = Hash->new;
    
    $self->{buffer} = StringBuffer->new;
    
    $self->{content} = Mojo::Content::Single->new;
    
    $self->{max_line_size} = length(my $_ = Sys->env("SPVM_MOJO_MAX_LINE_SIZE")) ? (int)$_ : 8192;
    
    $self->{max_message_size} = length(my $_ = Sys->env("SPVM_MOJO_MAX_MESSAGE_SIZE")) ? (int)$_ : 16777216;
    
    $self->{version} = "1.1";
  }
  
  method body : string () {
    
    my $content = $self->content;
    
    return $content->is_multipart ? "" : $content->(Mojo::Content::Single)->asset->slurp;
  }
  
  method set_body : void ($body : string) {
    
    my $content = $self->content;
    if ($content->is_multipart) {
      $content = Mojo::Content::Single->new;
      $self->{content} = $content;
    }
    
    my $asset = Mojo::Asset::Memory->new;
    $asset->add_chunk($body);
    $content->(Mojo::Content::Single)->set_asset($asset);
  }
  
  method body_params : Mojo::Parameters () {
    
    if ($self->{body_params}) {
      return $self->{body_params};
    }
    
    my $params = $self->{body_params} = Mojo::Parameters->new;
    
    # "application/x-www-form-urlencoded"
    my $type = $self->headers->content_type // "";
    if (Re->m($type, ["application/x-www-form-urlencoded", "i"])) {
      $params->parse($self->content->(Mojo::Content::Single)->asset->slurp);
    }
    
    # "multipart/form-data"
    elsif (Re->m($type, ["multipart/form-data", "i"])) {
      my $formdata = $self->_parse_formdata;
      
      for my $_ (@$formdata) {
        $params->append([$_->(object[])->[0], $_->(object[])->[1]]);
      }
    }
    
    return $params;
  }
  
  method body_size : int () {
    
    return $self->content->body_size;
  }
  
  method build_body : string () {
    
    return $self->_build("get_body_chunk");
  }
  
  method build_headers : string () {
    
    return $self->_build("get_header_chunk");
  }
  
  method build_start_line : string () {
    
    return $self->_build("get_start_line_chunk");
  }
  
  method cookie : Mojo::Cookie ($name : string) {
    
    return (Mojo::Cookie)$self->_cache("cookies", 0, $name);
  }
  
  method cookies : Mojo::Cookie[] () { die "Not implemented."; }
  
  method every_cookie : Mojo::Cookie[] ($name : string) {
    return (Mojo::Cookie[])$self->_cache("cookies", 1, $name);
  }
  
  method every_upload : Mojo::Upload[] ($name : string) {
    return (Mojo::Upload[])$self->_cache("uploads", 1, $name);
  }
  
  method extract_start_line : int ($str : mutable string) { die "Not implemented."; }
  
  method finish : void () {
    
    $self->{state} = "finished";
    
    unless ($self->{finished}) {
      
      $self->emit("finish");
      $self->{finished}++;
    }
  }
  
  method fix_headers : void () {
    
    if ($self->{fix}++) {
      return;
    }
    
    # Content-Length or Connection (unless chunked transfer encoding is used)
    my $content = $self->content;
    my $headers = $content->headers;
    if ($content->is_multipart) {
      $headers->remove("Content-Length");
    }
    elsif ($content->is_chunked || $headers->content_length) {
      return;
    }
    
    if ($content->is_dynamic) {
      $headers->set_connection("close");
    }
    else {
      $headers->set_content_length($self->body_size);
    }
  }
  
  method get_body_chunk : string ($offset : int) {
    
    $self->emit(progress => "body", $offset);
    my $chunk = $self->content->get_body_chunk($offset);
    
    if (!$chunk || length $chunk) {
      return $chunk;
    }
    
    $self->finish;
    
    return $chunk;
  }
  
  method get_header_chunk : string ($offset : int) {
    
    $self->emit(progress => "headers", $offset);
    
    $self->fix_headers;
    
    my $chunk = $self->content->get_header_chunk($offset);
    
    return $chunk;
  }
  
  method get_start_line_chunk : string ($offset : int) { die "Not implemented."; }
  
  method header_size : int () {
    
    $self->fix_headers;
    
    return $self->content->header_size;
  }
  
  method headers : Mojo::Headers () {
    return $self->content->headers;
  }
  
  method is_finished : int () {
    
    return ($self->{state} // "") eq "finished";
  }
  
  method json : object () {
    
    if ($self->content->is_multipart) {
      return undef;
    }
    
    my $data = $self->{json} //= JSON->new->decode($self->body);
    
    return $data;
  }
  
  method parse : void ($chunk : string) {
    
    $self->{raw_size} += length $chunk;
    
    $self->{buffer}->push($chunk);
    
    # Start-line
    unless ($self->{state}) {
      
      # Check start-line size
      my $len = $self->{buffer}->index("\x0a");
      if ($len < 0) {
        $len = $self->{buffer}->length;
      }
      
      if ($len > $self->max_line_size) {
        die "Maximum start-line size exceeded";
        return;
      }
      if ($self->extract_start_line((mutable string)$self->{buffer}->get_string)) {
        $self->{state} = "content";
      }
    }
    
    # Content
    my $state = $self->{state} // "";
    if ($state eq "content" || $state eq "finished") {
      my $buffer = $self->{buffer};
      $self->{buffer} = StringBuffer->new;
      my $content = $self->content;
      
      $content = $content->parse($buffer->get_string);
      
      $self->{content} = $content;
    }
    
    # Check message size
    my $max = $self->max_message_size;
    if ($max != 0 && $max < $self->{raw_size}) {
      die "Maximum message size exceeded";
      return;
    }
    
    $self->emit("progress");
    
    if ($self->content->is_finished) {
      $self->finish;
    }
  }
  
  method save_to : void ($path : string) {
    
    my $content = $self->content;
    
    if ($content->is_multipart) {
      die "Multipart content cannot be saved to files";
    }
    $content->(Mojo::Content::Single)->asset->move_to($path);
  }
  
  method start_line_size : int () { die "Not implemented."; }
  
  method text : string () {
    
    my $body = $self->body;
    
    return $body;
  }
  
  method to_string : string () {
    
    return $self->build_start_line . $self->build_headers . $self->build_body;
  }
  
  method upload : Mojo::Upload ($name : string) { return (Mojo::Upload)$self->_cache("uploads", 0, $name); }
  
  method uploads : Mojo::Upload[] () {
    
    my $uploads = (List of Mojo::Upload)List->new(new Mojo::Upload[0]);
    for my $data (@{$self->_parse_formdata(1)}) {
      my $upload = Mojo::Upload->new;
      $upload->set_name($data->(object[])->[0]->(string));
      $upload->set_filename($data->(object[])->[2]->(string));
      $upload->set_asset($data->(object[])->[1]->(Mojo::Content::Single)->asset);
      $upload->set_headers($data->(object[])->[1]->(Mojo::Content)->headers);
      $uploads->push($upload);
    }
    
    return $uploads->to_array;
  }
  
  private method _parse_formdata : object[] ($upload : int = 0) {
    
    my $formdata = (List of string|Mojo::Content)List->new;
    my $content = $self->content;
    unless ($content->is_multipart) {
      return $formdata->to_array;
    }
    
    # Check all parts recursively
    my $parts = (List of Mojo::Content)List->new(new Mojo::Content[0]);
    $parts->push($content);
    
    while (1) {
      
      unless ($parts->length) {
        last;
      }
      
      my $part = (Mojo::Content)$parts->shift;
      
      if ($part->is_multipart) {
        $parts->unshift_($part->(Mojo::Content::MultiPart)->parts);
        next;
      }
      
      my $disposition = $part->headers->content_disposition;
      unless ($disposition) {
        next;
      }
      
      my $filename = (string)undef;
      if (my $m = Re->m($disposition, "[; ]filename=\"((?:\\\\\"|[^\"])*)\"")) {;
        $filename = $m->cap1;
      }
      
      if ($upload && !length $filename || !$upload && length $filename) {
        next;
      }
      
      my $name = (string)undef;
      if (my $m = Re->m($disposition, "[; ]name=\"((?:\\\\\"|[^;\"])*)\"")) {
        $name = $m->cap1;
      }
      
      if (!length $name) {
        next;
      }
      
      my $part_ = (object)$part;
      unless ($upload) {
        $part_ = $part->(Mojo::Content::Single)->asset->slurp;
      }
      
      $formdata->push([(object)$name, $part_, $filename]);
    }
    
    return $formdata->to_array;
  }
  
  private method _build : string ($method : string) {
    
    my $buffer = StringBuffer->new;
    my $offset = 0;
    
    while (1) {
      
      my $chunk = (string)undef;
      if ($method eq "get_start_line_chunk") {
        $chunk = $self->get_start_line_chunk($offset);
      }
      elsif ($method eq "get_header_chunk") {
        $chunk = $self->get_header_chunk($offset);
      }
      elsif ($method eq "get_body_chunk") {
        $chunk = $self->get_body_chunk($offset);
      }
      
      # No chunk yet, try again
      unless ($chunk) {
        next;
      }
      
      # End of part
      my $len = length $chunk;
      unless ($len) {
        last;
      }
      
      $offset += $len;
      $buffer->push($chunk);
    }
    
    return $buffer->to_string;
  }
  
  private method _cache : object ($method : string, $all : int, $name : string) {
    
    my $tmp_list = (List)undef;
    if ($method eq "uploads") {
      $tmp_list = List->new(new Mojo::Upload[0]);
    }
    elsif ($method eq "cookies") {
      $tmp_list = List->new(new Mojo::Cookie[0]);
    }
    else {
      die "[Unexpecgted Error]Invalid _cache method.";
    }
    
    # Cache objects by name
    my $caches_all_h = $self->{_caches_all_h};
    
    unless ($caches_all_h->{$method}) {
      
      $caches_all_h->{$method} = Hash->new;
      
      my $items = (object[])undef;
      if ($method eq "uploads") {
        $items = $self->uploads;
      }
      elsif ($method eq "cookies") {
        $items = $self->cookies;
      }
      
      for my $item (@$items) {
        my $name = (string)undef;
        if ($method eq "uploads") {
          $name = $item->(Mojo::Upload)->name;
        }
        elsif ($method eq "cookies") {
          $name = $item->(Mojo::Cookie)->name;
        }
        
        unless ($caches_all_h->{$method}{$name}) {
          $caches_all_h->{$method}{$name} = $tmp_list->clone;
        }
        $caches_all_h->{$method}{$name}->(List)->push($item);
      }
    }
    
    my $objects_list = $caches_all_h->{$method}{$name}->(List) // $tmp_list->clone;
    my $objects = $objects_list->to_array;
    
    if ($all) {
      return $objects;
    }
    else {
      if (@$objects > 0) {
        return $objects->[@$objects - 1];
      }
      else {
        return undef;
      }
    }
  }
  
}
