.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Dispatchouli 3pm"
.TH Log::Dispatchouli 3pm "2020-08-24" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Dispatchouli \- a simple wrapper around Log::Dispatch
.SH "VERSION"
.IX Header "VERSION"
version 2.022
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  my $logger = Log::Dispatchouli\->new({
\&    ident     => \*(Aqstuff\-purger\*(Aq,
\&    facility  => \*(Aqdaemon\*(Aq,
\&    to_stdout => $opt\->{print},
\&    debug     => $opt\->{verbose}
\&  });
\&
\&  $logger\->log([ "There are %s items left to purge...", $stuff_left ]);
\&
\&  $logger\->log_debug("this is extra often\-ignored debugging log");
\&
\&  $logger\->log_fatal("Now we will die!!");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Log::Dispatchouli is a thin layer above Log::Dispatch and meant to make it
dead simple to add logging to a program without having to think much about
categories, facilities, levels, or things like that.  It is meant to make
logging just configurable enough that you can find the logs you want and just
easy enough that you will actually log things.
.PP
Log::Dispatchouli can log to syslog (if you specify a facility), standard error
or standard output, to a file, or to an array in memory.  That last one is
mostly useful for testing.
.PP
In addition to providing as simple a way to get a handle for logging
operations, Log::Dispatchouli uses String::Flogger to process the things to
be logged, meaning you can easily log data structures.  Basically: strings are
logged as is, arrayrefs are taken as (sprintf format, args), and subroutines
are called only if needed.  For more information read the String::Flogger
docs.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $logger = Log::Dispatchouli\->new(\e%arg);
.Ve
.PP
This returns a new logger, a Log::Dispatchouli object.
.PP
Valid arguments are:
.PP
.Vb 5
\&  ident       \- the name of the thing logging (mandatory)
\&  to_self     \- log to the logger object for testing; default: false
\&  to_stdout   \- log to STDOUT; default: false
\&  to_stderr   \- log to STDERR; default: false
\&  facility    \- to which syslog facility to send logs; default: none
\&
\&  to_file     \- log to PROGRAM_NAME.YYYYMMDD in the log path; default: false
\&  log_file    \- a leaf name for the file to log to with to_file
\&  log_path    \- path in which to log to file; defaults to DISPATCHOULI_PATH
\&                environment variable or, failing that, to your system\*(Aqs tmpdir
\&
\&  file_format \- this optional coderef is passed the message to be logged
\&                and returns the text to write out
\&
\&  log_pid     \- if true, prefix all log entries with the pid; default: true
\&  fail_fatal  \- a boolean; if true, failure to log is fatal; default: true
\&  muted       \- a boolean; if true, only fatals are logged; default: false
\&  debug       \- a boolean; if true, log_debug method is not a no\-op
\&                defaults to the truth of the DISPATCHOULI_DEBUG env var
\&  quiet_fatal \- \*(Aqstderr\*(Aq or \*(Aqstdout\*(Aq or an arrayref of zero, one, or both
\&                fatal log messages will not be logged to these
\&                (default: stderr)
\&  config_id   \- a name for this logger\*(Aqs config; rarely needed!
\&  syslog_socket \- a value for Sys::Syslog\*(Aqs "socket" arg; default: "native"
.Ve
.PP
The log path is either \fI/tmp\fR or the value of the \fI\s-1DISPATCHOULI_PATH\s0\fR env var.
.PP
If the \fI\s-1DISPATCHOULI_NOSYSLOG\s0\fR env var is true, we don't log to syslog.
.SS "log"
.IX Subsection "log"
.Vb 1
\&  $logger\->log(@messages);
\&
\&  $logger\->log(\e%arg, @messages);
.Ve
.PP
This method uses String::Flogger on the input, then \fIunconditionally\fR logs
the result.  Each message is flogged individually, then joined with spaces.
.PP
If the first argument is a hashref, it will be used as extra arguments to
logging.  It may include a \f(CW\*(C`prefix\*(C'\fR entry to preprocess the message by
prepending a string (if the prefix is a string) or calling a subroutine to
generate a new message (if the prefix is a coderef).
.SS "log_fatal"
.IX Subsection "log_fatal"
This behaves like the \f(CW\*(C`log\*(C'\fR method, but will throw the logged string as an
exception after logging.
.PP
This method can also be called as \f(CW\*(C`fatal\*(C'\fR, to match other popular logging
interfaces.  \fBIf you want to override this method, you must override
\&\f(CB\*(C`log_fatal\*(C'\fB and not \f(CB\*(C`fatal\*(C'\fB\fR.
.SS "log_debug"
.IX Subsection "log_debug"
This behaves like the \f(CW\*(C`log\*(C'\fR method, but will only log (at the debug level) if
the logger object has its debug property set to true.
.PP
This method can also be called as \f(CW\*(C`debug\*(C'\fR, to match other popular logging
interfaces.  \fBIf you want to override this method, you must override
\&\f(CB\*(C`log_debug\*(C'\fB and not \f(CB\*(C`debug\*(C'\fB\fR.
.SS "set_debug"
.IX Subsection "set_debug"
.Vb 1
\&  $logger\->set_debug($bool);
.Ve
.PP
This sets the logger's debug property, which affects the behavior of
\&\f(CW\*(C`log_debug\*(C'\fR.
.SS "get_debug"
.IX Subsection "get_debug"
This gets the logger's debug property, which affects the behavior of
\&\f(CW\*(C`log_debug\*(C'\fR.
.SS "clear_debug"
.IX Subsection "clear_debug"
This method does nothing, and is only useful for Log::Dispatchouli::Proxy
objects.  See Methods for Proxy Loggers, below.
.SS "set_muted"
.IX Subsection "set_muted"
.Vb 1
\&  $logger\->set_muted($bool);
.Ve
.PP
This sets the logger's muted property, which affects the behavior of
\&\f(CW\*(C`log\*(C'\fR.
.SS "get_muted"
.IX Subsection "get_muted"
This gets the logger's muted property, which affects the behavior of
\&\f(CW\*(C`log\*(C'\fR.
.SS "clear_muted"
.IX Subsection "clear_muted"
This method does nothing, and is only useful for Log::Dispatchouli::Proxy
objects.  See Methods for Proxy Loggers, below.
.SS "get_prefix"
.IX Subsection "get_prefix"
.Vb 1
\&  my $prefix = $logger\->get_prefix;
.Ve
.PP
This method returns the currently-set prefix for the logger, which may be a
string or code reference or undef.  See Logger Prefix.
.SS "set_prefix"
.IX Subsection "set_prefix"
.Vb 1
\&  $logger\->set_prefix( $new_prefix );
.Ve
.PP
This method changes the prefix.  See Logger Prefix.
.SS "clear_prefix"
.IX Subsection "clear_prefix"
This method clears any set logger prefix.  (It can also be called as
\&\f(CW\*(C`unset_prefix\*(C'\fR, but this is deprecated.  See Logger Prefix.
.SS "ident"
.IX Subsection "ident"
This method returns the logger's ident.
.SS "config_id"
.IX Subsection "config_id"
This method returns the logger's configuration id, which defaults to its ident.
This can be used to make two loggers equivalent in Log::Dispatchouli::Global so
that trying to reinitialize with a new logger with the same \f(CW\*(C`config_id\*(C'\fR as the
current logger will not throw an exception, and will simply do no thing.
.SS "dispatcher"
.IX Subsection "dispatcher"
This returns the underlying Log::Dispatch object.  This is not the method
you're looking for.  Move along.
.SS "stdio_dispatcher_class"
.IX Subsection "stdio_dispatcher_class"
This method is an experimental feature to allow you to pick an alternate
dispatch class for stderr and stdio.  By default, Log::Dispatch::Screen is
used.  \fBThis feature may go away at any time.\fR
.SH "LOGGER PREFIX"
.IX Header "LOGGER PREFIX"
Log messages may be prepended with information to set context.  This can be set
at a logger level or per log item.  The simplest example is:
.PP
.Vb 1
\&  my $logger = Log::Dispatchouli\->new( ... );
\&
\&  $logger\->set_prefix("Batch 123: ");
\&
\&  $logger\->log("begun processing");
\&
\&  # ...
\&
\&  $logger\->log("finished processing");
.Ve
.PP
The above will log something like:
.PP
.Vb 2
\&  Batch 123: begun processing
\&  Batch 123: finished processing
.Ve
.PP
To pass a prefix per-message:
.PP
.Vb 1
\&  $logger\->log({ prefix => \*(AqSub\-Item 234: \*(Aq }, \*(Aqerror!\*(Aq)
\&
\&  # Logs: Batch 123: Sub\-Item 234: error!
.Ve
.PP
If the prefix is a string, it is prepended to each line of the message.  If it
is a coderef, it is called and passed the message to be logged.  The return
value is logged instead.
.PP
Proxy loggers also have their own prefix
settings, which accumulate.  So:
.PP
.Vb 1
\&  my $proxy = $logger\->proxy({ proxy_prefix => \*(AqSubsystem 12: \*(Aq });
\&
\&  $proxy\->set_prefix(\*(AqPage 9: \*(Aq);
\&
\&  $proxy\->log({ prefix => \*(AqParagraph 6: \*(Aq }, \*(AqDone.\*(Aq);
.Ve
.PP
\&...will log...
.PP
.Vb 1
\&  Batch 123: Subsystem 12: Page 9: Paragraph 6: Done.
.Ve
.SH "METHODS FOR SUBCLASSING"
.IX Header "METHODS FOR SUBCLASSING"
.SS "string_flogger"
.IX Subsection "string_flogger"
This method returns the thing on which \fIflog\fR will be called to format log
messages.  By default, it just returns \f(CW\*(C`String::Flogger\*(C'\fR
.SS "env_prefix"
.IX Subsection "env_prefix"
This method should return a string used as a prefix to find environment
variables that affect the logger's behavior.  For example, if this method
returns \f(CW\*(C`XYZZY\*(C'\fR then when checking the environment for a default value for the
\&\f(CW\*(C`debug\*(C'\fR parameter, Log::Dispatchouli will first check \f(CW\*(C`XYZZY_DEBUG\*(C'\fR, then
\&\f(CW\*(C`DISPATCHOULI_DEBUG\*(C'\fR.
.PP
By default, this method returns \f(CW\*(C`()\*(C'\fR, which means no extra environment
variable is checked.
.SS "env_value"
.IX Subsection "env_value"
.Vb 1
\&  my $value = $logger\->env_value(\*(AqDEBUG\*(Aq);
.Ve
.PP
This method returns the value for the environment variable suffix given.  For
example, the example given, calling with \f(CW\*(C`DEBUG\*(C'\fR will check
\&\f(CW\*(C`DISPATCHOULI_DEBUG\*(C'\fR.
.SH "METHODS FOR TESTING"
.IX Header "METHODS FOR TESTING"
.SS "new_tester"
.IX Subsection "new_tester"
.Vb 1
\&  my $logger = Log::Dispatchouli\->new_tester( \e%arg );
.Ve
.PP
This returns a new logger that logs only \f(CW\*(C`to_self\*(C'\fR.  It's useful in testing.
If no \f(CW\*(C`ident\*(C'\fR arg is provided, one will be generated.  \f(CW\*(C`log_pid\*(C'\fR is off by
default, but can be overridden.
.PP
\&\f(CW\*(C`\e%arg\*(C'\fR is optional.
.SS "events"
.IX Subsection "events"
This method returns the arrayref of events logged to an array in memory (in the
logger).  If the logger is not logging \f(CW\*(C`to_self\*(C'\fR this raises an exception.
.SS "clear_events"
.IX Subsection "clear_events"
This method empties the current sequence of events logged into an array in
memory.  If the logger is not logging \f(CW\*(C`to_self\*(C'\fR this raises an exception.
.SH "METHODS FOR PROXY LOGGERS"
.IX Header "METHODS FOR PROXY LOGGERS"
.SS "proxy"
.IX Subsection "proxy"
.Vb 1
\&  my $proxy_logger = $logger\->proxy( \e%arg );
.Ve
.PP
This method returns a new proxy logger \*(-- an instance of
Log::Dispatchouli::Proxy \*(-- which will log through the given logger, but
which may have some settings localized.
.PP
\&\f(CW%arg\fR is optional.  It may contain the following entries:
.IP "proxy_prefix" 4
.IX Item "proxy_prefix"
This is a prefix that will be applied to anything the proxy logger logs, and
cannot be changed.
.IP "debug" 4
.IX Item "debug"
This can be set to true or false to change the proxy's \*(L"am I in debug mode?\*(R"
setting.  It can be changed or cleared later on the proxy.
.SS "parent"
.IX Subsection "parent"
.SS "logger"
.IX Subsection "logger"
These methods return the logger itself.  (They're more useful when called on
proxy loggers.)
.SH "METHODS FOR API COMPATIBILITY"
.IX Header "METHODS FOR API COMPATIBILITY"
To provide compatibility with some other loggers, most specifically
Log::Contextual, the following methods are provided.  You should not use
these methods without a good reason, and you should never subclass them.
Instead, subclass the methods they call.
.IP "is_debug" 4
.IX Item "is_debug"
This method calls \f(CW\*(C`get_debug\*(C'\fR.
.IP "is_info" 4
.IX Item "is_info"
.PD 0
.IP "is_fatal" 4
.IX Item "is_fatal"
.PD
These methods return true.
.IP "info" 4
.IX Item "info"
.PD 0
.IP "fatal" 4
.IX Item "fatal"
.IP "debug" 4
.IX Item "debug"
.PD
These methods redispatch to \f(CW\*(C`log\*(C'\fR, \f(CW\*(C`log_fatal\*(C'\fR, and \f(CW\*(C`log_debug\*(C'\fR
respectively.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Log::Dispatch
.IP "\(bu" 4
String::Flogger
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo \s-1SIGNES\s0 <rjbs@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Christopher J. Madsen <perl@cjmweb.net>
.IP "\(bu" 4
Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
.IP "\(bu" 4
Dan Book <grinnz@gmail.com>
.IP "\(bu" 4
George Hartzell <hartzell@alerce.com>
.IP "\(bu" 4
Jon Stuart <jon@fastmailteam.com>
.IP "\(bu" 4
Matt Phillips <mattp@cpan.org>
.IP "\(bu" 4
Olivier Mengué <dolmen@cpan.org>
.IP "\(bu" 4
Randy Stauner <randy@magnificent\-tears.com>
.IP "\(bu" 4
Ricardo Signes <rjbs@semiotic.systems>
.IP "\(bu" 4
Ricardo Signes <rjbs@users.noreply.github.com>
.IP "\(bu" 4
Sawyer X <xsawyerx@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2020 by Ricardo \s-1SIGNES.\s0
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
