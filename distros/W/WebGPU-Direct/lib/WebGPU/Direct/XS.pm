# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! #
#   This file is generated by webgpu.xs.PL  #
# !!!!!!!   ANY EDIT WILL BE LOST   !!!!!!! #

use v5.30;
use warnings;

package # Hide from PAUSE
    WebGPU::Direct::XS
{
  our $VERSION = '0.15';
  require XSLoader;
  XSLoader::load('WebGPU::Direct', $VERSION);
}

package # Hide from PAUSE
    WebGPU::Direct::Opaque {
}

require WebGPU::Direct::MappedBuffer;
require WebGPU::Direct::Error;

package
	WebGPU::Direct {
  sub createInstance { my $class = shift; WebGPU::Direct::XS::createInstance(@_); }
  sub getProcAddress { my $class = shift; WebGPU::Direct::XS::getProcAddress(@_); }
  our @export_all;
  sub AdapterType () { 'WebGPU::Direct::AdapterType' }; push @export_all, 'AdapterType';
  sub AddressMode () { 'WebGPU::Direct::AddressMode' }; push @export_all, 'AddressMode';
  sub BackendType () { 'WebGPU::Direct::BackendType' }; push @export_all, 'BackendType';
  sub BlendFactor () { 'WebGPU::Direct::BlendFactor' }; push @export_all, 'BlendFactor';
  sub BlendOperation () { 'WebGPU::Direct::BlendOperation' }; push @export_all, 'BlendOperation';
  sub BufferBindingType () { 'WebGPU::Direct::BufferBindingType' }; push @export_all, 'BufferBindingType';
  sub BufferMapAsyncStatus () { 'WebGPU::Direct::BufferMapAsyncStatus' }; push @export_all, 'BufferMapAsyncStatus';
  sub BufferMapState () { 'WebGPU::Direct::BufferMapState' }; push @export_all, 'BufferMapState';
  sub BufferUsage () { 'WebGPU::Direct::BufferUsage' }; push @export_all, 'BufferUsage';
  sub ColorWriteMask () { 'WebGPU::Direct::ColorWriteMask' }; push @export_all, 'ColorWriteMask';
  sub CompareFunction () { 'WebGPU::Direct::CompareFunction' }; push @export_all, 'CompareFunction';
  sub CompilationInfoRequestStatus () { 'WebGPU::Direct::CompilationInfoRequestStatus' }; push @export_all, 'CompilationInfoRequestStatus';
  sub CompilationMessageType () { 'WebGPU::Direct::CompilationMessageType' }; push @export_all, 'CompilationMessageType';
  sub CompositeAlphaMode () { 'WebGPU::Direct::CompositeAlphaMode' }; push @export_all, 'CompositeAlphaMode';
  sub CreatePipelineAsyncStatus () { 'WebGPU::Direct::CreatePipelineAsyncStatus' }; push @export_all, 'CreatePipelineAsyncStatus';
  sub CullMode () { 'WebGPU::Direct::CullMode' }; push @export_all, 'CullMode';
  sub DeviceLostReason () { 'WebGPU::Direct::DeviceLostReason' }; push @export_all, 'DeviceLostReason';
  sub ErrorFilter () { 'WebGPU::Direct::ErrorFilter' }; push @export_all, 'ErrorFilter';
  sub ErrorType () { 'WebGPU::Direct::ErrorType' }; push @export_all, 'ErrorType';
  sub FeatureName () { 'WebGPU::Direct::FeatureName' }; push @export_all, 'FeatureName';
  sub FilterMode () { 'WebGPU::Direct::FilterMode' }; push @export_all, 'FilterMode';
  sub FrontFace () { 'WebGPU::Direct::FrontFace' }; push @export_all, 'FrontFace';
  sub IndexFormat () { 'WebGPU::Direct::IndexFormat' }; push @export_all, 'IndexFormat';
  sub LoadOp () { 'WebGPU::Direct::LoadOp' }; push @export_all, 'LoadOp';
  sub MapMode () { 'WebGPU::Direct::MapMode' }; push @export_all, 'MapMode';
  sub MipmapFilterMode () { 'WebGPU::Direct::MipmapFilterMode' }; push @export_all, 'MipmapFilterMode';
  sub PowerPreference () { 'WebGPU::Direct::PowerPreference' }; push @export_all, 'PowerPreference';
  sub PresentMode () { 'WebGPU::Direct::PresentMode' }; push @export_all, 'PresentMode';
  sub PrimitiveTopology () { 'WebGPU::Direct::PrimitiveTopology' }; push @export_all, 'PrimitiveTopology';
  sub QueryType () { 'WebGPU::Direct::QueryType' }; push @export_all, 'QueryType';
  sub QueueWorkDoneStatus () { 'WebGPU::Direct::QueueWorkDoneStatus' }; push @export_all, 'QueueWorkDoneStatus';
  sub RequestAdapterStatus () { 'WebGPU::Direct::RequestAdapterStatus' }; push @export_all, 'RequestAdapterStatus';
  sub RequestDeviceStatus () { 'WebGPU::Direct::RequestDeviceStatus' }; push @export_all, 'RequestDeviceStatus';
  sub SType () { 'WebGPU::Direct::SType' }; push @export_all, 'SType';
  sub SamplerBindingType () { 'WebGPU::Direct::SamplerBindingType' }; push @export_all, 'SamplerBindingType';
  sub ShaderStage () { 'WebGPU::Direct::ShaderStage' }; push @export_all, 'ShaderStage';
  sub StencilOperation () { 'WebGPU::Direct::StencilOperation' }; push @export_all, 'StencilOperation';
  sub StorageTextureAccess () { 'WebGPU::Direct::StorageTextureAccess' }; push @export_all, 'StorageTextureAccess';
  sub StoreOp () { 'WebGPU::Direct::StoreOp' }; push @export_all, 'StoreOp';
  sub SurfaceGetCurrentTextureStatus () { 'WebGPU::Direct::SurfaceGetCurrentTextureStatus' }; push @export_all, 'SurfaceGetCurrentTextureStatus';
  sub TextureAspect () { 'WebGPU::Direct::TextureAspect' }; push @export_all, 'TextureAspect';
  sub TextureDimension () { 'WebGPU::Direct::TextureDimension' }; push @export_all, 'TextureDimension';
  sub TextureFormat () { 'WebGPU::Direct::TextureFormat' }; push @export_all, 'TextureFormat';
  sub TextureSampleType () { 'WebGPU::Direct::TextureSampleType' }; push @export_all, 'TextureSampleType';
  sub TextureUsage () { 'WebGPU::Direct::TextureUsage' }; push @export_all, 'TextureUsage';
  sub TextureViewDimension () { 'WebGPU::Direct::TextureViewDimension' }; push @export_all, 'TextureViewDimension';
  sub VertexFormat () { 'WebGPU::Direct::VertexFormat' }; push @export_all, 'VertexFormat';
  sub VertexStepMode () { 'WebGPU::Direct::VertexStepMode' }; push @export_all, 'VertexStepMode';
  sub AdapterProperties () { Carp::croak if @_>1; 'WebGPU::Direct::AdapterProperties' }
  sub BindGroupDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::BindGroupDescriptor' }
  sub BindGroupEntry () { Carp::croak if @_>1; 'WebGPU::Direct::BindGroupEntry' }
  sub BindGroupLayoutDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::BindGroupLayoutDescriptor' }
  sub BindGroupLayoutEntry () { Carp::croak if @_>1; 'WebGPU::Direct::BindGroupLayoutEntry' }
  sub BlendComponent () { Carp::croak if @_>1; 'WebGPU::Direct::BlendComponent' }
  sub BlendState () { Carp::croak if @_>1; 'WebGPU::Direct::BlendState' }
  sub BufferBindingLayout () { Carp::croak if @_>1; 'WebGPU::Direct::BufferBindingLayout' }
  sub BufferDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::BufferDescriptor' }
  sub ChainedStruct () { Carp::croak if @_>1; 'WebGPU::Direct::ChainedStruct' }
  sub ChainedStructOut () { Carp::croak if @_>1; 'WebGPU::Direct::ChainedStructOut' }
  sub Color () { Carp::croak if @_>1; 'WebGPU::Direct::Color' }
  sub ColorTargetState () { Carp::croak if @_>1; 'WebGPU::Direct::ColorTargetState' }
  sub CommandBufferDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::CommandBufferDescriptor' }
  sub CommandEncoderDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::CommandEncoderDescriptor' }
  sub CompilationInfo () { Carp::croak if @_>1; 'WebGPU::Direct::CompilationInfo' }
  sub CompilationMessage () { Carp::croak if @_>1; 'WebGPU::Direct::CompilationMessage' }
  sub ComputePassDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::ComputePassDescriptor' }
  sub ComputePassTimestampWrites () { Carp::croak if @_>1; 'WebGPU::Direct::ComputePassTimestampWrites' }
  sub ComputePipelineDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::ComputePipelineDescriptor' }
  sub ConstantEntry () { Carp::croak if @_>1; 'WebGPU::Direct::ConstantEntry' }
  sub DepthStencilState () { Carp::croak if @_>1; 'WebGPU::Direct::DepthStencilState' }
  sub DeviceDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::DeviceDescriptor' }
  sub Extent3D () { Carp::croak if @_>1; 'WebGPU::Direct::Extent3D' }
  sub FragmentState () { Carp::croak if @_>1; 'WebGPU::Direct::FragmentState' }
  sub ImageCopyBuffer () { Carp::croak if @_>1; 'WebGPU::Direct::ImageCopyBuffer' }
  sub ImageCopyTexture () { Carp::croak if @_>1; 'WebGPU::Direct::ImageCopyTexture' }
  sub InstanceDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::InstanceDescriptor' }
  sub Limits () { Carp::croak if @_>1; 'WebGPU::Direct::Limits' }
  sub MultisampleState () { Carp::croak if @_>1; 'WebGPU::Direct::MultisampleState' }
  sub Origin3D () { Carp::croak if @_>1; 'WebGPU::Direct::Origin3D' }
  sub PipelineLayoutDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::PipelineLayoutDescriptor' }
  sub PrimitiveDepthClipControl () { Carp::croak if @_>1; 'WebGPU::Direct::PrimitiveDepthClipControl' }
  sub PrimitiveState () { Carp::croak if @_>1; 'WebGPU::Direct::PrimitiveState' }
  sub ProgrammableStageDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::ProgrammableStageDescriptor' }
  sub QuerySetDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::QuerySetDescriptor' }
  sub QueueDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::QueueDescriptor' }
  sub RenderBundleDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::RenderBundleDescriptor' }
  sub RenderBundleEncoderDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::RenderBundleEncoderDescriptor' }
  sub RenderPassColorAttachment () { Carp::croak if @_>1; 'WebGPU::Direct::RenderPassColorAttachment' }
  sub RenderPassDepthStencilAttachment () { Carp::croak if @_>1; 'WebGPU::Direct::RenderPassDepthStencilAttachment' }
  sub RenderPassDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::RenderPassDescriptor' }
  sub RenderPassDescriptorMaxDrawCount () { Carp::croak if @_>1; 'WebGPU::Direct::RenderPassDescriptorMaxDrawCount' }
  sub RenderPassTimestampWrites () { Carp::croak if @_>1; 'WebGPU::Direct::RenderPassTimestampWrites' }
  sub RenderPipelineDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::RenderPipelineDescriptor' }
  sub RequestAdapterOptions () { Carp::croak if @_>1; 'WebGPU::Direct::RequestAdapterOptions' }
  sub RequiredLimits () { Carp::croak if @_>1; 'WebGPU::Direct::RequiredLimits' }
  sub SamplerBindingLayout () { Carp::croak if @_>1; 'WebGPU::Direct::SamplerBindingLayout' }
  sub SamplerDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::SamplerDescriptor' }
  sub ShaderModuleCompilationHint () { Carp::croak if @_>1; 'WebGPU::Direct::ShaderModuleCompilationHint' }
  sub ShaderModuleDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::ShaderModuleDescriptor' }
  sub ShaderModuleSPIRVDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::ShaderModuleSPIRVDescriptor' }
  sub ShaderModuleWGSLDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::ShaderModuleWGSLDescriptor' }
  sub StencilFaceState () { Carp::croak if @_>1; 'WebGPU::Direct::StencilFaceState' }
  sub StorageTextureBindingLayout () { Carp::croak if @_>1; 'WebGPU::Direct::StorageTextureBindingLayout' }
  sub SupportedLimits () { Carp::croak if @_>1; 'WebGPU::Direct::SupportedLimits' }
  sub SurfaceCapabilities () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceCapabilities' }
  sub SurfaceConfiguration () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceConfiguration' }
  sub SurfaceDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceDescriptor' }
  sub SurfaceDescriptorFromAndroidNativeWindow () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceDescriptorFromAndroidNativeWindow' }
  sub SurfaceDescriptorFromCanvasHTMLSelector () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceDescriptorFromCanvasHTMLSelector' }
  sub SurfaceDescriptorFromMetalLayer () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceDescriptorFromMetalLayer' }
  sub SurfaceDescriptorFromWaylandSurface () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceDescriptorFromWaylandSurface' }
  sub SurfaceDescriptorFromWindowsHWND () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceDescriptorFromWindowsHWND' }
  sub SurfaceDescriptorFromXcbWindow () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceDescriptorFromXcbWindow' }
  sub SurfaceDescriptorFromXlibWindow () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceDescriptorFromXlibWindow' }
  sub SurfaceTexture () { Carp::croak if @_>1; 'WebGPU::Direct::SurfaceTexture' }
  sub TextureBindingLayout () { Carp::croak if @_>1; 'WebGPU::Direct::TextureBindingLayout' }
  sub TextureDataLayout () { Carp::croak if @_>1; 'WebGPU::Direct::TextureDataLayout' }
  sub TextureDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::TextureDescriptor' }
  sub TextureViewDescriptor () { Carp::croak if @_>1; 'WebGPU::Direct::TextureViewDescriptor' }
  sub VertexAttribute () { Carp::croak if @_>1; 'WebGPU::Direct::VertexAttribute' }
  sub VertexBufferLayout () { Carp::croak if @_>1; 'WebGPU::Direct::VertexBufferLayout' }
  sub VertexState () { Carp::croak if @_>1; 'WebGPU::Direct::VertexState' }
  sub newAdapterProperties { my $class = shift; return WebGPU::Direct::AdapterProperties->new(@_); }
  sub newBindGroupDescriptor { my $class = shift; return WebGPU::Direct::BindGroupDescriptor->new(@_); }
  sub newBindGroupEntry { my $class = shift; return WebGPU::Direct::BindGroupEntry->new(@_); }
  sub newBindGroupLayoutDescriptor { my $class = shift; return WebGPU::Direct::BindGroupLayoutDescriptor->new(@_); }
  sub newBindGroupLayoutEntry { my $class = shift; return WebGPU::Direct::BindGroupLayoutEntry->new(@_); }
  sub newBlendComponent { my $class = shift; return WebGPU::Direct::BlendComponent->new(@_); }
  sub newBlendState { my $class = shift; return WebGPU::Direct::BlendState->new(@_); }
  sub newBufferBindingLayout { my $class = shift; return WebGPU::Direct::BufferBindingLayout->new(@_); }
  sub newBufferDescriptor { my $class = shift; return WebGPU::Direct::BufferDescriptor->new(@_); }
  sub newChainedStruct { my $class = shift; return WebGPU::Direct::ChainedStruct->new(@_); }
  sub newChainedStructOut { my $class = shift; return WebGPU::Direct::ChainedStructOut->new(@_); }
  sub newColor { my $class = shift; return WebGPU::Direct::Color->new(@_); }
  sub newColorTargetState { my $class = shift; return WebGPU::Direct::ColorTargetState->new(@_); }
  sub newCommandBufferDescriptor { my $class = shift; return WebGPU::Direct::CommandBufferDescriptor->new(@_); }
  sub newCommandEncoderDescriptor { my $class = shift; return WebGPU::Direct::CommandEncoderDescriptor->new(@_); }
  sub newCompilationInfo { my $class = shift; return WebGPU::Direct::CompilationInfo->new(@_); }
  sub newCompilationMessage { my $class = shift; return WebGPU::Direct::CompilationMessage->new(@_); }
  sub newComputePassDescriptor { my $class = shift; return WebGPU::Direct::ComputePassDescriptor->new(@_); }
  sub newComputePassTimestampWrites { my $class = shift; return WebGPU::Direct::ComputePassTimestampWrites->new(@_); }
  sub newComputePipelineDescriptor { my $class = shift; return WebGPU::Direct::ComputePipelineDescriptor->new(@_); }
  sub newConstantEntry { my $class = shift; return WebGPU::Direct::ConstantEntry->new(@_); }
  sub newDepthStencilState { my $class = shift; return WebGPU::Direct::DepthStencilState->new(@_); }
  sub newDeviceDescriptor { my $class = shift; return WebGPU::Direct::DeviceDescriptor->new(@_); }
  sub newExtent3D { my $class = shift; return WebGPU::Direct::Extent3D->new(@_); }
  sub newFragmentState { my $class = shift; return WebGPU::Direct::FragmentState->new(@_); }
  sub newImageCopyBuffer { my $class = shift; return WebGPU::Direct::ImageCopyBuffer->new(@_); }
  sub newImageCopyTexture { my $class = shift; return WebGPU::Direct::ImageCopyTexture->new(@_); }
  sub newInstanceDescriptor { my $class = shift; return WebGPU::Direct::InstanceDescriptor->new(@_); }
  sub newLimits { my $class = shift; return WebGPU::Direct::Limits->new(@_); }
  sub newMultisampleState { my $class = shift; return WebGPU::Direct::MultisampleState->new(@_); }
  sub newOrigin3D { my $class = shift; return WebGPU::Direct::Origin3D->new(@_); }
  sub newPipelineLayoutDescriptor { my $class = shift; return WebGPU::Direct::PipelineLayoutDescriptor->new(@_); }
  sub newPrimitiveDepthClipControl { my $class = shift; return WebGPU::Direct::PrimitiveDepthClipControl->new(@_); }
  sub newPrimitiveState { my $class = shift; return WebGPU::Direct::PrimitiveState->new(@_); }
  sub newProgrammableStageDescriptor { my $class = shift; return WebGPU::Direct::ProgrammableStageDescriptor->new(@_); }
  sub newQuerySetDescriptor { my $class = shift; return WebGPU::Direct::QuerySetDescriptor->new(@_); }
  sub newQueueDescriptor { my $class = shift; return WebGPU::Direct::QueueDescriptor->new(@_); }
  sub newRenderBundleDescriptor { my $class = shift; return WebGPU::Direct::RenderBundleDescriptor->new(@_); }
  sub newRenderBundleEncoderDescriptor { my $class = shift; return WebGPU::Direct::RenderBundleEncoderDescriptor->new(@_); }
  sub newRenderPassColorAttachment { my $class = shift; return WebGPU::Direct::RenderPassColorAttachment->new(@_); }
  sub newRenderPassDepthStencilAttachment { my $class = shift; return WebGPU::Direct::RenderPassDepthStencilAttachment->new(@_); }
  sub newRenderPassDescriptor { my $class = shift; return WebGPU::Direct::RenderPassDescriptor->new(@_); }
  sub newRenderPassDescriptorMaxDrawCount { my $class = shift; return WebGPU::Direct::RenderPassDescriptorMaxDrawCount->new(@_); }
  sub newRenderPassTimestampWrites { my $class = shift; return WebGPU::Direct::RenderPassTimestampWrites->new(@_); }
  sub newRenderPipelineDescriptor { my $class = shift; return WebGPU::Direct::RenderPipelineDescriptor->new(@_); }
  sub newRequestAdapterOptions { my $class = shift; return WebGPU::Direct::RequestAdapterOptions->new(@_); }
  sub newRequiredLimits { my $class = shift; return WebGPU::Direct::RequiredLimits->new(@_); }
  sub newSamplerBindingLayout { my $class = shift; return WebGPU::Direct::SamplerBindingLayout->new(@_); }
  sub newSamplerDescriptor { my $class = shift; return WebGPU::Direct::SamplerDescriptor->new(@_); }
  sub newShaderModuleCompilationHint { my $class = shift; return WebGPU::Direct::ShaderModuleCompilationHint->new(@_); }
  sub newShaderModuleDescriptor { my $class = shift; return WebGPU::Direct::ShaderModuleDescriptor->new(@_); }
  sub newShaderModuleSPIRVDescriptor { my $class = shift; return WebGPU::Direct::ShaderModuleSPIRVDescriptor->new(@_); }
  sub newShaderModuleWGSLDescriptor { my $class = shift; return WebGPU::Direct::ShaderModuleWGSLDescriptor->new(@_); }
  sub newStencilFaceState { my $class = shift; return WebGPU::Direct::StencilFaceState->new(@_); }
  sub newStorageTextureBindingLayout { my $class = shift; return WebGPU::Direct::StorageTextureBindingLayout->new(@_); }
  sub newSupportedLimits { my $class = shift; return WebGPU::Direct::SupportedLimits->new(@_); }
  sub newSurfaceCapabilities { my $class = shift; return WebGPU::Direct::SurfaceCapabilities->new(@_); }
  sub newSurfaceConfiguration { my $class = shift; return WebGPU::Direct::SurfaceConfiguration->new(@_); }
  sub newSurfaceDescriptor { my $class = shift; return WebGPU::Direct::SurfaceDescriptor->new(@_); }
  sub newSurfaceDescriptorFromAndroidNativeWindow { my $class = shift; return WebGPU::Direct::SurfaceDescriptorFromAndroidNativeWindow->new(@_); }
  sub newSurfaceDescriptorFromCanvasHTMLSelector { my $class = shift; return WebGPU::Direct::SurfaceDescriptorFromCanvasHTMLSelector->new(@_); }
  sub newSurfaceDescriptorFromMetalLayer { my $class = shift; return WebGPU::Direct::SurfaceDescriptorFromMetalLayer->new(@_); }
  sub newSurfaceDescriptorFromWaylandSurface { my $class = shift; return WebGPU::Direct::SurfaceDescriptorFromWaylandSurface->new(@_); }
  sub newSurfaceDescriptorFromWindowsHWND { my $class = shift; return WebGPU::Direct::SurfaceDescriptorFromWindowsHWND->new(@_); }
  sub newSurfaceDescriptorFromXcbWindow { my $class = shift; return WebGPU::Direct::SurfaceDescriptorFromXcbWindow->new(@_); }
  sub newSurfaceDescriptorFromXlibWindow { my $class = shift; return WebGPU::Direct::SurfaceDescriptorFromXlibWindow->new(@_); }
  sub newSurfaceTexture { my $class = shift; return WebGPU::Direct::SurfaceTexture->new(@_); }
  sub newTextureBindingLayout { my $class = shift; return WebGPU::Direct::TextureBindingLayout->new(@_); }
  sub newTextureDataLayout { my $class = shift; return WebGPU::Direct::TextureDataLayout->new(@_); }
  sub newTextureDescriptor { my $class = shift; return WebGPU::Direct::TextureDescriptor->new(@_); }
  sub newTextureViewDescriptor { my $class = shift; return WebGPU::Direct::TextureViewDescriptor->new(@_); }
  sub newVertexAttribute { my $class = shift; return WebGPU::Direct::VertexAttribute->new(@_); }
  sub newVertexBufferLayout { my $class = shift; return WebGPU::Direct::VertexBufferLayout->new(@_); }
  sub newVertexState { my $class = shift; return WebGPU::Direct::VertexState->new(@_); }
  sub ALIGN_OF_f16 () { 2 }; push @export_all, 'ALIGN_OF_f16';
  sub ALIGN_OF_f32 () { 4 }; push @export_all, 'ALIGN_OF_f32';
  sub ALIGN_OF_i32 () { 4 }; push @export_all, 'ALIGN_OF_i32';
  sub ALIGN_OF_u32 () { 4 }; push @export_all, 'ALIGN_OF_u32';
  sub BYTES_PER_f16 () { 2 }; push @export_all, 'BYTES_PER_f16';
  sub BYTES_PER_f32 () { 4 }; push @export_all, 'BYTES_PER_f32';
  sub BYTES_PER_i32 () { 4 }; push @export_all, 'BYTES_PER_i32';
  sub BYTES_PER_u32 () { 4 }; push @export_all, 'BYTES_PER_u32';
};

package
	WebGPU::Direct::AdapterType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('discreteGPU' => (0x00000000, 'WGPUAdapterType_DiscreteGPU'));
  __PACKAGE__->_add_enum('integratedGPU' => (0x00000001, 'WGPUAdapterType_IntegratedGPU'));
  __PACKAGE__->_add_enum('CPU' => (0x00000002, 'WGPUAdapterType_CPU'));
  __PACKAGE__->_add_enum('unknown' => (0x00000003, 'WGPUAdapterType_Unknown'));
  WebGPU::Direct::AdapterType->_build_const_lut;
};

package
	WebGPU::Direct::AddressMode {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('repeat' => (0x00000000, 'WGPUAddressMode_Repeat'));
  __PACKAGE__->_add_enum('mirrorRepeat' => (0x00000001, 'WGPUAddressMode_MirrorRepeat'));
  __PACKAGE__->_add_enum('clampToEdge' => (0x00000002, 'WGPUAddressMode_ClampToEdge'));
  WebGPU::Direct::AddressMode->_build_const_lut;
};

package
	WebGPU::Direct::BackendType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUBackendType_Undefined'));
  __PACKAGE__->_add_enum('null' => (0x00000001, 'WGPUBackendType_Null'));
  __PACKAGE__->_add_enum('webGPU' => (0x00000002, 'WGPUBackendType_WebGPU'));
  __PACKAGE__->_add_enum('D3D11' => (0x00000003, 'WGPUBackendType_D3D11'));
  __PACKAGE__->_add_enum('D3D12' => (0x00000004, 'WGPUBackendType_D3D12'));
  __PACKAGE__->_add_enum('metal' => (0x00000005, 'WGPUBackendType_Metal'));
  __PACKAGE__->_add_enum('vulkan' => (0x00000006, 'WGPUBackendType_Vulkan'));
  __PACKAGE__->_add_enum('openGL' => (0x00000007, 'WGPUBackendType_OpenGL'));
  __PACKAGE__->_add_enum('openGLES' => (0x00000008, 'WGPUBackendType_OpenGLES'));
  WebGPU::Direct::BackendType->_build_const_lut;
};

package
	WebGPU::Direct::BlendFactor {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('zero' => (0x00000000, 'WGPUBlendFactor_Zero'));
  __PACKAGE__->_add_enum('one' => (0x00000001, 'WGPUBlendFactor_One'));
  __PACKAGE__->_add_enum('src' => (0x00000002, 'WGPUBlendFactor_Src'));
  __PACKAGE__->_add_enum('oneMinusSrc' => (0x00000003, 'WGPUBlendFactor_OneMinusSrc'));
  __PACKAGE__->_add_enum('srcAlpha' => (0x00000004, 'WGPUBlendFactor_SrcAlpha'));
  __PACKAGE__->_add_enum('oneMinusSrcAlpha' => (0x00000005, 'WGPUBlendFactor_OneMinusSrcAlpha'));
  __PACKAGE__->_add_enum('dst' => (0x00000006, 'WGPUBlendFactor_Dst'));
  __PACKAGE__->_add_enum('oneMinusDst' => (0x00000007, 'WGPUBlendFactor_OneMinusDst'));
  __PACKAGE__->_add_enum('dstAlpha' => (0x00000008, 'WGPUBlendFactor_DstAlpha'));
  __PACKAGE__->_add_enum('oneMinusDstAlpha' => (0x00000009, 'WGPUBlendFactor_OneMinusDstAlpha'));
  __PACKAGE__->_add_enum('srcAlphaSaturated' => (0x0000000A, 'WGPUBlendFactor_SrcAlphaSaturated'));
  __PACKAGE__->_add_enum('constant' => (0x0000000B, 'WGPUBlendFactor_Constant'));
  __PACKAGE__->_add_enum('oneMinusConstant' => (0x0000000C, 'WGPUBlendFactor_OneMinusConstant'));
  WebGPU::Direct::BlendFactor->_build_const_lut;
};

package
	WebGPU::Direct::BlendOperation {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('add' => (0x00000000, 'WGPUBlendOperation_Add'));
  __PACKAGE__->_add_enum('subtract' => (0x00000001, 'WGPUBlendOperation_Subtract'));
  __PACKAGE__->_add_enum('reverseSubtract' => (0x00000002, 'WGPUBlendOperation_ReverseSubtract'));
  __PACKAGE__->_add_enum('min' => (0x00000003, 'WGPUBlendOperation_Min'));
  __PACKAGE__->_add_enum('max' => (0x00000004, 'WGPUBlendOperation_Max'));
  WebGPU::Direct::BlendOperation->_build_const_lut;
};

package
	WebGPU::Direct::BufferBindingType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUBufferBindingType_Undefined'));
  __PACKAGE__->_add_enum('uniform' => (0x00000001, 'WGPUBufferBindingType_Uniform'));
  __PACKAGE__->_add_enum('storage' => (0x00000002, 'WGPUBufferBindingType_Storage'));
  __PACKAGE__->_add_enum('readOnlyStorage' => (0x00000003, 'WGPUBufferBindingType_ReadOnlyStorage'));
  WebGPU::Direct::BufferBindingType->_build_const_lut;
};

package
	WebGPU::Direct::BufferMapAsyncStatus {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('success' => (0x00000000, 'WGPUBufferMapAsyncStatus_Success'));
  __PACKAGE__->_add_enum('validationError' => (0x00000001, 'WGPUBufferMapAsyncStatus_ValidationError'));
  __PACKAGE__->_add_enum('unknown' => (0x00000002, 'WGPUBufferMapAsyncStatus_Unknown'));
  __PACKAGE__->_add_enum('deviceLost' => (0x00000003, 'WGPUBufferMapAsyncStatus_DeviceLost'));
  __PACKAGE__->_add_enum('destroyedBeforeCallback' => (0x00000004, 'WGPUBufferMapAsyncStatus_DestroyedBeforeCallback'));
  __PACKAGE__->_add_enum('unmappedBeforeCallback' => (0x00000005, 'WGPUBufferMapAsyncStatus_UnmappedBeforeCallback'));
  __PACKAGE__->_add_enum('mappingAlreadyPending' => (0x00000006, 'WGPUBufferMapAsyncStatus_MappingAlreadyPending'));
  __PACKAGE__->_add_enum('offsetOutOfRange' => (0x00000007, 'WGPUBufferMapAsyncStatus_OffsetOutOfRange'));
  __PACKAGE__->_add_enum('sizeOutOfRange' => (0x00000008, 'WGPUBufferMapAsyncStatus_SizeOutOfRange'));
  WebGPU::Direct::BufferMapAsyncStatus->_build_const_lut;
};

package
	WebGPU::Direct::BufferMapState {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('unmapped' => (0x00000000, 'WGPUBufferMapState_Unmapped'));
  __PACKAGE__->_add_enum('pending' => (0x00000001, 'WGPUBufferMapState_Pending'));
  __PACKAGE__->_add_enum('mapped' => (0x00000002, 'WGPUBufferMapState_Mapped'));
  WebGPU::Direct::BufferMapState->_build_const_lut;
};

package
	WebGPU::Direct::BufferUsage {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('none' => (0x00000000, 'WGPUBufferUsage_None'));
  __PACKAGE__->_add_enum('mapRead' => (0x00000001, 'WGPUBufferUsage_MapRead'));
  __PACKAGE__->_add_enum('mapWrite' => (0x00000002, 'WGPUBufferUsage_MapWrite'));
  __PACKAGE__->_add_enum('copySrc' => (0x00000004, 'WGPUBufferUsage_CopySrc'));
  __PACKAGE__->_add_enum('copyDst' => (0x00000008, 'WGPUBufferUsage_CopyDst'));
  __PACKAGE__->_add_enum('index' => (0x00000010, 'WGPUBufferUsage_Index'));
  __PACKAGE__->_add_enum('vertex' => (0x00000020, 'WGPUBufferUsage_Vertex'));
  __PACKAGE__->_add_enum('uniform' => (0x00000040, 'WGPUBufferUsage_Uniform'));
  __PACKAGE__->_add_enum('storage' => (0x00000080, 'WGPUBufferUsage_Storage'));
  __PACKAGE__->_add_enum('indirect' => (0x00000100, 'WGPUBufferUsage_Indirect'));
  __PACKAGE__->_add_enum('queryResolve' => (0x00000200, 'WGPUBufferUsage_QueryResolve'));
  WebGPU::Direct::BufferUsage->_build_const_lut;
};

package
	WebGPU::Direct::ColorWriteMask {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('none' => (0x00000000, 'WGPUColorWriteMask_None'));
  __PACKAGE__->_add_enum('red' => (0x00000001, 'WGPUColorWriteMask_Red'));
  __PACKAGE__->_add_enum('green' => (0x00000002, 'WGPUColorWriteMask_Green'));
  __PACKAGE__->_add_enum('blue' => (0x00000004, 'WGPUColorWriteMask_Blue'));
  __PACKAGE__->_add_enum('alpha' => (0x00000008, 'WGPUColorWriteMask_Alpha'));
  __PACKAGE__->_add_enum('all' => (0x0000000F, 'WGPUColorWriteMask_All'));
  WebGPU::Direct::ColorWriteMask->_build_const_lut;
};

package
	WebGPU::Direct::CompareFunction {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUCompareFunction_Undefined'));
  __PACKAGE__->_add_enum('never' => (0x00000001, 'WGPUCompareFunction_Never'));
  __PACKAGE__->_add_enum('less' => (0x00000002, 'WGPUCompareFunction_Less'));
  __PACKAGE__->_add_enum('lessEqual' => (0x00000003, 'WGPUCompareFunction_LessEqual'));
  __PACKAGE__->_add_enum('greater' => (0x00000004, 'WGPUCompareFunction_Greater'));
  __PACKAGE__->_add_enum('greaterEqual' => (0x00000005, 'WGPUCompareFunction_GreaterEqual'));
  __PACKAGE__->_add_enum('equal' => (0x00000006, 'WGPUCompareFunction_Equal'));
  __PACKAGE__->_add_enum('notEqual' => (0x00000007, 'WGPUCompareFunction_NotEqual'));
  __PACKAGE__->_add_enum('always' => (0x00000008, 'WGPUCompareFunction_Always'));
  WebGPU::Direct::CompareFunction->_build_const_lut;
};

package
	WebGPU::Direct::CompilationInfoRequestStatus {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('success' => (0x00000000, 'WGPUCompilationInfoRequestStatus_Success'));
  __PACKAGE__->_add_enum('error' => (0x00000001, 'WGPUCompilationInfoRequestStatus_Error'));
  __PACKAGE__->_add_enum('deviceLost' => (0x00000002, 'WGPUCompilationInfoRequestStatus_DeviceLost'));
  __PACKAGE__->_add_enum('unknown' => (0x00000003, 'WGPUCompilationInfoRequestStatus_Unknown'));
  WebGPU::Direct::CompilationInfoRequestStatus->_build_const_lut;
};

package
	WebGPU::Direct::CompilationMessageType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('error' => (0x00000000, 'WGPUCompilationMessageType_Error'));
  __PACKAGE__->_add_enum('warning' => (0x00000001, 'WGPUCompilationMessageType_Warning'));
  __PACKAGE__->_add_enum('info' => (0x00000002, 'WGPUCompilationMessageType_Info'));
  WebGPU::Direct::CompilationMessageType->_build_const_lut;
};

package
	WebGPU::Direct::CompositeAlphaMode {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('auto' => (0x00000000, 'WGPUCompositeAlphaMode_Auto'));
  __PACKAGE__->_add_enum('opaque' => (0x00000001, 'WGPUCompositeAlphaMode_Opaque'));
  __PACKAGE__->_add_enum('premultiplied' => (0x00000002, 'WGPUCompositeAlphaMode_Premultiplied'));
  __PACKAGE__->_add_enum('unpremultiplied' => (0x00000003, 'WGPUCompositeAlphaMode_Unpremultiplied'));
  __PACKAGE__->_add_enum('inherit' => (0x00000004, 'WGPUCompositeAlphaMode_Inherit'));
  WebGPU::Direct::CompositeAlphaMode->_build_const_lut;
};

package
	WebGPU::Direct::CreatePipelineAsyncStatus {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('success' => (0x00000000, 'WGPUCreatePipelineAsyncStatus_Success'));
  __PACKAGE__->_add_enum('validationError' => (0x00000001, 'WGPUCreatePipelineAsyncStatus_ValidationError'));
  __PACKAGE__->_add_enum('internalError' => (0x00000002, 'WGPUCreatePipelineAsyncStatus_InternalError'));
  __PACKAGE__->_add_enum('deviceLost' => (0x00000003, 'WGPUCreatePipelineAsyncStatus_DeviceLost'));
  __PACKAGE__->_add_enum('deviceDestroyed' => (0x00000004, 'WGPUCreatePipelineAsyncStatus_DeviceDestroyed'));
  __PACKAGE__->_add_enum('unknown' => (0x00000005, 'WGPUCreatePipelineAsyncStatus_Unknown'));
  WebGPU::Direct::CreatePipelineAsyncStatus->_build_const_lut;
};

package
	WebGPU::Direct::CullMode {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('none' => (0x00000000, 'WGPUCullMode_None'));
  __PACKAGE__->_add_enum('front' => (0x00000001, 'WGPUCullMode_Front'));
  __PACKAGE__->_add_enum('back' => (0x00000002, 'WGPUCullMode_Back'));
  WebGPU::Direct::CullMode->_build_const_lut;
};

package
	WebGPU::Direct::DeviceLostReason {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUDeviceLostReason_Undefined'));
  __PACKAGE__->_add_enum('destroyed' => (0x00000001, 'WGPUDeviceLostReason_Destroyed'));
  WebGPU::Direct::DeviceLostReason->_build_const_lut;
};

package
	WebGPU::Direct::ErrorFilter {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('validation' => (0x00000000, 'WGPUErrorFilter_Validation'));
  __PACKAGE__->_add_enum('outOfMemory' => (0x00000001, 'WGPUErrorFilter_OutOfMemory'));
  __PACKAGE__->_add_enum('internal' => (0x00000002, 'WGPUErrorFilter_Internal'));
  WebGPU::Direct::ErrorFilter->_build_const_lut;
};

package
	WebGPU::Direct::ErrorType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('noError' => (0x00000000, 'WGPUErrorType_NoError'));
  __PACKAGE__->_add_enum('validation' => (0x00000001, 'WGPUErrorType_Validation'));
  __PACKAGE__->_add_enum('outOfMemory' => (0x00000002, 'WGPUErrorType_OutOfMemory'));
  __PACKAGE__->_add_enum('internal' => (0x00000003, 'WGPUErrorType_Internal'));
  __PACKAGE__->_add_enum('unknown' => (0x00000004, 'WGPUErrorType_Unknown'));
  __PACKAGE__->_add_enum('deviceLost' => (0x00000005, 'WGPUErrorType_DeviceLost'));
  WebGPU::Direct::ErrorType->_build_const_lut;
};

package
	WebGPU::Direct::FeatureName {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUFeatureName_Undefined'));
  __PACKAGE__->_add_enum('depthClipControl' => (0x00000001, 'WGPUFeatureName_DepthClipControl'));
  __PACKAGE__->_add_enum('depth32FloatStencil8' => (0x00000002, 'WGPUFeatureName_Depth32FloatStencil8'));
  __PACKAGE__->_add_enum('timestampQuery' => (0x00000003, 'WGPUFeatureName_TimestampQuery'));
  __PACKAGE__->_add_enum('textureCompressionBC' => (0x00000004, 'WGPUFeatureName_TextureCompressionBC'));
  __PACKAGE__->_add_enum('textureCompressionETC2' => (0x00000005, 'WGPUFeatureName_TextureCompressionETC2'));
  __PACKAGE__->_add_enum('textureCompressionASTC' => (0x00000006, 'WGPUFeatureName_TextureCompressionASTC'));
  __PACKAGE__->_add_enum('indirectFirstInstance' => (0x00000007, 'WGPUFeatureName_IndirectFirstInstance'));
  __PACKAGE__->_add_enum('shaderF16' => (0x00000008, 'WGPUFeatureName_ShaderF16'));
  __PACKAGE__->_add_enum('RG11B10UfloatRenderable' => (0x00000009, 'WGPUFeatureName_RG11B10UfloatRenderable'));
  __PACKAGE__->_add_enum('BGRA8UnormStorage' => (0x0000000A, 'WGPUFeatureName_BGRA8UnormStorage'));
  __PACKAGE__->_add_enum('float32Filterable' => (0x0000000B, 'WGPUFeatureName_Float32Filterable'));
  WebGPU::Direct::FeatureName->_build_const_lut;
};

package
	WebGPU::Direct::FilterMode {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('nearest' => (0x00000000, 'WGPUFilterMode_Nearest'));
  __PACKAGE__->_add_enum('linear' => (0x00000001, 'WGPUFilterMode_Linear'));
  WebGPU::Direct::FilterMode->_build_const_lut;
};

package
	WebGPU::Direct::FrontFace {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('CCW' => (0x00000000, 'WGPUFrontFace_CCW'));
  __PACKAGE__->_add_enum('CW' => (0x00000001, 'WGPUFrontFace_CW'));
  WebGPU::Direct::FrontFace->_build_const_lut;
};

package
	WebGPU::Direct::IndexFormat {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUIndexFormat_Undefined'));
  __PACKAGE__->_add_enum('uint16' => (0x00000001, 'WGPUIndexFormat_Uint16'));
  __PACKAGE__->_add_enum('uint32' => (0x00000002, 'WGPUIndexFormat_Uint32'));
  WebGPU::Direct::IndexFormat->_build_const_lut;
};

package
	WebGPU::Direct::LoadOp {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPULoadOp_Undefined'));
  __PACKAGE__->_add_enum('clear' => (0x00000001, 'WGPULoadOp_Clear'));
  __PACKAGE__->_add_enum('load' => (0x00000002, 'WGPULoadOp_Load'));
  WebGPU::Direct::LoadOp->_build_const_lut;
};

package
	WebGPU::Direct::MapMode {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('none' => (0x00000000, 'WGPUMapMode_None'));
  __PACKAGE__->_add_enum('read' => (0x00000001, 'WGPUMapMode_Read'));
  __PACKAGE__->_add_enum('write' => (0x00000002, 'WGPUMapMode_Write'));
  WebGPU::Direct::MapMode->_build_const_lut;
};

package
	WebGPU::Direct::MipmapFilterMode {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('nearest' => (0x00000000, 'WGPUMipmapFilterMode_Nearest'));
  __PACKAGE__->_add_enum('linear' => (0x00000001, 'WGPUMipmapFilterMode_Linear'));
  WebGPU::Direct::MipmapFilterMode->_build_const_lut;
};

package
	WebGPU::Direct::PowerPreference {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUPowerPreference_Undefined'));
  __PACKAGE__->_add_enum('lowPower' => (0x00000001, 'WGPUPowerPreference_LowPower'));
  __PACKAGE__->_add_enum('highPerformance' => (0x00000002, 'WGPUPowerPreference_HighPerformance'));
  WebGPU::Direct::PowerPreference->_build_const_lut;
};

package
	WebGPU::Direct::PresentMode {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('fifo' => (0x00000000, 'WGPUPresentMode_Fifo'));
  __PACKAGE__->_add_enum('fifoRelaxed' => (0x00000001, 'WGPUPresentMode_FifoRelaxed'));
  __PACKAGE__->_add_enum('immediate' => (0x00000002, 'WGPUPresentMode_Immediate'));
  __PACKAGE__->_add_enum('mailbox' => (0x00000003, 'WGPUPresentMode_Mailbox'));
  WebGPU::Direct::PresentMode->_build_const_lut;
};

package
	WebGPU::Direct::PrimitiveTopology {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('pointList' => (0x00000000, 'WGPUPrimitiveTopology_PointList'));
  __PACKAGE__->_add_enum('lineList' => (0x00000001, 'WGPUPrimitiveTopology_LineList'));
  __PACKAGE__->_add_enum('lineStrip' => (0x00000002, 'WGPUPrimitiveTopology_LineStrip'));
  __PACKAGE__->_add_enum('triangleList' => (0x00000003, 'WGPUPrimitiveTopology_TriangleList'));
  __PACKAGE__->_add_enum('triangleStrip' => (0x00000004, 'WGPUPrimitiveTopology_TriangleStrip'));
  WebGPU::Direct::PrimitiveTopology->_build_const_lut;
};

package
	WebGPU::Direct::QueryType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('occlusion' => (0x00000000, 'WGPUQueryType_Occlusion'));
  __PACKAGE__->_add_enum('timestamp' => (0x00000001, 'WGPUQueryType_Timestamp'));
  WebGPU::Direct::QueryType->_build_const_lut;
};

package
	WebGPU::Direct::QueueWorkDoneStatus {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('success' => (0x00000000, 'WGPUQueueWorkDoneStatus_Success'));
  __PACKAGE__->_add_enum('error' => (0x00000001, 'WGPUQueueWorkDoneStatus_Error'));
  __PACKAGE__->_add_enum('unknown' => (0x00000002, 'WGPUQueueWorkDoneStatus_Unknown'));
  __PACKAGE__->_add_enum('deviceLost' => (0x00000003, 'WGPUQueueWorkDoneStatus_DeviceLost'));
  WebGPU::Direct::QueueWorkDoneStatus->_build_const_lut;
};

package
	WebGPU::Direct::RequestAdapterStatus {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('success' => (0x00000000, 'WGPURequestAdapterStatus_Success'));
  __PACKAGE__->_add_enum('unavailable' => (0x00000001, 'WGPURequestAdapterStatus_Unavailable'));
  __PACKAGE__->_add_enum('error' => (0x00000002, 'WGPURequestAdapterStatus_Error'));
  __PACKAGE__->_add_enum('unknown' => (0x00000003, 'WGPURequestAdapterStatus_Unknown'));
  WebGPU::Direct::RequestAdapterStatus->_build_const_lut;
};

package
	WebGPU::Direct::RequestDeviceStatus {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('success' => (0x00000000, 'WGPURequestDeviceStatus_Success'));
  __PACKAGE__->_add_enum('error' => (0x00000001, 'WGPURequestDeviceStatus_Error'));
  __PACKAGE__->_add_enum('unknown' => (0x00000002, 'WGPURequestDeviceStatus_Unknown'));
  WebGPU::Direct::RequestDeviceStatus->_build_const_lut;
};

package
	WebGPU::Direct::SType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('invalid' => (0x00000000, 'WGPUSType_Invalid'));
  __PACKAGE__->_add_enum('surfaceDescriptorFromMetalLayer' => (0x00000001, 'WGPUSType_SurfaceDescriptorFromMetalLayer'));
  __PACKAGE__->_add_enum('surfaceDescriptorFromWindowsHWND' => (0x00000002, 'WGPUSType_SurfaceDescriptorFromWindowsHWND'));
  __PACKAGE__->_add_enum('surfaceDescriptorFromXlibWindow' => (0x00000003, 'WGPUSType_SurfaceDescriptorFromXlibWindow'));
  __PACKAGE__->_add_enum('surfaceDescriptorFromCanvasHTMLSelector' => (0x00000004, 'WGPUSType_SurfaceDescriptorFromCanvasHTMLSelector'));
  __PACKAGE__->_add_enum('shaderModuleSPIRVDescriptor' => (0x00000005, 'WGPUSType_ShaderModuleSPIRVDescriptor'));
  __PACKAGE__->_add_enum('shaderModuleWGSLDescriptor' => (0x00000006, 'WGPUSType_ShaderModuleWGSLDescriptor'));
  __PACKAGE__->_add_enum('primitiveDepthClipControl' => (0x00000007, 'WGPUSType_PrimitiveDepthClipControl'));
  __PACKAGE__->_add_enum('surfaceDescriptorFromWaylandSurface' => (0x00000008, 'WGPUSType_SurfaceDescriptorFromWaylandSurface'));
  __PACKAGE__->_add_enum('surfaceDescriptorFromAndroidNativeWindow' => (0x00000009, 'WGPUSType_SurfaceDescriptorFromAndroidNativeWindow'));
  __PACKAGE__->_add_enum('surfaceDescriptorFromXcbWindow' => (0x0000000A, 'WGPUSType_SurfaceDescriptorFromXcbWindow'));
  __PACKAGE__->_add_enum('renderPassDescriptorMaxDrawCount' => (0x0000000F, 'WGPUSType_RenderPassDescriptorMaxDrawCount'));
  WebGPU::Direct::SType->_build_const_lut;
};

package
	WebGPU::Direct::SamplerBindingType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUSamplerBindingType_Undefined'));
  __PACKAGE__->_add_enum('filtering' => (0x00000001, 'WGPUSamplerBindingType_Filtering'));
  __PACKAGE__->_add_enum('nonFiltering' => (0x00000002, 'WGPUSamplerBindingType_NonFiltering'));
  __PACKAGE__->_add_enum('comparison' => (0x00000003, 'WGPUSamplerBindingType_Comparison'));
  WebGPU::Direct::SamplerBindingType->_build_const_lut;
};

package
	WebGPU::Direct::ShaderStage {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('none' => (0x00000000, 'WGPUShaderStage_None'));
  __PACKAGE__->_add_enum('vertex' => (0x00000001, 'WGPUShaderStage_Vertex'));
  __PACKAGE__->_add_enum('fragment' => (0x00000002, 'WGPUShaderStage_Fragment'));
  __PACKAGE__->_add_enum('compute' => (0x00000004, 'WGPUShaderStage_Compute'));
  WebGPU::Direct::ShaderStage->_build_const_lut;
};

package
	WebGPU::Direct::StencilOperation {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('keep' => (0x00000000, 'WGPUStencilOperation_Keep'));
  __PACKAGE__->_add_enum('zero' => (0x00000001, 'WGPUStencilOperation_Zero'));
  __PACKAGE__->_add_enum('replace' => (0x00000002, 'WGPUStencilOperation_Replace'));
  __PACKAGE__->_add_enum('invert' => (0x00000003, 'WGPUStencilOperation_Invert'));
  __PACKAGE__->_add_enum('incrementClamp' => (0x00000004, 'WGPUStencilOperation_IncrementClamp'));
  __PACKAGE__->_add_enum('decrementClamp' => (0x00000005, 'WGPUStencilOperation_DecrementClamp'));
  __PACKAGE__->_add_enum('incrementWrap' => (0x00000006, 'WGPUStencilOperation_IncrementWrap'));
  __PACKAGE__->_add_enum('decrementWrap' => (0x00000007, 'WGPUStencilOperation_DecrementWrap'));
  WebGPU::Direct::StencilOperation->_build_const_lut;
};

package
	WebGPU::Direct::StorageTextureAccess {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUStorageTextureAccess_Undefined'));
  __PACKAGE__->_add_enum('writeOnly' => (0x00000001, 'WGPUStorageTextureAccess_WriteOnly'));
  __PACKAGE__->_add_enum('readOnly' => (0x00000002, 'WGPUStorageTextureAccess_ReadOnly'));
  __PACKAGE__->_add_enum('readWrite' => (0x00000003, 'WGPUStorageTextureAccess_ReadWrite'));
  WebGPU::Direct::StorageTextureAccess->_build_const_lut;
};

package
	WebGPU::Direct::StoreOp {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUStoreOp_Undefined'));
  __PACKAGE__->_add_enum('store' => (0x00000001, 'WGPUStoreOp_Store'));
  __PACKAGE__->_add_enum('discard' => (0x00000002, 'WGPUStoreOp_Discard'));
  WebGPU::Direct::StoreOp->_build_const_lut;
};

package
	WebGPU::Direct::SurfaceGetCurrentTextureStatus {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('success' => (0x00000000, 'WGPUSurfaceGetCurrentTextureStatus_Success'));
  __PACKAGE__->_add_enum('timeout' => (0x00000001, 'WGPUSurfaceGetCurrentTextureStatus_Timeout'));
  __PACKAGE__->_add_enum('outdated' => (0x00000002, 'WGPUSurfaceGetCurrentTextureStatus_Outdated'));
  __PACKAGE__->_add_enum('lost' => (0x00000003, 'WGPUSurfaceGetCurrentTextureStatus_Lost'));
  __PACKAGE__->_add_enum('outOfMemory' => (0x00000004, 'WGPUSurfaceGetCurrentTextureStatus_OutOfMemory'));
  __PACKAGE__->_add_enum('deviceLost' => (0x00000005, 'WGPUSurfaceGetCurrentTextureStatus_DeviceLost'));
  WebGPU::Direct::SurfaceGetCurrentTextureStatus->_build_const_lut;
};

package
	WebGPU::Direct::TextureAspect {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('all' => (0x00000000, 'WGPUTextureAspect_All'));
  __PACKAGE__->_add_enum('stencilOnly' => (0x00000001, 'WGPUTextureAspect_StencilOnly'));
  __PACKAGE__->_add_enum('depthOnly' => (0x00000002, 'WGPUTextureAspect_DepthOnly'));
  WebGPU::Direct::TextureAspect->_build_const_lut;
};

package
	WebGPU::Direct::TextureDimension {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('_1D' => (0x00000000, 'WGPUTextureDimension_1D'));
  __PACKAGE__->_add_enum('_2D' => (0x00000001, 'WGPUTextureDimension_2D'));
  __PACKAGE__->_add_enum('_3D' => (0x00000002, 'WGPUTextureDimension_3D'));
  WebGPU::Direct::TextureDimension->_build_const_lut;
};

package
	WebGPU::Direct::TextureFormat {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUTextureFormat_Undefined'));
  __PACKAGE__->_add_enum('R8Unorm' => (0x00000001, 'WGPUTextureFormat_R8Unorm'));
  __PACKAGE__->_add_enum('R8Snorm' => (0x00000002, 'WGPUTextureFormat_R8Snorm'));
  __PACKAGE__->_add_enum('R8Uint' => (0x00000003, 'WGPUTextureFormat_R8Uint'));
  __PACKAGE__->_add_enum('R8Sint' => (0x00000004, 'WGPUTextureFormat_R8Sint'));
  __PACKAGE__->_add_enum('R16Uint' => (0x00000005, 'WGPUTextureFormat_R16Uint'));
  __PACKAGE__->_add_enum('R16Sint' => (0x00000006, 'WGPUTextureFormat_R16Sint'));
  __PACKAGE__->_add_enum('R16Float' => (0x00000007, 'WGPUTextureFormat_R16Float'));
  __PACKAGE__->_add_enum('RG8Unorm' => (0x00000008, 'WGPUTextureFormat_RG8Unorm'));
  __PACKAGE__->_add_enum('RG8Snorm' => (0x00000009, 'WGPUTextureFormat_RG8Snorm'));
  __PACKAGE__->_add_enum('RG8Uint' => (0x0000000A, 'WGPUTextureFormat_RG8Uint'));
  __PACKAGE__->_add_enum('RG8Sint' => (0x0000000B, 'WGPUTextureFormat_RG8Sint'));
  __PACKAGE__->_add_enum('R32Float' => (0x0000000C, 'WGPUTextureFormat_R32Float'));
  __PACKAGE__->_add_enum('R32Uint' => (0x0000000D, 'WGPUTextureFormat_R32Uint'));
  __PACKAGE__->_add_enum('R32Sint' => (0x0000000E, 'WGPUTextureFormat_R32Sint'));
  __PACKAGE__->_add_enum('RG16Uint' => (0x0000000F, 'WGPUTextureFormat_RG16Uint'));
  __PACKAGE__->_add_enum('RG16Sint' => (0x00000010, 'WGPUTextureFormat_RG16Sint'));
  __PACKAGE__->_add_enum('RG16Float' => (0x00000011, 'WGPUTextureFormat_RG16Float'));
  __PACKAGE__->_add_enum('RGBA8Unorm' => (0x00000012, 'WGPUTextureFormat_RGBA8Unorm'));
  __PACKAGE__->_add_enum('RGBA8UnormSrgb' => (0x00000013, 'WGPUTextureFormat_RGBA8UnormSrgb'));
  __PACKAGE__->_add_enum('RGBA8Snorm' => (0x00000014, 'WGPUTextureFormat_RGBA8Snorm'));
  __PACKAGE__->_add_enum('RGBA8Uint' => (0x00000015, 'WGPUTextureFormat_RGBA8Uint'));
  __PACKAGE__->_add_enum('RGBA8Sint' => (0x00000016, 'WGPUTextureFormat_RGBA8Sint'));
  __PACKAGE__->_add_enum('BGRA8Unorm' => (0x00000017, 'WGPUTextureFormat_BGRA8Unorm'));
  __PACKAGE__->_add_enum('BGRA8UnormSrgb' => (0x00000018, 'WGPUTextureFormat_BGRA8UnormSrgb'));
  __PACKAGE__->_add_enum('RGB10A2Uint' => (0x00000019, 'WGPUTextureFormat_RGB10A2Uint'));
  __PACKAGE__->_add_enum('RGB10A2Unorm' => (0x0000001A, 'WGPUTextureFormat_RGB10A2Unorm'));
  __PACKAGE__->_add_enum('RG11B10Ufloat' => (0x0000001B, 'WGPUTextureFormat_RG11B10Ufloat'));
  __PACKAGE__->_add_enum('RGB9E5Ufloat' => (0x0000001C, 'WGPUTextureFormat_RGB9E5Ufloat'));
  __PACKAGE__->_add_enum('RG32Float' => (0x0000001D, 'WGPUTextureFormat_RG32Float'));
  __PACKAGE__->_add_enum('RG32Uint' => (0x0000001E, 'WGPUTextureFormat_RG32Uint'));
  __PACKAGE__->_add_enum('RG32Sint' => (0x0000001F, 'WGPUTextureFormat_RG32Sint'));
  __PACKAGE__->_add_enum('RGBA16Uint' => (0x00000020, 'WGPUTextureFormat_RGBA16Uint'));
  __PACKAGE__->_add_enum('RGBA16Sint' => (0x00000021, 'WGPUTextureFormat_RGBA16Sint'));
  __PACKAGE__->_add_enum('RGBA16Float' => (0x00000022, 'WGPUTextureFormat_RGBA16Float'));
  __PACKAGE__->_add_enum('RGBA32Float' => (0x00000023, 'WGPUTextureFormat_RGBA32Float'));
  __PACKAGE__->_add_enum('RGBA32Uint' => (0x00000024, 'WGPUTextureFormat_RGBA32Uint'));
  __PACKAGE__->_add_enum('RGBA32Sint' => (0x00000025, 'WGPUTextureFormat_RGBA32Sint'));
  __PACKAGE__->_add_enum('stencil8' => (0x00000026, 'WGPUTextureFormat_Stencil8'));
  __PACKAGE__->_add_enum('depth16Unorm' => (0x00000027, 'WGPUTextureFormat_Depth16Unorm'));
  __PACKAGE__->_add_enum('depth24Plus' => (0x00000028, 'WGPUTextureFormat_Depth24Plus'));
  __PACKAGE__->_add_enum('depth24PlusStencil8' => (0x00000029, 'WGPUTextureFormat_Depth24PlusStencil8'));
  __PACKAGE__->_add_enum('depth32Float' => (0x0000002A, 'WGPUTextureFormat_Depth32Float'));
  __PACKAGE__->_add_enum('depth32FloatStencil8' => (0x0000002B, 'WGPUTextureFormat_Depth32FloatStencil8'));
  __PACKAGE__->_add_enum('BC1RGBAUnorm' => (0x0000002C, 'WGPUTextureFormat_BC1RGBAUnorm'));
  __PACKAGE__->_add_enum('BC1RGBAUnormSrgb' => (0x0000002D, 'WGPUTextureFormat_BC1RGBAUnormSrgb'));
  __PACKAGE__->_add_enum('BC2RGBAUnorm' => (0x0000002E, 'WGPUTextureFormat_BC2RGBAUnorm'));
  __PACKAGE__->_add_enum('BC2RGBAUnormSrgb' => (0x0000002F, 'WGPUTextureFormat_BC2RGBAUnormSrgb'));
  __PACKAGE__->_add_enum('BC3RGBAUnorm' => (0x00000030, 'WGPUTextureFormat_BC3RGBAUnorm'));
  __PACKAGE__->_add_enum('BC3RGBAUnormSrgb' => (0x00000031, 'WGPUTextureFormat_BC3RGBAUnormSrgb'));
  __PACKAGE__->_add_enum('BC4RUnorm' => (0x00000032, 'WGPUTextureFormat_BC4RUnorm'));
  __PACKAGE__->_add_enum('BC4RSnorm' => (0x00000033, 'WGPUTextureFormat_BC4RSnorm'));
  __PACKAGE__->_add_enum('BC5RGUnorm' => (0x00000034, 'WGPUTextureFormat_BC5RGUnorm'));
  __PACKAGE__->_add_enum('BC5RGSnorm' => (0x00000035, 'WGPUTextureFormat_BC5RGSnorm'));
  __PACKAGE__->_add_enum('BC6HRGBUfloat' => (0x00000036, 'WGPUTextureFormat_BC6HRGBUfloat'));
  __PACKAGE__->_add_enum('BC6HRGBFloat' => (0x00000037, 'WGPUTextureFormat_BC6HRGBFloat'));
  __PACKAGE__->_add_enum('BC7RGBAUnorm' => (0x00000038, 'WGPUTextureFormat_BC7RGBAUnorm'));
  __PACKAGE__->_add_enum('BC7RGBAUnormSrgb' => (0x00000039, 'WGPUTextureFormat_BC7RGBAUnormSrgb'));
  __PACKAGE__->_add_enum('ETC2RGB8Unorm' => (0x0000003A, 'WGPUTextureFormat_ETC2RGB8Unorm'));
  __PACKAGE__->_add_enum('ETC2RGB8UnormSrgb' => (0x0000003B, 'WGPUTextureFormat_ETC2RGB8UnormSrgb'));
  __PACKAGE__->_add_enum('ETC2RGB8A1Unorm' => (0x0000003C, 'WGPUTextureFormat_ETC2RGB8A1Unorm'));
  __PACKAGE__->_add_enum('ETC2RGB8A1UnormSrgb' => (0x0000003D, 'WGPUTextureFormat_ETC2RGB8A1UnormSrgb'));
  __PACKAGE__->_add_enum('ETC2RGBA8Unorm' => (0x0000003E, 'WGPUTextureFormat_ETC2RGBA8Unorm'));
  __PACKAGE__->_add_enum('ETC2RGBA8UnormSrgb' => (0x0000003F, 'WGPUTextureFormat_ETC2RGBA8UnormSrgb'));
  __PACKAGE__->_add_enum('EACR11Unorm' => (0x00000040, 'WGPUTextureFormat_EACR11Unorm'));
  __PACKAGE__->_add_enum('EACR11Snorm' => (0x00000041, 'WGPUTextureFormat_EACR11Snorm'));
  __PACKAGE__->_add_enum('EACRG11Unorm' => (0x00000042, 'WGPUTextureFormat_EACRG11Unorm'));
  __PACKAGE__->_add_enum('EACRG11Snorm' => (0x00000043, 'WGPUTextureFormat_EACRG11Snorm'));
  __PACKAGE__->_add_enum('ASTC4x4Unorm' => (0x00000044, 'WGPUTextureFormat_ASTC4x4Unorm'));
  __PACKAGE__->_add_enum('ASTC4x4UnormSrgb' => (0x00000045, 'WGPUTextureFormat_ASTC4x4UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC5x4Unorm' => (0x00000046, 'WGPUTextureFormat_ASTC5x4Unorm'));
  __PACKAGE__->_add_enum('ASTC5x4UnormSrgb' => (0x00000047, 'WGPUTextureFormat_ASTC5x4UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC5x5Unorm' => (0x00000048, 'WGPUTextureFormat_ASTC5x5Unorm'));
  __PACKAGE__->_add_enum('ASTC5x5UnormSrgb' => (0x00000049, 'WGPUTextureFormat_ASTC5x5UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC6x5Unorm' => (0x0000004A, 'WGPUTextureFormat_ASTC6x5Unorm'));
  __PACKAGE__->_add_enum('ASTC6x5UnormSrgb' => (0x0000004B, 'WGPUTextureFormat_ASTC6x5UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC6x6Unorm' => (0x0000004C, 'WGPUTextureFormat_ASTC6x6Unorm'));
  __PACKAGE__->_add_enum('ASTC6x6UnormSrgb' => (0x0000004D, 'WGPUTextureFormat_ASTC6x6UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC8x5Unorm' => (0x0000004E, 'WGPUTextureFormat_ASTC8x5Unorm'));
  __PACKAGE__->_add_enum('ASTC8x5UnormSrgb' => (0x0000004F, 'WGPUTextureFormat_ASTC8x5UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC8x6Unorm' => (0x00000050, 'WGPUTextureFormat_ASTC8x6Unorm'));
  __PACKAGE__->_add_enum('ASTC8x6UnormSrgb' => (0x00000051, 'WGPUTextureFormat_ASTC8x6UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC8x8Unorm' => (0x00000052, 'WGPUTextureFormat_ASTC8x8Unorm'));
  __PACKAGE__->_add_enum('ASTC8x8UnormSrgb' => (0x00000053, 'WGPUTextureFormat_ASTC8x8UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC10x5Unorm' => (0x00000054, 'WGPUTextureFormat_ASTC10x5Unorm'));
  __PACKAGE__->_add_enum('ASTC10x5UnormSrgb' => (0x00000055, 'WGPUTextureFormat_ASTC10x5UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC10x6Unorm' => (0x00000056, 'WGPUTextureFormat_ASTC10x6Unorm'));
  __PACKAGE__->_add_enum('ASTC10x6UnormSrgb' => (0x00000057, 'WGPUTextureFormat_ASTC10x6UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC10x8Unorm' => (0x00000058, 'WGPUTextureFormat_ASTC10x8Unorm'));
  __PACKAGE__->_add_enum('ASTC10x8UnormSrgb' => (0x00000059, 'WGPUTextureFormat_ASTC10x8UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC10x10Unorm' => (0x0000005A, 'WGPUTextureFormat_ASTC10x10Unorm'));
  __PACKAGE__->_add_enum('ASTC10x10UnormSrgb' => (0x0000005B, 'WGPUTextureFormat_ASTC10x10UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC12x10Unorm' => (0x0000005C, 'WGPUTextureFormat_ASTC12x10Unorm'));
  __PACKAGE__->_add_enum('ASTC12x10UnormSrgb' => (0x0000005D, 'WGPUTextureFormat_ASTC12x10UnormSrgb'));
  __PACKAGE__->_add_enum('ASTC12x12Unorm' => (0x0000005E, 'WGPUTextureFormat_ASTC12x12Unorm'));
  __PACKAGE__->_add_enum('ASTC12x12UnormSrgb' => (0x0000005F, 'WGPUTextureFormat_ASTC12x12UnormSrgb'));
  WebGPU::Direct::TextureFormat->_build_const_lut;
};

package
	WebGPU::Direct::TextureSampleType {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUTextureSampleType_Undefined'));
  __PACKAGE__->_add_enum('float' => (0x00000001, 'WGPUTextureSampleType_Float'));
  __PACKAGE__->_add_enum('unfilterableFloat' => (0x00000002, 'WGPUTextureSampleType_UnfilterableFloat'));
  __PACKAGE__->_add_enum('depth' => (0x00000003, 'WGPUTextureSampleType_Depth'));
  __PACKAGE__->_add_enum('sint' => (0x00000004, 'WGPUTextureSampleType_Sint'));
  __PACKAGE__->_add_enum('uint' => (0x00000005, 'WGPUTextureSampleType_Uint'));
  WebGPU::Direct::TextureSampleType->_build_const_lut;
};

package
	WebGPU::Direct::TextureUsage {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('none' => (0x00000000, 'WGPUTextureUsage_None'));
  __PACKAGE__->_add_enum('copySrc' => (0x00000001, 'WGPUTextureUsage_CopySrc'));
  __PACKAGE__->_add_enum('copyDst' => (0x00000002, 'WGPUTextureUsage_CopyDst'));
  __PACKAGE__->_add_enum('textureBinding' => (0x00000004, 'WGPUTextureUsage_TextureBinding'));
  __PACKAGE__->_add_enum('storageBinding' => (0x00000008, 'WGPUTextureUsage_StorageBinding'));
  __PACKAGE__->_add_enum('renderAttachment' => (0x00000010, 'WGPUTextureUsage_RenderAttachment'));
  WebGPU::Direct::TextureUsage->_build_const_lut;
};

package
	WebGPU::Direct::TextureViewDimension {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUTextureViewDimension_Undefined'));
  __PACKAGE__->_add_enum('_1D' => (0x00000001, 'WGPUTextureViewDimension_1D'));
  __PACKAGE__->_add_enum('_2D' => (0x00000002, 'WGPUTextureViewDimension_2D'));
  __PACKAGE__->_add_enum('_2DArray' => (0x00000003, 'WGPUTextureViewDimension_2DArray'));
  __PACKAGE__->_add_enum('cube' => (0x00000004, 'WGPUTextureViewDimension_Cube'));
  __PACKAGE__->_add_enum('cubeArray' => (0x00000005, 'WGPUTextureViewDimension_CubeArray'));
  __PACKAGE__->_add_enum('_3D' => (0x00000006, 'WGPUTextureViewDimension_3D'));
  WebGPU::Direct::TextureViewDimension->_build_const_lut;
};

package
	WebGPU::Direct::VertexFormat {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('undefined' => (0x00000000, 'WGPUVertexFormat_Undefined'));
  __PACKAGE__->_add_enum('uint8x2' => (0x00000001, 'WGPUVertexFormat_Uint8x2'));
  __PACKAGE__->_add_enum('uint8x4' => (0x00000002, 'WGPUVertexFormat_Uint8x4'));
  __PACKAGE__->_add_enum('sint8x2' => (0x00000003, 'WGPUVertexFormat_Sint8x2'));
  __PACKAGE__->_add_enum('sint8x4' => (0x00000004, 'WGPUVertexFormat_Sint8x4'));
  __PACKAGE__->_add_enum('unorm8x2' => (0x00000005, 'WGPUVertexFormat_Unorm8x2'));
  __PACKAGE__->_add_enum('unorm8x4' => (0x00000006, 'WGPUVertexFormat_Unorm8x4'));
  __PACKAGE__->_add_enum('snorm8x2' => (0x00000007, 'WGPUVertexFormat_Snorm8x2'));
  __PACKAGE__->_add_enum('snorm8x4' => (0x00000008, 'WGPUVertexFormat_Snorm8x4'));
  __PACKAGE__->_add_enum('uint16x2' => (0x00000009, 'WGPUVertexFormat_Uint16x2'));
  __PACKAGE__->_add_enum('uint16x4' => (0x0000000A, 'WGPUVertexFormat_Uint16x4'));
  __PACKAGE__->_add_enum('sint16x2' => (0x0000000B, 'WGPUVertexFormat_Sint16x2'));
  __PACKAGE__->_add_enum('sint16x4' => (0x0000000C, 'WGPUVertexFormat_Sint16x4'));
  __PACKAGE__->_add_enum('unorm16x2' => (0x0000000D, 'WGPUVertexFormat_Unorm16x2'));
  __PACKAGE__->_add_enum('unorm16x4' => (0x0000000E, 'WGPUVertexFormat_Unorm16x4'));
  __PACKAGE__->_add_enum('snorm16x2' => (0x0000000F, 'WGPUVertexFormat_Snorm16x2'));
  __PACKAGE__->_add_enum('snorm16x4' => (0x00000010, 'WGPUVertexFormat_Snorm16x4'));
  __PACKAGE__->_add_enum('float16x2' => (0x00000011, 'WGPUVertexFormat_Float16x2'));
  __PACKAGE__->_add_enum('float16x4' => (0x00000012, 'WGPUVertexFormat_Float16x4'));
  __PACKAGE__->_add_enum('float32' => (0x00000013, 'WGPUVertexFormat_Float32'));
  __PACKAGE__->_add_enum('float32x2' => (0x00000014, 'WGPUVertexFormat_Float32x2'));
  __PACKAGE__->_add_enum('float32x3' => (0x00000015, 'WGPUVertexFormat_Float32x3'));
  __PACKAGE__->_add_enum('float32x4' => (0x00000016, 'WGPUVertexFormat_Float32x4'));
  __PACKAGE__->_add_enum('uint32' => (0x00000017, 'WGPUVertexFormat_Uint32'));
  __PACKAGE__->_add_enum('uint32x2' => (0x00000018, 'WGPUVertexFormat_Uint32x2'));
  __PACKAGE__->_add_enum('uint32x3' => (0x00000019, 'WGPUVertexFormat_Uint32x3'));
  __PACKAGE__->_add_enum('uint32x4' => (0x0000001A, 'WGPUVertexFormat_Uint32x4'));
  __PACKAGE__->_add_enum('sint32' => (0x0000001B, 'WGPUVertexFormat_Sint32'));
  __PACKAGE__->_add_enum('sint32x2' => (0x0000001C, 'WGPUVertexFormat_Sint32x2'));
  __PACKAGE__->_add_enum('sint32x3' => (0x0000001D, 'WGPUVertexFormat_Sint32x3'));
  __PACKAGE__->_add_enum('sint32x4' => (0x0000001E, 'WGPUVertexFormat_Sint32x4'));
  WebGPU::Direct::VertexFormat->_build_const_lut;
};

package
	WebGPU::Direct::VertexStepMode {
  use base "WebGPU::Direct::Enum";
  __PACKAGE__->_add_enum('vertex' => (0x00000000, 'WGPUVertexStepMode_Vertex'));
  __PACKAGE__->_add_enum('instance' => (0x00000001, 'WGPUVertexStepMode_Instance'));
  __PACKAGE__->_add_enum('vertexBufferNotUsed' => (0x00000002, 'WGPUVertexStepMode_VertexBufferNotUsed'));
  WebGPU::Direct::VertexStepMode->_build_const_lut;
};

package
	WebGPU::Direct::Adapter {
    push @WebGPU::Direct::Adapter::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::Adapter;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::BindGroup {
    push @WebGPU::Direct::BindGroup::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::BindGroup;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::BindGroupLayout {
    push @WebGPU::Direct::BindGroupLayout::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::BindGroupLayout;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::Buffer {
    push @WebGPU::Direct::Buffer::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::Buffer;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::CommandBuffer {
    push @WebGPU::Direct::CommandBuffer::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::CommandBuffer;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::CommandEncoder {
    push @WebGPU::Direct::CommandEncoder::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::CommandEncoder;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::ComputePassEncoder {
    push @WebGPU::Direct::ComputePassEncoder::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::ComputePassEncoder;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::ComputePipeline {
    push @WebGPU::Direct::ComputePipeline::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::ComputePipeline;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::Device {
    push @WebGPU::Direct::Device::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::Device;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::Instance {
    push @WebGPU::Direct::Instance::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::Instance;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::PipelineLayout {
    push @WebGPU::Direct::PipelineLayout::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::PipelineLayout;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::QuerySet {
    push @WebGPU::Direct::QuerySet::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::QuerySet;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::Queue {
    push @WebGPU::Direct::Queue::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::Queue;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::RenderBundle {
    push @WebGPU::Direct::RenderBundle::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::RenderBundle;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::RenderBundleEncoder {
    push @WebGPU::Direct::RenderBundleEncoder::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::RenderBundleEncoder;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::RenderPassEncoder {
    push @WebGPU::Direct::RenderPassEncoder::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::RenderPassEncoder;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::RenderPipeline {
    push @WebGPU::Direct::RenderPipeline::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::RenderPipeline;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::Sampler {
    push @WebGPU::Direct::Sampler::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::Sampler;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::ShaderModule {
    push @WebGPU::Direct::ShaderModule::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::ShaderModule;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::Surface {
    push @WebGPU::Direct::Surface::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::Surface;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::Texture {
    push @WebGPU::Direct::Texture::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::Texture;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::TextureView {
    push @WebGPU::Direct::TextureView::ISA, "WebGPU::Direct::Opaque";
    require WebGPU::Direct::TextureView;
    sub new {
        my $class = __PACKAGE__;
        die "Cannot call new on abstract class $class";
    }
    sub DESTROY
    {
      $_[0]->release;
    }

}

package
	WebGPU::Direct::ChainedStruct {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ChainedStruct\n"
          if !$class->isa("WebGPU::Direct::ChainedStruct");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ChainedStructOut {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ChainedStructOut\n"
          if !$class->isa("WebGPU::Direct::ChainedStructOut");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::AdapterProperties {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::AdapterProperties\n"
          if !$class->isa("WebGPU::Direct::AdapterProperties");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::BindGroupEntry {
    
    require WebGPU::Direct::BindGroupEntry;
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::BindGroupEntry\n"
          if !$class->isa("WebGPU::Direct::BindGroupEntry");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::BlendComponent {
    
    my $default = {
             'dstFactor' => WebGPU::Direct::BlendFactor->zero,
             'operation' => WebGPU::Direct::BlendOperation->add,
             'srcFactor' => WebGPU::Direct::BlendFactor->one,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::BlendComponent\n"
          if !$class->isa("WebGPU::Direct::BlendComponent");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::BufferBindingLayout {
    
    my $default = {
             'hasDynamicOffset' => 0,
             'minBindingSize' => 0,
             'type' => WebGPU::Direct::BufferBindingType->uniform,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::BufferBindingLayout\n"
          if !$class->isa("WebGPU::Direct::BufferBindingLayout");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::BufferDescriptor {
    
    my $default = {
             'mappedAtCreation' => 0,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::BufferDescriptor\n"
          if !$class->isa("WebGPU::Direct::BufferDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::Color {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::Color\n"
          if !$class->isa("WebGPU::Direct::Color");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref [] ? (r => $_[0]->[0] // 0, g => $_[0]->[1] // 0, b => $_[0]->[2] // 0, a => $_[0]->[3] // 0) : ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::CommandBufferDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::CommandBufferDescriptor\n"
          if !$class->isa("WebGPU::Direct::CommandBufferDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::CommandEncoderDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::CommandEncoderDescriptor\n"
          if !$class->isa("WebGPU::Direct::CommandEncoderDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::CompilationMessage {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::CompilationMessage\n"
          if !$class->isa("WebGPU::Direct::CompilationMessage");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ComputePassTimestampWrites {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ComputePassTimestampWrites\n"
          if !$class->isa("WebGPU::Direct::ComputePassTimestampWrites");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ConstantEntry {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ConstantEntry\n"
          if !$class->isa("WebGPU::Direct::ConstantEntry");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::Extent3D {
    
    my $default = {
             'depthOrArrayLayers' => 1,
             'height' => 1,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::Extent3D\n"
          if !$class->isa("WebGPU::Direct::Extent3D");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref [] ? (width => $_[0]->[0] // 0, height => $_[0]->[1] // 1, depthOrArrayLayers => $_[0]->[2] // 1) : ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::InstanceDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::InstanceDescriptor\n"
          if !$class->isa("WebGPU::Direct::InstanceDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::Limits {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::Limits\n"
          if !$class->isa("WebGPU::Direct::Limits");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::MultisampleState {
    
    my $default = {
             'alphaToCoverageEnabled' => 0,
             'count' => 1,
             'mask' => 4294967295,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::MultisampleState\n"
          if !$class->isa("WebGPU::Direct::MultisampleState");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::Origin3D {
    
    my $default = {
             'x' => 0,
             'y' => 0,
             'z' => 0,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::Origin3D\n"
          if !$class->isa("WebGPU::Direct::Origin3D");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::PipelineLayoutDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::PipelineLayoutDescriptor\n"
          if !$class->isa("WebGPU::Direct::PipelineLayoutDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::PrimitiveDepthClipControl {
    push @WebGPU::Direct::PrimitiveDepthClipControl::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::PrimitiveDepthClipControl\n"
          if !$class->isa("WebGPU::Direct::PrimitiveDepthClipControl");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::PrimitiveState {
    
    my $default = {
             'cullMode' => WebGPU::Direct::CullMode->none,
             'frontFace' => WebGPU::Direct::FrontFace->CCW,
             'topology' => WebGPU::Direct::PrimitiveTopology->triangleList,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::PrimitiveState\n"
          if !$class->isa("WebGPU::Direct::PrimitiveState");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::QuerySetDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::QuerySetDescriptor\n"
          if !$class->isa("WebGPU::Direct::QuerySetDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::QueueDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::QueueDescriptor\n"
          if !$class->isa("WebGPU::Direct::QueueDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RenderBundleDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RenderBundleDescriptor\n"
          if !$class->isa("WebGPU::Direct::RenderBundleDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RenderBundleEncoderDescriptor {
    
    my $default = {
             'depthReadOnly' => 0,
             'sampleCount' => 1,
             'stencilReadOnly' => 0,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RenderBundleEncoderDescriptor\n"
          if !$class->isa("WebGPU::Direct::RenderBundleEncoderDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RenderPassDepthStencilAttachment {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RenderPassDepthStencilAttachment\n"
          if !$class->isa("WebGPU::Direct::RenderPassDepthStencilAttachment");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RenderPassDescriptorMaxDrawCount {
    push @WebGPU::Direct::RenderPassDescriptorMaxDrawCount::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {
             'maxDrawCount' => 50000000,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RenderPassDescriptorMaxDrawCount\n"
          if !$class->isa("WebGPU::Direct::RenderPassDescriptorMaxDrawCount");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RenderPassTimestampWrites {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RenderPassTimestampWrites\n"
          if !$class->isa("WebGPU::Direct::RenderPassTimestampWrites");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RequestAdapterOptions {
    
    my $default = {
             'forceFallbackAdapter' => 0,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RequestAdapterOptions\n"
          if !$class->isa("WebGPU::Direct::RequestAdapterOptions");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SamplerBindingLayout {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SamplerBindingLayout\n"
          if !$class->isa("WebGPU::Direct::SamplerBindingLayout");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SamplerDescriptor {
    
    my $default = {
             'addressModeU' => WebGPU::Direct::AddressMode->clampToEdge,
             'addressModeV' => WebGPU::Direct::AddressMode->clampToEdge,
             'addressModeW' => WebGPU::Direct::AddressMode->clampToEdge,
             'lodMaxClamp' => 32,
             'lodMinClamp' => 0,
             'magFilter' => WebGPU::Direct::FilterMode->nearest,
             'maxAnisotropy' => 1,
             'minFilter' => WebGPU::Direct::FilterMode->nearest,
             'mipmapFilter' => WebGPU::Direct::MipmapFilterMode->nearest,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SamplerDescriptor\n"
          if !$class->isa("WebGPU::Direct::SamplerDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ShaderModuleCompilationHint {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ShaderModuleCompilationHint\n"
          if !$class->isa("WebGPU::Direct::ShaderModuleCompilationHint");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ShaderModuleSPIRVDescriptor {
    push @WebGPU::Direct::ShaderModuleSPIRVDescriptor::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ShaderModuleSPIRVDescriptor\n"
          if !$class->isa("WebGPU::Direct::ShaderModuleSPIRVDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ShaderModuleWGSLDescriptor {
    push @WebGPU::Direct::ShaderModuleWGSLDescriptor::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ShaderModuleWGSLDescriptor\n"
          if !$class->isa("WebGPU::Direct::ShaderModuleWGSLDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::StencilFaceState {
    
    my $default = {
             'compare' => WebGPU::Direct::CompareFunction->always,
             'depthFailOp' => WebGPU::Direct::StencilOperation->keep,
             'failOp' => WebGPU::Direct::StencilOperation->keep,
             'passOp' => WebGPU::Direct::StencilOperation->keep,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::StencilFaceState\n"
          if !$class->isa("WebGPU::Direct::StencilFaceState");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::StorageTextureBindingLayout {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::StorageTextureBindingLayout\n"
          if !$class->isa("WebGPU::Direct::StorageTextureBindingLayout");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceCapabilities {
    
    require WebGPU::Direct::SurfaceCapabilities;
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceCapabilities\n"
          if !$class->isa("WebGPU::Direct::SurfaceCapabilities");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceConfiguration {
    
    my $default = {
             'alphaMode' => WebGPU::Direct::CompositeAlphaMode->auto,
             'usage' => WebGPU::Direct::TextureUsage->renderAttachment,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceConfiguration\n"
          if !$class->isa("WebGPU::Direct::SurfaceConfiguration");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceDescriptor\n"
          if !$class->isa("WebGPU::Direct::SurfaceDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceDescriptorFromAndroidNativeWindow {
    push @WebGPU::Direct::SurfaceDescriptorFromAndroidNativeWindow::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceDescriptorFromAndroidNativeWindow\n"
          if !$class->isa("WebGPU::Direct::SurfaceDescriptorFromAndroidNativeWindow");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceDescriptorFromCanvasHTMLSelector {
    push @WebGPU::Direct::SurfaceDescriptorFromCanvasHTMLSelector::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceDescriptorFromCanvasHTMLSelector\n"
          if !$class->isa("WebGPU::Direct::SurfaceDescriptorFromCanvasHTMLSelector");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceDescriptorFromMetalLayer {
    push @WebGPU::Direct::SurfaceDescriptorFromMetalLayer::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceDescriptorFromMetalLayer\n"
          if !$class->isa("WebGPU::Direct::SurfaceDescriptorFromMetalLayer");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceDescriptorFromWaylandSurface {
    push @WebGPU::Direct::SurfaceDescriptorFromWaylandSurface::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceDescriptorFromWaylandSurface\n"
          if !$class->isa("WebGPU::Direct::SurfaceDescriptorFromWaylandSurface");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceDescriptorFromWindowsHWND {
    push @WebGPU::Direct::SurfaceDescriptorFromWindowsHWND::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceDescriptorFromWindowsHWND\n"
          if !$class->isa("WebGPU::Direct::SurfaceDescriptorFromWindowsHWND");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceDescriptorFromXcbWindow {
    push @WebGPU::Direct::SurfaceDescriptorFromXcbWindow::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceDescriptorFromXcbWindow\n"
          if !$class->isa("WebGPU::Direct::SurfaceDescriptorFromXcbWindow");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceDescriptorFromXlibWindow {
    push @WebGPU::Direct::SurfaceDescriptorFromXlibWindow::ISA, "WebGPU::Direct::ChainedStruct";
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceDescriptorFromXlibWindow\n"
          if !$class->isa("WebGPU::Direct::SurfaceDescriptorFromXlibWindow");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SurfaceTexture {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SurfaceTexture\n"
          if !$class->isa("WebGPU::Direct::SurfaceTexture");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::TextureBindingLayout {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::TextureBindingLayout\n"
          if !$class->isa("WebGPU::Direct::TextureBindingLayout");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::TextureDataLayout {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::TextureDataLayout\n"
          if !$class->isa("WebGPU::Direct::TextureDataLayout");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::TextureViewDescriptor {
    
    my $default = {
             'aspect' => WebGPU::Direct::TextureAspect->all,
             'baseArrayLayer' => 0,
             'baseMipLevel' => 0,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::TextureViewDescriptor\n"
          if !$class->isa("WebGPU::Direct::TextureViewDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::VertexAttribute {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::VertexAttribute\n"
          if !$class->isa("WebGPU::Direct::VertexAttribute");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::BindGroupDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::BindGroupDescriptor\n"
          if !$class->isa("WebGPU::Direct::BindGroupDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::BindGroupLayoutEntry {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::BindGroupLayoutEntry\n"
          if !$class->isa("WebGPU::Direct::BindGroupLayoutEntry");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::BlendState {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::BlendState\n"
          if !$class->isa("WebGPU::Direct::BlendState");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::CompilationInfo {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::CompilationInfo\n"
          if !$class->isa("WebGPU::Direct::CompilationInfo");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ComputePassDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ComputePassDescriptor\n"
          if !$class->isa("WebGPU::Direct::ComputePassDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::DepthStencilState {
    
    my $default = {
             'depthBias' => 0,
             'depthBiasClamp' => 0,
             'depthBiasSlopeScale' => 0,
             'stencilReadMask' => 4294967295,
             'stencilWriteMask' => 4294967295,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::DepthStencilState\n"
          if !$class->isa("WebGPU::Direct::DepthStencilState");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ImageCopyBuffer {
    
    my $default = {
             'offset' => 0,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ImageCopyBuffer\n"
          if !$class->isa("WebGPU::Direct::ImageCopyBuffer");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ImageCopyTexture {
    
    my $default = {
             'aspect' => WebGPU::Direct::TextureAspect->all,
             'mipLevel' => 0,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ImageCopyTexture\n"
          if !$class->isa("WebGPU::Direct::ImageCopyTexture");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ProgrammableStageDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ProgrammableStageDescriptor\n"
          if !$class->isa("WebGPU::Direct::ProgrammableStageDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RenderPassColorAttachment {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RenderPassColorAttachment\n"
          if !$class->isa("WebGPU::Direct::RenderPassColorAttachment");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RequiredLimits {
    
    my $default = {
             'maxBindGroups' => 4,
             'maxBindingsPerBindGroup' => 640,
             'maxBufferSize' => 268435456,
             'maxColorAttachmentBytesPerSample' => 32,
             'maxColorAttachments' => 8,
             'maxComputeInvocationsPerWorkgroup' => 256,
             'maxComputeWorkgroupSizeX' => 256,
             'maxComputeWorkgroupSizeY' => 256,
             'maxComputeWorkgroupSizeZ' => 64,
             'maxComputeWorkgroupStorageSize' => 16384,
             'maxComputeWorkgroupsPerDimension' => 65535,
             'maxDynamicStorageBuffersPerPipelineLayout' => 4,
             'maxDynamicUniformBuffersPerPipelineLayout' => 8,
             'maxInterStageShaderComponents' => 60,
             'maxInterStageShaderVariables' => 16,
             'maxSampledTexturesPerShaderStage' => 16,
             'maxSamplersPerShaderStage' => 16,
             'maxStorageBufferBindingSize' => 134217728,
             'maxStorageBuffersPerShaderStage' => 8,
             'maxStorageTexturesPerShaderStage' => 4,
             'maxTextureArrayLayers' => 256,
             'maxTextureDimension1D' => 8192,
             'maxTextureDimension2D' => 8192,
             'maxTextureDimension3D' => 2048,
             'maxUniformBufferBindingSize' => 65536,
             'maxUniformBuffersPerShaderStage' => 12,
             'maxVertexAttributes' => 16,
             'maxVertexBufferArrayStride' => 2048,
             'maxVertexBuffers' => 8,
             'minStorageBufferOffsetAlignment' => 256,
             'minUniformBufferOffsetAlignment' => 256,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RequiredLimits\n"
          if !$class->isa("WebGPU::Direct::RequiredLimits");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ShaderModuleDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ShaderModuleDescriptor\n"
          if !$class->isa("WebGPU::Direct::ShaderModuleDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::SupportedLimits {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::SupportedLimits\n"
          if !$class->isa("WebGPU::Direct::SupportedLimits");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::TextureDescriptor {
    
    my $default = {
             'dimension' => WebGPU::Direct::TextureDimension->_2D,
             'mipLevelCount' => 1,
             'sampleCount' => 1,
             'size' => {
                         'depthOrArrayLayers' => 1,
                         'height' => 1,
                       },
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::TextureDescriptor\n"
          if !$class->isa("WebGPU::Direct::TextureDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::VertexBufferLayout {
    
    my $default = {
             'stepMode' => WebGPU::Direct::VertexStepMode->vertex,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::VertexBufferLayout\n"
          if !$class->isa("WebGPU::Direct::VertexBufferLayout");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::BindGroupLayoutDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::BindGroupLayoutDescriptor\n"
          if !$class->isa("WebGPU::Direct::BindGroupLayoutDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ColorTargetState {
    
    my $default = {
             'blend' => undef,
             'writeMask' => WebGPU::Direct::ColorWriteMask->all,
           };

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ColorTargetState\n"
          if !$class->isa("WebGPU::Direct::ColorTargetState");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::ComputePipelineDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::ComputePipelineDescriptor\n"
          if !$class->isa("WebGPU::Direct::ComputePipelineDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::DeviceDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::DeviceDescriptor\n"
          if !$class->isa("WebGPU::Direct::DeviceDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RenderPassDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RenderPassDescriptor\n"
          if !$class->isa("WebGPU::Direct::RenderPassDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::VertexState {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::VertexState\n"
          if !$class->isa("WebGPU::Direct::VertexState");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::FragmentState {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::FragmentState\n"
          if !$class->isa("WebGPU::Direct::FragmentState");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

package
	WebGPU::Direct::RenderPipelineDescriptor {
    
    my $default = {};

    sub new {
        my $class = shift;
        die "$class does not inherit from WebGPU::Direct::RenderPipelineDescriptor\n"
          if !$class->isa("WebGPU::Direct::RenderPipelineDescriptor");
        $class = ref($class) ? ref($class) : $class;
        my %params = ref( $_[0] ) eq ref {} ? %{$_[0]} : @_;
        my $result = { %$default, %params };
        $result = $class->BUILDARGS($result)
          if $class->can('BUILDARGS');
        $result = bless( $result, $class );
        $result->pack;
        return $result;
    }
    
}

1;
