class Regex {
  use Fn;
  use Regex::Replacer;
  use Regex::Re2;
  use Hash;
  
  has re2 : Regex::Re2;
  has captures : ro string[];
  has match_start : ro int;
  has match_length : ro int;
  has replaced_count : ro int;
  
  static method new : Regex ($pattern_and_flags : string[]...) {
    
    my $pattern = $pattern_and_flags->[0];
    my $flags = (string)undef;
    if (@$pattern_and_flags > 1) {
      $flags = $pattern_and_flags->[1];
    }
    
    my $self = new Regex;
    
    my $re2_pattern = $pattern;
    
    if ($flags) {
      $re2_pattern = "(?$flags)$re2_pattern";
    }
    
    $self->compile($re2_pattern);
    
    return $self;
  }
  
  native method DESTROY : void ();
  
  private native method compile : void ($pattern : string);
  
  method match : int ($string : string) {
    my $offset = 0;
    return $self->match_offset($string, \$offset);
  }

  native method match_offset : int ($string : string, $offset : int*);

  method cap1 : string () { return $self->captures->[1]; }
  method cap2 : string () { return $self->captures->[2]; }
  method cap3 : string () { return $self->captures->[3]; }
  method cap4 : string () { return $self->captures->[4]; }
  method cap5 : string () { return $self->captures->[5]; }
  method cap6 : string () { return $self->captures->[6]; }
  method cap7 : string () { return $self->captures->[7]; }
  method cap8 : string () { return $self->captures->[8]; }
  method cap9 : string () { return $self->captures->[9]; }
  method cap10 : string () { return $self->captures->[10]; }
  method cap11 : string () { return $self->captures->[11]; }
  method cap12 : string () { return $self->captures->[12]; }
  method cap13 : string () { return $self->captures->[13]; }
  method cap14 : string () { return $self->captures->[14]; }
  method cap15 : string () { return $self->captures->[15]; }
  method cap16 : string () { return $self->captures->[16]; }
  method cap17 : string () { return $self->captures->[17]; }
  method cap18 : string () { return $self->captures->[18]; }
  method cap19 : string () { return $self->captures->[19]; }
  method cap20 : string () { return $self->captures->[20]; }

  method replace  : string ($string : string, $replace_string : string) {
    my $offset = 0;
    return $self->replace_common($string, \$offset, $replace_string, {global => 0});
  }
  
  method replace_cb  : string ($string : string, $replace_cb : Regex::Replacer) {
    my $offset = 0;
    return $self->replace_common($string, \$offset, $replace_cb, {global => 0});
  }
  
  method replace_g  : string ($string : string, $replace_string : string) {
    my $offset = 0;
    return $self->replace_common($string, \$offset, $replace_string, {global => 1});
  }
  
  method replace_g_cb  : string ($string : string, $replace_cb : Regex::Replacer) {
    my $offset = 0;
    return $self->replace_common($string, \$offset, $replace_cb, {global => 1});
  }
  
  method replace_offset  : string ($string : string, $offset_ref : int*, $replace : string) {
    return $self->replace_common($string, $offset_ref, $replace, {global => 0});
  }
  
  method replace_cb_offset  : string ($string : string, $offset_ref : int*, $replace_cb : Regex::Replacer) {
    return $self->replace_common($string, $offset_ref, $replace_cb, {global => 0});
  }
  
  method replace_g_offset  : string ($string : string, $offset_ref : int*, $replace : string) {
    return $self->replace_common($string, $offset_ref, $replace, {global => 1});
  }
  
  method replace_g_cb_offset  : string ($string : string, $offset_ref : int*, $replace_cb : Regex::Replacer) {
    return $self->replace_common($string, $offset_ref, $replace_cb, {global => 1});
  }
  
  private precompile method replace_common : string ($string : string, $offset_ref : int*, $replace : object, $options : object[]) {
    
    my $opt = Hash->new($options);
    
    my $offset = $$offset_ref;
    my $original_offset = $offset;
    
    my $global = 0;
    if (my $global_obj = $opt->get("global")) {
      $global = (int)$global_obj;
    }
    
    unless ($string) {
      die "The string must be specified";
    }
    
    if ($offset < 0) {
      die "The offset must be greater than or equal to 0";
    }
    
    my $result : string;
    my $result_buffer = StringBuffer->new;
    my $string_length = length $string;
    $result_buffer->push($string);
    
    my $match_count = 0;
    while (1) {
      my $result_buffer_value = $result_buffer->to_string;
      
      my $match = $self->match_offset($result_buffer_value, \$offset);
      
      if ($match) {
        $match_count++;
      }
      else {
        last;
      }
      
      my $replace_string : string;
      if ($replace isa string) {
        $replace_string = (string)$replace;
      }
      elsif ($replace isa Regex::Replacer) {
        my $replacer = (Regex::Replacer)$replace;
        $replace_string = $replacer->($self);
      }
      else {
        die "The replace argument must be a string or a Regex::Replacer object";
      }
      
      my $replace_string_length = length $replace_string;
      
      my $match_start = $self->match_start;
      my $match_length = $self->match_length;
      
      $result_buffer->replace($match_start, $match_length, $replace_string);
      
      $self->{replaced_count} = $match_count;
      
      unless ($global) {
        last;
      }
      
      my $next_offset = $match_start + $replace_string_length;
      $offset = $next_offset;
    }
    
    $result = $result_buffer->to_string;
    
    return $result;
  }
}

