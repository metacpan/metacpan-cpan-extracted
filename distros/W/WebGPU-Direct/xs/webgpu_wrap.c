/*
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! #
#   This file is generated by webgpu.xs.PL  #
# !!!!!!!   ANY EDIT WILL BE LOST   !!!!!!! #
*/

void WebGPU__Direct__BufferMapCallback__callback( WGPUMapAsyncStatus status, WGPUStringView message, void* userdata1, void* userdata2 );
void WebGPU__Direct__CompilationInfoCallback__callback( WGPUCompilationInfoRequestStatus status, struct WGPUCompilationInfo const * compilationInfo, void* userdata1, void* userdata2 );
void WebGPU__Direct__CreateComputePipelineAsyncCallback__callback( WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* userdata1, void* userdata2 );
void WebGPU__Direct__CreateRenderPipelineAsyncCallback__callback( WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* userdata1, void* userdata2 );
void WebGPU__Direct__DeviceLostCallback__callback( WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* userdata1, void* userdata2 );
void WebGPU__Direct__PopErrorScopeCallback__callback( WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* userdata1, void* userdata2 );
void WebGPU__Direct__QueueWorkDoneCallback__callback( WGPUQueueWorkDoneStatus status, void* userdata1, void* userdata2 );
void WebGPU__Direct__RequestAdapterCallback__callback( WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* userdata1, void* userdata2 );
void WebGPU__Direct__RequestDeviceCallback__callback( WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* userdata1, void* userdata2 );
void WebGPU__Direct__UncapturedErrorCallback__callback( WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* userdata1, void* userdata2 );

void WebGPU__Direct__StringView__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::StringView"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::StringView",
      "THIS", "WebGPU::Direct::StringView");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUStringView *n = (WGPUStringView *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUStringView); _init_strview(aTHX_ h, n);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_strview(aTHX_ h, "data", 4,  &n->data, &n->length, NULL);

  
}

void WebGPU__Direct__StringView__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::StringView"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::StringView",
      "THIS", "WebGPU::Direct::StringView");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUStringView *n = (WGPUStringView *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUStringView);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_strview(aTHX_ h, "data", 4,  &n->data, &n->length, NULL);
  _unpack_size_t(aTHX_ h, "length", 6,  &n->length, NULL);

}

SV *WGPUStringView__wrap( const WGPUStringView * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::StringView", GV_ADD));
  WebGPU__Direct__StringView__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__StringView;
SV *WGPUAdapter__wrap( WGPUAdapter  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Adapter"), n);
}

typedef SV* WebGPU__Direct__Adapter;
SV *WGPUBindGroup__wrap( WGPUBindGroup  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::BindGroup"), n);
}

typedef SV* WebGPU__Direct__BindGroup;
SV *WGPUBindGroupLayout__wrap( WGPUBindGroupLayout  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::BindGroupLayout"), n);
}

typedef SV* WebGPU__Direct__BindGroupLayout;
SV *WGPUBuffer__wrap( WGPUBuffer  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Buffer"), n);
}

typedef SV* WebGPU__Direct__Buffer;
SV *WGPUCommandBuffer__wrap( WGPUCommandBuffer  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::CommandBuffer"), n);
}

typedef SV* WebGPU__Direct__CommandBuffer;
SV *WGPUCommandEncoder__wrap( WGPUCommandEncoder  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::CommandEncoder"), n);
}

typedef SV* WebGPU__Direct__CommandEncoder;
SV *WGPUComputePassEncoder__wrap( WGPUComputePassEncoder  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::ComputePassEncoder"), n);
}

typedef SV* WebGPU__Direct__ComputePassEncoder;
SV *WGPUComputePipeline__wrap( WGPUComputePipeline  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::ComputePipeline"), n);
}

typedef SV* WebGPU__Direct__ComputePipeline;
SV *WGPUDevice__wrap( WGPUDevice  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Device"), n);
}

typedef SV* WebGPU__Direct__Device;
SV *WGPUInstance__wrap( WGPUInstance  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Instance"), n);
}

typedef SV* WebGPU__Direct__Instance;
SV *WGPUPipelineLayout__wrap( WGPUPipelineLayout  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::PipelineLayout"), n);
}

typedef SV* WebGPU__Direct__PipelineLayout;
SV *WGPUQuerySet__wrap( WGPUQuerySet  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::QuerySet"), n);
}

typedef SV* WebGPU__Direct__QuerySet;
SV *WGPUQueue__wrap( WGPUQueue  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Queue"), n);
}

typedef SV* WebGPU__Direct__Queue;
SV *WGPURenderBundle__wrap( WGPURenderBundle  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::RenderBundle"), n);
}

typedef SV* WebGPU__Direct__RenderBundle;
SV *WGPURenderBundleEncoder__wrap( WGPURenderBundleEncoder  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::RenderBundleEncoder"), n);
}

typedef SV* WebGPU__Direct__RenderBundleEncoder;
SV *WGPURenderPassEncoder__wrap( WGPURenderPassEncoder  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::RenderPassEncoder"), n);
}

typedef SV* WebGPU__Direct__RenderPassEncoder;
SV *WGPURenderPipeline__wrap( WGPURenderPipeline  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::RenderPipeline"), n);
}

typedef SV* WebGPU__Direct__RenderPipeline;
SV *WGPUSampler__wrap( WGPUSampler  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Sampler"), n);
}

typedef SV* WebGPU__Direct__Sampler;
SV *WGPUShaderModule__wrap( WGPUShaderModule  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::ShaderModule"), n);
}

typedef SV* WebGPU__Direct__ShaderModule;
SV *WGPUSurface__wrap( WGPUSurface  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Surface"), n);
}

typedef SV* WebGPU__Direct__Surface;
SV *WGPUTexture__wrap( WGPUTexture  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Texture"), n);
}

typedef SV* WebGPU__Direct__Texture;
SV *WGPUTextureView__wrap( WGPUTextureView  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::TextureView"), n);
}

typedef SV* WebGPU__Direct__TextureView;
SV *WGPUProc__wrap( WGPUProc  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::Proc"), n);
}

typedef SV* WebGPU__Direct__Proc;
SV *WGPUBufferMapCallback__wrap( WGPUBufferMapCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::BufferMapCallback"), n);
}

typedef SV* WebGPU__Direct__BufferMapCallback;
SV *WGPUCompilationInfoCallback__wrap( WGPUCompilationInfoCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::CompilationInfoCallback"), n);
}

typedef SV* WebGPU__Direct__CompilationInfoCallback;
SV *WGPUCreateComputePipelineAsyncCallback__wrap( WGPUCreateComputePipelineAsyncCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::CreateComputePipelineAsyncCallback"), n);
}

typedef SV* WebGPU__Direct__CreateComputePipelineAsyncCallback;
SV *WGPUCreateRenderPipelineAsyncCallback__wrap( WGPUCreateRenderPipelineAsyncCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::CreateRenderPipelineAsyncCallback"), n);
}

typedef SV* WebGPU__Direct__CreateRenderPipelineAsyncCallback;
SV *WGPUDeviceLostCallback__wrap( WGPUDeviceLostCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::DeviceLostCallback"), n);
}

typedef SV* WebGPU__Direct__DeviceLostCallback;
SV *WGPUPopErrorScopeCallback__wrap( WGPUPopErrorScopeCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::PopErrorScopeCallback"), n);
}

typedef SV* WebGPU__Direct__PopErrorScopeCallback;
SV *WGPUQueueWorkDoneCallback__wrap( WGPUQueueWorkDoneCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::QueueWorkDoneCallback"), n);
}

typedef SV* WebGPU__Direct__QueueWorkDoneCallback;
SV *WGPURequestAdapterCallback__wrap( WGPURequestAdapterCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::RequestAdapterCallback"), n);
}

typedef SV* WebGPU__Direct__RequestAdapterCallback;
SV *WGPURequestDeviceCallback__wrap( WGPURequestDeviceCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::RequestDeviceCallback"), n);
}

typedef SV* WebGPU__Direct__RequestDeviceCallback;
SV *WGPUUncapturedErrorCallback__wrap( WGPUUncapturedErrorCallback  n )
{
  return _new_opaque(newSVpvs("WebGPU::Direct::UncapturedErrorCallback"), n);
}

typedef SV* WebGPU__Direct__UncapturedErrorCallback;
void WebGPU__Direct__ChainedStruct__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ChainedStruct"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ChainedStruct",
      "THIS", "WebGPU::Direct::ChainedStruct");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUChainedStruct *n = (WGPUChainedStruct *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUChainedStruct);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "next", 4, (void **) &n->next, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "sType", 5,  &n->sType, newSVpvs("WebGPU::Direct::SType"));

  
}

void WebGPU__Direct__ChainedStruct__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ChainedStruct"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ChainedStruct",
      "THIS", "WebGPU::Direct::ChainedStruct");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUChainedStruct *n = (WGPUChainedStruct *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUChainedStruct);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "next", 4, (void **) &n->next, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "sType", 5,  &n->sType, newSVpvs("WebGPU::Direct::SType"));

}

SV *WGPUChainedStruct__wrap( const WGPUChainedStruct * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ChainedStruct", GV_ADD));
  WebGPU__Direct__ChainedStruct__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ChainedStruct;
void WebGPU__Direct__ChainedStructOut__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ChainedStructOut"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ChainedStructOut",
      "THIS", "WebGPU::Direct::ChainedStructOut");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUChainedStructOut *n = (WGPUChainedStructOut *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUChainedStructOut);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "next", 4, (void **) &n->next, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _pack_enum(aTHX_ h, "sType", 5,  &n->sType, newSVpvs("WebGPU::Direct::SType"));

  
}

void WebGPU__Direct__ChainedStructOut__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ChainedStructOut"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ChainedStructOut",
      "THIS", "WebGPU::Direct::ChainedStructOut");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUChainedStructOut *n = (WGPUChainedStructOut *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUChainedStructOut);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "next", 4, (void **) &n->next, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _unpack_enum(aTHX_ h, "sType", 5,  &n->sType, newSVpvs("WebGPU::Direct::SType"));

}

SV *WGPUChainedStructOut__wrap( const WGPUChainedStructOut * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ChainedStructOut", GV_ADD));
  WebGPU__Direct__ChainedStructOut__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ChainedStructOut;
void WebGPU__Direct__BufferMapCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BufferMapCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BufferMapCallbackInfo",
      "THIS", "WebGPU::Direct::BufferMapCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBufferMapCallbackInfo *n = (WGPUBufferMapCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBufferMapCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__BufferMapCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__BufferMapCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BufferMapCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BufferMapCallbackInfo",
      "THIS", "WebGPU::Direct::BufferMapCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBufferMapCallbackInfo *n = (WGPUBufferMapCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBufferMapCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPUBufferMapCallbackInfo__wrap( const WGPUBufferMapCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BufferMapCallbackInfo", GV_ADD));
  WebGPU__Direct__BufferMapCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BufferMapCallbackInfo;
void WebGPU__Direct__CompilationInfoCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CompilationInfoCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CompilationInfoCallbackInfo",
      "THIS", "WebGPU::Direct::CompilationInfoCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCompilationInfoCallbackInfo *n = (WGPUCompilationInfoCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCompilationInfoCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__CompilationInfoCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__CompilationInfoCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CompilationInfoCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CompilationInfoCallbackInfo",
      "THIS", "WebGPU::Direct::CompilationInfoCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCompilationInfoCallbackInfo *n = (WGPUCompilationInfoCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCompilationInfoCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPUCompilationInfoCallbackInfo__wrap( const WGPUCompilationInfoCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::CompilationInfoCallbackInfo", GV_ADD));
  WebGPU__Direct__CompilationInfoCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__CompilationInfoCallbackInfo;
void WebGPU__Direct__CreateComputePipelineAsyncCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo",
      "THIS", "WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCreateComputePipelineAsyncCallbackInfo *n = (WGPUCreateComputePipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCreateComputePipelineAsyncCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__CreateComputePipelineAsyncCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__CreateComputePipelineAsyncCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo",
      "THIS", "WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCreateComputePipelineAsyncCallbackInfo *n = (WGPUCreateComputePipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCreateComputePipelineAsyncCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPUCreateComputePipelineAsyncCallbackInfo__wrap( const WGPUCreateComputePipelineAsyncCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo", GV_ADD));
  WebGPU__Direct__CreateComputePipelineAsyncCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__CreateComputePipelineAsyncCallbackInfo;
void WebGPU__Direct__CreateRenderPipelineAsyncCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo",
      "THIS", "WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCreateRenderPipelineAsyncCallbackInfo *n = (WGPUCreateRenderPipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCreateRenderPipelineAsyncCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__CreateRenderPipelineAsyncCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__CreateRenderPipelineAsyncCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo",
      "THIS", "WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCreateRenderPipelineAsyncCallbackInfo *n = (WGPUCreateRenderPipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCreateRenderPipelineAsyncCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPUCreateRenderPipelineAsyncCallbackInfo__wrap( const WGPUCreateRenderPipelineAsyncCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo", GV_ADD));
  WebGPU__Direct__CreateRenderPipelineAsyncCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__CreateRenderPipelineAsyncCallbackInfo;
void WebGPU__Direct__DeviceLostCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::DeviceLostCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::DeviceLostCallbackInfo",
      "THIS", "WebGPU::Direct::DeviceLostCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUDeviceLostCallbackInfo *n = (WGPUDeviceLostCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUDeviceLostCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__DeviceLostCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__DeviceLostCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::DeviceLostCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::DeviceLostCallbackInfo",
      "THIS", "WebGPU::Direct::DeviceLostCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUDeviceLostCallbackInfo *n = (WGPUDeviceLostCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUDeviceLostCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPUDeviceLostCallbackInfo__wrap( const WGPUDeviceLostCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::DeviceLostCallbackInfo", GV_ADD));
  WebGPU__Direct__DeviceLostCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__DeviceLostCallbackInfo;
void WebGPU__Direct__PopErrorScopeCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::PopErrorScopeCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::PopErrorScopeCallbackInfo",
      "THIS", "WebGPU::Direct::PopErrorScopeCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUPopErrorScopeCallbackInfo *n = (WGPUPopErrorScopeCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUPopErrorScopeCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__PopErrorScopeCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__PopErrorScopeCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::PopErrorScopeCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::PopErrorScopeCallbackInfo",
      "THIS", "WebGPU::Direct::PopErrorScopeCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUPopErrorScopeCallbackInfo *n = (WGPUPopErrorScopeCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUPopErrorScopeCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPUPopErrorScopeCallbackInfo__wrap( const WGPUPopErrorScopeCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::PopErrorScopeCallbackInfo", GV_ADD));
  WebGPU__Direct__PopErrorScopeCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__PopErrorScopeCallbackInfo;
void WebGPU__Direct__QueueWorkDoneCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::QueueWorkDoneCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::QueueWorkDoneCallbackInfo",
      "THIS", "WebGPU::Direct::QueueWorkDoneCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUQueueWorkDoneCallbackInfo *n = (WGPUQueueWorkDoneCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUQueueWorkDoneCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__QueueWorkDoneCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__QueueWorkDoneCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::QueueWorkDoneCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::QueueWorkDoneCallbackInfo",
      "THIS", "WebGPU::Direct::QueueWorkDoneCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUQueueWorkDoneCallbackInfo *n = (WGPUQueueWorkDoneCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUQueueWorkDoneCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPUQueueWorkDoneCallbackInfo__wrap( const WGPUQueueWorkDoneCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::QueueWorkDoneCallbackInfo", GV_ADD));
  WebGPU__Direct__QueueWorkDoneCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__QueueWorkDoneCallbackInfo;
void WebGPU__Direct__RequestAdapterCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RequestAdapterCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RequestAdapterCallbackInfo",
      "THIS", "WebGPU::Direct::RequestAdapterCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURequestAdapterCallbackInfo *n = (WGPURequestAdapterCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURequestAdapterCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__RequestAdapterCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__RequestAdapterCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RequestAdapterCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RequestAdapterCallbackInfo",
      "THIS", "WebGPU::Direct::RequestAdapterCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURequestAdapterCallbackInfo *n = (WGPURequestAdapterCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURequestAdapterCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPURequestAdapterCallbackInfo__wrap( const WGPURequestAdapterCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RequestAdapterCallbackInfo", GV_ADD));
  WebGPU__Direct__RequestAdapterCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RequestAdapterCallbackInfo;
void WebGPU__Direct__RequestDeviceCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RequestDeviceCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RequestDeviceCallbackInfo",
      "THIS", "WebGPU::Direct::RequestDeviceCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURequestDeviceCallbackInfo *n = (WGPURequestDeviceCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURequestDeviceCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__RequestDeviceCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__RequestDeviceCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RequestDeviceCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RequestDeviceCallbackInfo",
      "THIS", "WebGPU::Direct::RequestDeviceCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURequestDeviceCallbackInfo *n = (WGPURequestDeviceCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURequestDeviceCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPURequestDeviceCallbackInfo__wrap( const WGPURequestDeviceCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RequestDeviceCallbackInfo", GV_ADD));
  WebGPU__Direct__RequestDeviceCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RequestDeviceCallbackInfo;
void WebGPU__Direct__UncapturedErrorCallbackInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::UncapturedErrorCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::UncapturedErrorCallbackInfo",
      "THIS", "WebGPU::Direct::UncapturedErrorCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUUncapturedErrorCallbackInfo *n = (WGPUUncapturedErrorCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUUncapturedErrorCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  n->callback = &WebGPU__Direct__UncapturedErrorCallback__callback;
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _pack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

  
}

void WebGPU__Direct__UncapturedErrorCallbackInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::UncapturedErrorCallbackInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::UncapturedErrorCallbackInfo",
      "THIS", "WebGPU::Direct::UncapturedErrorCallbackInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUUncapturedErrorCallbackInfo *n = (WGPUUncapturedErrorCallbackInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUUncapturedErrorCallbackInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);
  _unpack_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

}

SV *WGPUUncapturedErrorCallbackInfo__wrap( const WGPUUncapturedErrorCallbackInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::UncapturedErrorCallbackInfo", GV_ADD));
  WebGPU__Direct__UncapturedErrorCallbackInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__UncapturedErrorCallbackInfo;
void WebGPU__Direct__AdapterInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::AdapterInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::AdapterInfo",
      "THIS", "WebGPU::Direct::AdapterInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUAdapterInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _pack_obj(aTHX_ h, "vendor", 6,  &n->vendor, sizeof(n->vendor), newSVpvs("WebGPU::Direct::StringView"));
  _pack_obj(aTHX_ h, "architecture", 12,  &n->architecture, sizeof(n->architecture), newSVpvs("WebGPU::Direct::StringView"));
  _pack_obj(aTHX_ h, "device", 6,  &n->device, sizeof(n->device), newSVpvs("WebGPU::Direct::StringView"));
  _pack_obj(aTHX_ h, "description", 11,  &n->description, sizeof(n->description), newSVpvs("WebGPU::Direct::StringView"));
  _pack_enum(aTHX_ h, "backendType", 11,  &n->backendType, newSVpvs("WebGPU::Direct::BackendType"));
  _pack_enum(aTHX_ h, "adapterType", 11,  &n->adapterType, newSVpvs("WebGPU::Direct::AdapterType"));
  _pack_uint32_t(aTHX_ h, "vendorID", 8,  &n->vendorID, NULL);
  _pack_uint32_t(aTHX_ h, "deviceID", 8,  &n->deviceID, NULL);

  
}

void WebGPU__Direct__AdapterInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::AdapterInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::AdapterInfo",
      "THIS", "WebGPU::Direct::AdapterInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUAdapterInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _unpack_obj(aTHX_ h, "vendor", 6,  &n->vendor, sizeof(n->vendor), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_obj(aTHX_ h, "architecture", 12,  &n->architecture, sizeof(n->architecture), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_obj(aTHX_ h, "device", 6,  &n->device, sizeof(n->device), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_obj(aTHX_ h, "description", 11,  &n->description, sizeof(n->description), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_enum(aTHX_ h, "backendType", 11,  &n->backendType, newSVpvs("WebGPU::Direct::BackendType"));
  _unpack_enum(aTHX_ h, "adapterType", 11,  &n->adapterType, newSVpvs("WebGPU::Direct::AdapterType"));
  _unpack_uint32_t(aTHX_ h, "vendorID", 8,  &n->vendorID, NULL);
  _unpack_uint32_t(aTHX_ h, "deviceID", 8,  &n->deviceID, NULL);

}

SV *WGPUAdapterInfo__wrap( const WGPUAdapterInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::AdapterInfo", GV_ADD));
  WebGPU__Direct__AdapterInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__AdapterInfo;
void WebGPU__Direct__BindGroupEntry__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BindGroupEntry"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BindGroupEntry",
      "THIS", "WebGPU::Direct::BindGroupEntry");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBindGroupEntry);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_uint32_t(aTHX_ h, "binding", 7,  &n->binding, NULL);
  _pack_opaque(aTHX_ h, "buffer", 6, (void **) &n->buffer, newSVpvs("WebGPU::Direct::Buffer"));
  _pack_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);
  _pack_uint64_t(aTHX_ h, "size", 4,  &n->size, NULL);
  _pack_opaque(aTHX_ h, "sampler", 7, (void **) &n->sampler, newSVpvs("WebGPU::Direct::Sampler"));
  _pack_opaque(aTHX_ h, "textureView", 11, (void **) &n->textureView, newSVpvs("WebGPU::Direct::TextureView"));

  
}

void WebGPU__Direct__BindGroupEntry__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BindGroupEntry"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BindGroupEntry",
      "THIS", "WebGPU::Direct::BindGroupEntry");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBindGroupEntry);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_uint32_t(aTHX_ h, "binding", 7,  &n->binding, NULL);
  _unpack_opaque(aTHX_ h, "buffer", 6, (void **) &n->buffer, newSVpvs("WebGPU::Direct::Buffer"));
  _unpack_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);
  _unpack_uint64_t(aTHX_ h, "size", 4,  &n->size, NULL);
  _unpack_opaque(aTHX_ h, "sampler", 7, (void **) &n->sampler, newSVpvs("WebGPU::Direct::Sampler"));
  _unpack_opaque(aTHX_ h, "textureView", 11, (void **) &n->textureView, newSVpvs("WebGPU::Direct::TextureView"));

}

SV *WGPUBindGroupEntry__wrap( const WGPUBindGroupEntry * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BindGroupEntry", GV_ADD));
  WebGPU__Direct__BindGroupEntry__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BindGroupEntry;
void WebGPU__Direct__BlendComponent__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BlendComponent"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BlendComponent",
      "THIS", "WebGPU::Direct::BlendComponent");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBlendComponent *n = (WGPUBlendComponent *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBlendComponent);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_enum(aTHX_ h, "operation", 9,  &n->operation, newSVpvs("WebGPU::Direct::BlendOperation"));
  _pack_enum(aTHX_ h, "srcFactor", 9,  &n->srcFactor, newSVpvs("WebGPU::Direct::BlendFactor"));
  _pack_enum(aTHX_ h, "dstFactor", 9,  &n->dstFactor, newSVpvs("WebGPU::Direct::BlendFactor"));

  
}

void WebGPU__Direct__BlendComponent__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BlendComponent"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BlendComponent",
      "THIS", "WebGPU::Direct::BlendComponent");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBlendComponent *n = (WGPUBlendComponent *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBlendComponent);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_enum(aTHX_ h, "operation", 9,  &n->operation, newSVpvs("WebGPU::Direct::BlendOperation"));
  _unpack_enum(aTHX_ h, "srcFactor", 9,  &n->srcFactor, newSVpvs("WebGPU::Direct::BlendFactor"));
  _unpack_enum(aTHX_ h, "dstFactor", 9,  &n->dstFactor, newSVpvs("WebGPU::Direct::BlendFactor"));

}

SV *WGPUBlendComponent__wrap( const WGPUBlendComponent * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BlendComponent", GV_ADD));
  WebGPU__Direct__BlendComponent__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BlendComponent;
void WebGPU__Direct__BufferBindingLayout__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BufferBindingLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BufferBindingLayout",
      "THIS", "WebGPU::Direct::BufferBindingLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBufferBindingLayout *n = (WGPUBufferBindingLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBufferBindingLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::BufferBindingType"));
  _pack_uint32_t(aTHX_ h, "hasDynamicOffset", 16,  &n->hasDynamicOffset, NULL);
  _pack_uint64_t(aTHX_ h, "minBindingSize", 14,  &n->minBindingSize, NULL);

  
}

void WebGPU__Direct__BufferBindingLayout__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BufferBindingLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BufferBindingLayout",
      "THIS", "WebGPU::Direct::BufferBindingLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBufferBindingLayout *n = (WGPUBufferBindingLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBufferBindingLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::BufferBindingType"));
  _unpack_uint32_t(aTHX_ h, "hasDynamicOffset", 16,  &n->hasDynamicOffset, NULL);
  _unpack_uint64_t(aTHX_ h, "minBindingSize", 14,  &n->minBindingSize, NULL);

}

SV *WGPUBufferBindingLayout__wrap( const WGPUBufferBindingLayout * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BufferBindingLayout", GV_ADD));
  WebGPU__Direct__BufferBindingLayout__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BufferBindingLayout;
void WebGPU__Direct__BufferDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BufferDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BufferDescriptor",
      "THIS", "WebGPU::Direct::BufferDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBufferDescriptor *n = (WGPUBufferDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBufferDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::BufferUsage"));
  _pack_uint64_t(aTHX_ h, "size", 4,  &n->size, NULL);
  _pack_uint32_t(aTHX_ h, "mappedAtCreation", 16,  &n->mappedAtCreation, NULL);

  
}

void WebGPU__Direct__BufferDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BufferDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BufferDescriptor",
      "THIS", "WebGPU::Direct::BufferDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBufferDescriptor *n = (WGPUBufferDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBufferDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::BufferUsage"));
  _unpack_uint64_t(aTHX_ h, "size", 4,  &n->size, NULL);
  _unpack_uint32_t(aTHX_ h, "mappedAtCreation", 16,  &n->mappedAtCreation, NULL);

}

SV *WGPUBufferDescriptor__wrap( const WGPUBufferDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BufferDescriptor", GV_ADD));
  WebGPU__Direct__BufferDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BufferDescriptor;
void WebGPU__Direct__Color__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Color"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Color",
      "THIS", "WebGPU::Direct::Color");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUColor *n = (WGPUColor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUColor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_double(aTHX_ h, "r", 1,  &n->r, NULL);
  _pack_double(aTHX_ h, "g", 1,  &n->g, NULL);
  _pack_double(aTHX_ h, "b", 1,  &n->b, NULL);
  _pack_double(aTHX_ h, "a", 1,  &n->a, NULL);

  
}

void WebGPU__Direct__Color__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Color"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Color",
      "THIS", "WebGPU::Direct::Color");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUColor *n = (WGPUColor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUColor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_double(aTHX_ h, "r", 1,  &n->r, NULL);
  _unpack_double(aTHX_ h, "g", 1,  &n->g, NULL);
  _unpack_double(aTHX_ h, "b", 1,  &n->b, NULL);
  _unpack_double(aTHX_ h, "a", 1,  &n->a, NULL);

}

SV *WGPUColor__wrap( const WGPUColor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::Color", GV_ADD));
  WebGPU__Direct__Color__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__Color;
void WebGPU__Direct__CommandBufferDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CommandBufferDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CommandBufferDescriptor",
      "THIS", "WebGPU::Direct::CommandBufferDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCommandBufferDescriptor *n = (WGPUCommandBufferDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCommandBufferDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

  
}

void WebGPU__Direct__CommandBufferDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CommandBufferDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CommandBufferDescriptor",
      "THIS", "WebGPU::Direct::CommandBufferDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCommandBufferDescriptor *n = (WGPUCommandBufferDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCommandBufferDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

}

SV *WGPUCommandBufferDescriptor__wrap( const WGPUCommandBufferDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::CommandBufferDescriptor", GV_ADD));
  WebGPU__Direct__CommandBufferDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__CommandBufferDescriptor;
void WebGPU__Direct__CommandEncoderDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CommandEncoderDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CommandEncoderDescriptor",
      "THIS", "WebGPU::Direct::CommandEncoderDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCommandEncoderDescriptor *n = (WGPUCommandEncoderDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCommandEncoderDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

  
}

void WebGPU__Direct__CommandEncoderDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CommandEncoderDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CommandEncoderDescriptor",
      "THIS", "WebGPU::Direct::CommandEncoderDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCommandEncoderDescriptor *n = (WGPUCommandEncoderDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCommandEncoderDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

}

SV *WGPUCommandEncoderDescriptor__wrap( const WGPUCommandEncoderDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::CommandEncoderDescriptor", GV_ADD));
  WebGPU__Direct__CommandEncoderDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__CommandEncoderDescriptor;
void WebGPU__Direct__CompilationMessage__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CompilationMessage"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CompilationMessage",
      "THIS", "WebGPU::Direct::CompilationMessage");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCompilationMessage);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "message", 7,  &n->message, sizeof(n->message), newSVpvs("WebGPU::Direct::StringView"));
  _pack_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::CompilationMessageType"));
  _pack_uint64_t(aTHX_ h, "lineNum", 7,  &n->lineNum, NULL);
  _pack_uint64_t(aTHX_ h, "linePos", 7,  &n->linePos, NULL);
  _pack_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);
  _pack_uint64_t(aTHX_ h, "length", 6,  &n->length, NULL);

  
}

void WebGPU__Direct__CompilationMessage__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CompilationMessage"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CompilationMessage",
      "THIS", "WebGPU::Direct::CompilationMessage");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCompilationMessage);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "message", 7,  &n->message, sizeof(n->message), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::CompilationMessageType"));
  _unpack_uint64_t(aTHX_ h, "lineNum", 7,  &n->lineNum, NULL);
  _unpack_uint64_t(aTHX_ h, "linePos", 7,  &n->linePos, NULL);
  _unpack_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);
  _unpack_uint64_t(aTHX_ h, "length", 6,  &n->length, NULL);

}

SV *WGPUCompilationMessage__wrap( const WGPUCompilationMessage * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::CompilationMessage", GV_ADD));
  WebGPU__Direct__CompilationMessage__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__CompilationMessage;
void WebGPU__Direct__ComputePassTimestampWrites__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ComputePassTimestampWrites"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ComputePassTimestampWrites",
      "THIS", "WebGPU::Direct::ComputePassTimestampWrites");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUComputePassTimestampWrites *n = (WGPUComputePassTimestampWrites *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUComputePassTimestampWrites);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_opaque(aTHX_ h, "querySet", 8, (void **) &n->querySet, newSVpvs("WebGPU::Direct::QuerySet"));
  _pack_uint32_t(aTHX_ h, "beginningOfPassWriteIndex", 25,  &n->beginningOfPassWriteIndex, NULL);
  _pack_uint32_t(aTHX_ h, "endOfPassWriteIndex", 19,  &n->endOfPassWriteIndex, NULL);

  
}

void WebGPU__Direct__ComputePassTimestampWrites__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ComputePassTimestampWrites"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ComputePassTimestampWrites",
      "THIS", "WebGPU::Direct::ComputePassTimestampWrites");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUComputePassTimestampWrites *n = (WGPUComputePassTimestampWrites *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUComputePassTimestampWrites);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_opaque(aTHX_ h, "querySet", 8, (void **) &n->querySet, newSVpvs("WebGPU::Direct::QuerySet"));
  _unpack_uint32_t(aTHX_ h, "beginningOfPassWriteIndex", 25,  &n->beginningOfPassWriteIndex, NULL);
  _unpack_uint32_t(aTHX_ h, "endOfPassWriteIndex", 19,  &n->endOfPassWriteIndex, NULL);

}

SV *WGPUComputePassTimestampWrites__wrap( const WGPUComputePassTimestampWrites * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ComputePassTimestampWrites", GV_ADD));
  WebGPU__Direct__ComputePassTimestampWrites__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ComputePassTimestampWrites;
void WebGPU__Direct__ConstantEntry__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ConstantEntry"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ConstantEntry",
      "THIS", "WebGPU::Direct::ConstantEntry");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUConstantEntry *n = (WGPUConstantEntry *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUConstantEntry);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "key", 3,  &n->key, sizeof(n->key), newSVpvs("WebGPU::Direct::StringView"));
  _pack_double(aTHX_ h, "value", 5,  &n->value, NULL);

  
}

void WebGPU__Direct__ConstantEntry__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ConstantEntry"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ConstantEntry",
      "THIS", "WebGPU::Direct::ConstantEntry");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUConstantEntry *n = (WGPUConstantEntry *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUConstantEntry);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "key", 3,  &n->key, sizeof(n->key), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_double(aTHX_ h, "value", 5,  &n->value, NULL);

}

SV *WGPUConstantEntry__wrap( const WGPUConstantEntry * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ConstantEntry", GV_ADD));
  WebGPU__Direct__ConstantEntry__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ConstantEntry;
void WebGPU__Direct__Extent3D__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Extent3D"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Extent3D",
      "THIS", "WebGPU::Direct::Extent3D");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUExtent3D *n = (WGPUExtent3D *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUExtent3D);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_uint32_t(aTHX_ h, "width", 5,  &n->width, NULL);
  _pack_uint32_t(aTHX_ h, "height", 6,  &n->height, NULL);
  _pack_uint32_t(aTHX_ h, "depthOrArrayLayers", 18,  &n->depthOrArrayLayers, NULL);

  
}

void WebGPU__Direct__Extent3D__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Extent3D"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Extent3D",
      "THIS", "WebGPU::Direct::Extent3D");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUExtent3D *n = (WGPUExtent3D *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUExtent3D);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_uint32_t(aTHX_ h, "width", 5,  &n->width, NULL);
  _unpack_uint32_t(aTHX_ h, "height", 6,  &n->height, NULL);
  _unpack_uint32_t(aTHX_ h, "depthOrArrayLayers", 18,  &n->depthOrArrayLayers, NULL);

}

SV *WGPUExtent3D__wrap( const WGPUExtent3D * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::Extent3D", GV_ADD));
  WebGPU__Direct__Extent3D__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__Extent3D;
void WebGPU__Direct__Future__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Future"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Future",
      "THIS", "WebGPU::Direct::Future");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUFuture *n = (WGPUFuture *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUFuture);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_uint64_t(aTHX_ h, "id", 2,  &n->id, NULL);

  
}

void WebGPU__Direct__Future__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Future"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Future",
      "THIS", "WebGPU::Direct::Future");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUFuture *n = (WGPUFuture *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUFuture);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_uint64_t(aTHX_ h, "id", 2,  &n->id, NULL);

}

SV *WGPUFuture__wrap( const WGPUFuture * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::Future", GV_ADD));
  WebGPU__Direct__Future__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__Future;
void WebGPU__Direct__InstanceCapabilities__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::InstanceCapabilities"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::InstanceCapabilities",
      "THIS", "WebGPU::Direct::InstanceCapabilities");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUInstanceCapabilities *n = (WGPUInstanceCapabilities *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUInstanceCapabilities);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _pack_uint32_t(aTHX_ h, "timedWaitAnyEnable", 18,  &n->timedWaitAnyEnable, NULL);
  _pack_size_t(aTHX_ h, "timedWaitAnyMaxCount", 20,  &n->timedWaitAnyMaxCount, NULL);

  
}

void WebGPU__Direct__InstanceCapabilities__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::InstanceCapabilities"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::InstanceCapabilities",
      "THIS", "WebGPU::Direct::InstanceCapabilities");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUInstanceCapabilities *n = (WGPUInstanceCapabilities *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUInstanceCapabilities);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _unpack_uint32_t(aTHX_ h, "timedWaitAnyEnable", 18,  &n->timedWaitAnyEnable, NULL);
  _unpack_size_t(aTHX_ h, "timedWaitAnyMaxCount", 20,  &n->timedWaitAnyMaxCount, NULL);

}

SV *WGPUInstanceCapabilities__wrap( const WGPUInstanceCapabilities * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::InstanceCapabilities", GV_ADD));
  WebGPU__Direct__InstanceCapabilities__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__InstanceCapabilities;
void WebGPU__Direct__Limits__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Limits"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Limits",
      "THIS", "WebGPU::Direct::Limits");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPULimits);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _pack_uint32_t(aTHX_ h, "maxTextureDimension1D", 21,  &n->maxTextureDimension1D, NULL);
  _pack_uint32_t(aTHX_ h, "maxTextureDimension2D", 21,  &n->maxTextureDimension2D, NULL);
  _pack_uint32_t(aTHX_ h, "maxTextureDimension3D", 21,  &n->maxTextureDimension3D, NULL);
  _pack_uint32_t(aTHX_ h, "maxTextureArrayLayers", 21,  &n->maxTextureArrayLayers, NULL);
  _pack_uint32_t(aTHX_ h, "maxBindGroups", 13,  &n->maxBindGroups, NULL);
  _pack_uint32_t(aTHX_ h, "maxBindGroupsPlusVertexBuffers", 30,  &n->maxBindGroupsPlusVertexBuffers, NULL);
  _pack_uint32_t(aTHX_ h, "maxBindingsPerBindGroup", 23,  &n->maxBindingsPerBindGroup, NULL);
  _pack_uint32_t(aTHX_ h, "maxDynamicUniformBuffersPerPipelineLayout", 41,  &n->maxDynamicUniformBuffersPerPipelineLayout, NULL);
  _pack_uint32_t(aTHX_ h, "maxDynamicStorageBuffersPerPipelineLayout", 41,  &n->maxDynamicStorageBuffersPerPipelineLayout, NULL);
  _pack_uint32_t(aTHX_ h, "maxSampledTexturesPerShaderStage", 32,  &n->maxSampledTexturesPerShaderStage, NULL);
  _pack_uint32_t(aTHX_ h, "maxSamplersPerShaderStage", 25,  &n->maxSamplersPerShaderStage, NULL);
  _pack_uint32_t(aTHX_ h, "maxStorageBuffersPerShaderStage", 31,  &n->maxStorageBuffersPerShaderStage, NULL);
  _pack_uint32_t(aTHX_ h, "maxStorageTexturesPerShaderStage", 32,  &n->maxStorageTexturesPerShaderStage, NULL);
  _pack_uint32_t(aTHX_ h, "maxUniformBuffersPerShaderStage", 31,  &n->maxUniformBuffersPerShaderStage, NULL);
  _pack_uint64_t(aTHX_ h, "maxUniformBufferBindingSize", 27,  &n->maxUniformBufferBindingSize, NULL);
  _pack_uint64_t(aTHX_ h, "maxStorageBufferBindingSize", 27,  &n->maxStorageBufferBindingSize, NULL);
  _pack_uint32_t(aTHX_ h, "minUniformBufferOffsetAlignment", 31,  &n->minUniformBufferOffsetAlignment, NULL);
  _pack_uint32_t(aTHX_ h, "minStorageBufferOffsetAlignment", 31,  &n->minStorageBufferOffsetAlignment, NULL);
  _pack_uint32_t(aTHX_ h, "maxVertexBuffers", 16,  &n->maxVertexBuffers, NULL);
  _pack_uint64_t(aTHX_ h, "maxBufferSize", 13,  &n->maxBufferSize, NULL);
  _pack_uint32_t(aTHX_ h, "maxVertexAttributes", 19,  &n->maxVertexAttributes, NULL);
  _pack_uint32_t(aTHX_ h, "maxVertexBufferArrayStride", 26,  &n->maxVertexBufferArrayStride, NULL);
  _pack_uint32_t(aTHX_ h, "maxInterStageShaderVariables", 28,  &n->maxInterStageShaderVariables, NULL);
  _pack_uint32_t(aTHX_ h, "maxColorAttachments", 19,  &n->maxColorAttachments, NULL);
  _pack_uint32_t(aTHX_ h, "maxColorAttachmentBytesPerSample", 32,  &n->maxColorAttachmentBytesPerSample, NULL);
  _pack_uint32_t(aTHX_ h, "maxComputeWorkgroupStorageSize", 30,  &n->maxComputeWorkgroupStorageSize, NULL);
  _pack_uint32_t(aTHX_ h, "maxComputeInvocationsPerWorkgroup", 33,  &n->maxComputeInvocationsPerWorkgroup, NULL);
  _pack_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeX", 24,  &n->maxComputeWorkgroupSizeX, NULL);
  _pack_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeY", 24,  &n->maxComputeWorkgroupSizeY, NULL);
  _pack_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeZ", 24,  &n->maxComputeWorkgroupSizeZ, NULL);
  _pack_uint32_t(aTHX_ h, "maxComputeWorkgroupsPerDimension", 32,  &n->maxComputeWorkgroupsPerDimension, NULL);

  
}

void WebGPU__Direct__Limits__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Limits"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Limits",
      "THIS", "WebGPU::Direct::Limits");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPULimits);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _unpack_uint32_t(aTHX_ h, "maxTextureDimension1D", 21,  &n->maxTextureDimension1D, NULL);
  _unpack_uint32_t(aTHX_ h, "maxTextureDimension2D", 21,  &n->maxTextureDimension2D, NULL);
  _unpack_uint32_t(aTHX_ h, "maxTextureDimension3D", 21,  &n->maxTextureDimension3D, NULL);
  _unpack_uint32_t(aTHX_ h, "maxTextureArrayLayers", 21,  &n->maxTextureArrayLayers, NULL);
  _unpack_uint32_t(aTHX_ h, "maxBindGroups", 13,  &n->maxBindGroups, NULL);
  _unpack_uint32_t(aTHX_ h, "maxBindGroupsPlusVertexBuffers", 30,  &n->maxBindGroupsPlusVertexBuffers, NULL);
  _unpack_uint32_t(aTHX_ h, "maxBindingsPerBindGroup", 23,  &n->maxBindingsPerBindGroup, NULL);
  _unpack_uint32_t(aTHX_ h, "maxDynamicUniformBuffersPerPipelineLayout", 41,  &n->maxDynamicUniformBuffersPerPipelineLayout, NULL);
  _unpack_uint32_t(aTHX_ h, "maxDynamicStorageBuffersPerPipelineLayout", 41,  &n->maxDynamicStorageBuffersPerPipelineLayout, NULL);
  _unpack_uint32_t(aTHX_ h, "maxSampledTexturesPerShaderStage", 32,  &n->maxSampledTexturesPerShaderStage, NULL);
  _unpack_uint32_t(aTHX_ h, "maxSamplersPerShaderStage", 25,  &n->maxSamplersPerShaderStage, NULL);
  _unpack_uint32_t(aTHX_ h, "maxStorageBuffersPerShaderStage", 31,  &n->maxStorageBuffersPerShaderStage, NULL);
  _unpack_uint32_t(aTHX_ h, "maxStorageTexturesPerShaderStage", 32,  &n->maxStorageTexturesPerShaderStage, NULL);
  _unpack_uint32_t(aTHX_ h, "maxUniformBuffersPerShaderStage", 31,  &n->maxUniformBuffersPerShaderStage, NULL);
  _unpack_uint64_t(aTHX_ h, "maxUniformBufferBindingSize", 27,  &n->maxUniformBufferBindingSize, NULL);
  _unpack_uint64_t(aTHX_ h, "maxStorageBufferBindingSize", 27,  &n->maxStorageBufferBindingSize, NULL);
  _unpack_uint32_t(aTHX_ h, "minUniformBufferOffsetAlignment", 31,  &n->minUniformBufferOffsetAlignment, NULL);
  _unpack_uint32_t(aTHX_ h, "minStorageBufferOffsetAlignment", 31,  &n->minStorageBufferOffsetAlignment, NULL);
  _unpack_uint32_t(aTHX_ h, "maxVertexBuffers", 16,  &n->maxVertexBuffers, NULL);
  _unpack_uint64_t(aTHX_ h, "maxBufferSize", 13,  &n->maxBufferSize, NULL);
  _unpack_uint32_t(aTHX_ h, "maxVertexAttributes", 19,  &n->maxVertexAttributes, NULL);
  _unpack_uint32_t(aTHX_ h, "maxVertexBufferArrayStride", 26,  &n->maxVertexBufferArrayStride, NULL);
  _unpack_uint32_t(aTHX_ h, "maxInterStageShaderVariables", 28,  &n->maxInterStageShaderVariables, NULL);
  _unpack_uint32_t(aTHX_ h, "maxColorAttachments", 19,  &n->maxColorAttachments, NULL);
  _unpack_uint32_t(aTHX_ h, "maxColorAttachmentBytesPerSample", 32,  &n->maxColorAttachmentBytesPerSample, NULL);
  _unpack_uint32_t(aTHX_ h, "maxComputeWorkgroupStorageSize", 30,  &n->maxComputeWorkgroupStorageSize, NULL);
  _unpack_uint32_t(aTHX_ h, "maxComputeInvocationsPerWorkgroup", 33,  &n->maxComputeInvocationsPerWorkgroup, NULL);
  _unpack_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeX", 24,  &n->maxComputeWorkgroupSizeX, NULL);
  _unpack_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeY", 24,  &n->maxComputeWorkgroupSizeY, NULL);
  _unpack_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeZ", 24,  &n->maxComputeWorkgroupSizeZ, NULL);
  _unpack_uint32_t(aTHX_ h, "maxComputeWorkgroupsPerDimension", 32,  &n->maxComputeWorkgroupsPerDimension, NULL);

}

SV *WGPULimits__wrap( const WGPULimits * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::Limits", GV_ADD));
  WebGPU__Direct__Limits__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__Limits;
void WebGPU__Direct__MultisampleState__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::MultisampleState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::MultisampleState",
      "THIS", "WebGPU::Direct::MultisampleState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUMultisampleState *n = (WGPUMultisampleState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUMultisampleState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_uint32_t(aTHX_ h, "count", 5,  &n->count, NULL);
  _pack_uint32_t(aTHX_ h, "mask", 4,  &n->mask, NULL);
  _pack_uint32_t(aTHX_ h, "alphaToCoverageEnabled", 22,  &n->alphaToCoverageEnabled, NULL);

  
}

void WebGPU__Direct__MultisampleState__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::MultisampleState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::MultisampleState",
      "THIS", "WebGPU::Direct::MultisampleState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUMultisampleState *n = (WGPUMultisampleState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUMultisampleState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_uint32_t(aTHX_ h, "count", 5,  &n->count, NULL);
  _unpack_uint32_t(aTHX_ h, "mask", 4,  &n->mask, NULL);
  _unpack_uint32_t(aTHX_ h, "alphaToCoverageEnabled", 22,  &n->alphaToCoverageEnabled, NULL);

}

SV *WGPUMultisampleState__wrap( const WGPUMultisampleState * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::MultisampleState", GV_ADD));
  WebGPU__Direct__MultisampleState__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__MultisampleState;
void WebGPU__Direct__Origin3D__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Origin3D"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Origin3D",
      "THIS", "WebGPU::Direct::Origin3D");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUOrigin3D *n = (WGPUOrigin3D *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUOrigin3D);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_uint32_t(aTHX_ h, "x", 1,  &n->x, NULL);
  _pack_uint32_t(aTHX_ h, "y", 1,  &n->y, NULL);
  _pack_uint32_t(aTHX_ h, "z", 1,  &n->z, NULL);

  
}

void WebGPU__Direct__Origin3D__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::Origin3D"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::Origin3D",
      "THIS", "WebGPU::Direct::Origin3D");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUOrigin3D *n = (WGPUOrigin3D *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUOrigin3D);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_uint32_t(aTHX_ h, "x", 1,  &n->x, NULL);
  _unpack_uint32_t(aTHX_ h, "y", 1,  &n->y, NULL);
  _unpack_uint32_t(aTHX_ h, "z", 1,  &n->z, NULL);

}

SV *WGPUOrigin3D__wrap( const WGPUOrigin3D * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::Origin3D", GV_ADD));
  WebGPU__Direct__Origin3D__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__Origin3D;
void WebGPU__Direct__PipelineLayoutDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::PipelineLayoutDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::PipelineLayoutDescriptor",
      "THIS", "WebGPU::Direct::PipelineLayoutDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUPipelineLayoutDescriptor *n = (WGPUPipelineLayoutDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUPipelineLayoutDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objarray(aTHX_ h, "bindGroupLayouts", 16, (void **) &n->bindGroupLayouts, &n->bindGroupLayoutCount, sizeof(*n->bindGroupLayouts), newSVpvs("WebGPU::Direct::BindGroupLayout"));

  
}

void WebGPU__Direct__PipelineLayoutDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::PipelineLayoutDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::PipelineLayoutDescriptor",
      "THIS", "WebGPU::Direct::PipelineLayoutDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUPipelineLayoutDescriptor *n = (WGPUPipelineLayoutDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUPipelineLayoutDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_size_t(aTHX_ h, "bindGroupLayoutCount", 20,  &n->bindGroupLayoutCount, NULL);
  _unpack_objarray(aTHX_ h, "bindGroupLayouts", 16, (void **) &n->bindGroupLayouts, &n->bindGroupLayoutCount, sizeof(*n->bindGroupLayouts), newSVpvs("WebGPU::Direct::BindGroupLayout"));

}

SV *WGPUPipelineLayoutDescriptor__wrap( const WGPUPipelineLayoutDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::PipelineLayoutDescriptor", GV_ADD));
  WebGPU__Direct__PipelineLayoutDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__PipelineLayoutDescriptor;
void WebGPU__Direct__PrimitiveState__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::PrimitiveState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::PrimitiveState",
      "THIS", "WebGPU::Direct::PrimitiveState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUPrimitiveState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "topology", 8,  &n->topology, newSVpvs("WebGPU::Direct::PrimitiveTopology"));
  _pack_enum(aTHX_ h, "stripIndexFormat", 16,  &n->stripIndexFormat, newSVpvs("WebGPU::Direct::IndexFormat"));
  _pack_enum(aTHX_ h, "frontFace", 9,  &n->frontFace, newSVpvs("WebGPU::Direct::FrontFace"));
  _pack_enum(aTHX_ h, "cullMode", 8,  &n->cullMode, newSVpvs("WebGPU::Direct::CullMode"));
  _pack_uint32_t(aTHX_ h, "unclippedDepth", 14,  &n->unclippedDepth, NULL);

  
}

void WebGPU__Direct__PrimitiveState__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::PrimitiveState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::PrimitiveState",
      "THIS", "WebGPU::Direct::PrimitiveState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUPrimitiveState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "topology", 8,  &n->topology, newSVpvs("WebGPU::Direct::PrimitiveTopology"));
  _unpack_enum(aTHX_ h, "stripIndexFormat", 16,  &n->stripIndexFormat, newSVpvs("WebGPU::Direct::IndexFormat"));
  _unpack_enum(aTHX_ h, "frontFace", 9,  &n->frontFace, newSVpvs("WebGPU::Direct::FrontFace"));
  _unpack_enum(aTHX_ h, "cullMode", 8,  &n->cullMode, newSVpvs("WebGPU::Direct::CullMode"));
  _unpack_uint32_t(aTHX_ h, "unclippedDepth", 14,  &n->unclippedDepth, NULL);

}

SV *WGPUPrimitiveState__wrap( const WGPUPrimitiveState * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::PrimitiveState", GV_ADD));
  WebGPU__Direct__PrimitiveState__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__PrimitiveState;
void WebGPU__Direct__QuerySetDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::QuerySetDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::QuerySetDescriptor",
      "THIS", "WebGPU::Direct::QuerySetDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUQuerySetDescriptor *n = (WGPUQuerySetDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUQuerySetDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::QueryType"));
  _pack_uint32_t(aTHX_ h, "count", 5,  &n->count, NULL);

  
}

void WebGPU__Direct__QuerySetDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::QuerySetDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::QuerySetDescriptor",
      "THIS", "WebGPU::Direct::QuerySetDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUQuerySetDescriptor *n = (WGPUQuerySetDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUQuerySetDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::QueryType"));
  _unpack_uint32_t(aTHX_ h, "count", 5,  &n->count, NULL);

}

SV *WGPUQuerySetDescriptor__wrap( const WGPUQuerySetDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::QuerySetDescriptor", GV_ADD));
  WebGPU__Direct__QuerySetDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__QuerySetDescriptor;
void WebGPU__Direct__QueueDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::QueueDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::QueueDescriptor",
      "THIS", "WebGPU::Direct::QueueDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUQueueDescriptor *n = (WGPUQueueDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUQueueDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

  
}

void WebGPU__Direct__QueueDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::QueueDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::QueueDescriptor",
      "THIS", "WebGPU::Direct::QueueDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUQueueDescriptor *n = (WGPUQueueDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUQueueDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

}

SV *WGPUQueueDescriptor__wrap( const WGPUQueueDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::QueueDescriptor", GV_ADD));
  WebGPU__Direct__QueueDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__QueueDescriptor;
void WebGPU__Direct__RenderBundleDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderBundleDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderBundleDescriptor",
      "THIS", "WebGPU::Direct::RenderBundleDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderBundleDescriptor *n = (WGPURenderBundleDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderBundleDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

  
}

void WebGPU__Direct__RenderBundleDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderBundleDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderBundleDescriptor",
      "THIS", "WebGPU::Direct::RenderBundleDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderBundleDescriptor *n = (WGPURenderBundleDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderBundleDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

}

SV *WGPURenderBundleDescriptor__wrap( const WGPURenderBundleDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RenderBundleDescriptor", GV_ADD));
  WebGPU__Direct__RenderBundleDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RenderBundleDescriptor;
void WebGPU__Direct__RenderBundleEncoderDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderBundleEncoderDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderBundleEncoderDescriptor",
      "THIS", "WebGPU::Direct::RenderBundleEncoderDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderBundleEncoderDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objarray(aTHX_ h, "colorFormats", 12, (void **) &n->colorFormats, &n->colorFormatCount, sizeof(*n->colorFormats), newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_enum(aTHX_ h, "depthStencilFormat", 18,  &n->depthStencilFormat, newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_uint32_t(aTHX_ h, "sampleCount", 11,  &n->sampleCount, NULL);
  _pack_uint32_t(aTHX_ h, "depthReadOnly", 13,  &n->depthReadOnly, NULL);
  _pack_uint32_t(aTHX_ h, "stencilReadOnly", 15,  &n->stencilReadOnly, NULL);

  
}

void WebGPU__Direct__RenderBundleEncoderDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderBundleEncoderDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderBundleEncoderDescriptor",
      "THIS", "WebGPU::Direct::RenderBundleEncoderDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderBundleEncoderDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_size_t(aTHX_ h, "colorFormatCount", 16,  &n->colorFormatCount, NULL);
  _unpack_objarray(aTHX_ h, "colorFormats", 12, (void **) &n->colorFormats, &n->colorFormatCount, sizeof(*n->colorFormats), newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_enum(aTHX_ h, "depthStencilFormat", 18,  &n->depthStencilFormat, newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_uint32_t(aTHX_ h, "sampleCount", 11,  &n->sampleCount, NULL);
  _unpack_uint32_t(aTHX_ h, "depthReadOnly", 13,  &n->depthReadOnly, NULL);
  _unpack_uint32_t(aTHX_ h, "stencilReadOnly", 15,  &n->stencilReadOnly, NULL);

}

SV *WGPURenderBundleEncoderDescriptor__wrap( const WGPURenderBundleEncoderDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RenderBundleEncoderDescriptor", GV_ADD));
  WebGPU__Direct__RenderBundleEncoderDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RenderBundleEncoderDescriptor;
void WebGPU__Direct__RenderPassDepthStencilAttachment__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassDepthStencilAttachment"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassDepthStencilAttachment",
      "THIS", "WebGPU::Direct::RenderPassDepthStencilAttachment");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassDepthStencilAttachment);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_opaque(aTHX_ h, "view", 4, (void **) &n->view, newSVpvs("WebGPU::Direct::TextureView"));
  _pack_enum(aTHX_ h, "depthLoadOp", 11,  &n->depthLoadOp, newSVpvs("WebGPU::Direct::LoadOp"));
  _pack_enum(aTHX_ h, "depthStoreOp", 12,  &n->depthStoreOp, newSVpvs("WebGPU::Direct::StoreOp"));
  _pack_float(aTHX_ h, "depthClearValue", 15,  &n->depthClearValue, NULL);
  _pack_uint32_t(aTHX_ h, "depthReadOnly", 13,  &n->depthReadOnly, NULL);
  _pack_enum(aTHX_ h, "stencilLoadOp", 13,  &n->stencilLoadOp, newSVpvs("WebGPU::Direct::LoadOp"));
  _pack_enum(aTHX_ h, "stencilStoreOp", 14,  &n->stencilStoreOp, newSVpvs("WebGPU::Direct::StoreOp"));
  _pack_uint32_t(aTHX_ h, "stencilClearValue", 17,  &n->stencilClearValue, NULL);
  _pack_uint32_t(aTHX_ h, "stencilReadOnly", 15,  &n->stencilReadOnly, NULL);

  
}

void WebGPU__Direct__RenderPassDepthStencilAttachment__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassDepthStencilAttachment"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassDepthStencilAttachment",
      "THIS", "WebGPU::Direct::RenderPassDepthStencilAttachment");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassDepthStencilAttachment);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_opaque(aTHX_ h, "view", 4, (void **) &n->view, newSVpvs("WebGPU::Direct::TextureView"));
  _unpack_enum(aTHX_ h, "depthLoadOp", 11,  &n->depthLoadOp, newSVpvs("WebGPU::Direct::LoadOp"));
  _unpack_enum(aTHX_ h, "depthStoreOp", 12,  &n->depthStoreOp, newSVpvs("WebGPU::Direct::StoreOp"));
  _unpack_float(aTHX_ h, "depthClearValue", 15,  &n->depthClearValue, NULL);
  _unpack_uint32_t(aTHX_ h, "depthReadOnly", 13,  &n->depthReadOnly, NULL);
  _unpack_enum(aTHX_ h, "stencilLoadOp", 13,  &n->stencilLoadOp, newSVpvs("WebGPU::Direct::LoadOp"));
  _unpack_enum(aTHX_ h, "stencilStoreOp", 14,  &n->stencilStoreOp, newSVpvs("WebGPU::Direct::StoreOp"));
  _unpack_uint32_t(aTHX_ h, "stencilClearValue", 17,  &n->stencilClearValue, NULL);
  _unpack_uint32_t(aTHX_ h, "stencilReadOnly", 15,  &n->stencilReadOnly, NULL);

}

SV *WGPURenderPassDepthStencilAttachment__wrap( const WGPURenderPassDepthStencilAttachment * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RenderPassDepthStencilAttachment", GV_ADD));
  WebGPU__Direct__RenderPassDepthStencilAttachment__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RenderPassDepthStencilAttachment;
void WebGPU__Direct__RenderPassMaxDrawCount__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassMaxDrawCount"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassMaxDrawCount",
      "THIS", "WebGPU::Direct::RenderPassMaxDrawCount");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassMaxDrawCount *n = (WGPURenderPassMaxDrawCount *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassMaxDrawCount);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_uint64_t(aTHX_ h, "maxDrawCount", 12,  &n->maxDrawCount, NULL);

  
}

void WebGPU__Direct__RenderPassMaxDrawCount__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassMaxDrawCount"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassMaxDrawCount",
      "THIS", "WebGPU::Direct::RenderPassMaxDrawCount");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassMaxDrawCount *n = (WGPURenderPassMaxDrawCount *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassMaxDrawCount);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_uint64_t(aTHX_ h, "maxDrawCount", 12,  &n->maxDrawCount, NULL);

}

SV *WGPURenderPassMaxDrawCount__wrap( const WGPURenderPassMaxDrawCount * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RenderPassMaxDrawCount", GV_ADD));
  WebGPU__Direct__RenderPassMaxDrawCount__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RenderPassMaxDrawCount;
void WebGPU__Direct__RenderPassTimestampWrites__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassTimestampWrites"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassTimestampWrites",
      "THIS", "WebGPU::Direct::RenderPassTimestampWrites");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassTimestampWrites *n = (WGPURenderPassTimestampWrites *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassTimestampWrites);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_opaque(aTHX_ h, "querySet", 8, (void **) &n->querySet, newSVpvs("WebGPU::Direct::QuerySet"));
  _pack_uint32_t(aTHX_ h, "beginningOfPassWriteIndex", 25,  &n->beginningOfPassWriteIndex, NULL);
  _pack_uint32_t(aTHX_ h, "endOfPassWriteIndex", 19,  &n->endOfPassWriteIndex, NULL);

  
}

void WebGPU__Direct__RenderPassTimestampWrites__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassTimestampWrites"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassTimestampWrites",
      "THIS", "WebGPU::Direct::RenderPassTimestampWrites");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassTimestampWrites *n = (WGPURenderPassTimestampWrites *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassTimestampWrites);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_opaque(aTHX_ h, "querySet", 8, (void **) &n->querySet, newSVpvs("WebGPU::Direct::QuerySet"));
  _unpack_uint32_t(aTHX_ h, "beginningOfPassWriteIndex", 25,  &n->beginningOfPassWriteIndex, NULL);
  _unpack_uint32_t(aTHX_ h, "endOfPassWriteIndex", 19,  &n->endOfPassWriteIndex, NULL);

}

SV *WGPURenderPassTimestampWrites__wrap( const WGPURenderPassTimestampWrites * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RenderPassTimestampWrites", GV_ADD));
  WebGPU__Direct__RenderPassTimestampWrites__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RenderPassTimestampWrites;
void WebGPU__Direct__RequestAdapterOptions__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RequestAdapterOptions"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RequestAdapterOptions",
      "THIS", "WebGPU::Direct::RequestAdapterOptions");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURequestAdapterOptions);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "featureLevel", 12,  &n->featureLevel, newSVpvs("WebGPU::Direct::FeatureLevel"));
  _pack_enum(aTHX_ h, "powerPreference", 15,  &n->powerPreference, newSVpvs("WebGPU::Direct::PowerPreference"));
  _pack_uint32_t(aTHX_ h, "forceFallbackAdapter", 20,  &n->forceFallbackAdapter, NULL);
  _pack_enum(aTHX_ h, "backendType", 11,  &n->backendType, newSVpvs("WebGPU::Direct::BackendType"));
  _pack_opaque(aTHX_ h, "compatibleSurface", 17, (void **) &n->compatibleSurface, newSVpvs("WebGPU::Direct::Surface"));

  
}

void WebGPU__Direct__RequestAdapterOptions__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RequestAdapterOptions"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RequestAdapterOptions",
      "THIS", "WebGPU::Direct::RequestAdapterOptions");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURequestAdapterOptions);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "featureLevel", 12,  &n->featureLevel, newSVpvs("WebGPU::Direct::FeatureLevel"));
  _unpack_enum(aTHX_ h, "powerPreference", 15,  &n->powerPreference, newSVpvs("WebGPU::Direct::PowerPreference"));
  _unpack_uint32_t(aTHX_ h, "forceFallbackAdapter", 20,  &n->forceFallbackAdapter, NULL);
  _unpack_enum(aTHX_ h, "backendType", 11,  &n->backendType, newSVpvs("WebGPU::Direct::BackendType"));
  _unpack_opaque(aTHX_ h, "compatibleSurface", 17, (void **) &n->compatibleSurface, newSVpvs("WebGPU::Direct::Surface"));

}

SV *WGPURequestAdapterOptions__wrap( const WGPURequestAdapterOptions * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RequestAdapterOptions", GV_ADD));
  WebGPU__Direct__RequestAdapterOptions__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RequestAdapterOptions;
void WebGPU__Direct__SamplerBindingLayout__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SamplerBindingLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SamplerBindingLayout",
      "THIS", "WebGPU::Direct::SamplerBindingLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSamplerBindingLayout *n = (WGPUSamplerBindingLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSamplerBindingLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::SamplerBindingType"));

  
}

void WebGPU__Direct__SamplerBindingLayout__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SamplerBindingLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SamplerBindingLayout",
      "THIS", "WebGPU::Direct::SamplerBindingLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSamplerBindingLayout *n = (WGPUSamplerBindingLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSamplerBindingLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::SamplerBindingType"));

}

SV *WGPUSamplerBindingLayout__wrap( const WGPUSamplerBindingLayout * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SamplerBindingLayout", GV_ADD));
  WebGPU__Direct__SamplerBindingLayout__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SamplerBindingLayout;
void WebGPU__Direct__SamplerDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SamplerDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SamplerDescriptor",
      "THIS", "WebGPU::Direct::SamplerDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSamplerDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_enum(aTHX_ h, "addressModeU", 12,  &n->addressModeU, newSVpvs("WebGPU::Direct::AddressMode"));
  _pack_enum(aTHX_ h, "addressModeV", 12,  &n->addressModeV, newSVpvs("WebGPU::Direct::AddressMode"));
  _pack_enum(aTHX_ h, "addressModeW", 12,  &n->addressModeW, newSVpvs("WebGPU::Direct::AddressMode"));
  _pack_enum(aTHX_ h, "magFilter", 9,  &n->magFilter, newSVpvs("WebGPU::Direct::FilterMode"));
  _pack_enum(aTHX_ h, "minFilter", 9,  &n->minFilter, newSVpvs("WebGPU::Direct::FilterMode"));
  _pack_enum(aTHX_ h, "mipmapFilter", 12,  &n->mipmapFilter, newSVpvs("WebGPU::Direct::MipmapFilterMode"));
  _pack_float(aTHX_ h, "lodMinClamp", 11,  &n->lodMinClamp, NULL);
  _pack_float(aTHX_ h, "lodMaxClamp", 11,  &n->lodMaxClamp, NULL);
  _pack_enum(aTHX_ h, "compare", 7,  &n->compare, newSVpvs("WebGPU::Direct::CompareFunction"));
  _pack_uint16_t(aTHX_ h, "maxAnisotropy", 13,  &n->maxAnisotropy, NULL);

  
}

void WebGPU__Direct__SamplerDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SamplerDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SamplerDescriptor",
      "THIS", "WebGPU::Direct::SamplerDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSamplerDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_enum(aTHX_ h, "addressModeU", 12,  &n->addressModeU, newSVpvs("WebGPU::Direct::AddressMode"));
  _unpack_enum(aTHX_ h, "addressModeV", 12,  &n->addressModeV, newSVpvs("WebGPU::Direct::AddressMode"));
  _unpack_enum(aTHX_ h, "addressModeW", 12,  &n->addressModeW, newSVpvs("WebGPU::Direct::AddressMode"));
  _unpack_enum(aTHX_ h, "magFilter", 9,  &n->magFilter, newSVpvs("WebGPU::Direct::FilterMode"));
  _unpack_enum(aTHX_ h, "minFilter", 9,  &n->minFilter, newSVpvs("WebGPU::Direct::FilterMode"));
  _unpack_enum(aTHX_ h, "mipmapFilter", 12,  &n->mipmapFilter, newSVpvs("WebGPU::Direct::MipmapFilterMode"));
  _unpack_float(aTHX_ h, "lodMinClamp", 11,  &n->lodMinClamp, NULL);
  _unpack_float(aTHX_ h, "lodMaxClamp", 11,  &n->lodMaxClamp, NULL);
  _unpack_enum(aTHX_ h, "compare", 7,  &n->compare, newSVpvs("WebGPU::Direct::CompareFunction"));
  _unpack_uint16_t(aTHX_ h, "maxAnisotropy", 13,  &n->maxAnisotropy, NULL);

}

SV *WGPUSamplerDescriptor__wrap( const WGPUSamplerDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SamplerDescriptor", GV_ADD));
  WebGPU__Direct__SamplerDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SamplerDescriptor;
void WebGPU__Direct__ShaderModuleDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ShaderModuleDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ShaderModuleDescriptor",
      "THIS", "WebGPU::Direct::ShaderModuleDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUShaderModuleDescriptor *n = (WGPUShaderModuleDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUShaderModuleDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

  
}

void WebGPU__Direct__ShaderModuleDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ShaderModuleDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ShaderModuleDescriptor",
      "THIS", "WebGPU::Direct::ShaderModuleDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUShaderModuleDescriptor *n = (WGPUShaderModuleDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUShaderModuleDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

}

SV *WGPUShaderModuleDescriptor__wrap( const WGPUShaderModuleDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ShaderModuleDescriptor", GV_ADD));
  WebGPU__Direct__ShaderModuleDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ShaderModuleDescriptor;
void WebGPU__Direct__ShaderSourceSPIRV__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ShaderSourceSPIRV"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ShaderSourceSPIRV",
      "THIS", "WebGPU::Direct::ShaderSourceSPIRV");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUShaderSourceSPIRV *n = (WGPUShaderSourceSPIRV *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUShaderSourceSPIRV);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_uint32_t(aTHX_ h, "codeSize", 8,  &n->codeSize, NULL);
  // "code" is a ptr type uint32_t, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "code", 4, (void **) &n->code, NULL);

  
}

void WebGPU__Direct__ShaderSourceSPIRV__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ShaderSourceSPIRV"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ShaderSourceSPIRV",
      "THIS", "WebGPU::Direct::ShaderSourceSPIRV");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUShaderSourceSPIRV *n = (WGPUShaderSourceSPIRV *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUShaderSourceSPIRV);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_uint32_t(aTHX_ h, "codeSize", 8,  &n->codeSize, NULL);
  // "code" is a ptr type uint32_t, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "code", 4, (void **) &n->code, NULL);

}

SV *WGPUShaderSourceSPIRV__wrap( const WGPUShaderSourceSPIRV * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ShaderSourceSPIRV", GV_ADD));
  WebGPU__Direct__ShaderSourceSPIRV__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ShaderSourceSPIRV;
void WebGPU__Direct__ShaderSourceWGSL__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ShaderSourceWGSL"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ShaderSourceWGSL",
      "THIS", "WebGPU::Direct::ShaderSourceWGSL");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUShaderSourceWGSL *n = (WGPUShaderSourceWGSL *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUShaderSourceWGSL);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "code", 4,  &n->code, sizeof(n->code), newSVpvs("WebGPU::Direct::StringView"));

  
}

void WebGPU__Direct__ShaderSourceWGSL__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ShaderSourceWGSL"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ShaderSourceWGSL",
      "THIS", "WebGPU::Direct::ShaderSourceWGSL");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUShaderSourceWGSL *n = (WGPUShaderSourceWGSL *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUShaderSourceWGSL);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "code", 4,  &n->code, sizeof(n->code), newSVpvs("WebGPU::Direct::StringView"));

}

SV *WGPUShaderSourceWGSL__wrap( const WGPUShaderSourceWGSL * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ShaderSourceWGSL", GV_ADD));
  WebGPU__Direct__ShaderSourceWGSL__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ShaderSourceWGSL;
void WebGPU__Direct__StencilFaceState__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::StencilFaceState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::StencilFaceState",
      "THIS", "WebGPU::Direct::StencilFaceState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUStencilFaceState *n = (WGPUStencilFaceState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUStencilFaceState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_enum(aTHX_ h, "compare", 7,  &n->compare, newSVpvs("WebGPU::Direct::CompareFunction"));
  _pack_enum(aTHX_ h, "failOp", 6,  &n->failOp, newSVpvs("WebGPU::Direct::StencilOperation"));
  _pack_enum(aTHX_ h, "depthFailOp", 11,  &n->depthFailOp, newSVpvs("WebGPU::Direct::StencilOperation"));
  _pack_enum(aTHX_ h, "passOp", 6,  &n->passOp, newSVpvs("WebGPU::Direct::StencilOperation"));

  
}

void WebGPU__Direct__StencilFaceState__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::StencilFaceState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::StencilFaceState",
      "THIS", "WebGPU::Direct::StencilFaceState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUStencilFaceState *n = (WGPUStencilFaceState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUStencilFaceState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_enum(aTHX_ h, "compare", 7,  &n->compare, newSVpvs("WebGPU::Direct::CompareFunction"));
  _unpack_enum(aTHX_ h, "failOp", 6,  &n->failOp, newSVpvs("WebGPU::Direct::StencilOperation"));
  _unpack_enum(aTHX_ h, "depthFailOp", 11,  &n->depthFailOp, newSVpvs("WebGPU::Direct::StencilOperation"));
  _unpack_enum(aTHX_ h, "passOp", 6,  &n->passOp, newSVpvs("WebGPU::Direct::StencilOperation"));

}

SV *WGPUStencilFaceState__wrap( const WGPUStencilFaceState * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::StencilFaceState", GV_ADD));
  WebGPU__Direct__StencilFaceState__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__StencilFaceState;
void WebGPU__Direct__StorageTextureBindingLayout__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::StorageTextureBindingLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::StorageTextureBindingLayout",
      "THIS", "WebGPU::Direct::StorageTextureBindingLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUStorageTextureBindingLayout *n = (WGPUStorageTextureBindingLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUStorageTextureBindingLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "access", 6,  &n->access, newSVpvs("WebGPU::Direct::StorageTextureAccess"));
  _pack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_enum(aTHX_ h, "viewDimension", 13,  &n->viewDimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));

  
}

void WebGPU__Direct__StorageTextureBindingLayout__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::StorageTextureBindingLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::StorageTextureBindingLayout",
      "THIS", "WebGPU::Direct::StorageTextureBindingLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUStorageTextureBindingLayout *n = (WGPUStorageTextureBindingLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUStorageTextureBindingLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "access", 6,  &n->access, newSVpvs("WebGPU::Direct::StorageTextureAccess"));
  _unpack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_enum(aTHX_ h, "viewDimension", 13,  &n->viewDimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));

}

SV *WGPUStorageTextureBindingLayout__wrap( const WGPUStorageTextureBindingLayout * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::StorageTextureBindingLayout", GV_ADD));
  WebGPU__Direct__StorageTextureBindingLayout__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__StorageTextureBindingLayout;
void WebGPU__Direct__SupportedFeatures__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SupportedFeatures"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SupportedFeatures",
      "THIS", "WebGPU::Direct::SupportedFeatures");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSupportedFeatures *n = (WGPUSupportedFeatures *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSupportedFeatures);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objarray(aTHX_ h, "features", 8, (void **) &n->features, &n->featureCount, sizeof(*n->features), newSVpvs("WebGPU::Direct::FeatureName"));

  
}

void WebGPU__Direct__SupportedFeatures__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SupportedFeatures"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SupportedFeatures",
      "THIS", "WebGPU::Direct::SupportedFeatures");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSupportedFeatures *n = (WGPUSupportedFeatures *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSupportedFeatures);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_size_t(aTHX_ h, "featureCount", 12,  &n->featureCount, NULL);
  _unpack_objarray(aTHX_ h, "features", 8, (void **) &n->features, &n->featureCount, sizeof(*n->features), newSVpvs("WebGPU::Direct::FeatureName"));

}

SV *WGPUSupportedFeatures__wrap( const WGPUSupportedFeatures * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SupportedFeatures", GV_ADD));
  WebGPU__Direct__SupportedFeatures__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SupportedFeatures;
void WebGPU__Direct__SupportedWGSLLanguageFeatures__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SupportedWGSLLanguageFeatures"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SupportedWGSLLanguageFeatures",
      "THIS", "WebGPU::Direct::SupportedWGSLLanguageFeatures");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSupportedWGSLLanguageFeatures *n = (WGPUSupportedWGSLLanguageFeatures *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSupportedWGSLLanguageFeatures);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objarray(aTHX_ h, "features", 8, (void **) &n->features, &n->featureCount, sizeof(*n->features), newSVpvs("WebGPU::Direct::WGSLLanguageFeatureName"));

  
}

void WebGPU__Direct__SupportedWGSLLanguageFeatures__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SupportedWGSLLanguageFeatures"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SupportedWGSLLanguageFeatures",
      "THIS", "WebGPU::Direct::SupportedWGSLLanguageFeatures");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSupportedWGSLLanguageFeatures *n = (WGPUSupportedWGSLLanguageFeatures *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSupportedWGSLLanguageFeatures);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_size_t(aTHX_ h, "featureCount", 12,  &n->featureCount, NULL);
  _unpack_objarray(aTHX_ h, "features", 8, (void **) &n->features, &n->featureCount, sizeof(*n->features), newSVpvs("WebGPU::Direct::WGSLLanguageFeatureName"));

}

SV *WGPUSupportedWGSLLanguageFeatures__wrap( const WGPUSupportedWGSLLanguageFeatures * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SupportedWGSLLanguageFeatures", GV_ADD));
  WebGPU__Direct__SupportedWGSLLanguageFeatures__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SupportedWGSLLanguageFeatures;
void WebGPU__Direct__SurfaceCapabilities__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceCapabilities"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceCapabilities",
      "THIS", "WebGPU::Direct::SurfaceCapabilities");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceCapabilities);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _pack_flag(aTHX_ h, "usages", 6,  &n->usages, newSVpvs("WebGPU::Direct::TextureUsage"));
  _pack_objarray(aTHX_ h, "formats", 7, (void **) &n->formats, &n->formatCount, sizeof(*n->formats), newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_objarray(aTHX_ h, "presentModes", 12, (void **) &n->presentModes, &n->presentModeCount, sizeof(*n->presentModes), newSVpvs("WebGPU::Direct::PresentMode"));
  _pack_objarray(aTHX_ h, "alphaModes", 10, (void **) &n->alphaModes, &n->alphaModeCount, sizeof(*n->alphaModes), newSVpvs("WebGPU::Direct::CompositeAlphaMode"));

  
}

void WebGPU__Direct__SurfaceCapabilities__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceCapabilities"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceCapabilities",
      "THIS", "WebGPU::Direct::SurfaceCapabilities");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceCapabilities);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _unpack_flag(aTHX_ h, "usages", 6,  &n->usages, newSVpvs("WebGPU::Direct::TextureUsage"));
  _unpack_size_t(aTHX_ h, "formatCount", 11,  &n->formatCount, NULL);
  _unpack_objarray(aTHX_ h, "formats", 7, (void **) &n->formats, &n->formatCount, sizeof(*n->formats), newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_size_t(aTHX_ h, "presentModeCount", 16,  &n->presentModeCount, NULL);
  _unpack_objarray(aTHX_ h, "presentModes", 12, (void **) &n->presentModes, &n->presentModeCount, sizeof(*n->presentModes), newSVpvs("WebGPU::Direct::PresentMode"));
  _unpack_size_t(aTHX_ h, "alphaModeCount", 14,  &n->alphaModeCount, NULL);
  _unpack_objarray(aTHX_ h, "alphaModes", 10, (void **) &n->alphaModes, &n->alphaModeCount, sizeof(*n->alphaModes), newSVpvs("WebGPU::Direct::CompositeAlphaMode"));

}

SV *WGPUSurfaceCapabilities__wrap( const WGPUSurfaceCapabilities * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceCapabilities", GV_ADD));
  WebGPU__Direct__SurfaceCapabilities__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceCapabilities;
void WebGPU__Direct__SurfaceConfiguration__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceConfiguration"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceConfiguration",
      "THIS", "WebGPU::Direct::SurfaceConfiguration");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceConfiguration);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_opaque(aTHX_ h, "device", 6, (void **) &n->device, newSVpvs("WebGPU::Direct::Device"));
  _pack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));
  _pack_uint32_t(aTHX_ h, "width", 5,  &n->width, NULL);
  _pack_uint32_t(aTHX_ h, "height", 6,  &n->height, NULL);
  _pack_objarray(aTHX_ h, "viewFormats", 11, (void **) &n->viewFormats, &n->viewFormatCount, sizeof(*n->viewFormats), newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_enum(aTHX_ h, "alphaMode", 9,  &n->alphaMode, newSVpvs("WebGPU::Direct::CompositeAlphaMode"));
  _pack_enum(aTHX_ h, "presentMode", 11,  &n->presentMode, newSVpvs("WebGPU::Direct::PresentMode"));

  
}

void WebGPU__Direct__SurfaceConfiguration__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceConfiguration"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceConfiguration",
      "THIS", "WebGPU::Direct::SurfaceConfiguration");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceConfiguration);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_opaque(aTHX_ h, "device", 6, (void **) &n->device, newSVpvs("WebGPU::Direct::Device"));
  _unpack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));
  _unpack_uint32_t(aTHX_ h, "width", 5,  &n->width, NULL);
  _unpack_uint32_t(aTHX_ h, "height", 6,  &n->height, NULL);
  _unpack_size_t(aTHX_ h, "viewFormatCount", 15,  &n->viewFormatCount, NULL);
  _unpack_objarray(aTHX_ h, "viewFormats", 11, (void **) &n->viewFormats, &n->viewFormatCount, sizeof(*n->viewFormats), newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_enum(aTHX_ h, "alphaMode", 9,  &n->alphaMode, newSVpvs("WebGPU::Direct::CompositeAlphaMode"));
  _unpack_enum(aTHX_ h, "presentMode", 11,  &n->presentMode, newSVpvs("WebGPU::Direct::PresentMode"));

}

SV *WGPUSurfaceConfiguration__wrap( const WGPUSurfaceConfiguration * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceConfiguration", GV_ADD));
  WebGPU__Direct__SurfaceConfiguration__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceConfiguration;
void WebGPU__Direct__SurfaceDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceDescriptor",
      "THIS", "WebGPU::Direct::SurfaceDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceDescriptor *n = (WGPUSurfaceDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

  
}

void WebGPU__Direct__SurfaceDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceDescriptor",
      "THIS", "WebGPU::Direct::SurfaceDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceDescriptor *n = (WGPUSurfaceDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

}

SV *WGPUSurfaceDescriptor__wrap( const WGPUSurfaceDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceDescriptor", GV_ADD));
  WebGPU__Direct__SurfaceDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceDescriptor;
void WebGPU__Direct__SurfaceSourceAndroidNativeWindow__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceAndroidNativeWindow"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceAndroidNativeWindow",
      "THIS", "WebGPU::Direct::SurfaceSourceAndroidNativeWindow");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceAndroidNativeWindow *n = (WGPUSurfaceSourceAndroidNativeWindow *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceAndroidNativeWindow);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "window" is a ptr type void, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "window", 6, (void **) &n->window, NULL);

  
}

void WebGPU__Direct__SurfaceSourceAndroidNativeWindow__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceAndroidNativeWindow"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceAndroidNativeWindow",
      "THIS", "WebGPU::Direct::SurfaceSourceAndroidNativeWindow");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceAndroidNativeWindow *n = (WGPUSurfaceSourceAndroidNativeWindow *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceAndroidNativeWindow);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "window" is a ptr type void, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "window", 6, (void **) &n->window, NULL);

}

SV *WGPUSurfaceSourceAndroidNativeWindow__wrap( const WGPUSurfaceSourceAndroidNativeWindow * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceSourceAndroidNativeWindow", GV_ADD));
  WebGPU__Direct__SurfaceSourceAndroidNativeWindow__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceSourceAndroidNativeWindow;
void WebGPU__Direct__SurfaceSourceMetalLayer__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceMetalLayer"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceMetalLayer",
      "THIS", "WebGPU::Direct::SurfaceSourceMetalLayer");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceMetalLayer *n = (WGPUSurfaceSourceMetalLayer *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceMetalLayer);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "layer" is a ptr type void, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "layer", 5, (void **) &n->layer, NULL);

  
}

void WebGPU__Direct__SurfaceSourceMetalLayer__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceMetalLayer"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceMetalLayer",
      "THIS", "WebGPU::Direct::SurfaceSourceMetalLayer");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceMetalLayer *n = (WGPUSurfaceSourceMetalLayer *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceMetalLayer);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "layer" is a ptr type void, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "layer", 5, (void **) &n->layer, NULL);

}

SV *WGPUSurfaceSourceMetalLayer__wrap( const WGPUSurfaceSourceMetalLayer * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceSourceMetalLayer", GV_ADD));
  WebGPU__Direct__SurfaceSourceMetalLayer__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceSourceMetalLayer;
void WebGPU__Direct__SurfaceSourceWaylandSurface__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceWaylandSurface"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceWaylandSurface",
      "THIS", "WebGPU::Direct::SurfaceSourceWaylandSurface");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceWaylandSurface *n = (WGPUSurfaceSourceWaylandSurface *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceWaylandSurface);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "display" is a ptr type void, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "display", 7, (void **) &n->display, NULL);
  // "surface" is a ptr type void, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "surface", 7, (void **) &n->surface, NULL);

  
}

void WebGPU__Direct__SurfaceSourceWaylandSurface__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceWaylandSurface"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceWaylandSurface",
      "THIS", "WebGPU::Direct::SurfaceSourceWaylandSurface");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceWaylandSurface *n = (WGPUSurfaceSourceWaylandSurface *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceWaylandSurface);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "display" is a ptr type void, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "display", 7, (void **) &n->display, NULL);
  // "surface" is a ptr type void, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "surface", 7, (void **) &n->surface, NULL);

}

SV *WGPUSurfaceSourceWaylandSurface__wrap( const WGPUSurfaceSourceWaylandSurface * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceSourceWaylandSurface", GV_ADD));
  WebGPU__Direct__SurfaceSourceWaylandSurface__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceSourceWaylandSurface;
void WebGPU__Direct__SurfaceSourceWindowsHWND__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceWindowsHWND"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceWindowsHWND",
      "THIS", "WebGPU::Direct::SurfaceSourceWindowsHWND");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceWindowsHWND *n = (WGPUSurfaceSourceWindowsHWND *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceWindowsHWND);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "hinstance" is a ptr type void, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "hinstance", 9, (void **) &n->hinstance, NULL);
  // "hwnd" is a ptr type void, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "hwnd", 4, (void **) &n->hwnd, NULL);

  
}

void WebGPU__Direct__SurfaceSourceWindowsHWND__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceWindowsHWND"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceWindowsHWND",
      "THIS", "WebGPU::Direct::SurfaceSourceWindowsHWND");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceWindowsHWND *n = (WGPUSurfaceSourceWindowsHWND *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceWindowsHWND);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "hinstance" is a ptr type void, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "hinstance", 9, (void **) &n->hinstance, NULL);
  // "hwnd" is a ptr type void, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "hwnd", 4, (void **) &n->hwnd, NULL);

}

SV *WGPUSurfaceSourceWindowsHWND__wrap( const WGPUSurfaceSourceWindowsHWND * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceSourceWindowsHWND", GV_ADD));
  WebGPU__Direct__SurfaceSourceWindowsHWND__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceSourceWindowsHWND;
void WebGPU__Direct__SurfaceSourceXCBWindow__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceXCBWindow"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceXCBWindow",
      "THIS", "WebGPU::Direct::SurfaceSourceXCBWindow");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceXCBWindow *n = (WGPUSurfaceSourceXCBWindow *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceXCBWindow);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "connection" is a ptr type void, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "connection", 10, (void **) &n->connection, NULL);
  _pack_uint32_t(aTHX_ h, "window", 6,  &n->window, NULL);

  
}

void WebGPU__Direct__SurfaceSourceXCBWindow__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceXCBWindow"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceXCBWindow",
      "THIS", "WebGPU::Direct::SurfaceSourceXCBWindow");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceXCBWindow *n = (WGPUSurfaceSourceXCBWindow *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceXCBWindow);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "connection" is a ptr type void, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "connection", 10, (void **) &n->connection, NULL);
  _unpack_uint32_t(aTHX_ h, "window", 6,  &n->window, NULL);

}

SV *WGPUSurfaceSourceXCBWindow__wrap( const WGPUSurfaceSourceXCBWindow * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceSourceXCBWindow", GV_ADD));
  WebGPU__Direct__SurfaceSourceXCBWindow__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceSourceXCBWindow;
void WebGPU__Direct__SurfaceSourceXlibWindow__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceXlibWindow"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceXlibWindow",
      "THIS", "WebGPU::Direct::SurfaceSourceXlibWindow");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceXlibWindow *n = (WGPUSurfaceSourceXlibWindow *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceXlibWindow);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "display" is a ptr type void, and that's not quite right yet, using opaque
  _pack_void(aTHX_ h, "display", 7, (void **) &n->display, NULL);
  _pack_uint64_t(aTHX_ h, "window", 6,  &n->window, NULL);

  
}

void WebGPU__Direct__SurfaceSourceXlibWindow__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceSourceXlibWindow"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceSourceXlibWindow",
      "THIS", "WebGPU::Direct::SurfaceSourceXlibWindow");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceSourceXlibWindow *n = (WGPUSurfaceSourceXlibWindow *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceSourceXlibWindow);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));
  // "display" is a ptr type void, and that's not quite right yet, using opaque
  _unpack_void(aTHX_ h, "display", 7, (void **) &n->display, NULL);
  _unpack_uint64_t(aTHX_ h, "window", 6,  &n->window, NULL);

}

SV *WGPUSurfaceSourceXlibWindow__wrap( const WGPUSurfaceSourceXlibWindow * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceSourceXlibWindow", GV_ADD));
  WebGPU__Direct__SurfaceSourceXlibWindow__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceSourceXlibWindow;
void WebGPU__Direct__SurfaceTexture__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceTexture"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceTexture",
      "THIS", "WebGPU::Direct::SurfaceTexture");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceTexture *n = (WGPUSurfaceTexture *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceTexture);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _pack_opaque(aTHX_ h, "texture", 7, (void **) &n->texture, newSVpvs("WebGPU::Direct::Texture"));
  _pack_enum(aTHX_ h, "status", 6,  &n->status, newSVpvs("WebGPU::Direct::SurfaceGetCurrentTextureStatus"));

  
}

void WebGPU__Direct__SurfaceTexture__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::SurfaceTexture"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::SurfaceTexture",
      "THIS", "WebGPU::Direct::SurfaceTexture");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUSurfaceTexture *n = (WGPUSurfaceTexture *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUSurfaceTexture);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));
  _unpack_opaque(aTHX_ h, "texture", 7, (void **) &n->texture, newSVpvs("WebGPU::Direct::Texture"));
  _unpack_enum(aTHX_ h, "status", 6,  &n->status, newSVpvs("WebGPU::Direct::SurfaceGetCurrentTextureStatus"));

}

SV *WGPUSurfaceTexture__wrap( const WGPUSurfaceTexture * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::SurfaceTexture", GV_ADD));
  WebGPU__Direct__SurfaceTexture__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__SurfaceTexture;
void WebGPU__Direct__TexelCopyBufferLayout__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TexelCopyBufferLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TexelCopyBufferLayout",
      "THIS", "WebGPU::Direct::TexelCopyBufferLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTexelCopyBufferLayout *n = (WGPUTexelCopyBufferLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTexelCopyBufferLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);
  _pack_uint32_t(aTHX_ h, "bytesPerRow", 11,  &n->bytesPerRow, NULL);
  _pack_uint32_t(aTHX_ h, "rowsPerImage", 12,  &n->rowsPerImage, NULL);

  
}

void WebGPU__Direct__TexelCopyBufferLayout__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TexelCopyBufferLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TexelCopyBufferLayout",
      "THIS", "WebGPU::Direct::TexelCopyBufferLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTexelCopyBufferLayout *n = (WGPUTexelCopyBufferLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTexelCopyBufferLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);
  _unpack_uint32_t(aTHX_ h, "bytesPerRow", 11,  &n->bytesPerRow, NULL);
  _unpack_uint32_t(aTHX_ h, "rowsPerImage", 12,  &n->rowsPerImage, NULL);

}

SV *WGPUTexelCopyBufferLayout__wrap( const WGPUTexelCopyBufferLayout * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::TexelCopyBufferLayout", GV_ADD));
  WebGPU__Direct__TexelCopyBufferLayout__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__TexelCopyBufferLayout;
void WebGPU__Direct__TextureBindingLayout__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TextureBindingLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TextureBindingLayout",
      "THIS", "WebGPU::Direct::TextureBindingLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTextureBindingLayout *n = (WGPUTextureBindingLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTextureBindingLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "sampleType", 10,  &n->sampleType, newSVpvs("WebGPU::Direct::TextureSampleType"));
  _pack_enum(aTHX_ h, "viewDimension", 13,  &n->viewDimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));
  _pack_uint32_t(aTHX_ h, "multisampled", 12,  &n->multisampled, NULL);

  
}

void WebGPU__Direct__TextureBindingLayout__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TextureBindingLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TextureBindingLayout",
      "THIS", "WebGPU::Direct::TextureBindingLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTextureBindingLayout *n = (WGPUTextureBindingLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTextureBindingLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "sampleType", 10,  &n->sampleType, newSVpvs("WebGPU::Direct::TextureSampleType"));
  _unpack_enum(aTHX_ h, "viewDimension", 13,  &n->viewDimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));
  _unpack_uint32_t(aTHX_ h, "multisampled", 12,  &n->multisampled, NULL);

}

SV *WGPUTextureBindingLayout__wrap( const WGPUTextureBindingLayout * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::TextureBindingLayout", GV_ADD));
  WebGPU__Direct__TextureBindingLayout__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__TextureBindingLayout;
void WebGPU__Direct__TextureViewDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TextureViewDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TextureViewDescriptor",
      "THIS", "WebGPU::Direct::TextureViewDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTextureViewDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_enum(aTHX_ h, "dimension", 9,  &n->dimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));
  _pack_uint32_t(aTHX_ h, "baseMipLevel", 12,  &n->baseMipLevel, NULL);
  _pack_uint32_t(aTHX_ h, "mipLevelCount", 13,  &n->mipLevelCount, NULL);
  _pack_uint32_t(aTHX_ h, "baseArrayLayer", 14,  &n->baseArrayLayer, NULL);
  _pack_uint32_t(aTHX_ h, "arrayLayerCount", 15,  &n->arrayLayerCount, NULL);
  _pack_enum(aTHX_ h, "aspect", 6,  &n->aspect, newSVpvs("WebGPU::Direct::TextureAspect"));
  _pack_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));

  
}

void WebGPU__Direct__TextureViewDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TextureViewDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TextureViewDescriptor",
      "THIS", "WebGPU::Direct::TextureViewDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTextureViewDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_enum(aTHX_ h, "dimension", 9,  &n->dimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));
  _unpack_uint32_t(aTHX_ h, "baseMipLevel", 12,  &n->baseMipLevel, NULL);
  _unpack_uint32_t(aTHX_ h, "mipLevelCount", 13,  &n->mipLevelCount, NULL);
  _unpack_uint32_t(aTHX_ h, "baseArrayLayer", 14,  &n->baseArrayLayer, NULL);
  _unpack_uint32_t(aTHX_ h, "arrayLayerCount", 15,  &n->arrayLayerCount, NULL);
  _unpack_enum(aTHX_ h, "aspect", 6,  &n->aspect, newSVpvs("WebGPU::Direct::TextureAspect"));
  _unpack_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));

}

SV *WGPUTextureViewDescriptor__wrap( const WGPUTextureViewDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::TextureViewDescriptor", GV_ADD));
  WebGPU__Direct__TextureViewDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__TextureViewDescriptor;
void WebGPU__Direct__VertexAttribute__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::VertexAttribute"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::VertexAttribute",
      "THIS", "WebGPU::Direct::VertexAttribute");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUVertexAttribute *n = (WGPUVertexAttribute *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUVertexAttribute);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::VertexFormat"));
  _pack_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);
  _pack_uint32_t(aTHX_ h, "shaderLocation", 14,  &n->shaderLocation, NULL);

  
}

void WebGPU__Direct__VertexAttribute__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::VertexAttribute"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::VertexAttribute",
      "THIS", "WebGPU::Direct::VertexAttribute");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUVertexAttribute *n = (WGPUVertexAttribute *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUVertexAttribute);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::VertexFormat"));
  _unpack_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);
  _unpack_uint32_t(aTHX_ h, "shaderLocation", 14,  &n->shaderLocation, NULL);

}

SV *WGPUVertexAttribute__wrap( const WGPUVertexAttribute * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::VertexAttribute", GV_ADD));
  WebGPU__Direct__VertexAttribute__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__VertexAttribute;
void WebGPU__Direct__BindGroupDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BindGroupDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BindGroupDescriptor",
      "THIS", "WebGPU::Direct::BindGroupDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBindGroupDescriptor *n = (WGPUBindGroupDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBindGroupDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::BindGroupLayout"));
  _pack_objarray(aTHX_ h, "entries", 7, (void **) &n->entries, &n->entryCount, sizeof(*n->entries), newSVpvs("WebGPU::Direct::BindGroupEntry"));

  
}

void WebGPU__Direct__BindGroupDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BindGroupDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BindGroupDescriptor",
      "THIS", "WebGPU::Direct::BindGroupDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBindGroupDescriptor *n = (WGPUBindGroupDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBindGroupDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::BindGroupLayout"));
  _unpack_size_t(aTHX_ h, "entryCount", 10,  &n->entryCount, NULL);
  _unpack_objarray(aTHX_ h, "entries", 7, (void **) &n->entries, &n->entryCount, sizeof(*n->entries), newSVpvs("WebGPU::Direct::BindGroupEntry"));

}

SV *WGPUBindGroupDescriptor__wrap( const WGPUBindGroupDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BindGroupDescriptor", GV_ADD));
  WebGPU__Direct__BindGroupDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BindGroupDescriptor;
void WebGPU__Direct__BindGroupLayoutEntry__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BindGroupLayoutEntry"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BindGroupLayoutEntry",
      "THIS", "WebGPU::Direct::BindGroupLayoutEntry");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBindGroupLayoutEntry);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_uint32_t(aTHX_ h, "binding", 7,  &n->binding, NULL);
  _pack_flag(aTHX_ h, "visibility", 10,  &n->visibility, newSVpvs("WebGPU::Direct::ShaderStage"));
  _pack_obj(aTHX_ h, "buffer", 6,  &n->buffer, sizeof(n->buffer), newSVpvs("WebGPU::Direct::BufferBindingLayout"));
  _pack_obj(aTHX_ h, "sampler", 7,  &n->sampler, sizeof(n->sampler), newSVpvs("WebGPU::Direct::SamplerBindingLayout"));
  _pack_obj(aTHX_ h, "texture", 7,  &n->texture, sizeof(n->texture), newSVpvs("WebGPU::Direct::TextureBindingLayout"));
  _pack_obj(aTHX_ h, "storageTexture", 14,  &n->storageTexture, sizeof(n->storageTexture), newSVpvs("WebGPU::Direct::StorageTextureBindingLayout"));

  
}

void WebGPU__Direct__BindGroupLayoutEntry__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BindGroupLayoutEntry"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BindGroupLayoutEntry",
      "THIS", "WebGPU::Direct::BindGroupLayoutEntry");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBindGroupLayoutEntry);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_uint32_t(aTHX_ h, "binding", 7,  &n->binding, NULL);
  _unpack_flag(aTHX_ h, "visibility", 10,  &n->visibility, newSVpvs("WebGPU::Direct::ShaderStage"));
  _unpack_obj(aTHX_ h, "buffer", 6,  &n->buffer, sizeof(n->buffer), newSVpvs("WebGPU::Direct::BufferBindingLayout"));
  _unpack_obj(aTHX_ h, "sampler", 7,  &n->sampler, sizeof(n->sampler), newSVpvs("WebGPU::Direct::SamplerBindingLayout"));
  _unpack_obj(aTHX_ h, "texture", 7,  &n->texture, sizeof(n->texture), newSVpvs("WebGPU::Direct::TextureBindingLayout"));
  _unpack_obj(aTHX_ h, "storageTexture", 14,  &n->storageTexture, sizeof(n->storageTexture), newSVpvs("WebGPU::Direct::StorageTextureBindingLayout"));

}

SV *WGPUBindGroupLayoutEntry__wrap( const WGPUBindGroupLayoutEntry * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BindGroupLayoutEntry", GV_ADD));
  WebGPU__Direct__BindGroupLayoutEntry__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BindGroupLayoutEntry;
void WebGPU__Direct__BlendState__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BlendState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BlendState",
      "THIS", "WebGPU::Direct::BlendState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBlendState *n = (WGPUBlendState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBlendState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "color", 5,  &n->color, sizeof(n->color), newSVpvs("WebGPU::Direct::BlendComponent"));
  _pack_obj(aTHX_ h, "alpha", 5,  &n->alpha, sizeof(n->alpha), newSVpvs("WebGPU::Direct::BlendComponent"));

  
}

void WebGPU__Direct__BlendState__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BlendState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BlendState",
      "THIS", "WebGPU::Direct::BlendState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBlendState *n = (WGPUBlendState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBlendState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "color", 5,  &n->color, sizeof(n->color), newSVpvs("WebGPU::Direct::BlendComponent"));
  _unpack_obj(aTHX_ h, "alpha", 5,  &n->alpha, sizeof(n->alpha), newSVpvs("WebGPU::Direct::BlendComponent"));

}

SV *WGPUBlendState__wrap( const WGPUBlendState * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BlendState", GV_ADD));
  WebGPU__Direct__BlendState__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BlendState;
void WebGPU__Direct__CompilationInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CompilationInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CompilationInfo",
      "THIS", "WebGPU::Direct::CompilationInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCompilationInfo *n = (WGPUCompilationInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCompilationInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_objarray(aTHX_ h, "messages", 8, (void **) &n->messages, &n->messageCount, sizeof(*n->messages), newSVpvs("WebGPU::Direct::CompilationMessage"));

  
}

void WebGPU__Direct__CompilationInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::CompilationInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::CompilationInfo",
      "THIS", "WebGPU::Direct::CompilationInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUCompilationInfo *n = (WGPUCompilationInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUCompilationInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_size_t(aTHX_ h, "messageCount", 12,  &n->messageCount, NULL);
  _unpack_objarray(aTHX_ h, "messages", 8, (void **) &n->messages, &n->messageCount, sizeof(*n->messages), newSVpvs("WebGPU::Direct::CompilationMessage"));

}

SV *WGPUCompilationInfo__wrap( const WGPUCompilationInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::CompilationInfo", GV_ADD));
  WebGPU__Direct__CompilationInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__CompilationInfo;
void WebGPU__Direct__ComputePassDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ComputePassDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ComputePassDescriptor",
      "THIS", "WebGPU::Direct::ComputePassDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUComputePassDescriptor *n = (WGPUComputePassDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUComputePassDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objptr(aTHX_ h, "timestampWrites", 15, (void **) &n->timestampWrites, newSVpvs("WebGPU::Direct::ComputePassTimestampWrites"));

  
}

void WebGPU__Direct__ComputePassDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ComputePassDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ComputePassDescriptor",
      "THIS", "WebGPU::Direct::ComputePassDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUComputePassDescriptor *n = (WGPUComputePassDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUComputePassDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_objptr(aTHX_ h, "timestampWrites", 15, (void **) &n->timestampWrites, newSVpvs("WebGPU::Direct::ComputePassTimestampWrites"));

}

SV *WGPUComputePassDescriptor__wrap( const WGPUComputePassDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ComputePassDescriptor", GV_ADD));
  WebGPU__Direct__ComputePassDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ComputePassDescriptor;
void WebGPU__Direct__DepthStencilState__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::DepthStencilState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::DepthStencilState",
      "THIS", "WebGPU::Direct::DepthStencilState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUDepthStencilState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_enum(aTHX_ h, "depthWriteEnabled", 17,  &n->depthWriteEnabled, newSVpvs("WebGPU::Direct::OptionalBool"));
  _pack_enum(aTHX_ h, "depthCompare", 12,  &n->depthCompare, newSVpvs("WebGPU::Direct::CompareFunction"));
  _pack_obj(aTHX_ h, "stencilFront", 12,  &n->stencilFront, sizeof(n->stencilFront), newSVpvs("WebGPU::Direct::StencilFaceState"));
  _pack_obj(aTHX_ h, "stencilBack", 11,  &n->stencilBack, sizeof(n->stencilBack), newSVpvs("WebGPU::Direct::StencilFaceState"));
  _pack_uint32_t(aTHX_ h, "stencilReadMask", 15,  &n->stencilReadMask, NULL);
  _pack_uint32_t(aTHX_ h, "stencilWriteMask", 16,  &n->stencilWriteMask, NULL);
  _pack_int32_t(aTHX_ h, "depthBias", 9,  &n->depthBias, NULL);
  _pack_float(aTHX_ h, "depthBiasSlopeScale", 19,  &n->depthBiasSlopeScale, NULL);
  _pack_float(aTHX_ h, "depthBiasClamp", 14,  &n->depthBiasClamp, NULL);

  
}

void WebGPU__Direct__DepthStencilState__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::DepthStencilState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::DepthStencilState",
      "THIS", "WebGPU::Direct::DepthStencilState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUDepthStencilState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_enum(aTHX_ h, "depthWriteEnabled", 17,  &n->depthWriteEnabled, newSVpvs("WebGPU::Direct::OptionalBool"));
  _unpack_enum(aTHX_ h, "depthCompare", 12,  &n->depthCompare, newSVpvs("WebGPU::Direct::CompareFunction"));
  _unpack_obj(aTHX_ h, "stencilFront", 12,  &n->stencilFront, sizeof(n->stencilFront), newSVpvs("WebGPU::Direct::StencilFaceState"));
  _unpack_obj(aTHX_ h, "stencilBack", 11,  &n->stencilBack, sizeof(n->stencilBack), newSVpvs("WebGPU::Direct::StencilFaceState"));
  _unpack_uint32_t(aTHX_ h, "stencilReadMask", 15,  &n->stencilReadMask, NULL);
  _unpack_uint32_t(aTHX_ h, "stencilWriteMask", 16,  &n->stencilWriteMask, NULL);
  _unpack_int32_t(aTHX_ h, "depthBias", 9,  &n->depthBias, NULL);
  _unpack_float(aTHX_ h, "depthBiasSlopeScale", 19,  &n->depthBiasSlopeScale, NULL);
  _unpack_float(aTHX_ h, "depthBiasClamp", 14,  &n->depthBiasClamp, NULL);

}

SV *WGPUDepthStencilState__wrap( const WGPUDepthStencilState * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::DepthStencilState", GV_ADD));
  WebGPU__Direct__DepthStencilState__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__DepthStencilState;
void WebGPU__Direct__DeviceDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::DeviceDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::DeviceDescriptor",
      "THIS", "WebGPU::Direct::DeviceDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUDeviceDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objarray(aTHX_ h, "requiredFeatures", 16, (void **) &n->requiredFeatures, &n->requiredFeatureCount, sizeof(*n->requiredFeatures), newSVpvs("WebGPU::Direct::FeatureName"));
  _pack_objptr(aTHX_ h, "requiredLimits", 14, (void **) &n->requiredLimits, newSVpvs("WebGPU::Direct::Limits"));
  _pack_obj(aTHX_ h, "defaultQueue", 12,  &n->defaultQueue, sizeof(n->defaultQueue), newSVpvs("WebGPU::Direct::QueueDescriptor"));
  _pack_obj(aTHX_ h, "deviceLostCallbackInfo", 22,  &n->deviceLostCallbackInfo, sizeof(n->deviceLostCallbackInfo), newSVpvs("WebGPU::Direct::DeviceLostCallbackInfo"));
  _pack_obj(aTHX_ h, "uncapturedErrorCallbackInfo", 27,  &n->uncapturedErrorCallbackInfo, sizeof(n->uncapturedErrorCallbackInfo), newSVpvs("WebGPU::Direct::UncapturedErrorCallbackInfo"));

  
}

void WebGPU__Direct__DeviceDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::DeviceDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::DeviceDescriptor",
      "THIS", "WebGPU::Direct::DeviceDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUDeviceDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_size_t(aTHX_ h, "requiredFeatureCount", 20,  &n->requiredFeatureCount, NULL);
  _unpack_objarray(aTHX_ h, "requiredFeatures", 16, (void **) &n->requiredFeatures, &n->requiredFeatureCount, sizeof(*n->requiredFeatures), newSVpvs("WebGPU::Direct::FeatureName"));
  _unpack_objptr(aTHX_ h, "requiredLimits", 14, (void **) &n->requiredLimits, newSVpvs("WebGPU::Direct::Limits"));
  _unpack_obj(aTHX_ h, "defaultQueue", 12,  &n->defaultQueue, sizeof(n->defaultQueue), newSVpvs("WebGPU::Direct::QueueDescriptor"));
  _unpack_obj(aTHX_ h, "deviceLostCallbackInfo", 22,  &n->deviceLostCallbackInfo, sizeof(n->deviceLostCallbackInfo), newSVpvs("WebGPU::Direct::DeviceLostCallbackInfo"));
  _unpack_obj(aTHX_ h, "uncapturedErrorCallbackInfo", 27,  &n->uncapturedErrorCallbackInfo, sizeof(n->uncapturedErrorCallbackInfo), newSVpvs("WebGPU::Direct::UncapturedErrorCallbackInfo"));

}

SV *WGPUDeviceDescriptor__wrap( const WGPUDeviceDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::DeviceDescriptor", GV_ADD));
  WebGPU__Direct__DeviceDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__DeviceDescriptor;
void WebGPU__Direct__FutureWaitInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::FutureWaitInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::FutureWaitInfo",
      "THIS", "WebGPU::Direct::FutureWaitInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUFutureWaitInfo *n = (WGPUFutureWaitInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUFutureWaitInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "future", 6,  &n->future, sizeof(n->future), newSVpvs("WebGPU::Direct::Future"));
  _pack_uint32_t(aTHX_ h, "completed", 9,  &n->completed, NULL);

  
}

void WebGPU__Direct__FutureWaitInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::FutureWaitInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::FutureWaitInfo",
      "THIS", "WebGPU::Direct::FutureWaitInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUFutureWaitInfo *n = (WGPUFutureWaitInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUFutureWaitInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "future", 6,  &n->future, sizeof(n->future), newSVpvs("WebGPU::Direct::Future"));
  _unpack_uint32_t(aTHX_ h, "completed", 9,  &n->completed, NULL);

}

SV *WGPUFutureWaitInfo__wrap( const WGPUFutureWaitInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::FutureWaitInfo", GV_ADD));
  WebGPU__Direct__FutureWaitInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__FutureWaitInfo;
void WebGPU__Direct__InstanceDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::InstanceDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::InstanceDescriptor",
      "THIS", "WebGPU::Direct::InstanceDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUInstanceDescriptor *n = (WGPUInstanceDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUInstanceDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "features", 8,  &n->features, sizeof(n->features), newSVpvs("WebGPU::Direct::InstanceCapabilities"));

  
}

void WebGPU__Direct__InstanceDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::InstanceDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::InstanceDescriptor",
      "THIS", "WebGPU::Direct::InstanceDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUInstanceDescriptor *n = (WGPUInstanceDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUInstanceDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "features", 8,  &n->features, sizeof(n->features), newSVpvs("WebGPU::Direct::InstanceCapabilities"));

}

SV *WGPUInstanceDescriptor__wrap( const WGPUInstanceDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::InstanceDescriptor", GV_ADD));
  WebGPU__Direct__InstanceDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__InstanceDescriptor;
void WebGPU__Direct__ProgrammableStageDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ProgrammableStageDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ProgrammableStageDescriptor",
      "THIS", "WebGPU::Direct::ProgrammableStageDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUProgrammableStageDescriptor *n = (WGPUProgrammableStageDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUProgrammableStageDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));
  _pack_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));

  
}

void WebGPU__Direct__ProgrammableStageDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ProgrammableStageDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ProgrammableStageDescriptor",
      "THIS", "WebGPU::Direct::ProgrammableStageDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUProgrammableStageDescriptor *n = (WGPUProgrammableStageDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUProgrammableStageDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));
  _unpack_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_size_t(aTHX_ h, "constantCount", 13,  &n->constantCount, NULL);
  _unpack_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));

}

SV *WGPUProgrammableStageDescriptor__wrap( const WGPUProgrammableStageDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ProgrammableStageDescriptor", GV_ADD));
  WebGPU__Direct__ProgrammableStageDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ProgrammableStageDescriptor;
void WebGPU__Direct__RenderPassColorAttachment__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassColorAttachment"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassColorAttachment",
      "THIS", "WebGPU::Direct::RenderPassColorAttachment");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassColorAttachment);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_opaque(aTHX_ h, "view", 4, (void **) &n->view, newSVpvs("WebGPU::Direct::TextureView"));
  _pack_uint32_t(aTHX_ h, "depthSlice", 10,  &n->depthSlice, NULL);
  _pack_opaque(aTHX_ h, "resolveTarget", 13, (void **) &n->resolveTarget, newSVpvs("WebGPU::Direct::TextureView"));
  _pack_enum(aTHX_ h, "loadOp", 6,  &n->loadOp, newSVpvs("WebGPU::Direct::LoadOp"));
  _pack_enum(aTHX_ h, "storeOp", 7,  &n->storeOp, newSVpvs("WebGPU::Direct::StoreOp"));
  _pack_obj(aTHX_ h, "clearValue", 10,  &n->clearValue, sizeof(n->clearValue), newSVpvs("WebGPU::Direct::Color"));

  
}

void WebGPU__Direct__RenderPassColorAttachment__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassColorAttachment"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassColorAttachment",
      "THIS", "WebGPU::Direct::RenderPassColorAttachment");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassColorAttachment);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_opaque(aTHX_ h, "view", 4, (void **) &n->view, newSVpvs("WebGPU::Direct::TextureView"));
  _unpack_uint32_t(aTHX_ h, "depthSlice", 10,  &n->depthSlice, NULL);
  _unpack_opaque(aTHX_ h, "resolveTarget", 13, (void **) &n->resolveTarget, newSVpvs("WebGPU::Direct::TextureView"));
  _unpack_enum(aTHX_ h, "loadOp", 6,  &n->loadOp, newSVpvs("WebGPU::Direct::LoadOp"));
  _unpack_enum(aTHX_ h, "storeOp", 7,  &n->storeOp, newSVpvs("WebGPU::Direct::StoreOp"));
  _unpack_obj(aTHX_ h, "clearValue", 10,  &n->clearValue, sizeof(n->clearValue), newSVpvs("WebGPU::Direct::Color"));

}

SV *WGPURenderPassColorAttachment__wrap( const WGPURenderPassColorAttachment * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RenderPassColorAttachment", GV_ADD));
  WebGPU__Direct__RenderPassColorAttachment__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RenderPassColorAttachment;
void WebGPU__Direct__TexelCopyBufferInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TexelCopyBufferInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TexelCopyBufferInfo",
      "THIS", "WebGPU::Direct::TexelCopyBufferInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTexelCopyBufferInfo *n = (WGPUTexelCopyBufferInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTexelCopyBufferInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_obj(aTHX_ h, "layout", 6,  &n->layout, sizeof(n->layout), newSVpvs("WebGPU::Direct::TexelCopyBufferLayout"));
  _pack_opaque(aTHX_ h, "buffer", 6, (void **) &n->buffer, newSVpvs("WebGPU::Direct::Buffer"));

  
}

void WebGPU__Direct__TexelCopyBufferInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TexelCopyBufferInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TexelCopyBufferInfo",
      "THIS", "WebGPU::Direct::TexelCopyBufferInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTexelCopyBufferInfo *n = (WGPUTexelCopyBufferInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTexelCopyBufferInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_obj(aTHX_ h, "layout", 6,  &n->layout, sizeof(n->layout), newSVpvs("WebGPU::Direct::TexelCopyBufferLayout"));
  _unpack_opaque(aTHX_ h, "buffer", 6, (void **) &n->buffer, newSVpvs("WebGPU::Direct::Buffer"));

}

SV *WGPUTexelCopyBufferInfo__wrap( const WGPUTexelCopyBufferInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::TexelCopyBufferInfo", GV_ADD));
  WebGPU__Direct__TexelCopyBufferInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__TexelCopyBufferInfo;
void WebGPU__Direct__TexelCopyTextureInfo__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TexelCopyTextureInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TexelCopyTextureInfo",
      "THIS", "WebGPU::Direct::TexelCopyTextureInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTexelCopyTextureInfo *n = (WGPUTexelCopyTextureInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTexelCopyTextureInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_opaque(aTHX_ h, "texture", 7, (void **) &n->texture, newSVpvs("WebGPU::Direct::Texture"));
  _pack_uint32_t(aTHX_ h, "mipLevel", 8,  &n->mipLevel, NULL);
  _pack_obj(aTHX_ h, "origin", 6,  &n->origin, sizeof(n->origin), newSVpvs("WebGPU::Direct::Origin3D"));
  _pack_enum(aTHX_ h, "aspect", 6,  &n->aspect, newSVpvs("WebGPU::Direct::TextureAspect"));

  
}

void WebGPU__Direct__TexelCopyTextureInfo__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TexelCopyTextureInfo"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TexelCopyTextureInfo",
      "THIS", "WebGPU::Direct::TexelCopyTextureInfo");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTexelCopyTextureInfo *n = (WGPUTexelCopyTextureInfo *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTexelCopyTextureInfo);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_opaque(aTHX_ h, "texture", 7, (void **) &n->texture, newSVpvs("WebGPU::Direct::Texture"));
  _unpack_uint32_t(aTHX_ h, "mipLevel", 8,  &n->mipLevel, NULL);
  _unpack_obj(aTHX_ h, "origin", 6,  &n->origin, sizeof(n->origin), newSVpvs("WebGPU::Direct::Origin3D"));
  _unpack_enum(aTHX_ h, "aspect", 6,  &n->aspect, newSVpvs("WebGPU::Direct::TextureAspect"));

}

SV *WGPUTexelCopyTextureInfo__wrap( const WGPUTexelCopyTextureInfo * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::TexelCopyTextureInfo", GV_ADD));
  WebGPU__Direct__TexelCopyTextureInfo__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__TexelCopyTextureInfo;
void WebGPU__Direct__TextureDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TextureDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TextureDescriptor",
      "THIS", "WebGPU::Direct::TextureDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTextureDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));
  _pack_enum(aTHX_ h, "dimension", 9,  &n->dimension, newSVpvs("WebGPU::Direct::TextureDimension"));
  _pack_obj(aTHX_ h, "size", 4,  &n->size, sizeof(n->size), newSVpvs("WebGPU::Direct::Extent3D"));
  _pack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_uint32_t(aTHX_ h, "mipLevelCount", 13,  &n->mipLevelCount, NULL);
  _pack_uint32_t(aTHX_ h, "sampleCount", 11,  &n->sampleCount, NULL);
  _pack_objarray(aTHX_ h, "viewFormats", 11, (void **) &n->viewFormats, &n->viewFormatCount, sizeof(*n->viewFormats), newSVpvs("WebGPU::Direct::TextureFormat"));

  
}

void WebGPU__Direct__TextureDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::TextureDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::TextureDescriptor",
      "THIS", "WebGPU::Direct::TextureDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUTextureDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));
  _unpack_enum(aTHX_ h, "dimension", 9,  &n->dimension, newSVpvs("WebGPU::Direct::TextureDimension"));
  _unpack_obj(aTHX_ h, "size", 4,  &n->size, sizeof(n->size), newSVpvs("WebGPU::Direct::Extent3D"));
  _unpack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_uint32_t(aTHX_ h, "mipLevelCount", 13,  &n->mipLevelCount, NULL);
  _unpack_uint32_t(aTHX_ h, "sampleCount", 11,  &n->sampleCount, NULL);
  _unpack_size_t(aTHX_ h, "viewFormatCount", 15,  &n->viewFormatCount, NULL);
  _unpack_objarray(aTHX_ h, "viewFormats", 11, (void **) &n->viewFormats, &n->viewFormatCount, sizeof(*n->viewFormats), newSVpvs("WebGPU::Direct::TextureFormat"));

}

SV *WGPUTextureDescriptor__wrap( const WGPUTextureDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::TextureDescriptor", GV_ADD));
  WebGPU__Direct__TextureDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__TextureDescriptor;
void WebGPU__Direct__VertexBufferLayout__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::VertexBufferLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::VertexBufferLayout",
      "THIS", "WebGPU::Direct::VertexBufferLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUVertexBufferLayout *n = (WGPUVertexBufferLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUVertexBufferLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_enum(aTHX_ h, "stepMode", 8,  &n->stepMode, newSVpvs("WebGPU::Direct::VertexStepMode"));
  _pack_uint64_t(aTHX_ h, "arrayStride", 11,  &n->arrayStride, NULL);
  _pack_objarray(aTHX_ h, "attributes", 10, (void **) &n->attributes, &n->attributeCount, sizeof(*n->attributes), newSVpvs("WebGPU::Direct::VertexAttribute"));

  
}

void WebGPU__Direct__VertexBufferLayout__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::VertexBufferLayout"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::VertexBufferLayout",
      "THIS", "WebGPU::Direct::VertexBufferLayout");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUVertexBufferLayout *n = (WGPUVertexBufferLayout *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUVertexBufferLayout);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_enum(aTHX_ h, "stepMode", 8,  &n->stepMode, newSVpvs("WebGPU::Direct::VertexStepMode"));
  _unpack_uint64_t(aTHX_ h, "arrayStride", 11,  &n->arrayStride, NULL);
  _unpack_size_t(aTHX_ h, "attributeCount", 14,  &n->attributeCount, NULL);
  _unpack_objarray(aTHX_ h, "attributes", 10, (void **) &n->attributes, &n->attributeCount, sizeof(*n->attributes), newSVpvs("WebGPU::Direct::VertexAttribute"));

}

SV *WGPUVertexBufferLayout__wrap( const WGPUVertexBufferLayout * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::VertexBufferLayout", GV_ADD));
  WebGPU__Direct__VertexBufferLayout__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__VertexBufferLayout;
void WebGPU__Direct__BindGroupLayoutDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BindGroupLayoutDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BindGroupLayoutDescriptor",
      "THIS", "WebGPU::Direct::BindGroupLayoutDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBindGroupLayoutDescriptor *n = (WGPUBindGroupLayoutDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBindGroupLayoutDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objarray(aTHX_ h, "entries", 7, (void **) &n->entries, &n->entryCount, sizeof(*n->entries), newSVpvs("WebGPU::Direct::BindGroupLayoutEntry"));

  
}

void WebGPU__Direct__BindGroupLayoutDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::BindGroupLayoutDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::BindGroupLayoutDescriptor",
      "THIS", "WebGPU::Direct::BindGroupLayoutDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUBindGroupLayoutDescriptor *n = (WGPUBindGroupLayoutDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUBindGroupLayoutDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_size_t(aTHX_ h, "entryCount", 10,  &n->entryCount, NULL);
  _unpack_objarray(aTHX_ h, "entries", 7, (void **) &n->entries, &n->entryCount, sizeof(*n->entries), newSVpvs("WebGPU::Direct::BindGroupLayoutEntry"));

}

SV *WGPUBindGroupLayoutDescriptor__wrap( const WGPUBindGroupLayoutDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::BindGroupLayoutDescriptor", GV_ADD));
  WebGPU__Direct__BindGroupLayoutDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__BindGroupLayoutDescriptor;
void WebGPU__Direct__ColorTargetState__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ColorTargetState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ColorTargetState",
      "THIS", "WebGPU::Direct::ColorTargetState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUColorTargetState *n = (WGPUColorTargetState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUColorTargetState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _pack_objptr(aTHX_ h, "blend", 5, (void **) &n->blend, newSVpvs("WebGPU::Direct::BlendState"));
  _pack_flag(aTHX_ h, "writeMask", 9,  &n->writeMask, newSVpvs("WebGPU::Direct::ColorWriteMask"));

  
}

void WebGPU__Direct__ColorTargetState__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ColorTargetState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ColorTargetState",
      "THIS", "WebGPU::Direct::ColorTargetState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUColorTargetState *n = (WGPUColorTargetState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUColorTargetState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));
  _unpack_objptr(aTHX_ h, "blend", 5, (void **) &n->blend, newSVpvs("WebGPU::Direct::BlendState"));
  _unpack_flag(aTHX_ h, "writeMask", 9,  &n->writeMask, newSVpvs("WebGPU::Direct::ColorWriteMask"));

}

SV *WGPUColorTargetState__wrap( const WGPUColorTargetState * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ColorTargetState", GV_ADD));
  WebGPU__Direct__ColorTargetState__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ColorTargetState;
void WebGPU__Direct__ComputePipelineDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ComputePipelineDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ComputePipelineDescriptor",
      "THIS", "WebGPU::Direct::ComputePipelineDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUComputePipelineDescriptor *n = (WGPUComputePipelineDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUComputePipelineDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::PipelineLayout"));
  _pack_obj(aTHX_ h, "compute", 7,  &n->compute, sizeof(n->compute), newSVpvs("WebGPU::Direct::ProgrammableStageDescriptor"));

  
}

void WebGPU__Direct__ComputePipelineDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::ComputePipelineDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::ComputePipelineDescriptor",
      "THIS", "WebGPU::Direct::ComputePipelineDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUComputePipelineDescriptor *n = (WGPUComputePipelineDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUComputePipelineDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::PipelineLayout"));
  _unpack_obj(aTHX_ h, "compute", 7,  &n->compute, sizeof(n->compute), newSVpvs("WebGPU::Direct::ProgrammableStageDescriptor"));

}

SV *WGPUComputePipelineDescriptor__wrap( const WGPUComputePipelineDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::ComputePipelineDescriptor", GV_ADD));
  WebGPU__Direct__ComputePipelineDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__ComputePipelineDescriptor;
void WebGPU__Direct__RenderPassDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassDescriptor",
      "THIS", "WebGPU::Direct::RenderPassDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objarray(aTHX_ h, "colorAttachments", 16, (void **) &n->colorAttachments, &n->colorAttachmentCount, sizeof(*n->colorAttachments), newSVpvs("WebGPU::Direct::RenderPassColorAttachment"));
  _pack_objptr(aTHX_ h, "depthStencilAttachment", 22, (void **) &n->depthStencilAttachment, newSVpvs("WebGPU::Direct::RenderPassDepthStencilAttachment"));
  _pack_opaque(aTHX_ h, "occlusionQuerySet", 17, (void **) &n->occlusionQuerySet, newSVpvs("WebGPU::Direct::QuerySet"));
  _pack_objptr(aTHX_ h, "timestampWrites", 15, (void **) &n->timestampWrites, newSVpvs("WebGPU::Direct::RenderPassTimestampWrites"));

  
}

void WebGPU__Direct__RenderPassDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPassDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPassDescriptor",
      "THIS", "WebGPU::Direct::RenderPassDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPassDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_size_t(aTHX_ h, "colorAttachmentCount", 20,  &n->colorAttachmentCount, NULL);
  _unpack_objarray(aTHX_ h, "colorAttachments", 16, (void **) &n->colorAttachments, &n->colorAttachmentCount, sizeof(*n->colorAttachments), newSVpvs("WebGPU::Direct::RenderPassColorAttachment"));
  _unpack_objptr(aTHX_ h, "depthStencilAttachment", 22, (void **) &n->depthStencilAttachment, newSVpvs("WebGPU::Direct::RenderPassDepthStencilAttachment"));
  _unpack_opaque(aTHX_ h, "occlusionQuerySet", 17, (void **) &n->occlusionQuerySet, newSVpvs("WebGPU::Direct::QuerySet"));
  _unpack_objptr(aTHX_ h, "timestampWrites", 15, (void **) &n->timestampWrites, newSVpvs("WebGPU::Direct::RenderPassTimestampWrites"));

}

SV *WGPURenderPassDescriptor__wrap( const WGPURenderPassDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RenderPassDescriptor", GV_ADD));
  WebGPU__Direct__RenderPassDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RenderPassDescriptor;
void WebGPU__Direct__VertexState__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::VertexState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::VertexState",
      "THIS", "WebGPU::Direct::VertexState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUVertexState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));
  _pack_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));
  _pack_objarray(aTHX_ h, "buffers", 7, (void **) &n->buffers, &n->bufferCount, sizeof(*n->buffers), newSVpvs("WebGPU::Direct::VertexBufferLayout"));

  
}

void WebGPU__Direct__VertexState__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::VertexState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::VertexState",
      "THIS", "WebGPU::Direct::VertexState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUVertexState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));
  _unpack_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_size_t(aTHX_ h, "constantCount", 13,  &n->constantCount, NULL);
  _unpack_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));
  _unpack_size_t(aTHX_ h, "bufferCount", 11,  &n->bufferCount, NULL);
  _unpack_objarray(aTHX_ h, "buffers", 7, (void **) &n->buffers, &n->bufferCount, sizeof(*n->buffers), newSVpvs("WebGPU::Direct::VertexBufferLayout"));

}

SV *WGPUVertexState__wrap( const WGPUVertexState * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::VertexState", GV_ADD));
  WebGPU__Direct__VertexState__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__VertexState;
void WebGPU__Direct__FragmentState__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::FragmentState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::FragmentState",
      "THIS", "WebGPU::Direct::FragmentState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUFragmentState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));
  _pack_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));
  _pack_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));
  _pack_objarray(aTHX_ h, "targets", 7, (void **) &n->targets, &n->targetCount, sizeof(*n->targets), newSVpvs("WebGPU::Direct::ColorTargetState"));

  
}

void WebGPU__Direct__FragmentState__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::FragmentState"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::FragmentState",
      "THIS", "WebGPU::Direct::FragmentState");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPUFragmentState);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));
  _unpack_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_size_t(aTHX_ h, "constantCount", 13,  &n->constantCount, NULL);
  _unpack_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));
  _unpack_size_t(aTHX_ h, "targetCount", 11,  &n->targetCount, NULL);
  _unpack_objarray(aTHX_ h, "targets", 7, (void **) &n->targets, &n->targetCount, sizeof(*n->targets), newSVpvs("WebGPU::Direct::ColorTargetState"));

}

SV *WGPUFragmentState__wrap( const WGPUFragmentState * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::FragmentState", GV_ADD));
  WebGPU__Direct__FragmentState__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__FragmentState;
void WebGPU__Direct__RenderPipelineDescriptor__pack( SV *THIS )
{
  
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPipelineDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPipelineDescriptor",
      "THIS", "WebGPU::Direct::RenderPipelineDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPipelineDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _pack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _pack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _pack_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::PipelineLayout"));
  _pack_obj(aTHX_ h, "vertex", 6,  &n->vertex, sizeof(n->vertex), newSVpvs("WebGPU::Direct::VertexState"));
  _pack_obj(aTHX_ h, "primitive", 9,  &n->primitive, sizeof(n->primitive), newSVpvs("WebGPU::Direct::PrimitiveState"));
  _pack_objptr(aTHX_ h, "depthStencil", 12, (void **) &n->depthStencil, newSVpvs("WebGPU::Direct::DepthStencilState"));
  _pack_obj(aTHX_ h, "multisample", 11,  &n->multisample, sizeof(n->multisample), newSVpvs("WebGPU::Direct::MultisampleState"));
  _pack_objptr(aTHX_ h, "fragment", 8, (void **) &n->fragment, newSVpvs("WebGPU::Direct::FragmentState"));

  
}

void WebGPU__Direct__RenderPipelineDescriptor__unpack( SV *THIS )
{
  if (!SvROK(THIS) || !sv_derived_from(THIS, "WebGPU::Direct::RenderPipelineDescriptor"))
  {
    croak_nocontext("%s: %s is not of type %s",
      "WebGPU::Direct::RenderPipelineDescriptor",
      "THIS", "WebGPU::Direct::RenderPipelineDescriptor");
  }

  HV *h = (HV *)SvRV(THIS);
  WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX_ THIS, NULL);
  if ( !n )
  {
    Newxz(n, 1, WGPURenderPipelineDescriptor);
    sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  }
  _unpack_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));
  _unpack_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));
  _unpack_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::PipelineLayout"));
  _unpack_obj(aTHX_ h, "vertex", 6,  &n->vertex, sizeof(n->vertex), newSVpvs("WebGPU::Direct::VertexState"));
  _unpack_obj(aTHX_ h, "primitive", 9,  &n->primitive, sizeof(n->primitive), newSVpvs("WebGPU::Direct::PrimitiveState"));
  _unpack_objptr(aTHX_ h, "depthStencil", 12, (void **) &n->depthStencil, newSVpvs("WebGPU::Direct::DepthStencilState"));
  _unpack_obj(aTHX_ h, "multisample", 11,  &n->multisample, sizeof(n->multisample), newSVpvs("WebGPU::Direct::MultisampleState"));
  _unpack_objptr(aTHX_ h, "fragment", 8, (void **) &n->fragment, newSVpvs("WebGPU::Direct::FragmentState"));

}

SV *WGPURenderPipelineDescriptor__wrap( const WGPURenderPipelineDescriptor * n )
{
  HV *h = newHV();
  SV *RETVAL = sv_2mortal(newRV((SV*)h));

  sv_magicext((SV *)h, NULL, PERL_MAGIC_ext, NULL, (const char *)n, 0);
  sv_bless(RETVAL, gv_stashpv("WebGPU::Direct::RenderPipelineDescriptor", GV_ADD));
  WebGPU__Direct__RenderPipelineDescriptor__unpack(RETVAL);
  return SvREFCNT_inc(RETVAL);
}

typedef SV* WebGPU__Direct__RenderPipelineDescriptor;
void WebGPU__Direct__BufferMapCallback__callback( WGPUMapAsyncStatus status, WGPUStringView message, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__BufferMapCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__BufferMapCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__BufferMapCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__BufferMapCallback tm_status = newSV(0); 	sv_setiv(tm_status, (IV)status);
; 
    XPUSHs(tm_status); 
    WebGPU__Direct__BufferMapCallback tm_message = newSV(0);     WGPUStringView* ptr_message; Newx(ptr_message, 1, WGPUStringView);
    Copy(&message, ptr_message, 1, WGPUStringView);
    tm_message = WGPUStringView__wrap(ptr_message); /* T_FETCH */
; 
    XPUSHs(tm_message); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__CompilationInfoCallback__callback( WGPUCompilationInfoRequestStatus status, struct WGPUCompilationInfo const * compilationInfo, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__CompilationInfoCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__CompilationInfoCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__CompilationInfoCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__CompilationInfoCallback tm_status = newSV(0); 	sv_setiv(tm_status, (IV)status);
; 
    XPUSHs(tm_status); 
    WebGPU__Direct__CompilationInfoCallback tm_compilationInfo = newSV(0);     tm_compilationInfo = WGPUCompilationInfo__wrap(compilationInfo); /* T_FETCHPTR */
; 
    XPUSHs(tm_compilationInfo); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__CreateComputePipelineAsyncCallback__callback( WGPUCreatePipelineAsyncStatus status, WGPUComputePipeline pipeline, WGPUStringView message, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__CreateComputePipelineAsyncCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__CreateComputePipelineAsyncCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__CreateComputePipelineAsyncCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__CreateComputePipelineAsyncCallback tm_status = newSV(0); 	sv_setiv(tm_status, (IV)status);
; 
    XPUSHs(tm_status); 
    WebGPU__Direct__CreateComputePipelineAsyncCallback tm_pipeline = newSV(0);     tm_pipeline = WGPUComputePipeline__wrap(pipeline); /* T_FETCHPTR */
; 
    XPUSHs(tm_pipeline); 
    WebGPU__Direct__CreateComputePipelineAsyncCallback tm_message = newSV(0);     WGPUStringView* ptr_message; Newx(ptr_message, 1, WGPUStringView);
    Copy(&message, ptr_message, 1, WGPUStringView);
    tm_message = WGPUStringView__wrap(ptr_message); /* T_FETCH */
; 
    XPUSHs(tm_message); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__CreateRenderPipelineAsyncCallback__callback( WGPUCreatePipelineAsyncStatus status, WGPURenderPipeline pipeline, WGPUStringView message, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__CreateRenderPipelineAsyncCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__CreateRenderPipelineAsyncCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__CreateRenderPipelineAsyncCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__CreateRenderPipelineAsyncCallback tm_status = newSV(0); 	sv_setiv(tm_status, (IV)status);
; 
    XPUSHs(tm_status); 
    WebGPU__Direct__CreateRenderPipelineAsyncCallback tm_pipeline = newSV(0);     tm_pipeline = WGPURenderPipeline__wrap(pipeline); /* T_FETCHPTR */
; 
    XPUSHs(tm_pipeline); 
    WebGPU__Direct__CreateRenderPipelineAsyncCallback tm_message = newSV(0);     WGPUStringView* ptr_message; Newx(ptr_message, 1, WGPUStringView);
    Copy(&message, ptr_message, 1, WGPUStringView);
    tm_message = WGPUStringView__wrap(ptr_message); /* T_FETCH */
; 
    XPUSHs(tm_message); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__DeviceLostCallback__callback( WGPUDevice const * device, WGPUDeviceLostReason reason, WGPUStringView message, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__DeviceLostCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__DeviceLostCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__DeviceLostCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__DeviceLostCallback tm_device = newSV(0);     tm_device = WGPUDevice__wrap(*device); /* T_FETCHPTR */
; 
    XPUSHs(tm_device); 
    WebGPU__Direct__DeviceLostCallback tm_reason = newSV(0); 	sv_setiv(tm_reason, (IV)reason);
; 
    XPUSHs(tm_reason); 
    WebGPU__Direct__DeviceLostCallback tm_message = newSV(0);     WGPUStringView* ptr_message; Newx(ptr_message, 1, WGPUStringView);
    Copy(&message, ptr_message, 1, WGPUStringView);
    tm_message = WGPUStringView__wrap(ptr_message); /* T_FETCH */
; 
    XPUSHs(tm_message); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__PopErrorScopeCallback__callback( WGPUPopErrorScopeStatus status, WGPUErrorType type, WGPUStringView message, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__PopErrorScopeCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__PopErrorScopeCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__PopErrorScopeCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__PopErrorScopeCallback tm_status = newSV(0); 	sv_setiv(tm_status, (IV)status);
; 
    XPUSHs(tm_status); 
    WebGPU__Direct__PopErrorScopeCallback tm_type = newSV(0); 	sv_setiv(tm_type, (IV)type);
; 
    XPUSHs(tm_type); 
    WebGPU__Direct__PopErrorScopeCallback tm_message = newSV(0);     WGPUStringView* ptr_message; Newx(ptr_message, 1, WGPUStringView);
    Copy(&message, ptr_message, 1, WGPUStringView);
    tm_message = WGPUStringView__wrap(ptr_message); /* T_FETCH */
; 
    XPUSHs(tm_message); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__QueueWorkDoneCallback__callback( WGPUQueueWorkDoneStatus status, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__QueueWorkDoneCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__QueueWorkDoneCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__QueueWorkDoneCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__QueueWorkDoneCallback tm_status = newSV(0); 	sv_setiv(tm_status, (IV)status);
; 
    XPUSHs(tm_status); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__RequestAdapterCallback__callback( WGPURequestAdapterStatus status, WGPUAdapter adapter, WGPUStringView message, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__RequestAdapterCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__RequestAdapterCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__RequestAdapterCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__RequestAdapterCallback tm_status = newSV(0); 	sv_setiv(tm_status, (IV)status);
; 
    XPUSHs(tm_status); 
    WebGPU__Direct__RequestAdapterCallback tm_adapter = newSV(0);     tm_adapter = WGPUAdapter__wrap(adapter); /* T_FETCHPTR */
; 
    XPUSHs(tm_adapter); 
    WebGPU__Direct__RequestAdapterCallback tm_message = newSV(0);     WGPUStringView* ptr_message; Newx(ptr_message, 1, WGPUStringView);
    Copy(&message, ptr_message, 1, WGPUStringView);
    tm_message = WGPUStringView__wrap(ptr_message); /* T_FETCH */
; 
    XPUSHs(tm_message); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__RequestDeviceCallback__callback( WGPURequestDeviceStatus status, WGPUDevice device, WGPUStringView message, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__RequestDeviceCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__RequestDeviceCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__RequestDeviceCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__RequestDeviceCallback tm_status = newSV(0); 	sv_setiv(tm_status, (IV)status);
; 
    XPUSHs(tm_status); 
    WebGPU__Direct__RequestDeviceCallback tm_device = newSV(0);     tm_device = WGPUDevice__wrap(device); /* T_FETCHPTR */
; 
    XPUSHs(tm_device); 
    WebGPU__Direct__RequestDeviceCallback tm_message = newSV(0);     WGPUStringView* ptr_message; Newx(ptr_message, 1, WGPUStringView);
    Copy(&message, ptr_message, 1, WGPUStringView);
    tm_message = WGPUStringView__wrap(ptr_message); /* T_FETCH */
; 
    XPUSHs(tm_message); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

void WebGPU__Direct__UncapturedErrorCallback__callback( WGPUDevice const * device, WGPUErrorType type, WGPUStringView message, void* userdata1, void* userdata2 )
  {
    if ( userdata1 == NULL || !SvOK((SV *)userdata1) )
    {
      warn("Callback WebGPU__Direct__UncapturedErrorCallback failed: callback function was NULL");
      return;
    }

    SV* callback = (SV *) userdata1;
    SV* user_sv  = (SV *) userdata2;

    if ( userdata2 == NULL || !SvOK(user_sv) )
    {
      user_sv = &PL_sv_undef;
    }

    if ( !SvROK(callback) )
    {
      warn("Callback WebGPU__Direct__UncapturedErrorCallback failed: callback function was not a ref: %s", SvPV_nolen(callback));
      return;
    }
    if ( SvTYPE(SvRV(callback)) != SVt_PVCV )
    {
      warn("Callback WebGPU__Direct__UncapturedErrorCallback failed: callback function was not a coderef: %s", SvPV_nolen(callback));
      return;
    }

    dSP;
    dTARGET;
    PUSHMARK(SP);
    WebGPU__Direct__UncapturedErrorCallback tm_device = newSV(0);     tm_device = WGPUDevice__wrap(*device); /* T_FETCHPTR */
; 
    XPUSHs(tm_device); 
    WebGPU__Direct__UncapturedErrorCallback tm_type = newSV(0); 	sv_setiv(tm_type, (IV)type);
; 
    XPUSHs(tm_type); 
    WebGPU__Direct__UncapturedErrorCallback tm_message = newSV(0);     WGPUStringView* ptr_message; Newx(ptr_message, 1, WGPUStringView);
    Copy(&message, ptr_message, 1, WGPUStringView);
    tm_message = WGPUStringView__wrap(ptr_message); /* T_FETCH */
; 
    XPUSHs(tm_message); 
    XPUSHs(user_sv);
    PUTBACK;
    call_sv((SV *)callback, G_VOID);
  }

