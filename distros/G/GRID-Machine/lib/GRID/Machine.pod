=for PROGRAMMERS
Don't write in Machine.pod file!!!!!
Changes will be lost!!.
Use Template Toolkit tt2/Machine.tt2 instead

=head1 NAME

GRID::Machine - Remote Procedure Calls over a SSH link

=head1 SYNOPSIS

  use GRID::Machine;

  my $host = shift || 'mylogin@remote.machine';

  my $machine = GRID::Machine->new(host => $host, uses => [ 'Sys::Hostname' ]);

  # Install function 'rmap' on remote.machine
  my $r = $machine->sub( 
    rmap => q{
      my $f = shift;        
      die "Code reference expected\n" unless UNIVERSAL::isa($f, 'CODE');

      my @result;
      for (@_) {
        die "Array reference expected\n" unless UNIVERSAL::isa($_, 'ARRAY');

        print hostname().": processing row [ @$_ ]\n";
        push @result, [ map { $f->($_) } @$_ ];
      }
      return @result;
    },
  );
  die $r->errmsg unless $r->ok;

  my $cube = sub { $_[0]**3 };

  # RPC involving code references and nested structures ...
  $r = $machine->rmap($cube, [1..3], [4..6], [7..9]);
  print $r; # Dumps remote stdout and stderr

  for ($r->Results) {               # Output:
    my $format = "%5d"x(@$_)."\n";  #    1    8   27
    printf $format, @$_             #   64  125  216
  }                                 #  343  512  729


=head1 DESCRIPTION

This module is inspired in the L<IPC::PerlSSH> module by Paul Evans.
It provides Remote Procedure Calls
(RPC) via a SSH connection. What made L<IPC::PerlSSH> appealing to me
was that 

  'no special software is required on the remote end, other than the
  ability to run perl nor are any special administrative rights required;
  any account that has shell access and can execute the perl binary on
  the remote host can use this module'.

The only requirement being that automatic SSH autentification
between the local and remote hosts has been established.
I have tried to expand the capabilities but preserving this feature.

=over 2

=item * Provide I<Remote Procedure Calls> (RPC). Subroutines on the remote
side can be called with arbitrary nested structures as arguments from
the local side.

=item * The result of a remote call is a L<GRID::Machine::Result>
object. Among the attributes of such object are the C<results> of the call, 
are the outputs produced in C<stdout> and C<stderr>, C<errmsg> etc. 
The remote function 
can produce output without risk of misleading the protocol.

=item * Services for the transference of files are provided

=item * Support for writing and management 
I<Remote Modules> and the transference of Classes and Modules
between machines

=item * An Extensible Protocol

=back

=head1 METHODS ON THE LOCAL SIDE

=head2 The Constructor C<new>

The typical call looks like:

    my $machine = GRID::Machine->new(host => 'user@remote.machine.domain');

This function returns a new instance of an object. 
The object is blessed in a unique class that inherits from 
C<GRID::Machine>. That is, the new object is a I<singleton>.
When later the machine object is provided with new methods,
those are installed in the I<singleton> class.
The following example illustrates the point.

  $ cat -n classes.pl
   1  #!/usr/local/bin/perl -w
   2  use strict;
   3  use GRID::Machine;
   4
   5  my @m = qw(orion beowulf);
   6
   7  my $m = GRID::Machine->new( host => shift @m, uses => [qw(Sys::Hostname)]);
   8  print ref($m)."\n";
   9
  10  $m->sub( one => q { print hostname().": one\n"; } );
  11  print $m->one;
  12
  13  my $p = GRID::Machine->new( host => shift @m,  uses => [qw(Sys::Hostname)] );
  14  print ref($p)."\n";
  15
  16  $p->sub( one => q { print hostname().": 1\n"; } );
  17  print $p->one;

There are two C<GRID::Machine> objects involved: C<$m> (for a connection to 
a machine named C<orion>)
and C<$p> (connection to a machine named C<beowulf>) created at lines 7 and 13. 
Two subroutines with the same name C<one> are installed
on both machines (lines 10 and 16). As remote functions
they don't collide since they are being executed in two different machines.
As local methods they don't collide too since 
the method C<one> of C<$m> lives in a different namespace than
the method C<one> of C<$p>.
The remote functions are called in lines 11 and 17. The result 
of such call is a C<GRID::Machine::Result> object. 
Such C<GRID::Machine::Result> object describes the result of the 
RPC. It has attributes like: 

=over 2

=item C<results> 

A reference to an C<ARRAY> holding the results returned
by the call

=item C<stdout> 

The ouput produced in the remote C<stdout> during the execution
of the RPC

=item C<stderr> 

The ouput produced in the remote C<stderr> during the execution
of the RPC

=back

etc. 

Wherever is evaluated in a string context a C<GRID::Machine::Result> object
returns a string containing the output produced (to both C<stdout> and C<stderr> plus 
any specific perl error messages as in C<$@>)
during the execution of the RPC.
When executed the former program will produce an output similar to this:

                          $ classes.pl
                          GRID::Machine::138737228
                          orion: one
                          GRID::Machine::139666876
                          beowulf: 1

=head3 Exceptions
 
The constructor doesn't return on failure:
It raises an exception if the connection can't be 
established. 
See the result of an attempt to connect to a machine when there is no automatic authentication:

  $ perl -MGRID::Machine -e " GRID::Machine->new( host => 'user@not.available')"
  ssh: connect to host not.available port 22: No route to host
  Can't execute perl in user@not.available using ssh connection with automatic authentication

=head3 Arguments of C<new>

The following arguments are legal:

=head4 host

The host to connect. The user can be specified here.
Also the port. I.e. it can be something like:

  my $machine = GRID::Machine->new(host => 'casiano@orion:2048');

If host is the empty string:

  my $machine = GRID::Machine->new(host => '');

a process executing C<perl> in the local machine is open via C<open2> (no SSH call will 
be involved).

Instead of specifying the user, port and other C<ssh> parameters here,
the recommended way to work is to
insert a section inside the C</home/user/.ssh/config>
file:

 ...

 # A new section inside the config file: 
 # it will be used when writing a command like: 
 #                     $ ssh gridyum 

 Host orion

 # My username in the remote machine
 user casiano

 # The actual name of the machine: by default the one provided in the
 # command line
 Hostname orion.at.some.domain

 # The port to use: by default 22
 Port 2048

 # The identitiy pair to use. By default ~/.ssh/id_rsa and ~/.ssh/id_dsa
 IdentityFile /home/user/.ssh/orionid

 # Useful to detect a broken network
 BatchMode yes

 # Useful when the home directory is shared across machines,
 # to avoid warnings about changed host keys when connecting
 # to local host
 NoHostAuthenticationForLocalhost yes

=head4 command

This argument is an alternative to the C<host> argument. Use one or the other. It allows 
a more specific control of the command executed.

It can be a I<reference to a list> or a I<string>. It fully specifies the C<command> to execute. 

=over 2 

=item Example 1: Using I<password authentication> 


The following example uses L<Net::OpenSSH> to open a SSH connection
using I<password authentication> instead of asymmetric cryptography:

  $ cat -n openSSH.pl 
     1  use strict;
     2  use warnings;
     3  use Net::OpenSSH;
     4  use GRID::Machine;
     5  
     6  my $host = (shift() or $ENV{GRID_REMOTE_MACHINE});
     7  my @ARGS;
     8  push @ARGS, (user      => $ENV{USR})   if $ENV{USR};
     9  push @ARGS, ( password => $ENV{PASS}) if $ENV{PASS};
    10  
    11  my $ssh = Net::OpenSSH->new($host, @ARGS); 
    12  $ssh->error and die "Couldn't establish SSH connection: ". $ssh->error;
    13  
    14  my @cmd = $ssh->make_remote_command('perl');
    15  { local $" = ','; print "@cmd\n"; }
    16  my $grid = GRID::Machine->new(command => \@cmd);
    17  my $r = $grid->eval('print "hello world!\n"');
    18  print "$r\n";

when executed produces an output like this:

  $ perl openSSH.pl 
  ssh,-S,/Users/localuser/.libnet-openssh-perl/user-machine-2413-275647,-o,User=user,--,machine,perl
  hello world!



=item Example 2: X11 forwarding

The argument associated with C<command> can be a string. 
The following example initiates a SSH connection with the remote machine
with X11 forwarding:

  $ cat -n testptkdb_2.pl 
     1  #!/usr/local/bin/perl -w
     2  # Execute this program being the user
     3  # that initiated the X11 session
     4  use strict;
     5  use GRID::Machine;
     6  
     7  my $host = $ENV{GRID_REMOTE_MACHINE};
     8  
     9  my $machine = GRID::Machine->new(
    10     command => "ssh -X $host perl", 
    11  );
    12  
    13  print $machine->eval(q{ 
    14    print "$ENV{DISPLAY}\n" if $ENV{DISPLAY};
    15    CORE::system('xclock') and  warn "Mmmm.. something went wrong!\n";
    16    print "Hello world!\n";
    17  });

It will produce an output like:

  $ pp2_testptkdb.pl
  localhost:11.0

and I<a graphics clock will pop-up on your window>.


=item Example 3: I<Debugging> L<GRID::Machine> programs

Another example of use of the C<command> option is to put the remote
side on I<debugging> mode:

  pp2@nereida:~/LGRID_Machine/examples$ cat netcat3.pl
  #!/usr/local/bin/perl -w
  use strict;
  use GRID::Machine;

  my $port = shift || 12345;

  my $debug = qq{PERLDB_OPTS="RemotePort=beowulf:$port"};

  my $machine = GRID::Machine->new(
     command => qq{ssh beowulf '$debug perl -d'},
  );

  print $machine->eval(q{
    system('ls');
    print %ENV,"\n";
  });

Start by running netcat on the remote side:

  pp2@nereida:~/LGRID_Machine/examples$ ssh beowulf nc  -v -l beowulf -p 12345

and now run the program:

  pp2@nereida:~/LGRID_Machine/examples$ netcat3.pl

The prompt of the debugger will appear in the netcat terminal

=back 

=head4 No C<host> and No C<command>: no SSH connection. Just a process 

If neither the C<host> nor the C<command> argument are specified,
a process executing C<perl> in the local machine is open via C<open2>:


  $ cat -n commandlocal.pl 
     1  use strict;
     2  use warnings;
     3  use GRID::Machine;
     4  use Sys::Hostname;
     5  
     6  my $machine = GRID::Machine->new(uses => [ 'Sys::Hostname' ]);
     7  
     8  my $remote =  $machine->eval(q{hostname()});
     9  my $local  =  hostname();
    10  
    11  print "Local and remote machines are the same\n" if ($local eq $remote->result);
  
When executed, this program produces the following output:

  $ perl commandlocal.pl 
  Local and remote machines are the same


=head4 logic_id

An integer. Contains the logical identifier associated with the L<GRID::Machine>.
By default, 0 if it was the first L<GRID::Machine> created, 1 if it was the second, etc.
See an example:

  $ cat -n logic_id.pl 
       1  #!/usr/bin/perl -w
       2  use strict;
       3  use GRID::Machine;
       4  
       5  my $m1 = GRID::Machine->new( host => shift());
       6  my $m2 = GRID::Machine->new( host => shift());
       7  my $m3 = GRID::Machine->new( host => shift());
       8  
       9  print $m1->logic_id."\n";
      10  print $m2->logic_id."\n";
      11  print $m3->logic_id."\n";

the execution produces the following output:

  $ ./logic_id.pl machine othermachine somemachine
  0
  1
  2

=head4 log

Relative path of the file where remote C<STDOUT> will be redirected.
Each time a RPC occurs STDOUT is redirected to a file. 
By default the name of this file
is C<$TMP/rperl$LOCALPID_$REMOTEPID.log>, where C<$TMP> is the name of the temporary directory
as returned by C<File::Spec->tmpdir()>, C<$LOCALPID> is the PID of the process running in the local machines
and C<$REMOTEPID> is the PID of the process running
in the remote machine.

=head4 err

Relative path of the file where remote C<STDERR> will be redirected.
Each time a RPC occurs STDERR is redirected to a file. 
By default the name of this file
is C<$TMP/rperl$LOCALPID_$REMOTEPID.err>, where C<$TMP> is the name of the temporary directory
as returned by C<File::Spec->tmpdir()>, C<$LOCALPID> is the PID of the process running in the local machines
and C<$REMOTEPID> is the PID of the process running
in the remote machine.

=head4 report

Relative path of the report file where the (remote) method
C<remotelog> writes.
By default the name of this file
is C<$TMP/rperl$LOCALPID_$REMOTEPID.report>, where C<$TMP> is the name of the temporary directory
as returned by C<File::Spec->tmpdir()>, C<$LOCALPID> is the PID of the process running in the local machines
and C<$REMOTEPID> is the PID of the process running
in the remote machine. Set C<cleanup> to false to keep this file.


When executing the following program:

  $ cat logerr.pl 
  use strict;
  use GRID::Machine;

  my $machine = GRID::Machine->new( host => $ENV{GRID_REMOTE_MACHINE}, cleanup => 0);
  print $machine->eval(q{ 
    print File::Spec->tmpdir()."\n";
    my @files =  glob(File::Spec->tmpdir().'/rperl/*');
    local $" = "\n";
    print "@files\n";
    SERVER->remotelog("This message will be saved in the report file");
  });


the output will be similar to this:

  ~/grid-machine/examples$ perl logerr.pl 
  /tmp
  /tmp/rperl/1309_4318.err
  /tmp/rperl/1309_4318.log
  /tmp/rperl/1309_4318.report


The C<report> file contains:

  $ ssh $GRID_REMOTE_MACHINE cat /tmp/rperl/1309_4318.report
  4318:Sat Apr 16 20:28:22 2011  => This message will be saved in the report file

=head4 wait

Maximum number of seconds to wait for the setting of the connection.
If an automatic connection can't be established in such time.
The constructor calls the C<is_operative function> 
(see section L<The Function is_operative>) to check this.
The default value is 15 seconds.

=head4 ssh

A string.  Specifies the C<ssh> command to be used. Take advantage of this if
you want to specify some special parameters. Defaults to C<ssh>. 

=head4 sshoptions

An C<ARRAY> ref or a string. Specifies options for the C<ssh> command.
See an example in which is a string:


  my $machine = GRID::Machine->new(
                  host => $host,
                  sshoptions => '-p 22 -l casiano',
                  uses => [ 'Sys::Hostname' ]
  );

an another in which is an array ref:

  my $machine = GRID::Machine->new(
                  host => $host,
                  sshoptions => [ '-l', 'casiano'],
                  uses => [ 'Sys::Hostname' ]
  );



=head4 scp

A string defining the program to use to transfer files between the local and remote
machines. Defaults to C<scp -q -p>.



=head4 cleanup

Boolean. If true the remote log files for STDOUT and STDERR will be erased
when the connection ends. True by default.

=head4 sendstdout

Boolean. If true the contents of STDOUT and STDERR after each RPC are sent 
to the client. By default is true. The following example illustrates its use:

  $ cat -n package.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $s = shift || 0;
     6  my $machine = 'user@remote.machine.domain';
     7
     8  my $m = GRID::Machine->new( host => $machine, sendstdout => $s);
     9
    10  my $p = $m->eval(
    11    q{
    12      print "Name of the Caller Package: ";
    13      return caller(0)
    14    }
    15  );
    16  print "$p",$p->result,"\n";

when executed with argument 0 the remote output is not saved and sent, but the returned
result is still available:

                    $ package.pl 1
                    Name of the Caller Package: GRID::Machine
                    $ package.pl 0
                    GRID::Machine


=head4 perl

A string. The perl interpreter to use in the remote machine.
See an example:

  $ cat -n poption.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $machine = shift || 'remote.machine.domain';
     6  my $m = GRID::Machine->new(
     7    host => $machine,
     8    perl => 'perl -I/home/user/prefix -I/home/user/perl',
     9  );
    10
    11  print $m->eval( q{
    12      local $" = "\n";
    13      print  "@INC";
    14    }

when executed the program produces an output similar to this:

    $ poption.pl
    /home/user/prefix
    /home/user/perl
    /etc/perl
    /usr/local/lib/perl/5.8.4
    etc. etc.

=head4 perloptions

A string or an array ref. Contains the options to be passed to the Perl interpreter.
See an example:

  my $host = "orion:22";
  my $machine = GRID::Machine->new(
                  host => $host,
                  sshoptions => '-p 22 -l casiano',
                  perloptions => [ '-w', '-MSys::Hostname' ],
  );

Take into account that C<-MSys::Hostname> takes place at a very early stage
of the boot process and the functions will be exported to the C<main> 
package. Therefore a use of the function C<hostname> exported by L<Sys::Hostname>
inside a remote C<sub> must be done as in this example:

  my $r = $machine->sub(
    rmap => q{
      ...
      gprint ::hostname(),": Processing @$_\n";
      ...
    }



=head4 remotelibs

An C<ARRAY> reference. The referenced array contain the list of modules
that will be loaded when bootstrapping
the remote perl server. It is used to extend the C<GRID::Machine> protocol. 
By default the following modules are loaded:

            GRID::Machine::MakeAccessors  
            GRID::Machine::Message
            GRID::Machine::Result
            GRID::Machine::REMOTE

See the section L<EXTENDING THE PROTOCOL> for a full example.

=head4 startdir

The string specifying the directory where the remote execution starts.
By default the home directory. For example:

    my $m = GRID::Machine->new(host => $host, startdir => '/tmp');

If it does not exist is created.

=head4 startenv

A reference to a hash. It will be used to modify the remote
C<%ENV>.

=head4 pushinc

Reference to a list of directories. All this directories will be C<push>ed in the C<@INC>
list of the remote machine

=head4 unshiftinc

Reference to a list of directories. All this directories will be C<unshift>ed in the C<@INC>
list of the remote machine. See an example:

    use GRID::Machine;

    my $m = GRID::Machine->new(
      host => 'remote.machine.domain',
      unshiftinc => [ qw(/home/user/prefix /home/user/perl) ],
    );

    print $m->eval(q{ local $" = "\n"; print  "@INC"; });


=head4 prefix

Libraries can be transferred from the local to the remote server.
The prefix option is a string containing the directory where 
the libraries will be stored. By default is C<$ENV{HOME}/perl5lib>.

=head4 uses

A reference to an ARRAY of strings. Determines the modules that will be 
loaded when the remote Perl interpreter is started. The enumerated modules must be 
available on the remote side. For instance:

  my $machine = GRID::Machine->new(host => $host, uses => [ 'POSIX qw( uname )' ])

See the section 
L<Opaque Structures> for a full example

=head4 includes

A reference to an ARRAY of strings. Determines the "remote modules"
that will be included when the remote Perl interpreter is started.
The enumerated modules must be available on the local side. For instance,
the following program loads the "Module":

  pp2@nereida:~/LGRID_Machine/examples$ cat -n includes.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $host = shift || die "Usage:\n$0 machine\n";
     6
     7  my $machine = GRID::Machine->new(
     8     host => $host,
     9     includes => [ qw{SomeFunc} ],
    10  );
    11
    12  my $r = $machine->max(7, 9, 2, 8);
    13
    14  print $r;
    15  print "Max of (7, 9, 2, 8) is: ".$r->result."\n";


A "remote module" resembles a module but contains only subroutines 
and C<uses>. The functions are directly placed in the space name of the 
C<GRID::Machine> object (just like the method C<sub> does. 
See section L<The sub Method>).
Here are the contents of the "remote module" C<SomeFunc.pm>:

  pp2@nereida:~/LGRID_Machine/examples$ cat -n SomeFunc.pm
     1  use List::Util qw{max};
     2  use Sys::Hostname;
     3
     4  sub max {
     5    print "machine: ".hostname().": Inside sub two(@_)\n";
     6    List::Util::max(@_)
     7  }

when executed, the program produces the following output:

  pp2@nereida:~/LGRID_Machine/examples$ includes.pl beowulf
  machine: beowulf: Inside sub two(7 9 2 8)
  Max of (7, 9, 2, 8) is: 9


=head4 debug

The value must be a port number higher than 1024. Used to run the remote
side under the control of the debugger. See the section L<REMOTE DEBUGGING>

     my $machine = GRID::Machine->new(
        host => $host,
        debug => $port,
        includes => [ qw{SomeFunc} ],
     );

=head4 survive

No exception will be produced if the connection fails.
Instead C<undef> is returned. Often used when building several L<GRID::Machines>
and you don't care (too much) if one of them fails::

  $ cat pi8.pl 
  #!/usr/bin/perl -w
  use strict;
  use GRID::Machine;
  use GRID::Machine::Group;
  use Data::Dumper;

  my @MACHINE_NAMES = split /\s+/, $ENV{MACHINES};
  my @m = map { GRID::Machine->new(host => $_, wait => 5, survive => 1) } @MACHINE_NAMES;

  my $c = GRID::Machine::Group->new(cluster => [ @m ]);

  $c->sub(suma_areas => q{
     my ($id, $N, $np) = @_;
       
     my $sum = 0;
     for (my $i = $id; $i < $N; $i += $np) {
         my $x = ($i + 0.5) / $N;
         $sum += 4 / (1 + $x * $x);
     }
     $sum /= $N; 
  });

  my ($N, $np, $pi)  = (1000, 4, 0);

  print Dumper($c->suma_areas(args => [ map {  [$_, $N, $np] } 0..$np-1 ]));


=head2 The C<eval> Method

The syntax is:

            $result = $machine->eval( $code, @args )

This method evaluates code in the remote host, passing arguments and returning
a C<GRID::Machine::Result> object. See an example:

    use GRID::Machine qw(is_operative);
    use Data::Dumper;

    my $machine = GRID::Machine->new(host => 'user@remote.machine.domain');

    my $p = { name => 'Peter', familyname => [ 'Smith', 'Garcia'], age => 31 };

    print Dumper($machine->eval(q{
      my $q = shift;

      $q->{familyname}

      }, $p
    ));

=head3 The Result of a RPC

When executed, the former code produces the following output:

    $ struct.pl
    $VAR1 = bless( {
                     'stderr' => '',
                     'errmsg' => '',
                     'type' => 'RETURNED',
                     'stdout' => '',
                     'errcode' => 0,
                     'results' => [
                                    [ 'Smith', 'Garcia' ]
                                  ]
                   }, 'GRID::Machine::Result' );

A C<GRID::Machine::Result> result object describes the result of a RPC.
The C<results> attribute is an ARRAY reference holding the result returned
by the call. The other attributes C<stdout>, C<stderr>, etc. hold
the respective outputs. 
See section L<THE GRID::Machine::Result CLASS> for a more detailed description
of C<GRID::Machine::Result> objects.

=head3 The Algorithm of C<eval>

When a call

            $result = $machine->eval( $code, @args )

occurs, the code C<$code> should be passed in a string, and is compiled using a string
C<eval> in the remote host:

               my $subref = eval "use strict; sub { $code }";

Files C<STDOUT> and C<STDERR> are redirected and the subroutine
referenced by C<$subref> is called 
inside an eval with the specified arguments:

                my @results = eval { $subref->( @_ ) };

=head3 Errors and Exceptions

If there are errors at compile time, they will be
collected into the  C<GRID::Machine::Result> object. 
In the following example the code to eval has an error (variable
C<$q> is not declared):


  ~/grid-machine/examples$ cat -n syntaxerr2.pl 
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  use Data::Dumper;
     5  
     6  my $machine = GRID::Machine->new(host => 'user@machine.domain.es');
     7  
     8  my $p = { name => 'Peter', familyname => [ 'Smith', 'Garcia'] };
     9  
    10  my $r = $machine->eval( q{ $q = shift; $q->{familyname} }, $p);
    11  
    12  die  Dumper($r) unless $r->ok;
    13  
    14  print "Still alive\n";


When executed this code produces something like:

  $VAR1 = bless( {
                 'stderr' => '',
                 'errmsg' => 'user@machine.domain.es: Error while compiling eval \'$q = shift; $q->{fam...\'
                  Global symbol "$q" requires explicit package name at syntaxerr2.pl line 10, <STDIN> line 230.
                  Global symbol "$q" requires explicit package name at syntaxerr2.pl line 10, <STDIN> line 230.',
                 'type' => 'DIED',
                 'stdout' => '',
                 'errcode' => 0
               }, 'GRID::Machine::Result' );

The error message accurately reports the correct source offending line.

C<GRID::Machine::Result> objects have an C<ok> method which
returns TRUE if the RPC call didn't died. Therefore a common idiom
after a RPC is:

                          die "$r" unless $r->ok;

=head3 Scope and Visibility Issues

Since the C<eval> method wraps the code into a subroutine 
(see section L<The Algorithm of eval>) like this

               my $subref = eval "use strict; sub { $code }";

variables declared using C<our> inside an C<eval> must be redeclared
in subsequent C<evals> to make them visible. The following code produces an error message:

 $ cat -n vars1.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine qw(qc);
     4
     5  my $machine = GRID::Machine->new(host => 'user@remote');
     6
     7  $machine->eval(q{
     8    our $h;
     9    $h = [4..9];
    10  });
    11
    12  my $r = $machine->eval(qc q{
    13    $h = [map {$_*$_} @$h];
    14  });
    15
    16  die $r unless $r->noerr;


The interpreter complains about C<$h>:

  $ vars1.pl
  user@remote: Error while compiling eval. \
    Global symbol "$h" requires explicit package name at ./vars1.pl line 13,\
                                                           <STDIN> line 198.
    Global symbol "$h" requires explicit package name at ./vars1.pl line 13, \
                                                           <STDIN> line 198.


The problem can be solved by redeclaring C<our $h> in the second C<eval> or changing
the declaration at line 8 by C<use vars>:

      7 $machine->eval(q{
      8   use vars qw{$h};
      9   $h = [4..9];
     10 });

=head3 Closures

One of the consequences of wrapping C<$code> inside a sub is that any
lexical variable is limited to the scope of the C<eval>.
Another is that nested subroutines inside C<$code> will live in
a (involuntary)  I<closure>. See the example:

  $ cat -n vars5.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine qw(qc);
     4
     5  my $machine = GRID::Machine->new(host => 'casiano@beowulf.pcg.ull.es');
     6
     7  my $r = $machine->eval(qc q{
     8    my $h = 1;
     9
    10    sub dumph {
    11      print "$h\n";
    12      $h++
    13    }
    14
    15    dumph();
    16  });
    17
    18  print "Result: ".$r->result."\nWarning: ".$r->stderr;
    19
    20  $r = $machine->eval(qc q{
    21    dumph();
    22  });
    23
    24  print "Result: ".$r->result."\nWarning: ".$r->stderr;

When executed, the program produces the following warning:

  $ vars5.pl
  Result: 1
  Warning: Variable "$h" will not stay shared at ./vars5.pl line 11\
                                                 , <STDIN> line 194.
  Result: 2
  Warning: Variable "$h" will not stay shared at ./vars5.pl line 11,\
                                                   <STDIN> line 194.

The warning announces that later calls (in subsequent C<eval>s) to sub 
C<dumph> can no longer reach C<$h> (Other than trhough C<dumph> itself).
If you want lexical nested subroutines declare them through a reference:

 $ cat -n vars6.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine qw(qc);
     4
     5  my $machine = GRID::Machine->new(host => 'casiano@beowulf.pcg.ull.es');
     6
     7  my $r = $machine->eval(qc q{
     8    my $h = 1;
     9
    10    use vars '$dumph';
    11    $dumph = sub {
    12      print "$h";
    13      $h++;
    14    };
    15
    16    $dumph->();
    17  });
    18
    19  print "$r\n";
    20
    21  $r = $machine->eval(qc q{
    22    $dumph->();
    23  });
    24
    25  print "$r\n";


=head2 The C<compile> Method

Syntax:

                   $machine->compile( $name, $code )
                   $machine->compile( $name, $code, politely => $politely )
                   $machine->compile( $name, $code, filter => $filter )
                   $machine->compile( $name, $code, politely => $politely, filter => $filter )

This method sends code to the remote host to store it inside the remote
side of the C<GRID::Machine> object. Namely, the C<stored_procedures> 
attribute of the remote object is a hash reference containing the stored 
subroutines. The string C<$code> is compiled into a C<CODE> reference which
can be executed later through the C<call> method.

The two first arguments are the name C<$name> of the subroutine and the 
code C<$code>. The order of the other arguments is irrelevant.

The subroutine name C<$name> must be an identifier, i. e. must match
the regexp C<[a-zA-Z_]\w*>. Full names aren't allowed.

The following example uses C<compile> to
install handlers for the most common file-testing
functions C<-r> (is readable), C<-w> (writeable), etc. (lines 8-15):

  $ cat -n compile.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $machine = $ENV{GRID_REMOTE_MACHINE} || shift;
     6  my $m = GRID::Machine->new( host => $machine );
     7
     8  for (qw(r w e x z s f d  t T B M A C)) {
     9    $m->compile( "$_" => qq{
    10        my \$file = shift;
    11
    12        return -$_ \$file;
    13      }
    14    );
    15  }
    16
    17  my @files = $m->eval(q{ glob('*') })->Results;
    18
    19  for (@files) {
    20    print "$_ is a directory\n" if $m->call('d', $_)->result;
    21  }


After the testing functions  are installed (lines 8-15),
a list of files in the current (remote) directory is obtained (line 17)
and those which are directories are printed (lines 19-21).

=head3 Collisions

When two functions are installed with the same name
the last prevails:

            use GRID::Machine;

            my $machine = shift || 'remote.machine.domain';
            my $m = GRID::Machine->new( host => $machine );

            $m->compile(one => q{print "one\n"; });

            $m->compile(one => q{ print "1\n"; });

            my $r= $m->call("one");
            print $r; # prints 1


To avoid overwriting an existent function the C<exists> method can be used:

            use GRID::Machine;

            my $machine = shift || 'remote.machine.domain';
            my $m = GRID::Machine->new( host => $machine );

            $m->compile(one => q{ print "one\n"; });

            $m->compile(one => q{ print "1"; }) unless $m->exists('one');

            my $r= $m->call("one");
            print $r; # prints "one"

=head3 The C<politely> argument

An alternative solution is to use the C<politely> argument of C<compile>. 
If true the function won't be
overwritten:


            use GRID::Machine;

            my $machine = shift || 'remote.machine.domain';
            my $m = GRID::Machine->new( host => $machine );

            my $r = $m->compile(one => q{ print "one\n"; });

            $r = $m->compile(
              one => q{ print "1"; },
              politely => 1 # Don't overwrite if exists
            );
            print $r->errmsg."\n";

            $r= $m->call("one");
            print $r; # prints "one"

When executed, the former program produces this output:

    $ compile5.pl
    Warning! Attempt to overwrite sub 'one'. New version was not installed.
    one



=head2 The C<sub> Method

Syntax:

                    $machine->sub( $name, $code, %args )

Valid arguments (C<%args>) are::

=over 2

=item *  C<politely =E<gt> $politely>

=item *  C<filter =E<gt> $filter>
                    
=item *  C<around =E<gt> sub { ... }>

=back

This method is identical to the C<compile> method, except that the remote
C<$code> will be available as a (singleton) 
method of the C<$machine> object within the local perl
program. Therefore, two methods of two different C<GRID::Machine> objects with
the same C<$name> are installed on different name spaces. See the example
in section
L<The Constructor new>.

The installed method C<$name> can also be accessed as an ordinary function C<$name>
on the remote side. If a function with the same name already exists, the oldest prevails.
See the call to function C<hi> at line 15 in this  example:

     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  
     5  my $host = $ENV{GRID_REMOTE_MACHINE}; 
     6  my $debug = @ARGV ? 1234 : 0;
     7  
     8  my $machine = GRID::Machine->new(host => $host, debug => $debug);
     9  
    10  $machine->sub( hi => q{ my $n = shift; "Hello $n\n"; } );
    11  
    12  print $machine->hi('Jane')->result;
    13  
    14  # same thing
    15  print $machine->eval(q{ hi(shift()) }, 'Jane')->result;

The execution produces the following output:

  $ perl subfromserver.pl 
  Hello Jane
  Hello Jane

  

=head3 The C<filter> Argument

By default, the result of a subroutine call is a C<GRID::Machine::Result> object.
However, for a given subroutine this behavior can be changed using the C<filter>
argument. Thus, the subroutine C<filter_results> installed in lines 12-15
of the code below, when called returns the C<results> attribute instead of the
whole  C<GRID::Machine::Result> object. The subroutine C<filter_result> installed in lines 17-20
returns the first element of the resulting list:

  $ cat -n filter.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  use Data::Dumper;
     5
     6  my $machine = GRID::Machine->new( host => $ENV{GRID_REMOTE_MACHINE} || shift);
     7
     8  $machine->sub(
     9    nofilter => q{ map { $_*$_ } @_ },
    10  );
    11
    12  $machine->sub(
    13    filter_results => q{ map { $_*$_ } @_ },
    14    filter => 'results'
    15  );
    16
    17  $machine->sub(
    18    filter_result => q{ map { $_*$_ } @_ },
    19    filter => 'result',
    20  );
    21
    22  my @x = (3..5);
    23  my $content = $machine->nofilter(@x);
    24  print Dumper($content);
    25
    26  $content = $machine->filter_results(@x);
    27  print Dumper($content);
    28
    29  $content = $machine->filter_result(@x);
    30  print Dumper($content);

When executed the former program produces this output:

  $ filter.pl
  $VAR1 = bless( {
                   'stderr' => '',
                   'errmsg' => '',
                   'type' => 'RETURNED',
                   'stdout' => '',
                   'errcode' => 0,
                   'results' => [ 9, 16, 25 ]
                 }, 'GRID::Machine::Result' );
  $VAR1 = [ 9, 16, 25 ];
  $VAR1 = 9;

In general, the result of a call to a subroutine installed using

                    $machine->sub( $name, $code, filter => $filter )

will apply the C<$filter> subroutine to the C<GRID::Machine::Result> object resulting
from the call. The filter C<$filter> must be a C<GRID::Machine::Result> method
and must return a scalar. The filter is executed in the remote side of the L<GRID::Machine>.

The usage of the C<results> and C<result> filters can be convenient
when the programmer isn't interested in the other attributes i.e. C<stdout>, 
C<stderr>, etc.

=head3 The C<around> argument

A C<CODE> reference. By default L<GRID::Machine> produces a proxy representative in the local 
side for the C<sub> being installed. The code of the proxy simply calls 
the corresponding C<sub> in the remote side:

      sub { my $self = shift; $self->call( $name, @_ ) };

You can substitute the proxy code by your own code using the C<around> parameter.
The proxy code receives the L<GRID::Machine> object and the arguments
for the remote side of the subroutine.
See the following example:

  $ cat around.pl 
  #!/usr/bin/perl -w
  use strict;
  use GRID::Machine;

  my $machine = GRID::Machine->new( host => $ENV{GRID_REMOTE_MACHINE} || shift);

  $machine->sub( 
    squares => q{ map { $_*$_ } @_ },
    filter => 'results',
    around => sub { 
                my $self = shift; 
                my $r = $self->call( 'squares', @_ ); 
                map { $_+1 } @$r; 
              }
  );

  my @x = (3..5);
  my @r = $machine->squares(@x);
  print "@r\n";

When called, the C<squares> function computes the squares on the remote side
and adds one to each element in the local side:

  $ perl around.pl
  10 17 26

=head2 The C<makemethod> Method

Syntax:

                    $machine->makemethod( $name, %args )

Valid arguments (C<%args>) are::

=over 2

=item *  C<politely =E<gt> $politely>

=item *  C<filter =E<gt> $filter>
                    
=item *  C<around =E<gt> sub { ... }>

=back

This method is identical to the C<sub> method, 
except that it assumes the sub C<$name> has 
been already installed in the remote side.
The C<$name>  can be a fully qualified name,
but the method call must use the short name.
The following example produces a proxy method for the 
function C<reduce> which is already available 
at the remote machine:

  $ cat -n makemethod.pl 
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  
     5  my $host = shift || $ENV{GRID_REMOTE_MACHINE};
     6  
     7  my $m = GRID::Machine->new(host => $host, uses => [q{List::Util qw{reduce}}]);
     8  
     9  $m->makemethod( 'reduce', filter => 'result' );
    10  my $r = $m->reduce(sub { $a > $b ? $a : $b }, (7,6,5,12,1,9));
    11  print "\$r =  $r\n";
    12  
    13  my $m2 = GRID::Machine->new(host => $host, uses => [q{List::Util}]);
    14  
    15  $m2->makemethod( 'List::Util::reduce' );
    16  $r = $m2->reduce(sub { $a > $b ? $a : $b }, (7,6,5,12,1,9));
    17  die $r->errmsg unless $r->ok;
    18  print "\$r =  ".$r->result."\n";

The execution produces:

  $ perl -w makemethod.pl 
  $r =  12
  $r =  12


=head2 The C<call> Method

Syntax:

                  $result = $machine->call( $name, @args )

This method invokes a remote method that has earlier been defined using the
C<compile> or C<sub> methods. The arguments are passed and the result is
returned in the same way as with the C<eval> method.

=head2 The C<makemethods> Method

Convenience method to install several methods in a row. The following call installs
methods C<fork>, C<waitpid>, C<kill> and C<poll>:

     $self->makemethods(
        [ 'fork', filter=>'result',
           around => sub { 
              my $self = shift; 
              my $r = $self->call( 'fork', @_ ); 
              $r->{machine} = $self; 
              $r 
           },
         ],
         [ 'waitpid', filter=>'result', ],
         [ 'kill', filter=>'result', ],
         [ 'poll', filter=>'result', ],
     );


=head2 Nested Structures

Nested Perl Data Structures can be transferred between the local and remote machines transparently:

      use Data::Dumper;

      my $host = shift || 'user@remote.machine.domain';

      my $machine = GRID::Machine->new(host => $host);

      my $r = $machine->sub(
        rpush => q{
          my $f = shift;
          my $s = shift;

          push @$f, $s;
          return $f;
        },
      );
      $r->ok or die $r->errmsg;

      my $f = [[1..3], { a => [], b => [2..4] } ];
      my $s = { x => 1, y => 2};

      $r = $machine->rpush($f, $s);
      die $r->errmsg unless $r->ok;

      $Data::Dumper::Indent = 0;
      print Dumper($r->result)."\n";

when executed the program above produces:

      $ nested4.pl
      $VAR1 = [[1,2,3],{'a' => [],'b' => [2,3,4]},{'y' => 2,'x' => 1}];

=head2 Aliasing

Aliasing between parameters is correctly catched. The following code
presents (line 24) a remote procedure call to a function C<iguales>
where the two local arguments C<$w> and C<$z> are the same:

 $ cat -n alias.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine qw(qc);
     4
     5  my $machine = GRID::Machine->new(host => shift(), uses => [ 'Sys::Hostname' ]);
     6
     7  my $r = $machine->sub( iguales => qc q{
     8      my ($first, $sec) = @_;
     9
    10      print hostname().": $first and $sec are ";
    11
    12      if ($first == $sec) {
    13        print "the same\n";
    14        return 1;
    15      }
    16      print "Different\n";
    17      return 0;
    18    },
    19  );
    20  $r->ok or die $r->errmsg;
    21
    22  my $w = [ 1..3 ];
    23  my $z = $w;
    24  $r = $machine->iguales($w, $z);
    25  print $r;


when executed the program produces the following output:

    $ alias.pl beowulf
    beowulf: ARRAY(0x8275040) and ARRAY(0x8275040) are the same

The reciprocal is true. Equality on the remote side translate to
equality on the local side. The program:

  $ cat -n aliasremote.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $machine = GRID::Machine->new(host => shift(), uses => [ 'Sys::Hostname' ]);
     6
     7  $machine->sub( iguales => q{
     8      my $first = [1..3];
     9      my $sec = $first;
    10
    11      return (hostname(), $first, $sec);
    12    },
    13  );
    14
    15  my ($h, $f, $s)  = $machine->iguales->Results;
    16  print "$h: same\n" if $f == $s;
    17  print "$h: different\n" if $f != $s;


produces the following output:

                            $ aliasremote.pl beowulf
                            beowulf: same

=head2 The C<run> Method

Syntax:

                             $m->run($command)

Is equivalent to 

                             print $m->system($command)
 
Returns true if there were no messages on C<stderr>. 

=head2 The C<exists> Method

Syntax:

                         $machine->exists(q{subname})

Returns true if, and only if, a subroutine  named C<subname>
has been previously installed on that machine (via C<sub>, C<compile> or some other
trick). See an example:

    use GRID::Machine;

    my $host = shift || 'user@remote.machine.domain';

    my $machine = GRID::Machine->new(host => $host);

    $machine->sub( one => q{ print "one\n" });

    print "<".$machine->exists(q{one}).">\n";
    print "<".$machine->exists(q{two}).">\n";

when executed the former code produces the following output:

    $ exists.pl
    <1>
    <>

=head1 FUNCTIONS ON THE LOCAL SIDE


=head2 The C<read_modules> Function

Syntax: 

                use GRID::Machine qw(read_modules)
                read_modules(qw(Module:One Module::Two, Module::Three, ...))

Searches for the specified modules C<Module:One>, etc.
in the local Perl installation.
Returns a string with the concatenation of the 
contents of these modules. 

For example, the line:

       read_modules(qw(Parse::Eyapp Parse::Eyapp::))

returns a string containing the concatenation of the contents of all the modules
in the L<Parse::Eyapp> distribution. Modules are searched by name 
(like C<'YAML'>) or by subcategories (C<'DBD::'> means all modules under the L<DBD> 
subdirectories of your Perl installation, matching both 'C<DBD::Oracle>' and 'C<DBD::ODBC::Changes>').

=head2 The Function C<is_operative>

The syntax is:

  is_operative($ssh, $machine, $command, $wait)

Returns true if C<$machine> is available through 
C<ssh> using automatic authentication and C<$command> can be executed
on the remote machine in less than C<$wait> seconds. The following example
illustrates its use:

  $ cat notavailable.pl
  #!/usr/local/bin/perl -w
  use strict;
  use GRID::Machine qw(is_operative);

  my $host = shift || 'user@machine.domain.es';
  my $command = shift || 'perl -v';
  my $delay = shift || 1;

  die "$host is not operative\n" unless is_operative('ssh', $host, $command, $delay);
  print "host is operative\n";

When not specified $command is C<perl -v> and C<$wait> is 15 seconds.
The following two executions of the former example check the availability
of machine C<beowulf>:

  $ notavailable.pl beowulf
  host is operative
  pp2@nereida:~/LGRID_Machine/examples$ notavailable.pl beowulf chum
  beowulf is not operative

The negative answer for the second execution is due to the fact that no command
called C<chum> is available on that machine.

If C<$machine> is the empty string i.e. C<$machine eq ''>, 
it refers to a direct connection to the local machine and thus,
it succeeds most of the time.

=head2 The Function C<qc>

Prefixes the string passed as argument with the string C<#line $LINE $FILE> where C<$LINE>
and C<$FILE> are the calling line and calling file respectively. Used to provide more accurate 
error messages when evaluating remote code.
See section L<Errors and Exceptions>.

=head1 THE TRANSFERENCE OF FILES 


=head2 The C<put> Method

Syntax:

               $m->put([ 'file1', 'file2', ... ], 'targetdir/')
               $m->put([ 'file1', 'file2', ... ])

Transfer files from the local machine to the remote machine.
When no target directory is specified the files will be copied into
the current directory (i.e. C<$ENV{PWD}>). If C<targetdir/> is a relative
path, it is meant to be relative to the current directory on the remote
machine.
It returns TRUE on success. See an example:

    $ cat put.pl
    #!/usr/local/bin/perl -w
    use strict;
    use GRID::Machine;

    my $m = GRID::Machine->new( host => shift());

    $m->chdir('/tmp');
    $m->put([ $0 ]);
    $m->run("uname -a; ls -l $0");


When executed the program produces:

  $ put.pl orion
  Linux orion 2.6.8-2-686 #1 Tue Aug 16 13:22:48 UTC 2005 i686 GNU/Linux
  -rwxr-xr-x  1 casiano casiano 171 2007-07-01 11:46 ./put.pl

If there is only one source file we can specify a new name for the target.
Thus, the line:

                  $m->put([ $0 ], '/tmp/newname.pl')

will copy the file containing the current program on the remote machine
as C</tmp/newname.pl>

=head2 The C<get> Method

Syntax:

               $m->get( [ 'file1', 'file2'], ... ], 'targetdir/')
               $m->get( [ 'file1', 'file2'], ... ])

Performs the reverse action of C<put>.
Transfer files from the remote machine to the local machine.
When the paths of the files to transfer C<'file1'>, C<'filer2'>, etc.
are relative, they are interpreted as relative to the current directory 
on the remote machine.
See an example:

    use GRID::Machine;

    my $m = GRID::Machine->new( host => shift(), startdir => 'tutu',);

    $m->put([ glob('nes*.pl') ]);
    $m->run('uname -a; pwd; ls -l n*.pl');

    print "*******************************\n";

    my $progs = $m->glob('nes*.pl')->results;
    $m->get($progs, '/tmp/');
    system('uname -a; pwd; ls -l n*.pl');

When executed the program produces an output similar to this:

  $ get.pl remote
  Linux remote 2.6.15-1-686-smp #2 SMP Mon Mar 6 15:34:50 UTC 2006 i686 GNU/Linux
  /home/casiano/tutu
  -rwxr-xr-x 1 casiano casiano 569 2007-05-16 13:45 nested2.pl
  -rwxr-xr-x 1 casiano casiano 756 2007-05-22 10:10 nested3.pl
  -rwxr-xr-x 1 casiano casiano 511 2007-06-27 13:08 nested4.pl
  -rwxr-xr-x 1 casiano casiano 450 2007-06-27 15:20 nested5.pl
  -rwxr-xr-x 1 casiano casiano 603 2007-05-16 14:49 nested.pl
  *******************************
  Linux local 2.4.20-perfctr #6 SMP vie abr 2 18:36:12 WEST 2004 i686 GNU/Linux
  /tmp
  -rwxr-xr-x  1 pp2 pp2 569 2007-05-16 13:45 nested2.pl
  -rwxr-xr-x  1 pp2 pp2 756 2007-05-22 10:10 nested3.pl
  -rwxr-xr-x  1 pp2 pp2 511 2007-06-27 13:08 nested4.pl
  -rwxr-xr-x  1 pp2 pp2 450 2007-06-27 15:20 nested5.pl
  -rwxr-xr-x  1 pp2 pp2 603 2007-05-16 14:49 nested.pl

=head2 The C<copyandmake> Method

Syntax:

    $m->copyandmake(
          dir => $dir,
          files => [ @files ],      # files to transfer
          make => $command,         # execute $command $commandargs 
          makeargs => $commandargs, # after the transference
          cleanfiles => $cleanup,   # remove files at the end
          cleandirs => $cleanup,    # remove the whole directory at the end
    )

C<copyandmake> copies (using C<scp>) the files 
C<@files> to a directory named C<$dir> in the remote machine.
The directory C<$dir> will be created if it does not exists. After the file transfer
the C<command> specified by the C<copyandmake> option 
               
                     make => 'command' 

will be executed with the arguments specified in the option C<makeargs>. 
If the C<make> option isn't specified but there is a file named C<Makefile>
between the transferred files, the C<make> program will be executed. 
Set the C<make> option to number 0 or the string C<''> if you want to 
avoid the execution of any command after the transfer.
The transferred files will be removed when the connection finishes if the
option C<cleanfiles> is set. If the option C<cleandirs> is set,
the 
created directory and all the files below it will be removed. 
Observe that the directory and the files 
will be kept if they were'nt created by this connection.
The call to C<copyandmake> by default sets C<dir> as the current directory in the remote
machine. Use the option C<keepdir =E<gt> 1> to one to avoid this.


=head1 LOADING CLASSES ONTO THE REMOTE SIDE

=head2  The C<modput> Method

Syntax:

            $machine->modput(@Modulenames)

Where C<@Modulenames> is a list of strings describing modules. 
Descriptors can be names (like C<'YAML'>) or subcategories (like C<'DBD::'> 
meaning all modules under the L<DBD> 
subdirectories of your Perl installation, matching both 'C<DBD::Oracle>' and 'C<DBD::ODBC::Changes>').

The following example will copy all the files in the distribution of C<Parse::Eyapp> 
to the remote machine inside the directory C<$machine-E<gt>prefix>. After the call 
to 

            my $r = $machine->install('Parse::Eyapp', 'Parse::Eyapp::')

the module is available for use on the remote machine:

  use GRID::Machine;
  use Data::Dumper;

  my $host = $ENV{GRID_REMOTE_MACHINE} ||shift;

  my $machine = GRID::Machine->new(host => $host, prefix => q{perl5lib/});

  my $r = $machine->modput('Parse::Eyapp', 'Parse::Eyapp::');

  $r = $machine->eval(q{
      use Parse::Eyapp;

      print Parse::Eyapp->VERSION."\n";
    }
  );
  print Dumper($r);

When executed, the former program produces an output like this:

  $ modput.pl
  $VAR1 = bless( {
                   'stderr' => '',
                   'errmsg' => '',
                   'type' => 'RETURNED',
                   'stdout' => "1.07\n",
                   'errcode' => 0,
                   'results' => [ 1 ]
                 }, 'GRID::Machine::Result' );

=head2 The C<include> Method

L<The sub Method> permits the installation of a remote subroutine as a method
of the C<GRID::Machine> object. This is efficient when only a few subroutines are involved.
However for large number of subroutines that procedure is error prone. It 
is better to have the code in some separated module.
This way we can test the components on the local machine and, once we are 
confident of their correct behavior, proceed to 
load them onto the remote machine. This is what C<include> is for. 

=head3 Syntax of C<include>

    $m->include(
          "Some::Module", 
          exclude => [ qw( f1 f2 ) ], 
          alias => { g1 => 'min', g2 => 'max' }
    )

This call will search in the paths in C<@INC> for C<Some/Module.pm>. 
Once C<Some/Module.pm> is found all the subroutines inside the module
will be loaded as methods of the C<GRID::Machine> (singleton) object C<$m>. Code outside subroutines,
plain old documentation and comments will be ignored. Everything after the markers
C<__END__> or C<__DATA__> will also be ignored.
The presence of the parameter 'C<exclude =E<gt> [ qw( f1 f2 ) ]>' means that 
subroutines C<f1> and C<f2> will be excluded from the process.
Subroutine C<g1> will be renamed as C<min> and subroutine C<g2> will be renamed as C<max>.

Consider the following I<Remote Module>:

  $ cat -n Include5.pm
     1  use strict;
     2
     3  sub last {
     4    $_[-1]
     5  }
     6
     7  sub one {
     8    print 'sub one'."\n";
     9  }
    10
    11  sub two {
    12    print "sub two\n";
    13  }

The following program I<includes> the remote module C<Include5.pm>:

  $ cat -n include5.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $host = $ENV{GRID_REMOTE_MACHINE} || 'user@remote.machine';
     6
     7  my $machine = GRID::Machine->new( host => $host);
     8
     9  $machine->include("Include5", exclude => [ qw(two) ], alias => { last => 'LAST' });
    10
    11  for my $method (qw(last LAST one two)) {
    12    if ($machine->can($method)) {
    13      print $machine->host." can do $method\n";
    14    }
    15  }
    16
    17  print $machine->LAST(4..9)->result."\n";

Then function C<two> is excluded and the subroutine C<last> is renamed as C<LAST>:

  $ include5.pl
  user@remote.machine can do LAST
  user@remote.machine can do one
  9

=head3 Remote Modules

The use of  C<include> lead us to the concept of I<Remote Modules>. A I<Remote Module> 
contains a family of subroutines that will be loaded onto the remote machine
via the C<sub> method of C<GRID::Machine> objects.


Here is a small example of I<Remote Module>:

  $ cat -n Include.pm
     1  sub one {
     2    print "sub one\n";
     3  }
     4
     5  sub two {
     6    print 'sub two'."\n";
     7  }
     8
     9  sub three {
    10    print "sub three\n";
    11  }
    12
    13  my $a = "sub five {}\n";
    14  my $b = 'sub six {}';
    15
    16  __DATA__
    17
    18  sub four {
    19    print "four\n";
    20  }


Source after the C<__DATA__> or C<__END__> delimiters are ignored. 
Also, code outside subroutines (for example lines 13 and 14) and C<pod> documentation are ignored.
Only the subroutines defined in the 
module are loaded. See
a program that I<includes> the former remote module:

  $ cat -n include.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $host = $ENV{GRID_REMOTE_MACHINE} || 'user@remote.machine.es';
     6
     7  my $machine = GRID::Machine->new( host => $host);
     8
     9  $machine->include(shift() || "Include");
    10
    11  for my $method (qw(one two three four five six)) {
    12    if ($machine->can($method)) {
    13      print $machine->host." can do $method\n";
    14      print $machine->$method();
    15    }
    16  }


When executed the former program produces an output like:
 
  $ include.pl
  user@remote.machine.es can do one
  sub one
  user@remote.machine.es can do two
  sub two
  user@remote.machine.es can do three
  sub three


=head3 The C<use> and C<LOCAL> directives in Remote Modules

Two directives that can be used isinde a I<Remote Module> are C<use> and
C<LOCAL>:

=over 2

=item *
A C<use Something> pragma inside a I<Remote Module> indicates that such module 
C<Something> must be loaded
onto the remote machine. Of course, the module
must be available there. An alternative to install it
is to transfer the module(s) on the local 
machine to the remote machine using C<modput> (see section L<The modput Method>).

=item *
A C<LOCAL { code }> directive inside a I<Remote Module> wraps C<code> that 
will be executed on the local machine. C<LOCAL> directives can be used to massively
load subroutines as in the example below.

=back

The following remote module contains a C<use> pragma in line 2. 

  $ cat -n Include4.pm
     1  use strict;
     2  use List::Util qw(sum); # List::Util will be loaded on the Remote Side
     3
     4  sub sigma {
     5    sum(@_);
     6  }
     7
     8  LOCAL {
     9    print "Installing new functions\n";
    10    for (qw(r w e x z s f d  t T B M A C)) {
    11      SERVER->sub( "$_" => qq{
    12          my \$file = shift;
    13
    14          return -$_ \$file;
    15        }
    16      );
    17    }
    18  }


Lines 9-17 are surrounded by a C<LOCAL> directive and thus they will be executed
on the local side. The effect is to install new methods for the C<GRID::Machine>
object that will be equivalent to the classic Perl file tests: C<-r>, C<-w>, etc.
Inside a C<LOCAL> directive the function C<SERVER> returns a reference 
to the current C<GRID::Machine> object (see line 11).

See a program that loads the former I<Remote Module>.
The call to C<include> will load C<List::Util> on the remote machine importing
the C<sum> function. Furthermore, methods with names
C<sigma>, C<r>, C<w>, etc. will be installed:

  $ cat -n include4.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $host = $ENV{GRID_REMOTE_MACHINE} || 'user@remote.machine.es';
     6
     7  my $machine = GRID::Machine->new(host => $host,);
     8
     9  $machine->include(shift() || "Include4");
    10
    11  print "1+..+5 = ".$machine->sigma( 1..5 )->result."\n";
    12
    13  $machine->put([$0]);
    14
    15  for my $method (qw(r w e x s t f d)) {
    16    if ($machine->can($method)) {
    17      my $r = $machine->$method($0)->result || "";
    18      print $machine->host."->$method( include4.pl ) = <$r>\n";
    19    }
    20  }


When executed the program produces an output like:

  $ include4.pl
  Installing new functions
  1+..+5 = 15
  user@remote.machine.es->r( include4.pl ) = <1>
  user@remote.machine.es->w( include4.pl ) = <1>
  user@remote.machine.es->e( include4.pl ) = <1>
  user@remote.machine.es->x( include4.pl ) = <1>
  user@remote.machine.es->s( include4.pl ) = <498>
  user@remote.machine.es->t( include4.pl ) = <>
  user@remote.machine.es->f( include4.pl ) = <1>
  user@remote.machine.es->d( include4.pl ) = <>

=head3 Specifying filters and proxys via C<#gm>

We can include comments C<grid machine comments> between 
the name of the subroutine and the open curly bracket
to specify the options for the C<sub> installation.
The comments must start with C<#gm >. See an example:

  $ cat -n Include6.pm 
     1  use strict;
     2  
     3  sub last 
     4  #gm (filter => 'result', ) 
     5  {
     6    $_[-1] 
     7  }
     8  
     9  sub LASTitem 
    10  {
    11    $_[-1] 
    12  }
    13  
    14  sub one 
    15  #gm (
    16  #gm   filter => 'result', 
    17  #gm   around => sub { 
    18  #gm     my $self = shift; 
    19  #gm     my $r = $self->call( 'one', @_ ); 
    20  #gm     use Sys::Hostname;
    21  #gm     $r."Local machine: ".hostname()."\n" 
    22  #gm   },
    23  #gm )
    24  {
    25    SERVER->host." received: <@_>\n";
    26  }

Sub C<last> will return just the C<result> instead of the 
full L<GRID::Machine::Result> object.
We have also substituted the proxy representative of
method C<one> using the C<around> parameter.
Consider the following script example:

  $ cat -n include6.pl 
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  use Data::Dumper;
     5  
     6  my $host = $ENV{GRID_REMOTE_MACHINE};
     7  
     8  my $machine = GRID::Machine->new( host => $host);
     9  
    10  $machine->include("Include6");
    11  
    12  print $machine->last(4..9)."\n";
    13  
    14  my $r = $machine->LASTitem(4..9);
    15  print Dumper($r);
    16  
    17  print $machine->one(4..9)."\n";

when executed, produces:

  $ perl include6.pl 
  9
  $VAR1 = bless( {
                   'stderr' => '',
                   'errmsg' => '',
                   'type' => 'RETURNED',
                   'stdout' => '',
                   'errcode' => 0,
                   'results' => [
                                  9
                                ]
                 }, 'GRID::Machine::Result' );
  some.machine received: <4 5 6 7 8 9>
  Local machine: my.local.machine

=head1 THE C<GRID::Machine::Core> REMOTE MODULE

The creation of a C<GRID::Machine> object through a call to C<GRID::Machine-E<gt>new>
implies the loading of a I<Remote Module> called  C<GRID::Machine::Core> which is delivered
with the C<GRID::Machine> distribution. Another module that is being I<included> at 
construction time is C<GRID::Machine::RIOHandle>.

One of the final goals of the C<GRID::Machine::Core> remote 
module is to provide homonymous methods per each of the Perl
C<CORE::> functions. At present time only a few are supported.


The following functions defined in the Remote Module C<GRID::Machine::Core> are loaded
via the C<include> mechanism on the remote machine. Therefore, they work as methods of the
C<GRID::Machine> object on the local machine. They perform the same operations than their Perl
aliases:

=head2 Function C<getcwd>

=head2 Function C<chdir>

=head2 Function C<umask>

=head2 Function C<mkdir>

=head2 Function C<system>

Executes C<system> on the remote machine. See an example:

  $ cat -n examples/transfer2.pl 
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine qw(is_operative);
     4  use Data::Dumper;
     5  
     6  my $host = shift || $ENV{GRID_REMOTE_MACHINE};
     7  
     8  my $machine = GRID::Machine->new( 
     9        host => $host,
    10        cleanup => 1,
    11        sendstdout => 1,
    12        startdir => '/tmp/perl5lib',
    13        prefix => '/tmp/perl5lib/',
    14     );
    15  
    16  my $dir = $machine->getcwd->result;
    17  print "$dir\n";
    18  
    19  $machine->modput('Parse::Eyapp::') or die "can't send module\n";
    20  
    21  print $machine->system('tree');
    22  my $r =  $machine->system('doesnotexist');
    23  print Dumper $r;

Observe the overloading of C<bool> at line 19. C<modput> returns
a C<GRID::Machine::Result> object which is evaluated in a Boolean 
context as a call to the C<result> getter.

When executed produces an output like:

  $ perl -w examples/transfer2.pl 
  /tmp/perl5lib
  .
  `---- Parse
      `---- Eyapp
          |---- Base.pm
          |---- Cleaner.pm
          |---- Driver.pm
          |---- Grammar.pm
          |---- Lalr.pm
          |---- Node.pm
          |---- Options.pm
          |---- Output.pm
          |---- Parse.pm
          |---- Scope.pm
          |---- TokenGen.pm
          |---- Treeregexp.pm
          |---- _TreeregexpSupport.pm
          |---- Unify.pm
          `---- YATW.pm

  2 directories, 15 files
  $VAR1 = bless( {
                   'stderr' => 'Can\'t exec "doesnotexist":',
                   'errmsg' => '',
                   'type' => 'RETURNED',
                   'stdout' => '',
                   'errcode' => -1,
                   'results' => [ -1 ]
                 }, 'GRID::Machine::Result' );

=head2 Function C<qx>

Similar to backtick quotes. The result depends on the context.
In a list context returns a list with the lines of the output.
In a scalar context reurns a string with the output. The value of
C<$"> on the local machine decides the register separator used.
See an example:

  $ cat -n transfer3.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine qw(is_operative);
     4  use Data::Dumper;
     5
     6  my $host = shift || 'casiano@remote.machine.es';
     7
     8  my $machine = GRID::Machine->new( host => $host );
     9  my $DOC = << "DOC";
    10  one. two. three.
    11  four. five. six.
    12  seven.
    13  DOC
    14
    15  # List context: returns  a list with the lines
    16  {
    17    local $/ = '.';
    18    my @a = $machine->qx("echo '$DOC'");
    19    local $"= ",";
    20    print "@a";
    21  }
    22
    23  # scalar context: returns a string with the output
    24  my $a = $machine->qx("echo '$DOC'");
    25  print $a;


When executed produces the following output:

  $ transfer3.pl
  one., two., three.,
  four., five., six.,
  seven.,

  one. two. three.
  four. five. six.
  seven.



=head2 Function C<glob>

=head2 Function C<tar>

Is equivalent to:

            system('tar', $options, ,'-f', $file)

Where C<$options> is a string containing the options.
Returns the error code from C<tar>.
Example:

  $m->tar($dist, '-xz')->ok or warn "$host: Can't extract files from $dist\n";

=head2 Function C<version>

Syntax:

              $machine->version('Some::Module')

Returns the VERSION of the module if the given module is installed on the remote machine
and has a VERSION number. 

See an example of use:

  $ cat version.pl
  #!/usr/bin/perl -w
  use strict;
  use GRID::Machine;
  use Data::Dumper;

  my $host = $ENV{GRID_REMOTE_MACHINE} ||shift;

  my $machine = GRID::Machine->new(host => $host,);

  print Dumper($machine->version('Data::Dumper'));
  print Dumper($machine->version('Does::Not::Exist::Yet'));

When executed the program produces an  output similar to this:

  $ version.pl
  $VAR1 = bless( {
                   'stderr' => '',
                   'errmsg' => '',
                   'type' => 'RETURNED',
                   'stdout' => '',
                   'errcode' => 0,
                   'results' => [ '2.121_08' ]
                 }, 'GRID::Machine::Result' );
  $VAR1 = bless( {
                   'stderr' => 'Can\'t locate Does/Not/Exist/Yet.pm in @INC \
                                (@INC contains: /etc/perl /usr/local/lib/perl/5.8.8 ...
                                BEGIN failed--compilation aborted.
                               ',
                   'errmsg' => '',
                   'type' => 'RETURNED',
                   'stdout' => '',
                   'errcode' => 0,
                   'results' => [ '' ]
                 }, 'GRID::Machine::Result' );


=head2 Function C<installed>

Syntax:

              $machine->installed('Some::Module')

Returns TRUE if the given module is installed on the remote machine.
Is equivalent to:

            system("$^X -M$module -e 0")

=head2 File Status Methods

Methods that are equivalent to the tests function

      -r -w -e -x -z -s -f -d  -t -T -B -M -A -C

are provided. Since hyphens aren't legal in Perl identifiers
the hyphen has been substituted by an underscore.
See an example:

  $ cat -n copyandmkdir.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $host = 'remote.machine.es';
     6  my $dir = shift || "somedir";
     7  my $file = shift || $0; # By default copy this program
     8
     9  my $machine = GRID::Machine->new(
    10    host => $host,
    11    uses => [qw(Sys::Hostname)],
    12  );
    13
    14  my $r;
    15  $r = $machine->mkdir($dir, 0777) unless $machine->_w($dir);
    16  die "Can't make dir\n" unless $r->ok;
    17  $machine->chdir($dir)->ok or die "Can't change dir\n";
    18  $machine->put([$file]) or die "Can't copy file\n";
    19  print "HOST: ",$machine->eval(" hostname ")->result,"\n",
    20        "DIR: ",$machine->getcwd->result,"\n",
    21        "FILE: ",$machine->glob('*')->result,"\n";


When this program runs we get an output similar to this:

                    $ copyandmkdir.pl
                    HOST: orion
                    DIR: /home/casiano/somedir
                    FILE: copyandmkdir.pl




=head1 ON THE REMOTE SIDE


=head2 The Structure of the Remote Server

As with most servers, the server side of the C<GRID::Machine> object consists of an infinite
loop waiting for requests:

  while( 1 ) {
     my ( $operation, @args ) = $server->read_operation();

     if ($server->can($operation)) {
       $server->$operation(@args);
       next;
     }

     $server->send_error( "Unknown operation $operation\nARGS: @args\n" );
  }

=head2 The Protocol

The protocol simply consists of the name of the method to execute and the arguments
for such method. The programmer - using inheritance - can extend the protocol
with new methods (see the section L<EXTENDING THE PROTOCOL>). The following 
operations are currently supported:

=over 2

=item * C<GRID::Machine::EVAL>

Used by the local method C<eval>

=item * C<GRID::Machine::STORE>

Used by the local methods C<compile> and C<sub> to install code on the remote side.

=item * C<GRID::Machine::EXISTS>

Used by the local method C<exists>

=item * C<GRID::Machine::CALL>

Used by the local method C<call>

=item * C<GRID::Machine::MODPUT>

Used by the C<modput> method. A list of pairs (C<Module::Name, code for Module::Name>) is sent to the remote machine.
For each pair, the remote side writes to disk a file C<Module/Name.pm> with the contents of the string 
C<code for Module::Name>. The file is stored in the directory referenced by the C<prefix> attribute 
of the C<GRID::Machine> object.


=item * C<GRID::Machine::OPEN>

Used by the C<open> method. As arguments receives a string
defining the way the file will be accessed.

=item * C<GRID::Machine::QUIT>

Usually is automatically called when the C<GRID::Machine> object
goes out of scope 

=item * C<GRID::Machine::GPRINT>

Most requests go from the local machine to the remote Perl server.
However, this and the next go in the other direction. This request
is generated in the remote machine and served by the local machine.
It is used when inmediate printing is required
(see section L<Functions gprint and gprintf>)


=item * C<GRID::Machine::GPRINTF>

This request
is generated in the remote machine and served by the local machine.
It is used when inmediate printing is required
(see section L<Functions gprint and gprintf>)

=item * C<GRID::Machine::CALLBACK>

Used to implement callbacks

=back 

=head2 The C<SERVER> function

The C<SERVER> function is available on the remote machine. Returns
the object representing the remote side of the C<GRID::Machine> object.
This way code on the remote side can gain access to the C<GRID::Machine> 
object. See an example:

    my $m = GRID::Machine->new( host => 'beowulf');

    $m->sub(installed => q { return  keys %{SERVER->stored_procedures}; });
    my @functions = $m->installed()->Results;
    local $" = "\n";
    print "@functions\n";

The C<stored_procedures> method returns a reference to the hash containing
the subroutines installed via the C<sub> and C<compile> methods. The keys are
the names of the subroutines, the values are the C<CODE> references implementing
them.  When executed the former program produces the list of installed subroutines:

                    $ accessobject.pl
                    tar
                    system
                    installed
                    getcwd
                    etc.

=head2 The C<read_operation> Method 

Syntax:

     my ( $operation, @args ) = $server->read_operation( );

Reads from the link. Returns the type of operation/tag and the results of the 
operation.

=head2 The C<send_error> Method 

Syntax:

     $server->send_error( "Error message" );

Inside code to be executed on the remote machine we can use the function
C<send_error> to send  error messages to the client

=head2 The C<send_result> Method

Syntax:

    $server->send_result( 
	stdout  => $stdout,
	stderr  => $stderr,
        errmsg  => $errmsg,
        results => [ @results ],
    );

Inside code to be executed on the remote machine we can use the function
C<send_result> to send  results to the client

=head1 EXTENDING THE PROTOCOL

Let us see a simple example. We will extend the
protocol with a new tag C<MYTAG>. 
We have to write a module that will be used in the remote
side of the link:

  $ cat -n MyRemote.pm      
     1  package GRID::Machine;
     2  use strict;
     3
     4  sub MYTAG {
     5    my ($server, $name) = @_;
     6
     7    $server->send_operation("RETURNED", "Hello $name!\n") if defined($name); 
     8    $server->send_operation("DIED", "Error: Provide a name to greet!\n");
     9  }
    10
    11  1;


This component will be loaded on the remote machine via the ssh link.
The name of the handling method C<MYTAG>
must be the same than the name of the tag (operation type) used to send the request. 
Here is a client program using the new tag:

  $ cat -n extendprotocol.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $name = shift;
     6  my $host = 'user@remote.machine';
     7
     8  my $machine = GRID::Machine->new(host => $host, remotelibs => [ qw(MyRemote) ]);
     9
    10  $machine->send_operation( "MYTAG", $name);
    11  my ($type, $result) = $machine->read_operation();
    12
    13  die $result unless $type eq 'RETURNED';
    14  print $result;


When the program is executed we get the following output:

                          $ extendprotocol.pl Larry
                          Hello Larry!
                          $ extendprotocol.pl
                          Error: Provide a name to greet!

=head1 INMEDIATE PRINTING

=head2 Functions C<gprint> and C<gprintf>

When running a RPC the output generated during the execution
of the remote subroutine isn't available until the return of the 
RPC. Use C<gprint> and C<gprintf> 
if what you want is inmediate output (for debugging purposes, for instance).
They work as C<print> and C<printf> respectively.

See an example:

  $ cat -n gprint.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $host = $ENV{GRID_REMOTE_MACHINE};
     6
     7  my $machine = GRID::Machine->new(host => $host, uses => [ 'Sys::Hostname' ]);
     8
     9  my $r = $machine->sub(
    10    rmap => q{
    11      my $f = shift; # function to apply
    12      die "Code reference expected\n" unless UNIVERSAL::isa($f, 'CODE');
    13
    14
    15      print "Inside rmap!\n"; # last message
    16      my @result;
    17      for (@_) {
    18        die "Array reference expected\n" unless UNIVERSAL::isa($_, 'ARRAY');
    19
    20        gprint hostname(),": Processing @$_\n";
    21
    22
    23        push @result, [ map { $f->($_) } @$_ ];
    24      }
    25
    26      gprintf "%12s:\n",hostname();
    27      for (@result) {
    28        my $format = "%5d"x(@$_)."\n";
    29        gprintf $format, @$_
    30      }
    31      return @result;
    32    },
    33  );
    34  die $r->errmsg unless $r->ok;
    35
    36  my $cube = sub { $_[0]**3 };
    37  $r = $machine->rmap($cube, [1..3], [4..6], [7..9]);
    38  print $r;

When executed the program produces the following output:

          $ gprint.pl
          orion: Processing 1 2 3
          orion: Processing 4 5 6
          orion: Processing 7 8 9
                 orion:
              1    8   27
             64  125  216
            343  512  729
          Inside rmap!

Observe how the message C<'Inside rmap!'> generated at line 15 using C<print> is the last 
(actually is sent to C<STDOUT> in line 38).
The messages generated using C<gprint> and C<gprintf> (lines 20, 26 and 29)
were inmediately sent to C<STDOUT>.

=head1 REMOTE DEBUGGING 

To run the remote side under the control of the perl debugger use the C<debug>
option of C<new>. The associated value must be a port number higher than 1024:

     my $machine = GRID::Machine->new(
        host => $host,
        debug => $port,
        includes => [ qw{SomeFunc} ],
     );

Before running the example open a SSH session to the remote machine
in a different terminal and execute C<netcat> to listen (option C<-l>)
in the chosen port:

  pp2@nereida:~/LGRID_Machine$ ssh beowulf 'netcat -v -l -p 12345'
  listening on [any] 12345 ...
                              
Now run the program in the first terminal:

  pp2@nereida:~/LGRID_Machine/examples$ debug1.pl beowulf:12345
  Debugging with 'ssh beowulf PERLDB_OPTS="RemotePort=beowulf:12345" perl -d'
  Remember to run 'netcat -v -l -p 12345' in beowulf

The program looks blocked. If you go to the other terminal you will find
the familiar perl debugger prompt:

  casiano@beowulf:~$ netcat -v -l -p 12345
  listening on [any] 12345 ...
  connect to [193.145.102.240] from beowulf.pcg.ull.es [193.145.102.240] 38979

  Loading DB routines from perl5db.pl version 1.28
  Editor support available.

  Enter h or `h h' for help, or `man perldebug' for more help.

  GRID::Machine::MakeAccessors::(/home/pp2/LGRID_Machine/lib/GRID/Machine/MakeAccessors.pm:33):
  33:     1;
  auto(-1)  DB<1> c GRID::Machine::main
  GRID::Machine::main(/home/pp2/LGRID_Machine/lib/GRID/Machine/REMOTE.pm:490):
  490:      my $server = shift;
    DB<2>                        

From now on you can execute almost any debugger command. Unfortunately
you are now inside C<GRID::Machine> code and - until you gain some familiarity 
with C<GRID::Machine> code -
it is a bit difficult to find where your code is and where to put 
your breakpoints.  Future work: write a proper debugger front end.




=head1 THE C<GRID::Machine::Result> CLASS


The class C<GRID::Machine::Result> is used by both the local and remote
sides of the C<GRID::Machine>, though most of its methods are called 
on the remote side. 

The result of a RPC is a C<GRID::Machine::Result> object. 
Such object has the following attributes:

=over 2

=item * I<type>

The C<type> of result returned. A string. Fixed by the protocol.
Common values are C<RETURNED> and C<DIED>.

=item * I<stdout>

A string containing the contents of C<STDOUT>
produced during the duration of the RPC

=item * I<stderr>

A string containing the contents of C<STDERR>
produced during the duration of the RPC

=item * I<results>

A reference to an C<ARRAY> containing the results returned by the RPC

=item * I<errcode>

The contents of C<$?> as produced during the RPC

=item * I<errmsg>

The contents of C<$@> as produced during the RPC

=back

=head2 The Constructor C<new>

Syntax:

  GRID::Machine::Result->new(
    stdout => $rstdout, 
    errmsg  => $err, 
    stderr => $rstderr, 
    results => \@results
  )

Builds a new result object.  

=head2 The C<ok> Method

Returns C<TRUE> if the RPC didn't died, i.e. if the C<type> attribute is not
the string C<'DIED'>

=head2 The C<noerr> Method

Returns C<TRUE> if the RPC didn't died and didn't send any messages 
through stderr.
See an example. When running the following program:

  $ cat noerrvsok.pl
  #!/usr/local/bin/perl -w
  use strict;
  use GRID::Machine;

  my $machine = shift || $ENV{GRID_REMOTE_MACHINE};
  my $m = GRID::Machine->new( host => $machine );

  my $r = $m->eval( q{print STDERR "This is the end\n" });

  print "print to STDERR:\n";
  print "<".$r->ok.">\n";
  print "<".$r->noerr.">\n";

  $r = $m->eval( q{warn "This is a warning\n" });

  print "Warn:\n";
  print "<".$r->ok.">\n";
  print "<".$r->noerr.">\n";

we get the following output:



                $ errvsok.pl
                print to STDERR:
                <1>
                <>
                Warn:
                <1>
                <>

=head2 The C<result> Method

Returns the first element of the list referenced by the C<results> attribute
This method is called when a C<GRID::Machine::Result> object is evaluated in a Boolean 
context (i.e. C<bool> is overloaded).

=head2 The C<Results> Method

Returns the list referenced by the C<results> attribute

=head2 The C<str> Method. Stringification of a C<Result> object

Returns the string made of concatenating C<stdout>, C<stderr> and C<errmsg>.
The Perl operator C<q("")> is overloaded using this method. Thus,
wherever a C<GRID::Machine::Result> object is used on a scalar string 
context the C<str> will be called.



=head1 THE C<GRID::Machine::Message> CLASS


This class is used by both the local and the remote sides of the
C<GRID::Machine>. It implements the low level communication 
layer. It is responsible of marshalling the data.

=head2 The C<read_operation> Method

Syntax:

   my ( $operation, @args ) = $server->read_operation( );

Returns the kind of operation and the data sent by the other
side of the SSH link.

=head2 The C<send_operation> Method

Examples:

  $server->send_operation("RETURNED", GRID::Machine::Result->new( %arg ));

  $server->send_operation("DIED", GRID::Machine::Result->new( 
                                    errmsg  => "$server->{host}: $message")
  );

  $server->send_operation("RETURNED", exists($server->{stored_procedures}{$name}));




Sends to other side of the link the C<type> of the message and the arguments.
It uses L<Data::Dumper> to serialize the data structures.

=head1 REMOTE INPUT/OUTPUT

C<GRID::Machine> objects have the C<open> method.
The C<open> method returns a  L<GRID::Machine::IOHandle> object.
Such objects very much behave as L<IO::Handle> objects but instead
they refer to handles and files on the associated machine.
See a simple example:

  use GRID::Machine;

  my $machine = shift || 'remote.machine';
  my $m = GRID::Machine->new( host => $machine );

  my $f = $m->open('> tutu.txt'); # Creates a GRID::Machine::IOHandle object
  $f->print("Hola Mundo!\n");
  $f->print("Hello World!\n");
  $f->printf("%s %d %4d\n","Bona Sera Signorina", 44, 77);
  $f->close();

  $f = $m->open('tutu.txt');
  my $x = <$f>;
  print "\n******diamond scalar********\n$x\n";
  $f->close();

  $f = $m->open('tutu.txt');
  my $old = $m->input_record_separator(undef);
  $x = <$f>;
  print "\n******diamond scalar context and \$/ = undef********\n$x\n";
  $f->close();
  $old = $m->input_record_separator($old);

A remote C<GRID::Machine::IOHandle> object is created through the call

                   my $f = $m->open('> tutu.txt')

from that moment on we can write in the file using the C<print> and C<printf> methods
of C<GRID::Machine::IOHandle> objects.
You can see later in the former code how the diamond operator can be called to read on a remote file:

                             my $x = <$f>;

When we run the former example we get an ouput similar to this:


    $ synopsisiohandle.pl

    ******diamond scalar********
    Hola Mundo!


    ******diamond scalar context and $/ = undef********
    Hola Mundo!
    Hello World!
    Bona Sera Signorina 44   77

See also the documentation in L<GRID::Machine::IOHandle> for more detailed 
information.

=head1 REMOTE PIPES

=head2 Opening pipes for input

The C<open> method of C<GRID::Machine> objects can be used to pipe programs as in the following
example:

  pp2@nereida:~/LGRID_Machine/examples$ cat -n pipes1.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $machine = shift || 'remote.machine.domain';
     6  my $m = GRID::Machine->new( host => $machine );
     7
     8  my $f = $m->open('uname -a |');
     9  my $x = <$f>;
    10  print "UNAME result: $x\n"

In a scalar context C<open> returns the handler.
In list context returns the pair C<(handler, PID)>.
See L<GRID::Machine::perlparintro> for a more detailed example.

When executed the program produces an output similar to this:

  pp2@nereida:~/LGRID_Machine/examples$ pipes1.pl
  UNAME result: Linux remote 2.6.8-2-686 #1 Tue Aug 16 13:22:48 UTC 2005 i686 GNU/Linux

=head2 Opening pipes for output

Pipes can be also for input as the following example shows:

  pp2@nereida:~/LGRID_Machine/examples$ cat -n pipes.pl
   1  #!/usr/local/bin/perl -w
   2  use strict;
   3  use GRID::Machine;
   4
   5  my $machine = shift || 'remote.machine';
   6  my $m = GRID::Machine->new( host => $machine );
   7
   8  my $i;
   9  my $f = $m->open('| sort -n > /tmp/sorted.txt');
  10  for($i=10; $i>=0;$i--) {
  11    $f->print("$i\n")
  12  }
  13  $f->close();
  14
  15  my $g = $m->open('/tmp/sorted.txt');
  16  print while <$g>;

when executed, the program produces the following output:

  pp2@nereida:~/LGRID_Machine/examples$ pipes.pl
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
10

When opening a pipe for output like in line 9 in the 
former example 

  my $f = $m->open('| sort -n > /tmp/sorted.txt')

be sure to redirect the C<STDOUT> of the program. 
Otherwise, C<GRID::Machine> will redirect it to the
C<null> device and the output will be lost.

=head2 Bidirectional pipes: C<open2> 

Synopsis:


  my $WTR = IO::Handle->new();
  my $RDR = IO::Handle->new();
  my $pid = $m->open2($fromchild, $tochild, 'command and args');

The C<open2> method runs the given command in machine C<$m>
and connects C<$fromchild> for
reading from C<command> and C<$tochild> 
for writing from C<command>.
Returns the PID of the process executing C<command>.

=head2 Bidirectional pipes: C<open3>

Synopsis:

  my $pid = $m->open3($tochild, $fromchild, $errfromchild, 'command and args');

Spawns the given command and connects C<$fromchild> for reading from the child,
C<$tochild> for writing to the child, and C<$errfromchild> for errors.  

See an example that opens the Unix calculator C<bc> in a remote machine:

  $ cat -n open3bc.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4
     5  my $machine = shift || 'orion.pcg.ull.es';
     6  my $m = GRID::Machine->new( host => $machine );
     7
     8  my $WTR = IO::Handle->new();
     9  my $RDR = IO::Handle->new();
    10  my $ERR = IO::Handle->new();
    11  my $pid = $m->open3($WTR, $RDR, $ERR, 'bc');
    12
    13  my $line;
    14
    15  print $WTR "3*2\n";
    16  $line = <$RDR>;
    17  print STDOUT "3*2 = $line";
    18
    19  print $WTR "3/(2-2)\n";
    20  $line = <$ERR>;
    21  print STDOUT "3/(2-2) produces error = $line\n";
    22
    23  print $WTR "quit\n";
    24  wait;

When executed, the former program produces an output like this:

  $ open3bc.pl
  3*2 = 6
  3/(2-2) produces error = Runtime error (func=(main), adr=11): Divide by zero



=head1 REMOTE PROCESSES (FORKING)


=head2 The C<fork> method

The C<fork> method of C<GRID::Machine> objects can be used to fork a process in the remote machine,
as shown in the following example:

  $ cat -n fork5.pl 
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  use Data::Dumper;
     5  
     6  my $host = $ENV{GRID_REMOTE_MACHINE};
     7  my $machine = GRID::Machine->new( host => $host );
     8  
     9  my $p = $machine->fork( q{
    10  
    11     print "stdout: Hello from process $$. args = (@_)\n";
    12     print STDERR "stderr: Hello from process $$\n";
    13  
    14     use List::Util qw{sum};
    15     return { s => sum(@_), args => [ @_ ] };
    16   },
    17   args => [ 1..4 ],
    18  );
    19  
    20  # GRID::Machine::Process objects are overloaded
    21  print "Doing something while $p is still alive  ...\n" if $p; 
    22  
    23  my $r = $machine->waitpid($p);
    24  
    25  print "Result from process '$p': ",Dumper($r),"\n";
    26  print "GRID::Machine::Process::Result objects are overloaded in a string context:\n$r\n";


When executed, the former program produces an output similar to this:

  $ perl fork5.pl 
  Doing something while 5220:5230:some.machine:5234:5237 is still alive  ...
  Result from process '5220:5230:some.machine:5234:5237': $VAR1 = bless( {
                   'machineID' => 0,
                   'stderr' => 'stderr: Hello from process 5237
  ',
                   'descriptor' => 'some.machine:5234:5237',
                   'status' => 0,
                   'waitpid' => 5237,
                   'errmsg' => '',
                   'stdout' => 'stdout: Hello from process 5237. args = (1 2 3 4)
  ',
                   'results' => [ { 'args' => [ 1, 2, 3, 4 ], 's' => 10 } ]
                 }, 'GRID::Machine::Process::Result' );

  GRID::Machine::Process::Result objects are overloaded in a string context:
  stdout: Hello from process 5237. args = (1 2 3 4)
  stderr: Hello from process 5237


The C<fork> method returns a L<GRID::Machine::Process> object. The first argument must be a string containing
the code that will be executed by the forked process in the remote machine.
Such code is always called in a list context.
The C<fork> method admits the following arguments:

=over 2

=item * C<stdin>

The name of the file to which C<stdin> will be redirected

=item * C<stdout>

The name of the file to which C<stdout> will be redirected. If not specified a temporary file will be used

=item * C<stderr>

The name of the file to which C<stderr> will be redirected. If not specified a temporary file will be used

=item * C<result>

The name of the file to which the result computed by the child process  will be dumped. If not specified a temporary file will be used

=item * C<args>

The arguments for the code executed by the remote child process

=back

=head2 C<GRID::Machine::Process> objects

L<GRID::Machine::Process> objects have been overloaded. In a string context 
a L<GRID::Machine::Process> object 
produces the concatenation C<hostname:clientPID:remotePID>. 
In a boolean context it returns true if the process is alive and false otherwise.
This way, the execution of line 21 in the program above:

    21  print "Doing something while $p is still alive  ...\n" if $p; 

produces an output like:

  Doing something while 5220:5230:some.machine:5234:5237 is still alive  ...

if the remote process is still alive. The descriptor of the process
C<5220:5230:some.machine:5234:5237>
is a colon separated sequence of five components:

=over 2

=item 1 - The PID of the local process executing L<GRID::Machine> 

=item 2 - The PID of the local process in charge of the connection with the remote 
machine

=item 3 - The name of the remote machine 

=item 4 - The PID of the remote process executing L<GRID::Machine::REMOTE>

=item 5 - The PID of the child process created by C<fork>

=back

When evaluated in a boolean context, a L<GRID::Machine::Process> returns
1 if it is alive and 0 otherwise.

=head2 The C<waitpid> method

The C<waitpid> method  waits for the L<GRID::Machine::Process> received as first argument 
to terminate. Additional C<FLAGS> as in perl C<waitpid> can be passed as arguments.
It returns a L<GRID::Machine::Process::Result> object, whose attributes contain:


=over 2 

=item * C<stdout>  

A string containing the output to C<STDOUT> of the remote child process

=item * C<stderr>

A string containing the output to C<STDERR> of the remote child process

=item * C<results>

The list of values returned by the child process. The forking code 
is always called in a list context.

=item * C<status>

The value associated with C<$?> as returned by the remote child process.

=item * C<waitpid>

The value returned by the Perl C<waitpid> function when synchronized 
with the remote child process.
It is usually the value is either the C<pid> of the deceased process, or C<-1> 
if there was no such child process.  On some systems, a value of C<0> indicates that
there are processes still running.  

=item * C<errmsg> 

The child error as in C<$@> 

=item * C<machineID>

The logical identifier of the associated L<GRID::Machine>.
By default, 0 if it was the first L<GRID::Machine> created, 1 if it was the second, etc.

=back 

=head2  The C<waitall> method

It is similar to C<waitpid> but instead waits for any child process.

Behaves like the wait(2) system call on your system: it waits
for a child process to terminate and returns 

=over 2

=item * The C<GRID::Machine::Process::Result>
object associated with the  deceased process if it was called via the L<GRID::Machine> 
C<fork> method, or 

=item * The PID of the deceased process if there is no C<GRID::Machine::Process>
associated (it was called using an ordinary C<fork>)

=item * C<-1> if there are no child processes.  
Note that a return value of C<-1> could mean that child processes are
being automatically reaped, as described in perlipc.

=back

See an example:

  $ cat -n wait1.pl 
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  use Data::Dumper;
     5  
     6  my $host = $ENV{GRID_REMOTE_MACHINE};
     7  my $machine = GRID::Machine->new( host => $host );
     8  
     9  my $p = $machine->fork( q{
    10  
    11     print "stdout: Hello from process $$. args = (@_)\n";
    12     print STDERR "stderr: Hello from process $$\n";
    13  
    14     use List::Util qw{sum};
    15     return { s => sum(@_), args => [ @_ ] };
    16   },
    17   args => [ 1..4 ],
    18  );
    19  
    20  # GRID::Machine::Process objects are overloaded
    21  print "Doing something while $p is still alive  ...\n" if $p; 
    22  
    23  my $r = $machine->waitall();
    24  
    25  print "Result from process '$p': ",Dumper($r),"\n";
    26  print "GRID::Machine::Process::Result objects are overloaded in a string context:\n$r\n";

When executed produces:

  $ perl wait1.pl 
  Doing something while 1271:1280:local:1284:1287 is still alive  ...
  Result from process '1271:1280:local:1284:1287': $VAR1 = bless( {
                   'machineID' => 0,
                   'stderr' => 'stderr: Hello from process 1287
  ',
                   'descriptor' => 'local:1284:1287',
                   'status' => 0,
                   'waitpid' => 1287,
                   'errmsg' => '',
                   'stdout' => 'stdout: Hello from process 1287. args = (1 2 3 4)
  ',
                   'results' => [ { 'args' => [ 1, 2, 3, 4 ], 's' => 10 } ]
                 }, 'GRID::Machine::Process::Result' );

  GRID::Machine::Process::Result objects are overloaded in a string context:
  stdout: Hello from process 1287. args = (1 2 3 4)
  stderr: Hello from process 1287

The following example uses the C<fork> method and C<waitall> to 
compute in parallel a numerical approach to the value of the number C<pi>:

  $ cat -n waitpi.pl 
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  
     5  my $host = $ENV{GRID_REMOTE_MACHINE};
     6  my $machine = GRID::Machine->new( host => $host );
     7  
     8  my ($N, $np, $pi)  = (1000, 4, 0);
     9  for (0..$np-1) {
    10     $machine->fork( q{
    11         my ($id, $N, $np) = @_;
    12           
    13         my $sum = 0;
    14         for (my $i = $id; $i < $N; $i += $np) {
    15             my $x = ($i + 0.5) / $N;
    16             $sum += 4 / (1 + $x * $x);
    17         }
    18         $sum /= $N; 
    19      },
    20      args => [ $_, $N, $np ],
    21    );
    22  }
    23  
    24  $pi += $machine->waitall()->result for 1..$np;
    25  
    26  print "pi = $pi\n";

=head2  The C<async> method

The C<async> method it is quite similar to the fork method
but receives as arguments the  name of a L<GRID::Machine> method 
and the arguments for this method.
It executes asynchronously the method. 
It returns a L<GRID::Machine::Process> object.
Basically, the call

            $m->async($subname => @args) 

is equivalent to:

            $m->fork($subname.'(@_)' args => [ @args ] ) 

The following example uses C<async> to compute in 
parallel an approximation to the value of pi:


  $ cat -n async.pl 
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  
     5  my $host = $ENV{GRID_REMOTE_MACHINE};
     6  my $machine = GRID::Machine->new( host => $host );
     7  
     8  $machine->sub(sumareas => q{
     9         my ($id, $N, $np) = @_;
    10           
    11         my $sum = 0;
    12         for (my $i = $id; $i < $N; $i += $np) {
    13             my $x = ($i + 0.5) / $N;
    14             $sum += 4 / (1 + $x * $x);
    15         }
    16         $sum /= $N; 
    17  });
    18  
    19  my ($N, $np, $pi)  = (1000, 4, 0);
    20  
    21  $machine->async( sumareas =>  $_, $N, $np ) for (0..$np-1);
    22  $pi += $machine->waitall()->result for 1..$np;
    23  
    24  print "pi = $pi\n";



=head2 GRID::Machine::Process::Result objects

In a string context a C<GRID::Machine::Process::Result> object produces the concatenation
of its output to C<STDOUT> followed by its output to C<STDERR>.
In a boolean context it evaluates according to its C<result> attribute.
It evaluates to true if it is an array reference with more than one element
or if the only element is true. Otherwise it is false.



=head1 CALLBACKS

It may happen that the local machine has installed a useful set of modules 
that are not present on the remote side. It may be also imposible to transfer
the modules to the remote machine using the mechanisms provided by 
C<GRID::Machine>. In such situations -and many others - the I<callback>
mechanism can be helpful to achieve the task at hand.

The C<callback> method provides a way to make a subroutine on the local side
callable from the remote side. The ideas and implementation mechanisms used 
for  callbacks is the work of Dmitriy Kargapolov  (Thanks Dmitri!).

The syntax is:

                $r = $machine->callback( 'localsubname' );
                $r = $machine->callback( localsub => sub { ... } );
                $r = $machine->callback( localsub => subref );
                $r = $machine->callback( sub { ... } );
                $r = $machine->callback( subref );

On success returns true, namely returns the address of the 
subroutine on the remote side that works as I<proxy> of the 
C<localsub> subroutine on the local side. 
Exceptions will be thrown in case of failure.

The following example shows a remote subroutine (lines 16-20)
that calls a subroutine C<test_callback> 
that will be executed on the local side (line 19). 
The call to the method C<callback> at line 23 makes the 
local subroutine C<test_callback> available from the remote side.

 $ cat -n callbackbyname2.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  use Sys::Hostname;
     5
     6  my $host = shift || $ENV{GRID_REMOTE_MACHINE};
     7
     8  sub test_callback {
     9    print 'Inside test_callback(). Host is '.&hostname."\n";
    10
    11    return shift()+1;
    12  }
    13
    14  my $machine = GRID::Machine->new(host => $host, uses => [ 'Sys::Hostname' ]);
    15
    16  my $r = $machine->sub( remote => q{
    17      gprint hostname().": inside remote\n";
    18
    19      return 1+test_callback(2);
    20  } );
    21  die $r->errmsg unless $r->ok;
    22
    23  $r = $machine->callback( 'test_callback' );
    24  die $r->errmsg unless $r->ok;
    25
    26  $r = $machine->remote();
    27  die $r->errmsg unless $r->noerr;
    28
    29  print "Result: ".$r->result."\n";

When the former program is executed (local machine is nereida) 
we get an output similar to this:

                $ callbackbyname2.pl
                beowulf: inside remote
                Inside test_callback(). Host is nereida.deioc.ull.es
                Result: 4


=head2 Callbacks and Namespaces

The callback subroutine is somewhat exported onto the remote side.
That is, when transforming a local subroutine in a callback 
you can specify it by its full name (see line 24 below) but it is
called from the remote side using its single name (line 18):

  $ cat -n callbackbyname3.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use GRID::Machine;
     4  use Sys::Hostname;
     5
     6  my $host = $ENV{GRID_REMOTE_MACHINE};
     7
     8  sub Tutu::test_callback {
     9    print 'Inside test_callback() host: ' . &hostname . "\n";
    10    return 3.1415;
    11  }
    12
    13  my $machine = GRID::Machine->new(host => $host, uses => [ 'Sys::Hostname' ]);
    14
    15  my $r = $machine->sub( remote => q{
    16      gprint hostname().": inside remote\n";
    17
    18      my $r = test_callback(); # scalar context
    19
    20      gprint hostname().": returned value from callback: $r\n";
    21  } );
    22  die $r->errmsg unless $r->ok;
    23
    24  $r = $machine->callback( 'Tutu::test_callback' );
    25  die $r->errmsg unless $r->ok;
    26
    27  $r = $machine->remote();
    28
    29  die $r->errmsg unless $r->noerr;

When executed the former program produces an output similar to this
(beowulf is the remote machine):

            $ callbackbyname3.pl
            beowulf: inside remote
            Inside test_callback() host: nereida.deioc.ull.es
            beowulf: returned value from callback: 3.1415

=head2 Context and Callbacks

When a callback subroutine is called in a I<scalar context> it returns the 
first element of the returned list. See line 18 in the previous code.

=head2 Anonymous Callbacks

The callback subroutine can be anonymous. The C<callback> method support the syntax: 

              $machine->callback( sub { ... } )

See an example:

 $ cat -n anonymouscallback.pl
     1  #!/usr/bin/perl
     2  use strict;
     3  use GRID::Machine;
     4  use Sys::Hostname;
     5
     6  my $host = shift || $ENV{GRID_REMOTE_MACHINE};
     7
     8  my $machine = GRID::Machine->new(host => $host, uses => [ 'Sys::Hostname' ]);
     9
    10  my $r = $machine->sub( remote => q{
    11      my $rsub = shift;
    12
    13      gprint &hostname.": inside remote sub\n";
    14      my $retval = $rsub->(3);
    15
    16      return  1+$retval;
    17  } );
    18
    19  die $r->errmsg unless $r->ok;
    20
    21  my $a =  $machine->callback(
    22             sub {
    23               print hostname().": inside anonymous inline callback. Args: (@_) \n";
    24               return shift() + 1;
    25             }
    26           );
    27
    28  $r = $machine->remote( $a );
    29
    30  die $r->errmsg unless $r->noerr;
    31
    32  print "Result = ".$r->result."\n";

When the previous example is executed using as local machine 'nereida'
it produces an output similar to this:

          $ anonymouscallback.pl
          beowulf: inside remote sub
          nereida.deioc.ull.es: inside anonymous inline callback. Args: (3)
          Result = 5

=head2 Recursive Remote Procedure Calls and Callbacks

The existence of callbacks opens the possibility of nested sets of RPCs and 
callbacks. The following example recursively computes the factorial of a number.
The execution of recursive calls alternates between remote and local sides:

  $ cat -n nestedcallback.pl
     1  #!/usr/bin/perl
     2  use strict;
     3  use GRID::Machine;
     4  use Sys::Hostname;
     5
     6  my $host = $ENV{GRID_REMOTE_MACHINE};
     7
     8  my $machine = GRID::Machine->new( host => $host, uses => [ 'Sys::Hostname' ] );
     9
    10  my $r = $machine->sub(
    11    fact => q{
    12      my $x = shift;
    13
    14      gprint &hostname . ": fact($x)\n";
    15
    16      if ($x > 1) {
    17        my $r = localfact($x-1);
    18        return $x*$r;
    19      }
    20      else {
    21        return 1;
    22      }
    23    }
    24  );
    25  die $r->errmsg unless $r->ok;
    26
    27  $r = $machine->callback(
    28
    29      localfact => sub {
    30        my $x = shift;
    31
    32        print &hostname . ": fact($x)\n";
    33
    34        if ($x > 1) {
    35          my $r = $machine->fact($x-1)->result;
    36          return $x*$r;
    37        }
    38        else {
    39          return 1;
    40        }
    41
    42      }
    43
    44  );
    45  die $r->errmsg unless $r->ok;
    46
    47  my $n = shift;
    48
    49  $r = $machine->fact($n);
    50
    51  die $r->errmsg unless $r->ok;
    52  print "=============\nfact($n) is ".$r->result."\n";

When executed, the former program produces an output similar to this (beowulf is the remote
machine):

                      $ nestedcallback.pl 6
                      beowulf: fact(6)
                      nereida.deioc.ull.es: fact(5)
                      beowulf: fact(4)
                      nereida.deioc.ull.es: fact(3)
                      beowulf: fact(2)
                      nereida.deioc.ull.es: fact(1)
                      =============
                      fact(6) is 720


=head1 LIMITATIONS

=head2 Operating System

I will be surprised if this module works on anything that is not
UNIX.


=head2 Opaque Structures

The RPC provided by C<GRID::Machine> uses L<Data::Dumper> to serialize 
the data. It consequently suffers the same limitations than L<Data::Dumper>.

Namely, I<Opaque structures> like those built by modules written using 
external languages like C
I<can't be correctly transferred> by the RPC system provided by C<GRID::Machine>. 
An example is the transference
of PDL objects (see L<PDL>). In such cases, the programmer must
transform (i.e. marshalling or project) the structure into a (linear)
string on one
side and rebuild (uplift) the (multidimensional) structure from the string
on the other side. See an example:

    use GRID::Machine;
    use PDL;
    use PDL::IO::Dumper;

    my $host = shift || 'user@remote.machine.domain';

    my $machine = GRID::Machine->new(host => $host, uses => [qw(PDL PDL::IO::Dumper)]);

    my $r = $machine->sub( mp => q{
        my ($f, $g) = @_;

        my $h = (pdl $f) x (pdl $g);

        sdump($h);
      },
    );
    $r->ok or die $r->errmsg;

    my $f = [[1,2],[3,4]];
    $r = $machine->mp($f, $f);
    die $r->errmsg unless $r->ok;
    my $matrix =  eval($r->result);
    print "\$matrix is a ".ref($matrix)." object\n";
    print "[[1,2],[3,4]] x [[1,2],[3,4]] = $matrix";

Here the C<sdump> method of L<PDL::IO::Dumper> solves the problem: it
gives a string representation of the C<PDL> object that is C<eval>ued
later to have the matrix data structure.
When executed this program produces the following output:

            $ uses.pl
            $matrix is a PDL object
            [[1,2],[3,4]] x [[1,2],[3,4]] =
            [
             [ 7 10]
             [15 22]
            ]

=begin COMMENT

  =head3 Wish List

It will benefit this module to have a more OOP oriented C<dumper>
so that if the objet being dumped is I<opaque> but has a C<Dumper> 
method, such method will be called. The idea being that anyone
developing some sort of external object (C, XS, etc.) will collaboratively
define a C<Dumper> method specifying how the object will be dumped.
That is a goal to fulfill.

=end COMMENT
  
=head2 Nested Uses of L<GRID::Machine>

The remote server can't use L<GRID::Machine> to connect to a second
server. I. e. a program like this fails:

  use GRID::Machine;

  my $host = shift || 'user@machine';

  my $machine = GRID::Machine->new(host => $host, uses => [ 'GRID::Machine' ]);

  my $r = $machine->eval(q{ my $t = GRID::Machine->new(host => 'orion'); });

  print $r->result;


=head2 Call by Reference

Remote Subroutine Call I<by reference> is not supported in this version. 
See the following example:

      use GRID::Machine;

      my $machine = GRID::Machine->new(
            host => 'user@remote.machine.domain',
            startdir => '/tmp',
         );

      my $r = $machine->sub(byref => q{ $_[0] = 4; });
      die $r->errmsg unless $r->ok;

      my ($x, $y) = (1, 1);

      $y = $machine->byref($x)->result;

      print "$x, $y\n"; # 1, 4

Observe that variable C<$x> is not modified. The only way to modify a variable on the local side
by a remote subroutine is I<by result>, like is done for C<$y> in the previous example.

=head2 Limitations of the C<include> Method

"Remote Modules" is the term used for files containing Perl code that will be loaded
onto the remote Perl server via the C<incldue> method or through the C<includes> 
argument of C<new>. These files can only contain 

=over 2

=item * Subroutines. Since these subroutines are anonymous in the remote side,
the only way to call them from the remote side is through the attribute
C<stored_procedures> of the C<SERVER> object:

                    SERVER->stored_procedures->{subname}

=item * C<use Module> declarations. The C<Module> must exists in the remote
server. Furthermote module import arguments as in C<use Module qw{ w1 w2 w3}> must be
in a single line.

=item * POD documentation

Variable declarations and variable initializations are ignored.

=back

The C<include> method parses Perl code. It is a heuristic one page length parser (72 lines at the moment
of writing). It obviously can't parse everything. But works for most of the code restricted
to the aforementioned limitations.

=head1 EXPORTS

When explicited by the client program C<GRID::Machine>
exports these functions:

=over 2

=item * C<is_operative> 

=item * C<read_modules>

=item * C<qc>

=back

=head1 INSTALLATION

To install L<GRID::Machine> follow the traditional steps:

   perl Makefile.PL
   make
   make test
   make install

=head2 Using Password Authentication

You can make L<GRID::Machine> to work without automatic authentication.


The following example uses L<Net::OpenSSH> to open a SSH connection
using I<password authentication> instead of asymmetric cryptography:

  $ cat -n openSSH.pl 
     1  use strict;
     2  use warnings;
     3  use Net::OpenSSH;
     4  use GRID::Machine;
     5  
     6  my $host = (shift() or $ENV{GRID_REMOTE_MACHINE});
     7  my @ARGS;
     8  push @ARGS, (user      => $ENV{USR})   if $ENV{USR};
     9  push @ARGS, ( password => $ENV{PASS}) if $ENV{PASS};
    10  
    11  my $ssh = Net::OpenSSH->new($host, @ARGS); 
    12  $ssh->error and die "Couldn't establish SSH connection: ". $ssh->error;
    13  
    14  my @cmd = $ssh->make_remote_command('perl');
    15  { local $" = ','; print "@cmd\n"; }
    16  my $grid = GRID::Machine->new(command => \@cmd);
    17  my $r = $grid->eval('print "hello world!\n"');
    18  print "$r\n";

when executed produces an output like this:

  $ perl openSSH.pl 
  ssh,-S,/Users/localuser/.libnet-openssh-perl/user-machine-2413-275647,-o,User=user,--,machine,perl
  hello world!



However, it seems a bad idea to have unencrypted passwords messing around.
It is much better to use asymmetric cryptography.


=head2 Using Automatic authentication: Asymmetric Cryptography

Set automatic ssh-authentication with the machines where you have an SSH account. 

SSH includes the ability to authenticate users using public keys. Instead of 
authenticating the user with a password, the SSH server on the remote machine will
verify a challenge signed by the user's I<private key> against its copy
of the user's I<public key>. To achieve this automatic ssh-authentication
you have to:

=over 2

=item * Generate a public key use the C<ssh-keygen> utility. For example:

  local.machine$ ssh-keygen -t rsa -N ''

The option C<-t> selects the type of key you want to generate.
There are three types of keys: I<rsa1>, I<rsa> and I<dsa>.
The C<-N> option is followed by the I<passphrase>. The C<-N ''> setting
indicates that no pasphrase will be used. This is useful when used 
with key restrictions or when dealing with cron jobs, batch 
commands and automatic processing which is the context in which this 
module was designed.
If still you don't like to have a private key without passphrase, 
provide a passphrase and use C<ssh-agent> 
to avoid the inconvenience of typing the passphrase each time. 
C<ssh-agent> is a program you run once per login sesion and load your keys into.
From that moment on, any C<ssh> client will contact C<ssh-agent>
and no more passphrase typing will be needed.

By default, your identification will be saved in a file C</home/user/.ssh/id_rsa>.
Your public key will be saved in C</home/user/.ssh/id_rsa.pub>.

=item * Once you have generated a key pair, you must install the public key on the 
remote machine. To do it, append the public component of the key in

           /home/user/.ssh/id_rsa.pub

to file 

           /home/user/.ssh/authorized_keys
           
on the remote machine.
If the C<ssh-copy-id> script is available, you can do it using:

  local.machine$ ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote.machine

Alternatively you can write the following command:

  $ ssh remote.machine "umask 077; cat >> .ssh/authorized_keys" < /home/user/.ssh/id_rsa.pub

The C<umask> command is needed since the SSH server will refuse to 
read a C</home/user/.ssh/authorized_keys> files which have loose permissions.

=item * Edit your local configuration file C</home/user/.ssh/config> (see C<man ssh_config> 
in UNIX) and create a new section for C<GRID::Machine> connections to that host.
Here follows an example:


 ...

 # A new section inside the config file: 
 # it will be used when writing a command like: 
 #                     $ ssh gridyum 

 Host gridyum

 # My username in the remote machine
 user my_login_in_the_remote_machine

 # The actual name of the machine: by default the one provided in the
 # command line
 Hostname real.machine.name

 # The port to use: by default 22
 Port 2048

 # The identitiy pair to use. By default ~/.ssh/id_rsa and ~/.ssh/id_dsa
 IdentityFile /home/user/.ssh/yumid

 # Useful to detect a broken network
 BatchMode yes

 # Useful when the home directory is shared across machines,
 # to avoid warnings about changed host keys when connecting
 # to local host
 NoHostAuthenticationForLocalhost yes


 # Another section ...
 Host another.remote.machine an.alias.for.this.machine
 user mylogin_there

 ...

This way you don't have to specify your I<login> name on the remote machine even if it
differs from your  I<login> name in the local machine, you don't have to specify the 
I<port> if it isn't 22, etc. This is the I<recommended> way to work with C<GRID::Machine>.
Avoid cluttering the constructor C<new>.

=item * Once the public key is installed on the server you should be able to
authenticate using your private key

  $ ssh remote.machine
  Linux remote.machine 2.6.15-1-686-smp #2 SMP Mon Mar 6 15:34:50 UTC 2006 i686
  Last login: Sat Jul  7 13:34:00 2007 from local.machine
  user@remote.machine:~$                                 

You can also automatically execute commands in the remote server:

  local.machine$ ssh remote.machine uname -a
  Linux remote.machine 2.6.15-1-686-smp #2 SMP Mon Mar 6 15:34:50 UTC 2006 i686 GNU/Linux

=item * Once you have installed L<GRID::Machine> you can check that C<perl> can
be executed in that machine using this one-liner:

  $ perl -e 'use GRID::Machine qw(is_operative); print is_operative("ssh", "beowulf")."\n"'
  1

=back






=head1 DEPENDENCIES

This module requires these other modules and libraries:

=over 2

=item *  L<Module::Which> 

=item *  L<Net::OpenSSH> is not needed but recommended. See section
L</"Using Password Authentication">.

=back 



=head1 SEE ALSO

=over 2

=item * L<GRID::Machine>

=item * L<GRID::Machine::IOHandle>

=item * L<GRID::Machine::Group>

=item * L<GRID::Machine::Process>

=item * L<GRID::Machine::perlparintro>


=item *  L<Net::OpenSSH> 

=item * L<IPC::PerlSSH>

=item * L<IPC::PerlSSH::Async>

=item * Man pages of C<ssh>, C<ssh-key-gen>, C<ssh_config>, C<scp>, 
C<ssh-agent>, C<ssh-add>, C<sshd>

=item * L<http://www.openssh.com>

=back


=head1 CONTRIBUTORS

=over 2 

=item * Dmitriy Kargapolov (<dmitriy.kargapolov@gmail.com>)
suggested, designed and provided an implementation 
for callbacks. 

=item * Eric Busto fixed a 
problem with C<is_operative> hanging on systems that are in an
odd state. 

=item * Alex White fixed bugs in C<modput> and the SSH options.

=item * Erik Welch fixed a bug in the (local) C<DESTROY> method.

=back


=head1 AUTHOR

Casiano Rodriguez Leon E<lt>casiano@ull.esE<gt>

=head1 ACKNOWLEDGMENTS

This work has been supported by CEE (FEDER) and the Spanish Ministry of
I<Educacion y Ciencia> through I<Plan Nacional I+D+I> number TIN2005-08818-C04-04
(ULL::OPLINK project L<http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through GC02210601
(I<Grupos Consolidados>).
The University of La Laguna has also supported my work in many ways
and for many years.

I wish to thank Paul Evans for his C<IPC::PerlSSH> module: it was the source
of inspiration for this module. To 
Alex White,
Dmitri Kargapolov, 
Eric Busto
and
Erik Welch 
for their contributions.
To the Perl Monks, and the Perl Community for generously sharing their knowledge.
Finally, thanks to Juana, Coro and  my students at La Laguna.

=head1 LICENCE AND COPYRIGHT
 
Copyright (c) 2007 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.

These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See L<perlartistic>.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 




