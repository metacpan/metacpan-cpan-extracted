# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Util {
  version_from Mojolicious;
  
  use Re;
  use Hash;
  use MIME::Base64;
  use StringList;
  use Digest::MD5;
  use Digest::SHA;
  use Format;
  use Getopt::Long;
  use Mojo::ByteStream;
  use Compress::Raw::Zlib;
  
  our $QUOTED_VALUE_RE : string;
  INIT {
    $QUOTED_VALUE_RE = "\A=\s*(\"(?:\\\\\\\\|\\\\\"|[^\"])*\")";
  }
  
  our $UNQUOTED_VALUE_RE : string;
  INIT {
    $UNQUOTED_VALUE_RE = "\A=\s*([^;, ]*)";
  }
  
  our $EXPIRES_RE : string;
  INIT {
    $EXPIRES_RE = "(\w+\W+\d+\W+\w+\W+\d+\W+\d+:\d+:\d+\W*\w+)";
  }
  
  our $XML : Hash of string;
  INIT {
    $XML = Hash->new({
      "&" => "&amp;", "<" => "&lt;", ">" => "&gt;", "\"" => "&quot;", "'" => "&#39;"
    });
  }
  
  static method b64_encode : string ($string : string, $eol : string = undef) {
    return MIME::Base64->encode_base64($string, $eol);
  }
  
  static method b64_decode : string ($string : string) {
    return MIME::Base64->decode_base64($string);
  }
  
  static method md5_bytes : string ($data : string) {
    
    return Digest::MD5->md5($data);
  }
  
  static method md5_sum : string ($data : string) {
    
    return Digest::MD5->md5_hex($data);
  }
  
  static method hmac_sha1_sum : string ($data : string, $key : string) {
    
    return Digest::SHA->hmac_sha1_hex($data, $key);
  }
  
  static method sha1_bytes : string ($data : string) {
    
    return Digest::SHA->sha1($data);
  }
  
  static method sha1_sum : string ($string : string) {
    return Digest::SHA->sha1_hex($string);
  }
  
  static method url_escape : string ($string : string, $pattern : string = undef) {
    
    unless ($string) {
      die "The string \$string must be defined.";
    }
    
    my $char_class = (string)undef;
    if ($pattern) {
      $char_class = "[$pattern]";
    }
    else {
      $char_class = "[^A-Za-z0-9\-._~]";
    }
    
    my $string = copy $string;
    Re->s((mutable string)$string, ["($char_class)", "g"], method : string ($regex : Regex, $match : Regex::Match) {
      
      my $ret = Format->sprintf("%%%02X", [(object)Fn->ord($match->cap1)]);
      
      return $ret;
    });
    
    return $string;
  }
  
  static method xml_escape : string ($string : string) {
    
    unless ($string) {
      die "The string \$string must be defined.";
    }
    
    my $escaped = copy $string;
    
    Re->s((mutable string)$escaped, ["([&<>\"'])", "g"], method : string ($regex : Regex, $match : Regex::Match) {
      return $XML->{$match->cap1};
    });
    
    return $escaped;
  }
  
  static method url_unescape : string ($string : string) {
    
    unless ($string) {
      die "The string \$string muse be defined.";
    }
    
    my $string = copy $string;
    Re->s((mutable string)$string, ["%([0-9a-fA-F]{2})", "g"], method : string ($regex : Regex, $match : Regex::Match) {
      
      my $ret = Fn->chr(Fn->hex($match->cap1));
      
      return $ret;
    });
    
    return $string;
  }
  
  private enum {
    PC_BASE         = 36,
    PC_TMIN         = 1,
    PC_TMAX         = 26,
    PC_SKEW         = 38,
    PC_DAMP         = 700,
    PC_INITIAL_BIAS = 72,
    PC_INITIAL_N    = 128,
  }
  
  static method punycode_decode : string ($string : string) {
    
    my $n = &PC_INITIAL_N;
    my $i = 0;
    my $bias = &PC_INITIAL_BIAS;
    
    my $output_buffer = StringBuffer->new;
    
    my $string = copy $string;
    if (my $_ = Re->s((mutable string)$string, ["(.*)\x2d", "s"], "")) {
      my $m = $_->match;
      
      my $items = Fn->split("", $m->cap1);
      
      for my $_ (@$items) {
        $output_buffer->push($_);
      }
    }
    
    while (length $string) {
      my $oldi = $i;
      my $w = 1;
      
      for (my $k = &PC_BASE; 1; $k += &PC_BASE) {
        my $digit = Fn->ord(Fn->substr($string, 0, 1, ""));
        if ($digit < 0x40) {
          $digit = $digit + (26 - 0x30);
        }
        else {
          $digit = ($digit & 0x1f) - 1;
        }
        $i += $digit * $w;
        my $t = $k - $bias;
        if ($t < &PC_TMIN) {
          $t = &PC_TMIN;
        }
        elsif ($t > &PC_TMAX) {
          $t = &PC_TMAX;
        }
        
        if ($digit < $t) {
          last;
        }
        
        $w *= &PC_BASE - $t;
      }
      
      $bias = &_adapt($i - $oldi, $output_buffer->length + 1, $oldi == 0);
      $n += $i / ($output_buffer->length + 1);
      $i = $i % ($output_buffer->length + 1);
      
      $output_buffer->substr($i++, 0, Fn->chr($n));
    }
    
    my $output = $output_buffer->to_string;
    
    return $output;  
  }
  
  static method punycode_encode : string ($string : string) {
    
    my $n = &PC_INITIAL_N;
    my $delta = 0;
    my $bias = &PC_INITIAL_BIAS;
    
    my $input_obj = Fn->map(method : Int ($_ : string) { return (Int)Fn->ord($_); }, Fn->split("", $string));
    
    my $string = copy $string;
    Re->s((mutable string)$string, ["[^\x00-\x7f]+", "gs"], "");
    my $h = my $basic = length $string;
    if ($basic > 0) {
      $string .= "\x2d";
    }
    
    my $input_obj_grep = (Int[])Fn->grep(method : int ($_ : Int) { return (int)$_ >= &PC_INITIAL_N; }, $input_obj);
    
    my $input = Array->to_array_int($input_obj_grep);
    
    Sort->sort_int_asc($input);
    
    for my $m (@$input) {
      if ($m < $n) {
        next;
      }
      $delta += ($m - $n) * ($h + 1);
      $n = $m;
      
      for my $c (@$input) {
        
        if    ($c < $n) { $delta++; }
        elsif ($c == $n) {
          my $q = $delta;
          
          for (my $k = &PC_BASE; 1; $k += &PC_BASE) {
            my $t = $k - $bias;
            if ($t < &PC_TMIN) {
              $t = &PC_TMIN;
            }
            elsif ( $t > &PC_TMAX) {
              $t = &PC_TMAX;
            }
            if ($q < $t) {
              last;
            }
            my $o = $t + (($q - $t) % (&PC_BASE - $t));
            my $o_plus = 0;
            if ($o < 26) {
              $o_plus = 0x61;
            }
            else {
              $o_plus = 0x30 - 26;
            }
            $string .= Fn->chr($o + $o_plus);
            $q = ($q - $t) / (&PC_BASE - $t);
          }
          
          my $q_plus = 0;
          if ($q < 26) {
            $q_plus = 0x61;
          }
          else {
            $q_plus = 0x30 - 26;
          }
          $string .= Fn->chr($q + $q_plus);
          $bias  = &_adapt($delta, $h + 1, $h == $basic);
          $delta = 0;
          $h++;
        }
      }
      
      $delta++;
      $n++;
    }
    
    return $string;
  }
  
  static method _adapt : int ($delta : int, $numpoints : int, $firsttime : int) {
    
    if ($firsttime) {
      $delta = $delta / &PC_DAMP;
    }
    else {
      $delta = $delta / 2;
    }
    
    $delta += $delta / $numpoints;
    my $k = 0;
    while ($delta > ((&PC_BASE - &PC_TMIN) * &PC_TMAX) / 2) {
      $delta /= &PC_BASE - &PC_TMIN;
      $k     += &PC_BASE;
    }
    
    return $k + (((&PC_BASE - &PC_TMIN + 1) * $delta) / ($delta + &PC_SKEW));
  }
  
  static method network_contains : int ($cidr : string, $addr : string) {
    
    die "[TODO]Not implemented.";
  }
  
  static method split_cookie_header : string[][] ($header : string) {
    return &_header($header, 1);
  }
  
  static method split_header : string[][] ($header : string) {
    return &_header($header, 0);
  }
  
  private static method _header : string[][] ($str : string, $set_cookie : int = 0) {
    
    my $tree = (List of string[])List->new(new string[][0]);
    my $part = StringList->new;
    
    my $offset = 0;
    while (my $m = Re->m($str, "\A[,;\s]*([^=;, ]+)\s*", \$offset)) {
      
      my $name = $m->cap1;
      
      $part->push_([$name, undef]);
      
      my $expires = 0;
      if ($set_cookie && $part->length > 2 && Fn->lc($m->cap1) eq "expires") {
        $expires = 1;
      }
      
      # Special "expires" value
      my $match = Re->m($str, "\A=\s*$EXPIRES_RE", \$offset);
      if ($expires && $match) {
        $part->[-1] = $match->cap1;
      }
      
      # Quoted value
      elsif (my $m = Re->m($str, $QUOTED_VALUE_RE, \$offset)) {
        $part->[-1] = &unquote($m->cap1);
      }
      
      # Unquoted value
      elsif (my $m = Re->m($str, $UNQUOTED_VALUE_RE, \$offset)) {
        $part->[-1] = $m->cap1;
      }
      
      # Separator
      unless (Re->m($str, "\A[;\s]*,\s*", \$offset)) {
        next;
      }
      
      $tree->push($part->get_array);
      $part = StringList->new;
    }
    
    if ($part->length > 0) {
      $tree->push($part->get_array);
    }
    
    return $tree->to_array;
  }
  static method unquote : string ($str : string) {
    
    my $str = copy $str;
    my $_ = Re->s((mutable string)$str, ["^\"(.*)\"$", "g"], method : string ($regex : Regex, $match : Regex::Match) {
      return $match->cap1;
    });
    
    unless ($_) {
      return $str;
    }
    
    Re->s((mutable string)$str, ["\\\\\\\\", "g"], "\\");
    
    Re->s((mutable string)$str, ["\\\\\"", "g"], "\"");
    
    return $str;
  }
  
  static method quote : string ($str : string) {
    
    my $str = copy $str;
    Re->s((mutable string)$str, ["([\"\\\\])", "g"], method : string ($regex : Regex, $match : Regex::Match) {
      return "\\" . $match->cap1;
    });
    
    return "\"$str\"";
  }
  
  static method header_params : object[] ($value : string){
    
    my $params = Hash->new;
    my $offset = 0;
    while (my $_ = Re->m($value, "\A[;\s]*([^=;, ]+)\s*", \$offset)) {
      my $name = $_->cap1;
      
      # Quoted value
      if (my $_ = Re->m($value, $QUOTED_VALUE_RE, \$offset)) {
        my $found = $params->get($name);
        unless ($found) {
          $params->set($name, &unquote($_->cap1));
        }
      }
      
      # Unquoted value
      elsif (my $_ = Re->m($value, $UNQUOTED_VALUE_RE, \$offset)) {
        my $found = $params->get($name);
        unless ($found) {
          $params->set($name, $_->cap1);
        }
      }
    }
    
    return [(object)$params, Fn->substr($value, $offset)];
  }
  
  static method getopt : void ($comand_args_ref : string[][], $values_h : Hash, $spec_strings : string[]) {
    
    Getopt::Long->GetOptionsFromArray($comand_args_ref, $values_h, $spec_strings);
  }
  
  static method gzip : string ($uncompressed : string) {
    
    Compress::Raw::Zlib->gzip($uncompressed, my $_ = [(string)undef]);
    my $compressed = $_->[0];
    
    return $compressed;
  }
  
  static method secure_compare : int ($one : string, $two : string) {
    my $r = length $one != length $two;
    
    if ($r) {
      $two = $one;
    }
    
    for (my $i = 0; $i < length $one; $i++) {
      $r |= Fn->ord(Fn->substr($one, $i)) ^ Fn->ord(Fn->substr($two, $i));
    }
    
    return $r == 0;
  }
  
}
