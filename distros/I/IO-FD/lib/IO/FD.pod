=head1 NAME

IO::FD - Faster accept, socket, listen with file descriptors, not handles

=head1 SYNOPSIS

Create and bind a STREAM socket (server):

	use IO::FD;
	use Socket ":all";

	die "Error creating socket"
		unless IO::FD::socket(my $listen_fd, AF_INET, SOCK_STREAM, 0);

	my ($err, @sockaddr)=addrinfo "0.0.0.0", 80, {
		family=>	AF_INET,
		socktype=>	SOCK_STREAM,
		flags=>		AI_NUMERICHOST|AI_PASSIVE
	};

	die "Error binding"
		unless FD::IO::bind($listen_fd, $sockaddr[0]{addr});	

	
	die "Error accepting" 
		unless IO::FD::accept(my $client_fd, $listen_fd);
	
	#read and write here
	

Create and connect a STREAM socket(client):
	
	use IO::FD;
	use Socket ":all";

	die "Error creating socket"
		unless IO::FD::socket(my $fd, AF_INET,SOCK_STREAM,0);

	my ($err,@sockaddr)=addrinfo "127.0.0.1", 80, {
		family=>	AF_INET,
		socktype=>	SOCK_STREAM,
		flags=>		AI_NUMERICHOST
	};

	die "Error connecting";
		unless FD::IO::connect($fd, $sockaddr[0]{addr});

	#read and write here

Open a file

	use IO::FD;
	use Fcntl;
	die "could not open file" 
		unless IO::FD::sysopen(my $fd, "path.txt", O_RDONLY);
	

Read/Write/Close an fd

	use IO::FD;

	my $fd; #From IO::FD::socket, IO::FD::accept IO::FD::sysopen, POSIX::open

	die "Error writing"
		unless IO::FD::syswrite $fd, "This is some data"; #Length and optional offset

	die "Error reading"
		unless IO::FD::sysread $fd, my $buffer, $length); 

	die "Error closing" 
		unless IO::FD::close $fd;


Advanced:

	fctrl...

	#TODO:
	ioctl...


=head1 DESCRIPTION

IO::FD is an XS module which implements common core Perl system I/O functions
to use B<file descriptors> instead of Perl B<file handles>. Functions include
but are not limited to C<accept>, C<connect>, C<socket>, C<bind>, C<sysopen>,
C<sysread>, and C<syswrite>.

It also implements some non core functions which normally would use file handles
such as C<dup> and C<mkstemp>.

This module can significantly lower memory usage per file descriptor and
decrease file/socket opening and socket accepting times.  C<accept> performance
is particularly improved with much higher connection handling rates for a given
backlog.

Actual byte throughput (read/write) is basically unchanged compared to the core
Perl sysread/syswrite.  Please see the PERFORMANCE section later in this
document

The supported interfaces mostly resemble the core Perl implementations of similarly
named functions. 

For example:

	#Perl:
	sysopen(my $file_handle, ...);
	sysread($file_handle, ...);

	#IO::FD
	IO::FD::sysopen(my $file_descriptor, ...);
	IO::FD::sysread($file_descriptor, ...);

This modules B<IS NOT> intended to be a drop in replacement for core IO
subroutines in existing code. If you want a 'drop in replacement' please look
at L<IO::FD::DWIM> which is part of the same distribution.

Currently this module is focused on Unix/Linux systems, as this is the natural
habitat of a file descriptor.

=head1 WHERE SHOULD I USE THIS MODULE?

=head2 Networking ... Oh Yes

Socket centric programs will benefit greatly from this module. The process of
socket creation/opening/accepting/listening, where it is INET/INET6 or UNIX
families is much improved. 

=head2 Slurp entire file ... Yes

If a file can be loaded completely into memory for processing, this module will
provide improved opening and closing times. Any decoding and line processing
will need to be done manually

=head2 Line Processing ... Hmmm, No

General text file line processing is best left to Perl file handles. File
handles do the heavy lifting of line splitting, EOL handling, encodings, which
this modules does not implement.

You can do it, but it is not in the scope of this module.


=head1 LIMITATIONS

Perl does a lot of nice things when working with files and handles. When using
file descriptors directly B<you will loose>:


=over

=item Buffering for file small read/write performance (via print and <FH>)

=item Automatic close when out of scope

=item Close on exec

=item Special variables not supported (ie '_' in stat)

=item <FH> 'readline' support

=item IO::Handle inheritance

=back



=head1 MOTIVATION

Perl makes working with text files easy, thanks to B<file handles>.  Line
splitting, UTF-8, EOL processing etc. are awesome and make your life easier.

However, the benefits of file handles in a network context or binary files are
not so clear cut. All the nice line ending and encoding support doesn't help in
these scenarios.

In addition, the OS kernel does a lot of buffering for networking already. Do we
really need to add more?

So if these features are not being fully utilised for binary/network
programming, the hypothesis is that opening and accepting operations would be
faster with file descriptors as less setup is required internally.

=head1 APIs

Each of the APIs mimic the Perl counterpart (if applicable) as much as
possible. Unless explicitly mentioned, they should operate like built in
routines.  Consult perldoc -f FUNCTION for details.

As none of these functions are exported, they must be called with full package
name.

=head2 Socket Manipulation

=head3 IO::FD::socket

=head3 IO::FD::socketpair

=head3 IO::FD::bind

=head3 IO::FD::listen

=head3 IO::FD::accept

=head3 IO::FD::accept_multiple

	my @new_fds;
	my @peers;
	my $count=accept_multiple(@new_fds, @peers, $listen_sock);

B<Note:> DO NOT use this function on a blocking socket.

Accepts as many new connection sockets as available. The new sockets are stored
in C<new_fds>, which is an array, not a array ref. The corresponding peers to
the connections are stored in C<@peers>, also an array not a reference.

C<$listen_sock> is the file descriptor from which  the sockets are accepted
from. It MUST be configured for non blocking  operation, otherwise your program
will just loop forever in this function

Because this function will only works for non blocking listening sockets, the
sockets/fds returned are forced into non blocking mode also. Than means on
linux an explicit fcntl is called. On BSD type systems the socket will already
be non blocking

Returns the number of sockets accepted until an error condition occurred.
Returns C<undef> if no sockets where accepted. Check the C<$!> for normal
non blocking error codes.

=head3 IO::FD::connect

=head3 IO::FD::getsockopt

=head3 IO::FD::setsockopt

Note: Implements the integer shorthand as per perldoc -f setsockopt

=head3 IO::FD::getpeername

=head3 IO::FD::getsockname


=head2 File Maniupulation

=head3 IO::FD::sysopen

=head3 IO::FD::sysopen4

Same as C<IO::FD::sysopen>, but expects all four arguments

=head3 IO::FD::mktemp

Behaves similar to L<File::Temp::mktemp>

Requires at least six 'X' characters at the end of the template

NOTE: This function does not return a file descriptor. It might be included in
future versions of this module

=head3 IO::FD::mkstemp

Behaves like L<File::Temp::mkstemp>

Requires at least six 'X' characters at the end of the template

NOTE: Currently returns C<undef> as path in list context. Cross platform fd
paths are hard to extract.  TODO:  Fix this across platforms.

=head3 IO::FD::sysseek


=head2 Pipes

=head3 IO::FD::pipe

=head3 IO::FD::syspipe

A alias of C<IO::FD::pipe>.

=head2 Common

=head3 IO::FD::dup

=head3 IO::FD::dup2

=head3 IO::FD::close

=head3 IO::FD::recv

=head3 IO::FD::send

=head3 IO::FD::sysread

=head3 IO::FD::sysread3

Same as C<IO::FD::sysread>, but expects only 3 of 4 arguments

=head3 IO::FD::sysread4

Same as C<IO::FD::sysread>, but expects all four arguments

=head3 IO::FD::syswrite

=head3 IO::FD::syswrite2

Same as C<IO::FD::syswrite>, but expect 2 of 4 arguments.

=head3 IO::FD::syswrite3

Same as C<IO::FD::syswrite>, but expect 3 of 4 arguments.

=head3 IO::FD::syswrite4

Same as C<IO::FD::syswrite>, but expect 4 of 4 arguments.

=head3 IO::FD::fcntl

=head3 IO::FD::sysfcntl

Alias to C<IO::FD::fcntl>

=head3 IO::FD::stat

Likely differences to Perl stat for larger integer values.

TODO: fix this!

=head3 IO::FD::lstat

Likely differences to Perl lstat for larger integer values

TODO: fix this!



=head2 Experimental

These functions haven't really been tested, documented or finished. They exist
none the less.  You will need to Look at the code for documentation at the
moment. Their behaviour and interface are LIKELY TO CHANGE without notice.

=head3 IO::FD::ioctl

Not complete

=head3 IO::FD::sysioctl

Alias to ioctl

=head3 IO::FD::clock_gettime_monotonic

=head3 IO::FD::select

Broken. Probably will be removed as core perl has this already.

=head3 IO::FD::poll

Constants for use with poll are available via  C<IO::FD:Constants>

=head3 IO::FD::kqueue

=head3 IO::FD::kevent

This is broken ok 32 bit BSD at the moment.
Constants for use with kevent are available via  C<IO::FD:Constants>

=head3 IO::FD::pack_kevent

=head3 IO::FD::sv_to_pointer

=head3 IO::FD::pointer_to_sv

=head3 IO::FD::SV
	
	IO::FD::SV($size)

Allocates a string SV with the given size preallocated. The current string
length is set to 0. For short string this is not the fastest way to allocate.
For 4k and above, it is much faster, and doesn't use extra memory in
compilation


=head3 IO::FD::readline

	#SLURP A FILE
	local $/=undef;
	my $slurp=IO::FD::readline;

		#or
	#SLURP ALL RECORDS OF KNOWN LENGTH
	local $/=\1234;
	my @records=IO::FD::readline;

A read line function is available, but is only operates in file slurp or record
slurp mode (see perldoc -f readline). As no buffering is used, It does not
attempt to split lines or read a line at a time like the normal Perl readline
or  <> operator



=head1 PERFORMANCE

Part of this distribution are benchmarking scripts. The following are typical
outputs from my Intel 2020 Macbook Pro.

=head2  Listen Backlog

Results from benchmark/server-perl.pl benchmark/server.pl and benchmark/client.pl

	Listen Backlog: 10
		Perl server:
		Connections before client refused: 18

		IO::FD server
		Connections before client refuse: 9285

	Listen Backlog: 100
		Perl server:
		Connections before client refused: 190

		IO::FD server
		Connections before client refuse:  (none refused)

	Listen Backlog: 1000

		Perl server:
		Connections before client refused: 245

		IO::FD server
		Connections before client refuse:  (none refused)

=head2 Accept 

Results from benchmark/server-perl.pl benchmark/server.pl and benchmark/client.pl

	Listen Backlog: 100
	
	Perl accept rate:    73568.4857256754/s
	IO::FD Accept rate: 150984.798776367/s
	


=head2	Memory Usage

Results from benchmark/file-memory.pl

	Creating 2000 file handles/descriptors
	Start maxrss (kB): 4500

	Perl file handles
	Bytes: 905216, per handle: 452.608

	IO::FD
	Bytes: 4096, per fd: 2.048

	End maxrss (kB): 5692

=head2 Socket creation 

Results from benchmark/socket-create.pl

			     Rate perl_socket_INET iofd_socket_INET
	perl_socket_INET  81919/s               --             -56%
	iofd_socket_INET 185679/s             127%               --
			      Rate perl_socket_INET6 iofd_socket_INET6
	perl_socket_INET6  81498/s                --              -57%
	iofd_socket_INET6 189253/s              132%                --
			     Rate perl_socket_UNIX iofd_socket_UNIX
	perl_socket_UNIX 113778/s               --             -78%
	iofd_socket_UNIX 508970/s             347%               --

=head2 File open and close

Results from benchmark/file-open-close.pl

			    Rate     file_handle file_desc_posix           io_fd
	file_handle      91897/s              --            -35%            -37%
	file_desc_posix 140549/s             53%              --             -4%
	io_fd           146161/s             59%              4%              --

=head2 Read Performance

Result from benchmark/file-read-write.pl

	Read performance:
	Read (bytes): 1024 x 2^0
			     Rate file_desc_posix     file_handle           io_fd
	file_desc_posix 1803743/s              --             -5%             -5%
	file_handle     1889325/s              5%              --             -0%
	io_fd           1890461/s              5%              0%              --
	Read (bytes): 1024 x 2^1
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1799026/s              --             -1%             -2%
	io_fd           1823610/s              1%              --             -1%
	file_handle     1837458/s              2%              1%              --
	Read (bytes): 1024 x 2^2
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1731140/s              --             -1%             -1%
	io_fd           1747626/s              1%              --             -0%
	file_handle     1747627/s              1%              0%              --
	Read (bytes): 1024 x 2^3
			     Rate           io_fd file_desc_posix     file_handle
	io_fd           1458670/s              --             -1%             -3%
	file_desc_posix 1470359/s              1%              --             -2%
	file_handle     1499189/s              3%              2%              --
	Read (bytes): 1024 x 2^4
			     Rate file_desc_posix     file_handle           io_fd
	file_desc_posix 1146879/s              --             -3%             -6%
	file_handle     1180322/s              3%              --             -3%
	io_fd           1214700/s              6%              3%              --

=head2 Write Performance

Result from benchmark/file-read-write.pl

	Write performance:
	Write (bytes): 1024 x 2^0
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1978800/s              --             -7%            -12%
	io_fd           2117316/s              7%              --             -6%
	file_handle     2244774/s             13%              6%              --
	Write (bytes): 1024 x 2^1
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 2007408/s              --             -6%             -9%
	io_fd           2143700/s              7%              --             -3%
	file_handle     2205537/s             10%              3%              --
	Write (bytes): 1024 x 2^2
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1978800/s              --             -7%            -12%
	io_fd           2123851/s              7%              --             -5%
	file_handle     2244774/s             13%              6%              --
	Write (bytes): 1024 x 2^3
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1960478/s              --             -7%             -9%
	io_fd           2117316/s              8%              --             -2%
	file_handle     2163924/s             10%              2%              --
	Write (bytes): 1024 x 2^4
			     Rate file_desc_posix           io_fd     file_handle
	file_desc_posix 1997468/s              --             -5%             -8%
	io_fd           2104367/s              5%              --             -3%
	file_handle     2163924/s              8%              3%              --


=head1 SEE ALSO

The L<POSIX> module provides an C<open>, C<close>, C<read> and C<write>
routines which return/work with file descriptors. If you are only concerned
with working with files, this is a better option as it is a core module, and
will give you the purported benefits of this module.  However it does not
provide any networking/socket support.

=head1 FUTURE WORK (IDEAS/TODO)


	Add more tests for stat and DWIM module
	Wider compatability for older perls
	Add More system functions which work with fds
	Work with win32 sockets
	Look into making a listen/accept fh/fd hybrid
	Maybe make an IO::Handle sub class

=head1 AUTHOR

Ruben Westerberg, E<lt>drclaw@mac.comE<gt>

=head1 REPOSITORTY and BUGS

Please report any bugs via git hub: L<http://github.com/drclaw1394/perl-io-fd>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 by Ruben Westerberg

This library is free software; you can redistribute it
and/or modify it under the same terms as Perl or the MIT
license.

=head1 DISCLAIMER OF WARRANTIES

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.
=cut
