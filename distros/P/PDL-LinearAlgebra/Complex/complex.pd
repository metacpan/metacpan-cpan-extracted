# TODO 'further details' ======= =========


do('../Config');
our $VERSION = '0.14';
pp_setversion($VERSION);
$VERSION = eval $VERSION;

use PDL::Exporter;

if ($config{CBLAS}){
	pp_addhdr('#include <cblas.h>');
}

if ($^O =~ /MSWin/) {
pp_addhdr('
#include <float.h>
');
}

pp_addhdr('
#include <math.h>

#if defined(PDL_CORE_VERSION) && PDL_CORE_VERSION < 10
typedef PDL_Long PDL_Indx;
#endif

typedef PDL_Long logical;
typedef PDL_Long integer;
typedef PDL_Long ftnlen;

#ifdef __cplusplus
typedef logical (*L_fp)(...);
#else
typedef logical (*L_fp)();
#endif

#ifndef min
#define min(a,b) ((a) <= (b) ? (a) : (b))
#endif
#ifndef max
#define max(a,b) ((a) >= (b) ? (a) : (b))
#endif

extern integer ilaenv_(integer *ispec, char *name__, char *opts, integer *n1,
integer *n2, integer *n3, integer *n4, ftnlen name_len, ftnlen
opts_len);

static integer c_zero = 0;
static integer c_nine = 9;
');

sub generate_code($){
	if ($config{WITHOUT_THREAD}){
	return '
		#if 0
		threadloop%{
		%}
		#endif'.$_[0];
	}
	else{
		return $_[0];
	}
}

my %float2native = (F => 'G', D => 'C');
sub pp_defc {
  my ($function, %hash) = @_;
  $hash{GenericTypes} ||= [qw(F D)];
  my $doc = $hash{Doc} || "\n=for ref\n\nComplex version of $function\n\n";
  $hash{Doc} = undef;
  my $decl = delete $hash{_decl};
  $decl =~ s/\$GENERIC\(\)\s*\*/void */g; # dodge float vs float complex ptr problem
  $hash{Code} = "$decl\n$hash{Code}";
  pp_def("__Cc$function", %hash);
  my %hash2 = %hash;
  $hash2{Pars} =~ s/\(2,/(/g;
  $hash2{GenericTypes} = [map $float2native{$_} || $_, @{$hash{GenericTypes}}];
  $hash2{Code} =~ s/\$GENERIC\(\)/\$TFD(float,double)/g;
  $hash2{Code} =~ s/\$TFD\(/\$TGC(/g;
  pp_def("__Nc$function", %hash2);
  pp_add_exported("c$function");
  pp_addpm(<<EOF);
=head2 c$function

=for sig

  Signature: ($hash{Pars})

$doc

=cut

sub PDL::c$function {
  \$_[0]->type->real ? goto &PDL::__Cc$function : goto &PDL::__Nc$function;
}
*c$function = \\&PDL::c$function;

EOF
}

pp_addpm({At=>'Top'},<<'EOD');
use strict;
use PDL::LinearAlgebra::Real;

{ 
  package # hide from CPAN
    PDL::Complex;
	my $warningFlag;
  	BEGIN{
  		$warningFlag = $^W;
		$^W = 0;
	}
	use overload (
		'x'     =>  sub {UNIVERSAL::isa($_[1],'PDL::Complex') ? PDL::cmmult($_[0], $_[1]) :
						PDL::cmmult($_[0], PDL::Complex::r2C($_[1]));
				},
	);
	BEGIN{ $^W = $warningFlag ; }
}

=encoding Latin-1

=head1 NAME

PDL::LinearAlgebra::Complex - PDL interface to the lapack linear algebra programming library (complex number)

=head1 SYNOPSIS

 use PDL::Complex
 use PDL::LinearAlgebra::Complex;

 $a = r2C random (100,100);
 $s = r2C zeroes(100);
 $u = r2C zeroes(100,100);
 $v = r2C zeroes(100,100);
 $info = 0;
 $job = 0;
 cgesdd($a, $job, $info, $s , $u, $v);

 # or, using native complex numbers:
 use PDL;
 use PDL::LinearAlgebra::Complex;
 $a = random(cdouble, 100, 100);
 $s = zeroes(cdouble, 100);
 $u = zeroes(cdouble, 100, 100);
 $v = zeroes(cdouble, 100, 100);
 $info = 0;
 $job = 0;
 cgesdd($a, $job, $info, $s , $u, $v);

=head1 DESCRIPTION

This module provides an interface to parts of the lapack library (complex numbers).
These routines accept either float or double piddles.

EOD

pp_defc("gtsv",
	_decl => <<'EOF',
		extern int $TFD(c,z)gtsv_(integer *n, integer *nrhs,
		$GENERIC() *dl, $GENERIC() *d, $GENERIC() *du, $GENERIC() *b,
                integer *ldb, integer *info);
EOF
	HandleBad => 0,
	Pars => '[phys]DL(2,n); [phys]D(2,n); [phys]DU(2,n); [io,phys]B(2,n,nrhs); int [o,phys]info()',
	Code => generate_code '
		$TFD(c,z)gtsv_(
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__nrhs_size)},
		$P(DL),
		$P(D),
		$P(DU),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(info));
',
      Doc => '

=for ref

Solves the equation

	A * X = B

where A is an C<n> by C<n> tridiagonal matrix, by Gaussian elimination with
partial pivoting, and B is an C<n> by C<nrhs> matrix.

Note that the equation C<A**T*X = B>  may be solved by interchanging the
order of the arguments DU and DL.

B<NB> This differs from the LINPACK function C<cgtsl> in that C<DL>
starts from its first element, while the LINPACK equivalent starts from
its second element.

    Arguments
    =========

    DL:   On entry, DL must contain the (n-1) sub-diagonal elements of A.

          On exit, DL is overwritten by the (n-2) elements of the
          second super-diagonal of the upper triangular matrix U from
          the LU factorization of A, in DL(1), ..., DL(n-2).

    D:    On entry, D must contain the diagonal elements of A.

          On exit, D is overwritten by the n diagonal elements of U.

    DU:   On entry, DU must contain the (n-1) super-diagonal elements of A.

          On exit, DU is overwritten by the (n-1) elements of the
          first super-diagonal of the U.

    B:    On entry, the n by nrhs matrix of right hand side matrix B.
          On exit, if info = 0, the n by nrhs solution matrix X.

    info:   = 0:  successful exit
            < 0:  if info = -i, the i-th argument had an illegal value
            > 0:  if info = i, U(i,i) is exactly zero, and the solution
                  has not been computed.  The factorization has not been
                  completed unless i = n.

=for example

 use PDL::Complex;
 $dl = random(float, 9) + random(float, 9) * i;
 $d = random(float, 10) + random(float, 10) * i;
 $du = random(float, 9) + random(float, 9) * i;
 $b = random(10,5) + random(10,5) * i;
 cgtsv($dl, $d, $du, $b, ($info=null));
 print "X is:\n$b" unless $info;

');

pp_defc("gesvd",
       _decl => <<'EOF',
		extern int $TFD(c,z)gesvd_(char *jobu, char *jobvt, integer *m, integer *n, $GENERIC() *a,
		integer *lda, $GENERIC() *s, $GENERIC() *u, int *ldu,
		$GENERIC() *vt, integer *ldvt, $GENERIC() *work, integer *lwork, $GENERIC() *rwork,
		integer *info);
EOF
       HandleBad => 0,
	RedoDimsCode => '$SIZE(r) =  $PDL(A)->ndims > 2 ? min($PDL(A)->dims[1], $PDL(A)->dims[2]) : 1;',
	Pars => '[io,phys]A(2,m,n); int jobu(); int jobvt(); [o,phys]s(r); [o,phys]U(2,p,q); [o,phys]VT(2,s,t); int [o,phys]info()',
	Code => generate_code '
		integer lwork;
		char trau, travt;
		$GENERIC() *rwork;
		$GENERIC() tmp_work[2];
		lwork = ($PRIV(__m_size) < $PRIV(__n_size)) ? 5*$PRIV(__m_size) : 5*$PRIV(__n_size);
		rwork = ($GENERIC() *)malloc(lwork *  sizeof($GENERIC()));
		lwork = -1;


		switch ($jobu())
		{
			case 1: trau = \'A\';
				break;
			case 2: trau = \'S\';
				break;
			case 3: trau = \'O\';
				break;
			default: trau = \'N\';
		}
		switch ($jobvt())
		{
			case 1: travt = \'A\';
				break;
			case 2: travt = \'S\';
				break;
			case 3: travt = \'O\';
				break;
			default: travt = \'N\';
		}

		$TFD(c,z)gesvd_(
		&trau,
		&travt,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(s),
		$P(U),
		&(integer){$PRIV(__p_size)},
		$P(VT),
		&(integer){$PRIV(__s_size)},
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(cgesvd_,zgesvd_)(
		&trau,
		&travt,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(s),
		$P(U),
		&(integer){$PRIV(__p_size)},
		$P(VT),
		&(integer){$PRIV(__s_size)},
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);
',
Doc=>'

=for ref

Complex version of gesvd.

The SVD is written

 A = U * SIGMA * ConjugateTranspose(V)

');

pp_defc("gesdd",
       _decl => <<'EOF',
		extern int $TFD(c,z)gesdd_(char *jobz, integer *m, integer *n, $GENERIC() *
		a, integer *lda, $GENERIC() *s, $GENERIC() *u, int *ldu,
		$GENERIC() *vt, integer *ldvt, $GENERIC() *work, integer *lwork,
		$GENERIC() *rwork, integer *iwork, integer *info);
EOF
       HandleBad => 0,
       RedoDimsCode => '$SIZE(r) =  $PDL(A)->ndims > 2 ? min($PDL(A)->dims[1], $PDL(A)->dims[2]) : 1;',
	Pars => '[io,phys]A(2,m,n); int job(); [o,phys]s(r); [o,phys]U(2,p,q); [o,phys]VT(2,s,t); int [o,phys]info()',
	Code => generate_code '
		integer lwork;
		integer *iwork;
		char tra;

		$GENERIC() *rwork;
		$GENERIC() tmp_work[2];
		
		lwork = ($PRIV(__m_size) < $PRIV(__n_size)) ? $PRIV(__m_size) : $PRIV(__n_size);
		iwork = (integer *)malloc(lwork * 8 * sizeof(integer));

		switch ($job())
		{

			case 1: tra = \'A\';
				rwork = ($GENERIC() *)malloc( (5 * lwork *lwork + 5 * lwork) * sizeof($GENERIC()));
				break;
			case 2: tra = \'S\';
				rwork = ($GENERIC() *)malloc( (5 * lwork *lwork + 5 * lwork) * sizeof($GENERIC()));
				break;
			case 3: tra = \'O\';
				rwork = ($GENERIC() *)malloc( (5 * lwork *lwork + 5 * lwork) * sizeof($GENERIC()));
				break;
			default: tra = \'N\';
				rwork = ($GENERIC() *)malloc( 7 * lwork  *  sizeof($GENERIC()));
				break;

		}		
		lwork = -1;
		$TFD(cgesdd_,zgesdd_)(
		&tra,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(s),
		$P(U),
		&(integer){$PRIV(__p_size)},
		$P(VT),
		&(integer){$PRIV(__s_size)},
		&tmp_work[0],
		&lwork,
		rwork,
		iwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{

		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cgesdd_,zgesdd_)(
		&tra,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(s),
		$P(U),
		&(integer){$PRIV(__p_size)},
		$P(VT),
		&(integer){$PRIV(__s_size)},
		work,
		&lwork,
		rwork,
		iwork,
		$P(info));
		free(work);
		}
		free(iwork);
		free(rwork);
',
Doc=>'

=for ref

Complex version of gesdd.

The SVD is written

 A = U * SIGMA * ConjugateTranspose(V)

');

pp_defc("ggsvd",
       _decl => <<'EOF',
		extern int $TFD(c,z)ggsvd3_(char *jobu, char *jobv, char *jobq, integer *m,
		integer *n, integer *p, integer *k, integer *l, $GENERIC() *a, 
		integer *lda, $GENERIC() *b, integer *ldb, $GENERIC() *alpha, 
		$GENERIC() *beta, $GENERIC() *u, integer *ldu, $GENERIC() *v, integer 
		*ldv, $GENERIC() *q, integer *ldq, $GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *iwork,
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); int jobu(); int jobv(); int jobq(); [io,phys]B(2,p,n); int [o,phys]k(); int [o,phys]l();[o,phys]alpha(n);[o,phys]beta(n); [o,phys]U(2,q,r); [o,phys]V(2,s,t); [o,phys]Q(2,u,v); int [o,phys]iwork(n); int [o,phys]info()',
	Code => generate_code '
		char pjobu = \'N\';
		char pjobv = \'N\';		
		char pjobq = \'N\';

		$GENERIC() *work, *rwork, twork[1];
		//integer lwork = ($SIZE (m) < $SIZE (n)) ? $SIZE (n): $SIZE (m);
		integer lwork = -1;

		//if ($SIZE (p) > lwork)
		//	lwork = $SIZE (p);
		if ($jobu())
			pjobu = \'U\';
		if ($jobv())
			pjobv = \'V\';
		if ($jobq())
			pjobq = \'Q\';

		$TFD(cggsvd3_,zggsvd3_)(
		&pjobu,
		&pjobv,
		&pjobq,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__p_size)},
		$P(k),
		$P(l),
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(alpha),
		$P(beta),
		$P(U),
		&(integer){$PRIV(__q_size)},
		$P(V),
		&(integer){$PRIV(__s_size)},
		$P(Q),
		&(integer){$PRIV(__u_size)},
		&twork[0],
		&lwork,
		rwork,
		$P(iwork),
		$P(info));

		lwork = (integer) twork[0];

			work = ($GENERIC() *)malloc(2*(lwork * sizeof($GENERIC())));
			rwork = ($GENERIC() *)malloc(2 * $SIZE (n) *  sizeof($GENERIC()));
		
		$TFD(cggsvd3_,zggsvd3_)(
		&pjobu,
		&pjobv,
		&pjobq,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__p_size)},
		$P(k),
		$P(l),
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(alpha),
		$P(beta),
		$P(U),
		&(integer){$PRIV(__q_size)},
		$P(V),
		&(integer){$PRIV(__s_size)},
		$P(Q),
		&(integer){$PRIV(__u_size)},
		work,
		&lwork,
		rwork,
		$P(iwork),
		$P(info));
		free(rwork);
		free(work);
');

pp_defc("geev",
       _decl => <<'EOF',
		extern int $TFD(c,z)geev_(char *jobvl, char *jobvr, integer *n, $GENERIC() *a,
		integer *lda, $GENERIC() *w, $GENERIC() *vl, integer *ldvl, $GENERIC() *vr,
		integer *ldvr, $GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int jobvl(); int jobvr(); [o,phys]w(2,n); [o,phys]vl(2,m,m); [o,phys]vr(2,p,p); int [o,phys]info()',
	Code => generate_code '
		char jvl = \'N\';
		char jvr = \'N\';
		$GENERIC() tmp_work[2], *rwork;
		integer lwork = -1;

		if ($jobvl())
			jvl = \'V\';
		if ($jobvr())
			jvr = \'V\';
			rwork = ($GENERIC() *)malloc( 2 * $PRIV(__n_size) *  sizeof($GENERIC()));
		$TFD(cgeev_,zgeev_)(
		&jvl,
		&jvr,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(w),
		$P(vl),
		&(integer){$PRIV(__m_size)},
		$P(vr),
		&(integer){$PRIV(__p_size)},
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(cgeev_,zgeev_)(
		&jvl,
		&jvr,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(w),
		$P(vl),
		&(integer){$PRIV(__m_size)},
		$P(vr),
		&(integer){$PRIV(__p_size)},
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);
');


pp_defc("geevx",
       _decl => <<'EOF',
		extern int $TFD(c,z)geevx_(char *balanc, char *jobvl, char *jobvr, char *
		sense, integer *n, $GENERIC() *a, integer *lda, $GENERIC() *w,
		$GENERIC() *vl, integer *ldvl, $GENERIC() *vr,
		integer *ldvr, integer *ilo, integer *ihi, $GENERIC() *scale,
		$GENERIC() *abnrm, $GENERIC() *rconde, $GENERIC() *rcondv, $GENERIC()
		*work, integer *lwork, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  int jobvl(); int jobvr(); int balance(); int sense(); [o,phys]w(2,n); [o,phys]vl(2,m,m); [o,phys]vr(2,p,p); int [o,phys]ilo(); int [o,phys]ihi(); [o,phys]scale(n); [o,phys]abnrm(); [o,phys]rconde(q); [o,phys]rcondv(r); int [o,phys]info()',
	Code => generate_code '
		char jvl = \'N\';
		char jvr = \'N\';
		char balanc, sens;
		integer lwork = -1;
		$GENERIC() tmp_work[2], *rwork;

		if ($jobvl())
			jvl = \'V\';
		if ($jobvr())
			jvr = \'V\';

		switch ($balance())
		{
			case 1: balanc = \'P\';
				break;
			case 2: balanc = \'S\';
				break;
			case 3: balanc = \'B\';
				break;
			default: balanc = \'N\';
		}
		switch ($sense())
		{
			case 1: sens = \'E\';
				break;
			case 2: sens = \'V\';
				break;
			case 3: sens = \'B\';
				break;
			default: sens = \'N\';
		}
			rwork = ($GENERIC() *)malloc( 2 * $PRIV(__n_size) *  sizeof($GENERIC()));
		$TFD(cgeevx_,zgeevx_)(
		&balanc,
		&jvl,
		&jvr,
		&sens,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(w),
		$P(vl),
		&(integer){$PRIV(__m_size)},
		$P(vr),
		&(integer){$PRIV(__p_size)},
		$P(ilo),
		$P(ihi),
		$P(scale),
		$P(abnrm),
		$P(rconde),
		$P(rcondv),
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cgeevx_,zgeevx_)(
		&balanc,
		&jvl,
		&jvr,
		&sens,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(w),
		$P(vl),
		&(integer){$PRIV(__m_size)},
		$P(vr),
		&(integer){$PRIV(__p_size)},
		$P(ilo),
		$P(ihi),
		$P(scale),
		$P(abnrm),
		$P(rconde),
		$P(rcondv),
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);
');

pp_defc("ggev",
       _decl => <<'EOF',
		extern int $TFD(c,z)ggev_(char *jobvl, char *jobvr, integer *n, $GENERIC() *
		a, integer *lda, $GENERIC() *b, integer *ldb, $GENERIC() *alpha,
		$GENERIC() *beta, $GENERIC() *vl, integer *ldvl,
		$GENERIC() *vr, integer *ldvr, $GENERIC() *work, integer *lwork,
		$GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int jobvl();int jobvr();[phys]B(2,n,n);[o,phys]alpha(2,n);[o,phys]beta(2,n);[o,phys]VL(2,m,m);[o,phys]VR(2,p,p);int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		char pjobvl = \'N\', pjobvr = \'N\';
		$GENERIC() tmp_work[2], *rwork;
		if ($jobvl())
			pjobvl = \'V\';
		if ($jobvr())
			pjobvr = \'V\';

			rwork = ($GENERIC() *)malloc(8 * $SIZE(n) *  sizeof($GENERIC()));
		$TFD(cggev_,zggev_)(
		&pjobvl,
		&pjobvr,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(alpha),
		$P(beta),
		$P(VL),
		&(integer){$PRIV(__m_size)},
		$P(VR),
		&(integer){$PRIV(__p_size)},
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));

		$TFD(cggev_,zggev_)(
		&pjobvl,
		&pjobvr,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(alpha),
		$P(beta),
		$P(VL),
		&(integer){$PRIV(__m_size)},
		$P(VR),
		&(integer){$PRIV(__p_size)},
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);

');

pp_defc("ggevx",
       _decl => <<'EOF',
		extern int $TFD(c,z)ggevx_(char *balanc, char *jobvl, char *jobvr, char *
		sense, integer *n, $GENERIC() *a, integer *lda, $GENERIC() *b,
		integer *ldb, $GENERIC() *alpha, $GENERIC() *
		beta, $GENERIC() *vl, integer *ldvl, $GENERIC() *vr, integer *ldvr,
		integer *ilo, integer *ihi, $GENERIC() *lscale, $GENERIC() *rscale,
		$GENERIC() *abnrm, $GENERIC() *bbnrm, $GENERIC() *rconde, $GENERIC() *
		rcondv, $GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *iwork, logical *
		bwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);int balanc();int jobvl();int jobvr();int sense();[io,phys]B(2,n,n);[o,phys]alpha(2,n);[o,phys]beta(2,n);[o,phys]VL(2,m,m);[o,phys]VR(2,p,p);int [o,phys]ilo();int [o,phys]ihi();[o,phys]lscale(n);[o,phys]rscale(n);[o,phys]abnrm();[o,phys]bbnrm();[o,phys]rconde(r);[o,phys]rcondv(s);int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1, *iwork, *bwork;
		char pjobvl = \'N\', pjobvr = \'N\';
		char pbalanc, psens;

		$GENERIC() tmp_work[2], *rwork;
		rwork = ($GENERIC() *)malloc(6 * $SIZE(n) *  sizeof($GENERIC()));
		if ($jobvl())
			pjobvl = \'V\';
		if ($jobvr())
			pjobvr = \'V\';

		switch ($balanc())
		{
			case 1: pbalanc = \'P\';
				break;
			case 2: pbalanc = \'S\';
				break;
			case 3: pbalanc = \'B\';
				break;
			default: pbalanc = \'N\';
		}
		switch ($sense())
		{
			case 1: psens = \'E\';
				bwork = (integer *)malloc($SIZE(n) *  sizeof(integer));
				break;
			case 2: psens = \'V\';
				iwork = (integer *)malloc(($SIZE(n) + 2) *  sizeof(integer));
				bwork = (integer *)malloc($SIZE(n) *  sizeof(integer));
				break;
			case 3: psens = \'B\';
				iwork = (integer *)malloc(($SIZE(n) + 2) *  sizeof(integer));
				bwork = (integer *)malloc($SIZE(n) *  sizeof(integer));
				break;
			default: psens = \'N\';
				iwork = (integer *)malloc(($SIZE(n) + 2) *  sizeof(integer));
		}

		$TFD(cggevx_,zggevx_)(
		&pbalanc,
		&pjobvl,
		&pjobvr,
		&psens,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(alpha),
		$P(beta),
		$P(VL),
		&(integer){$PRIV(__m_size)},
		$P(VR),
		&(integer){$PRIV(__p_size)},
		$P(ilo),
		$P(ihi),
		$P(lscale),
		$P(rscale),
		$P(abnrm),
		$P(bbnrm),
		$P(rconde),
		$P(rcondv),
		&tmp_work[0],
		&lwork,
		rwork,
		iwork,
		bwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));

		$TFD(cggevx_,zggevx_)(
		&pbalanc,
		&pjobvl,
		&pjobvr,
		&psens,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(alpha),
		$P(beta),
		$P(VL),
		&(integer){$PRIV(__m_size)},
		$P(VR),
		&(integer){$PRIV(__p_size)},
		$P(ilo),
		$P(ihi),
		$P(lscale),
		$P(rscale),
		$P(abnrm),
		$P(bbnrm),
		$P(rconde),
		$P(rcondv),
		work,
		&lwork,
		rwork,
		iwork,
		bwork,
		$P(info));
		free(work);
		}
		free(rwork);
		if ($sense())
			free(bwork);
		if ($sense() != 1)
			free(iwork);
');


pp_addhdr('
static SV*   fselect_func;
PDL_Long fselect_wrapper(float *p)
{
   dSP ;

   int count;
   long ret;
   SV *pdl1;
   HV *bless_stash;

   pdl *pdl;
   PDL_Indx odims[1];

   PDL_Indx dims[] = {2,1};
   pdl = PDL->pdlnew();
   PDL->setdims (pdl, dims, 2);
   pdl->datatype = PDL_F;
   pdl->data = p;
   pdl->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
   bless_stash = gv_stashpv("PDL::Complex", 0);

   ENTER ;   SAVETMPS ;   PUSHMARK(sp) ;

    pdl1 = sv_newmortal();
    PDL->SetSV_PDL(pdl1, pdl);
    pdl1 = sv_bless(pdl1, bless_stash); /* bless in PDL::Complex  */
    XPUSHs(pdl1);

   PUTBACK ;

   count = perl_call_sv(fselect_func, G_SCALAR);

   SPAGAIN;

   if (count !=1)
      croak("Error calling perl function\n");


   // For pdl_free
   odims[0] = 0;
   PDL->setdims (pdl, odims, 0);
   pdl->state &= ~ (PDL_ALLOCATED |PDL_DONTTOUCHDATA);
   pdl->data=NULL;
   ret = (long ) POPl ;
   PUTBACK ;   FREETMPS ;   LEAVE ;
   return ret;

}

static SV*   dselect_func;
PDL_Long dselect_wrapper(double *p)
{
   dSP ;

   int count;
   long ret;
   SV *pdl1;
   HV *bless_stash;

   pdl *pdl;
   PDL_Indx odims[1];

   PDL_Indx dims[] = {2,1};
   pdl = PDL->pdlnew();
   PDL->setdims (pdl, dims, 2);
   pdl->datatype = PDL_D;
   pdl->data = p;
   pdl->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
   bless_stash = gv_stashpv("PDL::Complex", 0);

   ENTER ;   SAVETMPS ;   PUSHMARK(sp) ;

    pdl1 = sv_newmortal();
    PDL->SetSV_PDL(pdl1, pdl);
    pdl1 = sv_bless(pdl1, bless_stash); /* bless in PDL::Complex  */
    XPUSHs(pdl1);

   PUTBACK ;

   count = perl_call_sv(dselect_func, G_SCALAR);

   SPAGAIN;

   if (count !=1)
      croak("Error calling perl function\n");


   // For pdl_free
   odims[0] = 0;
   PDL->setdims (pdl, odims, 0);
   pdl->state &= ~ (PDL_ALLOCATED |PDL_DONTTOUCHDATA);
   pdl->data=NULL;
   ret = (long ) POPl ;
   PUTBACK ;   FREETMPS ;   LEAVE ;
   return ret;

}

');

pp_defc("gees",
       _decl => <<'EOF',
		extern int $TFD(c,z)gees_(char *jobvs, char *sort, L_fp select, integer *n,
		$GENERIC() *a, integer *lda, integer *sdim, $GENERIC() *w,
		$GENERIC() *vs, integer *ldvs, $GENERIC() *work,
		integer *lwork, $GENERIC() *rwork, integer *bwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  int jobvs(); int sort(); [o,phys]w(2,n); [o,phys]vs(2,p,p); int [o,phys]sdim(); int [o,phys]info()',
	OtherPars => "SV* select_func" ,
	Code => generate_code '
		char jvs = \'N\';
		char psort = \'N\';
		integer *bwork;
		integer lwork = -1;

		$GENERIC() tmp_work[2];
		$GENERIC() *rwork, *work;
		rwork = ($GENERIC() *) malloc ($PRIV(__n_size) * sizeof ($GENERIC()));
		$TFD(f,d)select_func    = $PRIV(select_func);

		if ($jobvs())
			jvs = \'V\';
		if ($sort()){
			psort = \'S\';
			bwork  = (integer * ) malloc ($PRIV(__n_size) * sizeof (integer));
		}
             $TFD(c,z)gees_(
		&jvs,
		&psort,
		$TFD(f,d)select_wrapper,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(sdim),
		$P(w),
		$P(vs),
		&(integer){$PRIV(__p_size)},
		&tmp_work[0],
		&lwork,
		rwork,
		bwork,
		$P(info));             

		lwork = (integer )tmp_work[0];

		work = ($GENERIC() *) malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(c,z)gees_(
		&jvs,
		&psort,
		$TFD(f,d)select_wrapper,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(sdim),
		$P(w),
		$P(vs),
		&(integer){$PRIV(__p_size)},
		work,
		&lwork,
		rwork,
		bwork,
		$P(info));
		free(work);

		if ($sort())
			free(bwork);
		free(rwork);
		',
	Doc=>'

=for ref

Complex version of gees

    select_func:
            If sort = 1, select_func is used to select eigenvalues to sort
            to the top left of the Schur form.
            If sort = 0, select_func is not referenced.
            An complex eigenvalue w is selected if
            select_func(PDL::Complex(w)) is true;
            Note that a selected complex eigenvalue may no longer
            satisfy select_func(PDL::Complex(w)) = 1 after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned); in this
            case info is set to N+2.
	

');


pp_defc("geesx",
       _decl => <<'EOF',
		extern int $TFD(c,z)geesx_(char *jobvs, char *sort, L_fp select, char * sense,
		integer *n, $GENERIC() *a, integer *lda, integer *sdim, $GENERIC() *w,
		$GENERIC() *vs, integer *ldvs, $GENERIC() *rconde, $GENERIC() *rcondv,
		$GENERIC() *work, integer *lwork, $GENERIC() *rwork,
		integer *bwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  int jobvs(); int sort(); int sense(); [o,phys]w(2,n);[o,phys]vs(2,p,p); int [o,phys]sdim(); [o,phys]rconde();[o,phys]rcondv(); int [o,phys]info()',
	OtherPars => "SV* select_func" ,
	Code => generate_code '
		char jvs = \'N\';
		char psort = \'N\';
		integer *bwork;
		integer lwork = 0;
		char sens;

		$GENERIC() *work, *rwork;
		rwork = ($GENERIC() *) malloc ($PRIV(__n_size) * sizeof ($GENERIC()));
		$TFD(f,d)select_func    = $PRIV(select_func);


		if ($jobvs())
			jvs = \'V\';
		if ($sort()){
			psort = \'S\';
			bwork  = (integer * )  malloc ($PRIV(__n_size) * sizeof (integer));
		}

		switch ($sense())
		{
			case 1: sens = \'E\';
				lwork  = (integer ) ($PRIV(__n_size) * ($PRIV(__n_size)/2));
				break;
			case 2: sens = \'V\';
				lwork  = (integer ) ($PRIV(__n_size) * ($PRIV(__n_size)/2));
				break;
			case 3: sens = \'B\';
				lwork  = (integer ) ($PRIV(__n_size) * ($PRIV(__n_size)/2));
				break;
			default: sens = \'N\';
				 lwork = (integer ) ($PRIV(__n_size) * 2);
		}
		work  = ($GENERIC() * )malloc(2*lwork * sizeof ($GENERIC()));

		$TFD(c,z)geesx_(
		&jvs,
		&psort,
		$TFD(f,d)select_wrapper,
		&sens,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(sdim),
		$P(w),
		$P(vs),
		&(integer){$PRIV(__p_size)},
		$P(rconde),
		$P(rcondv),
		work,
		&lwork,
		rwork,
		bwork,
		$P(info));

		free(work);
		if ($sort())
			free(bwork);
		free(rwork);
',
      Doc => '

=for ref

Complex version of geesx

    select_func:
            If sort = 1, select_func is used to select eigenvalues to sort
            to the top left of the Schur form.
            If sort = 0, select_func is not referenced.
            An complex eigenvalue w is selected if
            select_func(PDL::Complex(w)) is true; 
            Note that a selected complex eigenvalue may no longer
            satisfy select_func(PDL::Complex(w)) = 1 after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned); in this
            case info is set to N+2.
	

');



pp_addhdr('
static SV*   fgselect_func;
PDL_Long fgselect_wrapper(float *p, float *q)
{
   dSP ;

   int count;
   long ret;
   SV *svpdl1, *svpdl2;
   HV *bless_stash;

   pdl *pdl1, *pdl2;
   PDL_Indx odims[1];

   PDL_Indx dims[] = {2,1};
   pdl1 = PDL->pdlnew();
   PDL->setdims (pdl1, dims, 2);
   pdl1->datatype = PDL_F;
   pdl1->data = p;
   pdl1->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
   pdl2 = PDL->pdlnew();
   PDL->setdims (pdl2, dims, 2);
   pdl2->datatype = PDL_F;
   pdl2->data = q;
   pdl2->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;



   bless_stash = gv_stashpv("PDL::Complex", 0);

   ENTER ;   SAVETMPS ;   PUSHMARK(sp) ;

    svpdl1 = sv_newmortal();
    PDL->SetSV_PDL(svpdl1, pdl1);
    svpdl1 = sv_bless(svpdl1, bless_stash); /* bless in PDL::Complex  */
    
    svpdl2 = sv_newmortal();
    PDL->SetSV_PDL(svpdl2, pdl2);
    svpdl2 = sv_bless(svpdl2, bless_stash); /* bless in PDL::Complex  */
    
    XPUSHs(svpdl1);
    XPUSHs(svpdl2);

   PUTBACK ;

   count = perl_call_sv(fgselect_func, G_SCALAR);

   SPAGAIN;

   if (count !=1)
      croak("Error calling perl function\n");


   // For pdl_free
   odims[0] = 0;
   PDL->setdims (pdl1, odims, 0);
   pdl1->state &= ~ (PDL_ALLOCATED |PDL_DONTTOUCHDATA);
   pdl1->data=NULL;

   PDL->setdims (pdl2, odims, 0);
   pdl1->state &= ~ (PDL_ALLOCATED |PDL_DONTTOUCHDATA);
   pdl1->data=NULL;

   ret = (long ) POPl ;
   PUTBACK ;   FREETMPS ;   LEAVE ;
   return ret;

}

static SV*   dgselect_func;
PDL_Long dgselect_wrapper(double *p, double *q)
{
   dSP ;

   int count;
   long ret;
   SV *svpdl1, *svpdl2;
   HV *bless_stash;

   pdl *pdl1, *pdl2;
   PDL_Indx odims[1];

   PDL_Indx dims[] = {2,1};
   pdl1 = PDL->pdlnew();
   PDL->setdims (pdl1, dims, 2);
   pdl1->datatype = PDL_D;
   pdl1->data = p;
   pdl1->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
   pdl2 = PDL->pdlnew();
   PDL->setdims (pdl2, dims, 2);
   pdl2->datatype = PDL_D;
   pdl2->data = q;
   pdl2->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;

   bless_stash = gv_stashpv("PDL::Complex", 0);


   ENTER ;   SAVETMPS ;   PUSHMARK(sp) ;

    svpdl1 = sv_newmortal();
    PDL->SetSV_PDL(svpdl1, pdl1);
    svpdl1 = sv_bless(svpdl1, bless_stash); /* bless in PDL::Complex  */
    svpdl2 = sv_newmortal();
    PDL->SetSV_PDL(svpdl2, pdl2);
    svpdl2 = sv_bless(svpdl2, bless_stash); /* bless in PDL::Complex  */

    XPUSHs(svpdl1);
    XPUSHs(svpdl2);

   PUTBACK ;

   count = perl_call_sv(dgselect_func, G_SCALAR);

   SPAGAIN;

   if (count !=1)
      croak("Error calling perl function\n");


   // For pdl_free
   odims[0] = 0;
   PDL->setdims (pdl1, odims, 0);
   pdl1->state &= ~ (PDL_ALLOCATED |PDL_DONTTOUCHDATA);
   pdl1->data=NULL;
   PDL->setdims (pdl2, odims, 0);
   pdl2->state &= ~ (PDL_ALLOCATED |PDL_DONTTOUCHDATA);
   pdl2->data=NULL;

   ret = (long ) POPl ;
   PUTBACK ;   FREETMPS ;   LEAVE ;
   return ret;

}

');


pp_defc("gges",
       _decl => <<'EOF',
		extern int $TFD(c,z)gges_(char *jobvsl, char *jobvsr, char *sort, L_fp
		delctg, integer *n, $GENERIC() *a, integer *lda, $GENERIC() *b,
		integer *ldb, integer *sdim, $GENERIC() *alpha,
		$GENERIC() *beta, $GENERIC() *vsl, integer *ldvsl, $GENERIC() *vsr,
		integer *ldvsr, $GENERIC() *work, integer *lwork, $GENERIC() *rwork,
		logical *bwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int jobvsl();int jobvsr();int sort();[io,phys]B(2,n,n);[o,phys]alpha(2,n);[o,phys]beta(2,n);[o,phys]VSL(2,m,m);[o,phys]VSR(2,p,p);int [o,phys]sdim();int [o,phys]info()',
	OtherPars => "SV* select_func" ,
	Code => generate_code '
		integer lwork = -1;
		char pjobvsl = \'N\', pjobvsr = \'N\', psort = \'N\';
		integer *bwork;

		$GENERIC() tmp_work[2], *rwork;
		$TFD(f,d)gselect_func    = $PRIV(select_func);
		rwork = ($GENERIC() *)malloc(8 * $SIZE(n) *  sizeof($GENERIC()));	
		if ($jobvsl())
			pjobvsl = \'V\';
		if ($jobvsr())
			pjobvsr = \'V\';
		if ($sort()){
			psort = \'S\';
			bwork = (integer *)malloc($PRIV(__n_size) *  sizeof(integer));
		}
		$TFD(c,z)gges_(
		&pjobvsl,
		&pjobvsr,
		&psort,
		$TFD(f,d)gselect_wrapper,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(sdim),
		$P(alpha),
		$P(beta),
		$P(VSL),
		&(integer){$PRIV(__m_size)},
		$P(VSR),
		&(integer){$PRIV(__p_size)},
		&tmp_work[0],
		&lwork,
		rwork,
		bwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));

		$TFD(c,z)gges_(
		&pjobvsl,
		&pjobvsr,
		&psort,
		$TFD(f,d)gselect_wrapper,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(sdim),
		$P(alpha),
		$P(beta),
		$P(VSL),
		&(integer){$PRIV(__m_size)},
		$P(VSR),
		&(integer){$PRIV(__p_size)},
		work,
		&lwork,
		rwork,
		bwork,
		$P(info));
		free(work);
		}
		if ($sort())
			free (bwork);
		free(rwork);

',
Doc=>'

=for ref

Complex version of ggees

    select_func:
            If sort = 1, select_func is used to select eigenvalues to sort
            to the top left of the Schur form.
            If sort = 0, select_func is not referenced.
            An eigenvalue w = w/beta is selected if
            select_func(PDL::Complex(w), PDL::Complex(beta)) is true; 
            Note that a selected complex eigenvalue may no longer
            satisfy select_func(PDL::Complex(w),PDL::Complex(beta)) = 1 after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned); in this
            case info is set to N+2.


');

pp_defc("ggesx",
       _decl => <<'EOF',
		extern int $TFD(c,z)ggesx_(char *jobvsl, char *jobvsr, char *sort, L_fp
		delctg, char *sense, integer *n, $GENERIC() *a, integer *lda, $GENERIC() *b,
		integer *ldb, integer *sdim, $GENERIC() *alpha,
		$GENERIC() *beta, $GENERIC() *vsl, integer *ldvsl, $GENERIC() *vsr,
		integer *ldvsr, $GENERIC() *rconde, $GENERIC() *rcondv,  $GENERIC() *work,
		integer *lwork, $GENERIC() *rwork, integer *iwork, integer *liwork, logical *bwork,
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int jobvsl();int jobvsr();int sort();int sense();[io,phys]B(2,n,n);[o,phys]alpha(2,n);[o,phys]beta(2,n);[o,phys]VSL(2,m,m);[o,phys]VSR(2,p,p);int [o,phys]sdim();[o,phys]rconde(q);[o,phys]rcondv(r);int [o,phys]info()',
	OtherPars => "SV* select_func" ,
	Code => generate_code '
		integer lwork, maxwrk;
		integer liwork = 1;
		integer minwrk = 1;
		static integer c__0 = 0;
		static integer c__1 = 1;
		static integer c_n1 = -1;
		char pjobvsl = \'N\';
		char pjobvsr = \'N\';
		char psort = \'N\';
		char psens = \'N\';
		integer *bwork;
		integer *iwork;
		$GENERIC() *rwork = ($GENERIC() *)malloc(8 * $SIZE(n) *  sizeof($GENERIC()));	
		$TFD(f,d)gselect_func    = $PRIV(select_func);
		if ($jobvsr())
			pjobvsr = \'V\';

		if ($sort()){
			psort = \'S\';
			bwork = (integer *)malloc($PRIV(__n_size) *  sizeof(integer));
		}

		switch ($sense())
		{
			case 1: psens = \'E\';
				break;
			case 2: psens = \'V\';
				break;
			case 3: psens = \'B\';
				break;
			default: psens = \'N\';
		}
//		if (!$sense())
//			liwork = 1;
//		else
//		{
			liwork = $SIZE(n) + 2;
			iwork =  (integer *)malloc(liwork *  sizeof(integer));
//		}


		// Code modified from Lapack
		// TODO other shur form above
		// The actual updated release (clapack 09/20/2000) do not allow
		// the workspace query. See release notes of Lapack
		// for this feature.

		minwrk = $SIZE(n)  << 1;
		maxwrk = $SIZE(n)  + $SIZE(n) * ilaenv_(&c__1, "ZGEQRF", " ", &(integer){$PRIV(__n_size)}, &c__1,
		&(integer){$PRIV(__n_size)}, &c__0, (ftnlen)6, (ftnlen)1);

		if ($jobvsl())
		{
			integer i__1 = maxwrk;
			integer i__2 = $SIZE(n) + $SIZE(n) * ilaenv_(&c__1, "ZUNGQR"
		    		, " ", &(integer){$PRIV(__n_size)}, &c__1, &(integer){$PRIV(__n_size)}, &c_n1, (ftnlen)6, (ftnlen)1);
	    		maxwrk = max(i__1,i__2);
			pjobvsl = \'V\';
		}
		lwork = max(maxwrk,minwrk);

		{
			$GENERIC() *work = ($GENERIC() *)malloc( 2 * lwork *  sizeof($GENERIC()));

		$TFD(c,z)ggesx_(
		&pjobvsl,
		&pjobvsr,
		&psort,
		$TFD(f,d)gselect_wrapper,
		&psens,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(sdim),
		$P(alpha),
		$P(beta),
		$P(VSL),
		&(integer){$PRIV(__m_size)},
		$P(VSR),
		&(integer){$PRIV(__p_size)},
		$P(rconde),
		$P(rcondv),
		work,
		&lwork,
		rwork,
		iwork,
		&liwork,
		bwork,
		$P(info));
		free(work);
		}
		if ($sort())
			free (bwork);
//		if ($sense())
			free(iwork);
		free(rwork);
',
Doc=>'

=for ref

Complex version of ggeesx

    select_func:
            If sort = 1, select_func is used to select eigenvalues to sort
            to the top left of the Schur form.
            If sort = 0, select_func is not referenced.
            An eigenvalue w = w/beta is selected if
            select_func(PDL::Complex(w), PDL::Complex(beta)) is true; 
            Note that a selected complex eigenvalue may no longer
            satisfy select_func(PDL::Complex(w),PDL::Complex(beta)) = 1 after ordering, since
            ordering may change the value of complex eigenvalues
            (especially if the eigenvalue is ill-conditioned); in this
            case info is set to N+3.


');


pp_defc("heev",
       _decl => <<'EOF',
		extern int $TFD(c,z)heev_(char *jobz, char *uplo, integer *n, $GENERIC() *a,
	 	integer *lda, $GENERIC() *w, $GENERIC() *work, integer *lwork, $GENERIC() *rwork,
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  int jobz(); int uplo(); [o,phys]w(n); int [o,phys]info()',
	Code => generate_code '
		char jz = \'N\';
		char puplo = \'U\';
		integer lwork = -1;
		$GENERIC() *rwork;
		$GENERIC() tmp_work[2];
		rwork = ($GENERIC() *) malloc ((3*$PRIV(__n_size)-2) * sizeof($GENERIC()));
		if ($jobz())
			jz = \'V\';
		if ($uplo())
			puplo = \'L\';

		$TFD(cheev_,zheev_)(
		&jz,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(w),
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(cheev_,zheev_)(
		&jz,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(w),
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);
',
Doc=>'

=for ref

Complex version of syev for Hermitian matrix

');

pp_defc("heevd",
       _decl => <<'EOF',
		extern int $TFD(c,z)heevd_(char *jobz, char *uplo, integer *n, $GENERIC() *a,
	 	integer *lda, $GENERIC() *w, $GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *lrwork,
		integer *iwork, integer *liwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  int jobz(); int uplo(); [o,phys]w(n); int [o,phys]info()',
	Code => generate_code '
		char jz = \'N\';
		char puplo = \'U\';
		integer lwork = -1;
		integer lrwork, liwork;
		integer tmpi_work;
		integer *iwork;
		$GENERIC() tmp_work[2];
		$GENERIC() tmpr_work;

		if ($jobz())
			jz = \'V\';
		if ($uplo())
			puplo = \'L\';


		$TFD(cheevd_,zheevd_)(
		&jz,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(w),
		&tmp_work[0],
		&lwork,
		&tmpr_work,
		&lwork,
		&tmpi_work,
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		lrwork = (integer )tmpr_work;
		liwork = (integer )tmpi_work;

		iwork = (integer *)malloc(liwork *  sizeof(integer));

		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$GENERIC() *rwork = ($GENERIC() *)malloc(lrwork *  sizeof($GENERIC()));
		$TFD(cheevd_,zheevd_)(
		&jz,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(w),
		work,
		&lwork,
		rwork,
		&lrwork,
		iwork,
		&liwork,
		$P(info));
		free(rwork);
		free(work);
		}

		free(iwork);
',
Doc=>'

=for ref

Complex version of syevd for Hermitian matrix

');


pp_defc("heevx",
       _decl => <<'EOF',
		extern int $TFD(c,z)heevx_(char *jobz, char *range, char *uplo, integer *n,
		$GENERIC() *a, integer *lda, $GENERIC() *vl, $GENERIC() *vu, integer *
		il, integer *iu, $GENERIC() *abstol, integer *m, $GENERIC() *w,
		$GENERIC() *z__, integer *ldz, $GENERIC() *work, integer *lwork,
		$GENERIC() *rwork, integer *iwork, integer *ifail, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n);  int jobz(); int range(); int uplo(); [phys]vl(); [phys]vu(); int [phys]il(); int [phys]iu(); [phys]abstol(); int [o,phys]m(); [o,phys]w(n); [o,phys]z(2,p,q);int [o,phys]ifail(r); int [o,phys]info()',
	Code => generate_code '
		char jz = \'N\';
		char puplo = \'U\';
		char prange = \'A\';
		integer lwork = -1;
		integer *iwork;

		$GENERIC() *rwork;
		$GENERIC() tmp_work[2];
		rwork = ($GENERIC() *)malloc(7 * $SIZE(n) * sizeof($GENERIC()));

		if ($jobz())
			jz = \'V\';
		if ($uplo())
			puplo = \'L\';

		switch ($range())
		{
			case 1: prange = \'V\';
				break;
			case 2: prange = \'I\';
				break;
			default: prange = \'A\';
		}

		iwork = (integer *)malloc(5 * $SIZE (n) * sizeof(integer));

		$TFD(cheevx_,zheevx_)(
		&jz,
		&prange,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(vl),
		$P(vu),
		$P(il),
		$P(iu),
		$P(abstol),
		$P(m),
		$P(w),
		$P(z),
		&(integer){$PRIV(__p_size)},
		&tmp_work[0],
		&lwork,
		rwork,
		iwork,
		$P(ifail),
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2* lwork *  sizeof($GENERIC()));
		$TFD(cheevx_,zheevx_)(
		&jz,
		&prange,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(vl),
		$P(vu),
		$P(il),
		$P(iu),
		$P(abstol),
		$P(m),
		$P(w),
		$P(z),
		&(integer){$PRIV(__p_size)},
		work,
		&lwork,
		rwork,
		iwork,
		$P(ifail),
		$P(info));
		free(work);
		}
		free(iwork);
		free(rwork);
',
Doc=>'

=for ref

Complex version of syevx for Hermitian matrix

');

pp_defc("heevr",
       _decl => <<'EOF',
		extern int $TFD(c,z)heevr_(char *jobz, char *range, char *uplo, integer *n,
		$GENERIC() *a, integer *lda, $GENERIC() *vl, $GENERIC() *vu, integer *
		il, integer *iu, $GENERIC() *abstol, integer *m, $GENERIC() *w,
		$GENERIC() *z__, integer *ldz, integer *isuppz, $GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *lrwork,
		integer *iwork, integer *liwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n);  int jobz(); int range(); int uplo(); [phys]vl(); [phys]vu(); int [phys]il(); int [phys]iu(); [phys]abstol(); int [o,phys]m(); [o,phys]w(n); [o,phys]z(2,p,q);int [o,phys]isuppz(r); int [o,phys]info()',
	Code => generate_code '
		char jz = \'N\';
		char puplo = \'U\';
		char prange = \'A\';
		integer lwork = -1;
		integer liwork,lrwork;
		integer tmpi_work;

		$GENERIC() tmp_work[2];
		$GENERIC() tmpr_work;

		if ($jobz())
			jz = \'V\';
		if ($uplo())
			puplo = \'L\';

		switch ($range())
		{
			case 1: prange = \'V\';
				break;
			case 2: prange = \'I\';
				break;
			default: prange = \'A\';
		}

		$TFD(cheevr_,zheevr_)(
		&jz,
		&prange,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(vl),
		$P(vu),
		$P(il),
		$P(iu),
		$P(abstol),
		$P(m),
		$P(w),
		$P(z),
		&(integer){$PRIV(__p_size)},
		$P(isuppz),
		&tmp_work[0],
		&lwork,
		&tmpr_work,
		&lwork,
		&tmpi_work,
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		lrwork = (integer )tmpr_work;
		liwork = (integer )tmpi_work;
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2* lwork *  sizeof($GENERIC()));
		$GENERIC() *rwork = ($GENERIC() *)malloc(lrwork *  sizeof($GENERIC()));
		integer *iwork = (integer *)malloc(liwork *  sizeof(integer));
		$TFD(cheevr_,zheevr_)(
		&jz,
		&prange,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(vl),
		$P(vu),
		$P(il),
		$P(iu),
		$P(abstol),
		$P(m),
		$P(w),
		$P(z),
		&(integer){$PRIV(__p_size)},
		$P(isuppz),
		work,
		&lwork,
		rwork,
		&lrwork,
		iwork,
		&liwork,
		$P(info));
		free(work);
		free(iwork);
		free(rwork);
		}

',
Doc=>'

=for ref

Complex version of syevr for Hermitian matrix

');

pp_defc("hegv",
       _decl => <<'EOF',
		extern int $TFD(c,z)hegv_(integer *itype, char *jobz, char *uplo, integer *
		n, $GENERIC() *a, integer *lda, $GENERIC() *b, integer *ldb,
		$GENERIC() *w, $GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);int [phys]itype();int jobz(); int uplo();[io,phys]B(2,n,n);[o,phys]w(n); int [o,phys]info()',
	Code => generate_code '
		char jz = \'N\';
		char puplo = \'U\';
		integer lwork = -1;

		$GENERIC() tmp_work[2], *rwork;
		rwork = ($GENERIC() *) malloc( (3 * $SIZE(n) - 2 ) *  sizeof($GENERIC()));

		if ($jobz())
			jz = \'V\';
		if ($uplo())
			puplo = \'L\';


		$TFD(chegv_,zhegv_)(
		$P(itype),
		&jz,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(w),
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(chegv_,zhegv_)(
		$P(itype),
		&jz,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(w),
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);
',
Doc=>'

=for ref

Complex version of sygv for Hermitian matrix

');


pp_defc("hegvd",
       _decl => <<'EOF',
		extern int $TFD(c,z)hegvd_(integer *itype, char *jobz, char *uplo, integer *
		n, $GENERIC() *a, integer *lda, $GENERIC() *b, integer *ldb,
		$GENERIC() *w, $GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *lrwork,
		integer *iwork,	integer *liwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);int [phys]itype();int jobz(); int uplo();[io,phys]B(2,n,n);[o,phys]w(n); int [o,phys]info()',
	Code => generate_code '
		char jz = \'N\';
		char puplo = \'U\';
		integer lwork = -1;
		integer liwork = -1;
		integer lrwork = -1;
		integer *iwork;
		integer tmp_iwork;

		$GENERIC() tmp_work[2], tmp_rwork;

		if ($jobz())
			jz = \'V\';
		if ($uplo())
			puplo = \'L\';


		$TFD(chegvd_,zhegvd_)(
		$P(itype),
		&jz,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(w),
		&tmp_work[0],
		&lwork,
		&tmp_rwork,	
		&lrwork,	
		&tmp_iwork,
		&liwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		lrwork = (integer )tmp_rwork;
		liwork = (integer )tmp_iwork;
		iwork = (integer *)malloc(liwork *  sizeof(integer));

		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$GENERIC() *rwork = ($GENERIC() *)malloc(lrwork *  sizeof($GENERIC()));
		$TFD(chegvd_,zhegvd_)(
		$P(itype),
		&jz,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(w),
		work,
		&lwork,
		rwork,
		&lrwork,
		iwork,
		&liwork,
		$P(info));
		free(work);
		free(rwork);
		}
		free(iwork);
',
Doc=>'

=for ref

Complex version of sygvd for Hermitian matrix

');


pp_defc("hegvx",
       _decl => <<'EOF',
		extern int $TFD(c,z)hegvx_(integer *itype, char *jobz, char *range, char *
		uplo, integer *n, $GENERIC() *a, integer *lda, $GENERIC() *b, integer
		*ldb, $GENERIC() *vl, $GENERIC() *vu, integer *il, integer *iu,
		$GENERIC() *abstol, integer *m, $GENERIC() *w, $GENERIC() *z__,
		integer *ldz, $GENERIC() *work, integer *lwork, $GENERIC() *rwork,
		integer *iwork, integer *ifail, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);int [phys]itype();int jobz();int range(); int uplo();[io,phys]B(2,n,n);[phys]vl();[phys]vu();int [phys]il();int [phys]iu();[phys]abstol();int [o,phys]m();[o,phys]w(n); [o,phys]Z(2,p,q);int [o,phys]ifail(r);int [o,phys]info()',
	Code => generate_code '
		char jz = \'N\';
		char puplo = \'U\';
		char prange;
		integer lwork = -1;
		integer *iwork;

		$GENERIC() tmp_work[2], *rwork;
		rwork = ($GENERIC() *)malloc(7 * $SIZE(n) *  sizeof($GENERIC()));

		if ($jobz())
			jz = \'V\';
		if ($uplo())
			puplo = \'L\';

		switch ($range())
		{
			case 1: prange = \'V\';
				break;
			case 2: prange = \'I\';
				break;
			default: prange = \'A\';
		}

		iwork = (integer *)malloc((5 * $SIZE(n)) *  sizeof(integer));

		$TFD(chegvx_,zhegvx_)(
		$P(itype),
		&jz,
		&prange,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(vl),
		$P(vu),
		$P(il),
		$P(iu),
		$P(abstol),
		$P(m),
		$P(w),
		$P(Z),
		&(integer){$PRIV(__p_size)},
		&tmp_work[0],
		&lwork,
		rwork,
		iwork,
		$P(ifail),
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc( 2 * lwork *  sizeof($GENERIC()));
		$TFD(chegvx_,zhegvx_)(
		$P(itype),
		&jz,
		&prange,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(vl),
		$P(vu),
		$P(il),
		$P(iu),
		$P(abstol),
		$P(m),
		$P(w),
		$P(Z),
		&(integer){$PRIV(__p_size)},
		work,
		&lwork,
		rwork,
		iwork,
		$P(ifail),
		$P(info));
		free(work);
		}
		free(iwork);
		free(rwork);
',
Doc=>'

=for ref

Complex version of sygvx for Hermitian matrix

');


pp_defc("gesv",
       _decl => <<'EOF',
		extern int $TFD(c,z)gesv_(integer *n, integer *nrhs, $GENERIC() *a, integer
		*lda, integer *ipiv, $GENERIC() *b, integer *ldb, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  [io,phys]B(2,n,m); int [o,phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
		$TFD(cgesv_,zgesv_)(
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(info));
');
pp_defc("gesvx",
       _decl => <<'EOF',
		extern int $TFD(c,z)gesvx_(char *fact, char *trans, integer *n, integer *
		nrhs, $GENERIC() *a, integer *lda, $GENERIC() *af, integer *ldaf,
		integer *ipiv, char *equed, $GENERIC() *r__, $GENERIC() *c__,
		$GENERIC() *b, integer *ldb, $GENERIC() *x, integer *ldx, $GENERIC() *
		rcond, $GENERIC() *ferr, $GENERIC() *berr, $GENERIC() *work, $GENERIC() *
		rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int trans(); int fact(); [io,phys]B(2,n,m); [io,phys]af(2,n,n); int [io,phys]ipiv(n); int [io]equed(); [io,phys]r(n); [io,phys]c(n); [o,phys]X(2,n,m); [o,phys]rcond(); [o,phys]ferr(m); [o,phys]berr(m); [o,phys]rpvgrw(); int [o,phys]info()',
	Code => generate_code '
		char ptrans, pfact, pequed;

		$GENERIC() *work = ($GENERIC() *) malloc(4 * $PRIV(__n_size) *  sizeof($GENERIC()));
		$GENERIC() *rwork  = ($GENERIC() *) malloc(4 * $PRIV(__n_size) *  sizeof($GENERIC()));

		switch ($trans())
		{
			case 1: ptrans = \'T\';
				break;
			case 2: ptrans = \'C\';
				break;
			default: ptrans = \'N\';
		}
		switch ($fact())
		{
			case 1: pfact = \'N\';
				break;
			case 2: pfact = \'E\';
				break;
			default: pfact = \'F\';
		}
		switch ($equed())
		{
			case 1:   pequed = \'R\';
				  break;
			case 2:   pequed = \'C\';
				  break;
			case 3:   pequed = \'B\';
				  break;
			default:  pequed = \'N\';
		}


		$TFD(cgesvx_,zgesvx_)(
		&pfact,
		&ptrans,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(af),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		&pequed,
		$P(r),
		$P(c),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(X),
		&(integer){$PRIV(__n_size)},
		$P(rcond),
		$P(ferr),
		$P(berr),
		work,
		rwork,
		$P(info));

		free(work);
		free(rwork);

		switch (pequed)
		{
			case \'R\': $equed() = 1;
				  break;
			case \'C\': $equed() = 2;
				  break;
			case \'B\': $equed() = 3;
				  break;
			default: $equed()= 0;
		}
		$rpvgrw() = rwork[0];
',
Doc => '

=for ref

Complex version of gesvx.

    trans:  Specifies the form of the system of equations:
            = 0:  A * X = B     (No transpose)   
            = 1:  A\' * X = B  (Transpose)   
            = 2:  A**H * X = B  (Conjugate transpose)  

');

pp_defc("sysv",
       _decl => <<'EOF',
		extern int $TFD(c,z)sysv_(char *uplo, integer *n, integer *nrhs, $GENERIC()
		*a, integer *lda, integer *ipiv, $GENERIC() *b, integer *ldb,
		$GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  int uplo(); [io,phys]B(2,n,m); int [o,phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
		char puplo = \'U\';
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		if ($uplo())
			puplo = \'L\';

		$TFD(csysv_,zsysv_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
                &tmp_work[0],
		&lwork,
		$P(info));


		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(csysv_,zsysv_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
                work,
		&lwork,
		$P(info));


             }
');

pp_defc("sysvx",
       _decl => <<'EOF',
		extern int $TFD(c,z)sysvx_(char *fact, char *uplo, integer *n, integer *
		nrhs, $GENERIC() *a, integer *lda, $GENERIC() *af, integer *ldaf,
		integer *ipiv, $GENERIC() *b, integer *ldb, $GENERIC() *x, integer *
		ldx, $GENERIC() *rcond, $GENERIC() *ferr, $GENERIC() *berr,
		$GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo(); int fact(); [phys]B(2,n,m); [io,phys]af(2,n,n); int [io,phys]ipiv(n); [o,phys]X(2,n,m); [o,phys]rcond(); [o,phys]ferr(m); [o,phys]berr(m); int [o,phys]info()',
	Code => generate_code '
		char pfact = \'N\';
		char puplo = \'U\';
		integer lwork = -1;

		$GENERIC() *rwork = ($GENERIC() * )malloc ($PRIV(__n_size)* sizeof ($GENERIC()));
		$GENERIC() tmp_work[2];

		if($fact())
			pfact = \'F\';

		if ($uplo())
			puplo = \'L\';


		$TFD(csysvx_,zsysvx_)(
		&pfact,
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(af),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(X),
		&(integer){$PRIV(__n_size)},
		$P(rcond),
		$P(ferr),
		$P(berr),
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));

		$TFD(csysvx_,zsysvx_)(
		&pfact,
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(af),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(X),
		&(integer){$PRIV(__n_size)},
		$P(rcond),
		$P(ferr),
		$P(berr),
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);

');

pp_defc("hesv",
       _decl => <<'EOF',
		extern int $TFD(c,z)hesv_(char *uplo, integer *n, integer *nrhs, $GENERIC()
		*a, integer *lda, integer *ipiv, $GENERIC() *b, integer *ldb,
		$GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  int uplo(); [io,phys]B(2,n,m); int [o,phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
		char puplo = \'U\';
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		if ($uplo())
			puplo = \'L\';

		$TFD(chesv_,zhesv_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
                &tmp_work[0],
		&lwork,
		$P(info));


		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(chesv_,zhesv_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
                work,
		&lwork,
		$P(info));


             }
',
Doc=>'

=for ref

Complex version of sysv for Hermitian matrix

');

pp_defc("hesvx",
       _decl => <<'EOF',
		extern int $TFD(c,z)hesvx_(char *fact, char *uplo, integer *n, integer *
		nrhs, $GENERIC() *a, integer *lda, $GENERIC() *af, integer *ldaf,
		integer *ipiv, $GENERIC() *b, integer *ldb, $GENERIC() *x, integer *
		ldx, $GENERIC() *rcond, $GENERIC() *ferr, $GENERIC() *berr,
		$GENERIC() *work, integer *lwork, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo(); int fact(); [phys]B(2,n,m); [io,phys]af(2,n,n); int [io,phys]ipiv(n); [o,phys]X(2,n,m); [o,phys]rcond(); [o,phys]ferr(m); [o,phys]berr(m); int [o,phys]info()',
	Code => generate_code '
		char pfact = \'N\';
		char puplo = \'U\';
		integer lwork = -1;

		$GENERIC() *rwork = ($GENERIC() * )malloc ($PRIV(__n_size)* sizeof ($GENERIC()));
		$GENERIC() tmp_work[2];

		if($fact())
			pfact = \'F\';

		if ($uplo())
			puplo = \'L\';


		$TFD(chesvx_,zhesvx_)(
		&pfact,
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(af),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(X),
		&(integer){$PRIV(__n_size)},
		$P(rcond),
		$P(ferr),
		$P(berr),
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));

		$TFD(chesvx_,zhesvx_)(
		&pfact,
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(af),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(X),
		&(integer){$PRIV(__n_size)},
		$P(rcond),
		$P(ferr),
		$P(berr),
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);

',
Doc=>'

=for ref

Complex version of sysvx for Hermitian matrix

');


pp_defc("posv",
       _decl => <<'EOF',
		extern int $TFD(c,z)posv_(char *uplo, integer *n, integer *nrhs, $GENERIC()
		*a, integer *lda, $GENERIC() *b, integer *ldb, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n);  int uplo(); [io,phys]B(2,n,m); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if ($uplo())
			puplo = \'L\';

		$TFD(cposv_,zposv_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(info));
',
Doc=>'

=for ref

Complex version of posv for Hermitian positive definite matrix

');
pp_defc("posvx",
       _decl => <<'EOF',
		extern int $TFD(c,z)posvx_(char *fact, char *uplo, integer *n, integer *
		nrhs, $GENERIC() *a, integer *lda, $GENERIC() *af, integer *ldaf,
		char *equed, $GENERIC() *s, $GENERIC() *b, integer *ldb, $GENERIC() *
		x, integer *ldx, $GENERIC() *rcond, $GENERIC() *ferr, $GENERIC() *
		berr, $GENERIC() *work, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int fact(); [io,phys]B(2,n,m); [io,phys]af(2,n,n); int [io]equed(); [io,phys]s(n); [o,phys]X(2,n,m); [o,phys]rcond(); [o,phys]ferr(m); [o,phys]berr(m); int [o,phys]info()',
	Code => generate_code '
		char pfact;
		char pequed = \'N\';
		char puplo = \'U\';

		$GENERIC() *work, *rwork;

		switch ($fact())
		{
			case 1: pfact = \'N\';
				break;
			case 2: pfact = \'E\';
				break;
			default: pfact = \'F\';
		}
		if ($equed())
			pequed = \'Y\';
		if ($uplo())
			puplo = \'L\';

		work = ($GENERIC() *) malloc(4 * $PRIV(__n_size) *  sizeof($GENERIC()));
		rwork = ($GENERIC() *) malloc(2 * $PRIV(__n_size) *  sizeof($GENERIC()));

		$TFD(cposvx_,zposvx_)(
		&pfact,
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(af),
		&(integer){$PRIV(__n_size)},
		&pequed,
		$P(s),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(X),
		&(integer){$PRIV(__n_size)},
		$P(rcond),
		$P(ferr),
		$P(berr),
		work,
		rwork,
		$P(info));

		free(work);
		free(rwork);

		switch (pequed)
		{
			case \'Y\': $equed() = 1;
				  break;
			default: $equed()= 0;
		}

',
Doc => '

=for ref

Complex version of posvx for Hermitian positive definite matrix

');

pp_defc("gels",
       _decl => <<'EOF',
		extern int $TFD(c,z)gels_(char *trans, integer *m, integer *n, integer *
		nrhs, $GENERIC() *a, integer *lda, $GENERIC() *b, integer *ldb,
		$GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); int trans(); [io,phys]B(2,p,q);int [o,phys]info()',
	Code => generate_code '
		char ptrans = \'N\';
		integer lwork = -1;

		$GENERIC() tmp_work[2];

		if($trans())
			ptrans = \'C\';

		$TFD(cgels_,zgels_)(
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__q_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));

		$TFD(cgels_,zgels_)(
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__q_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
Doc=>'

=for ref

Solves overdetermined or underdetermined complex linear systems   
involving an M-by-N matrix A, or its conjugate-transpose.
Complex version of gels.

    trans:  = 0: the linear system involves A;
            = 1: the linear system involves A**H.

');

pp_defc("gelsy",
       _decl => <<'EOF',
		extern int $TFD(c,z)gelsy_(integer *m, integer *n, integer *nrhs,
		$GENERIC() *a, integer *lda, $GENERIC() *b, integer *ldb, integer *
		jpvt, $GENERIC() *rcond, integer *rank, $GENERIC() *work, integer *
		lwork, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [io,phys]B(2,p,q); [phys]rcond(); int [io,phys]jpvt(n); int [o,phys]rank();int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;

		$GENERIC() tmp_work[2];
		$GENERIC() *rwork;

		rwork = ($GENERIC() *)malloc(2 * $PRIV(__m_size) * sizeof($GENERIC()));

		$TFD(cgelsy_,zgelsy_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__q_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(jpvt),
		$P(rcond),
		$P(rank),
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));

		$TFD(cgelsy_,zgelsy_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__q_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(jpvt),
		$P(rcond),
		$P(rank),
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);

');


pp_defc("gelss",
       _decl => <<'EOF',
		extern int $TFD(c,z)gelss_(integer *m, integer *n, integer *nrhs,
		$GENERIC() *a, integer *lda, $GENERIC() *b, integer *ldb, $GENERIC() *s,
		$GENERIC() *rcond, integer *rank, $GENERIC() *work, integer *
		lwork, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [io,phys]B(2,p,q); [phys]rcond(); [o,phys]s(r); int [o,phys]rank();int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		integer lrwork;

		$GENERIC() tmp_work[2];
		$GENERIC() *rwork;

		lrwork = min($PRIV(__m_size), $PRIV(__n_size));

			rwork = ($GENERIC() *)malloc(5 * lrwork *  sizeof($GENERIC()));

		$TFD(cgelss_,zgelss_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__q_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(s),
		$P(rcond),
		$P(rank),
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));

		$TFD(cgelss_,zgelss_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__q_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(s),
		$P(rcond),
		$P(rank),
		work,
		&lwork,
		rwork,
		$P(info));
		free(work);
		}
		free(rwork);

');

pp_defc("gelsd",
       _decl => <<'EOF',
		extern int $TFD(c,z)gelsd_(integer *m, integer *n, integer *nrhs,
		$GENERIC() *a, integer *lda, $GENERIC() *b, integer *ldb, $GENERIC() *s,
		$GENERIC() *rcond, integer *rank, $GENERIC() *work, integer *
		lwork,  $GENERIC() *rwork, integer *iwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [io,phys]B(2,p,q); [phys]rcond(); [o,phys]s(r); int [o,phys]rank();int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		integer smlsiz, size_i, nlvl, *iwork;
		integer minmn = min( $SIZE(m), $SIZE(n) );

		$GENERIC() *rwork;
		$GENERIC() tmp_work[2];

		minmn = max(1,minmn);

		smlsiz = ilaenv_(&c_nine, "CGELSD", " ", &c_zero, &c_zero, &c_zero, &c_zero, (ftnlen)6, (ftnlen)1);
		size_i = (integer) (log(($GENERIC()) minmn / ($GENERIC()) (smlsiz + 1)) /log(2.)) + 1;
		if ($PRIV(__m_size) >=  $PRIV(__n_size)){
			rwork = ($GENERIC() *) malloc ((10*$PRIV(__n_size) + 2 * $PRIV(__n_size) * smlsiz + 8 * $PRIV(__n_size) * size_i + 3 * smlsiz * $PRIV(__q_size) + pow((smlsiz+1),2))  *  sizeof($GENERIC()));
		}
		else{
			rwork = ($GENERIC() *) malloc ((10*$PRIV(__m_size) + 2 * $PRIV(__m_size) * smlsiz + 8 * $PRIV(__m_size) * size_i + 3 * smlsiz * $PRIV(__q_size) + pow((smlsiz+1),2))  *  sizeof($GENERIC()));
		}
		nlvl = max(size_i, 0);
		iwork = (integer *)malloc((3 * minmn * nlvl + 11 * minmn) *  sizeof(integer));


		$TFD(cgelsd_,zgelsd_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__q_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(s),
		$P(rcond),
		$P(rank),
		&tmp_work[0],
		&lwork,
		rwork,
		iwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));

		$TFD(cgelsd_,zgelsd_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__q_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(s),
		$P(rcond),
		$P(rank),
		work,
		&lwork,
		rwork,
		iwork,
		$P(info));
		free(work);
		}
		free (iwork);
		free (rwork);
');


pp_defc("gglse",
       _decl => <<'EOF',
		extern int $TFD(c,z)gglse_(integer *m, integer *n, integer *p, $GENERIC() *
		a, integer *lda, $GENERIC() *b, integer *ldb, $GENERIC() *c__,
		$GENERIC() *d__, $GENERIC() *x, $GENERIC() *work, integer *lwork,
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,m,n); [phys]B(2,p,n);[io,phys]c(2,m);[phys]d(2,p);[o,phys]x(2,n);int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;

		$GENERIC() tmp_work[2];

		$TFD(cgglse_,zgglse_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__p_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(c),
		$P(d),
		$P(x),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cgglse_,zgglse_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__p_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(c),
		$P(d),
		$P(x),
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

pp_defc("ggglm",
       _decl => <<'EOF',
		extern int $TFD(c,z)ggglm_(integer *n, integer *m, integer *p, $GENERIC() *
		a, integer *lda, $GENERIC() *b, integer *ldb, $GENERIC() *d__,
		$GENERIC() *x, $GENERIC() *y, $GENERIC() *work, integer *lwork,
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,m); [phys]B(2,n,p);[phys]d(2,n);[o,phys]x(2,m);[o,phys]y(2,p);int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;

		$GENERIC() tmp_work[2];

		$TFD(cggglm_,zggglm_)(
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__p_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(d),
		$P(x),
		$P(y),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cggglm_,zggglm_)(
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__p_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(d),
		$P(x),
		$P(y),
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

################################################################################
#
#		COMPUTATIONAL LEVEL ROUTINES
#
################################################################################
# TODO IPIV = min(m,n)
pp_defc("getrf",
       _decl => <<'EOF',
		extern int $TFD(c,z)getrf_(integer *m, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, integer *info);
EOF
       HandleBad => 0,
	RedoDimsCode => '$SIZE(p) =  $PDL(A)->ndims > 2 ? min($PDL(A)->dims[1], $PDL(A)->dims[2]) : 1;',
	Pars => '[io,phys]A(2,m,n); int [o,phys]ipiv(p); int [o,phys]info()',
	Code => generate_code '
		$TFD(cgetrf_,zgetrf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(ipiv),
		$P(info));
');

pp_defc("getf2",
       _decl => <<'EOF',
		extern int $TFD(c,z)getf2_(integer *m, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, integer *info);
EOF
       HandleBad => 0,
	RedoDimsCode => '$SIZE(p) =  $PDL(A)->ndims > 2 ? min($PDL(A)->dims[1], $PDL(A)->dims[2]) : 1;',
	Pars => '[io,phys]A(2,m,n); int [o,phys]ipiv(p); int [o,phys]info()',
	Code => generate_code '
		$TFD(cgetf2_,zgetf2_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(ipiv),
		$P(info));
');

pp_defc("sytrf",
       _decl => <<'EOF',
		extern int $TFD(c,z)sytrf_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [o,phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
	     integer lwork = -1;
		$GENERIC() tmp_work[2];
		if ($uplo())
			puplo = \'L\';

		$TFD(csytrf_,zsytrf_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(csytrf_,zsytrf_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		work,
		&lwork,
		$P(info));
		free (work);
             	}
');

pp_defc("sytf2",
       _decl => <<'EOF',
		extern int $TFD(c,z)sytf2_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [o,phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if ($uplo())
			puplo = \'L\';

		$TFD(csytf2_,zsytf2_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(info));
');

pp_defc("chetrf",
       _decl => <<'EOF',
		extern int $TFD(c,z)hetrf_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [o,phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
	     integer lwork = -1;
	     integer blocksiz;
		$GENERIC() *work;
		blocksiz = ilaenv_(&c_nine, "CHETRF", " ", &c_zero, &c_zero, &c_zero, &c_zero, (ftnlen)6, (ftnlen)1);

		if ($uplo())
			puplo = \'L\';

		lwork = (integer ) $PRIV(__n_size) * blocksiz;
		work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(chetrf_,zhetrf_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		work,
		&lwork,
		$P(info));
		free (work);
',
Doc=>'

=for ref

Complex version of sytrf for Hermitian matrix

');

pp_defc("hetf2",
       _decl => <<'EOF',
		extern int $TFD(c,z)hetf2_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [o,phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if ($uplo())
			puplo = \'L\';

		$TFD(chetf2_,zhetf2_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(info));
',
Doc=>'

=for ref

Complex version of sytf2 for Hermitian matrix

');

pp_defc("potrf",
       _decl => <<'EOF',
		extern int $TFD(c,z)potrf_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if ($uplo())
			puplo = \'L\';

		$TFD(cpotrf_,zpotrf_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(info));
',
Doc=>'

=for ref

Complex version of potrf for Hermitian positive definite matrix

');

pp_defc("potf2",
       _decl => <<'EOF',
		extern int $TFD(c,z)potf2_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if ($uplo())
			puplo = \'L\';

		$TFD(cpotf2_,zpotf2_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(info));
',
Doc => '

=for ref

Complex version of potf2 for Hermitian positive definite matrix

');

pp_defc("getri",
       _decl => <<'EOF',
		extern int $TFD(c,z)getri_(integer *n, $GENERIC() *a, integer *lda, integer
		*ipiv, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int [phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(cgetri_,zgetri_)(
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(cgetri_,zgetri_)(
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		work,
		&lwork,
		$P(info));
		free(work);
		}
');


pp_defc("sytri",
       _decl => <<'EOF',
		extern int $TFD(c,z)sytri_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, $GENERIC() *work, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		$GENERIC() *work = ($GENERIC() *)malloc(2*$PRIV(__n_size) *  sizeof($GENERIC()));
		if ($uplo())
			puplo = \'L\';

		$TFD(csytri_, zsytri_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		work,
		$P(info));
		free(work);
');

pp_defc("hetri",
       _decl => <<'EOF',
		extern int $TFD(c,z)hetri_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, $GENERIC() *work, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		$GENERIC() *work = ($GENERIC() *)malloc(2*$PRIV(__n_size) *  sizeof($GENERIC()));
		if ($uplo())
			puplo = \'L\';

		$TFD(chetri_, zhetri_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		work,
		$P(info));
		free(work);
',
Doc => '

=for ref

Complex version of sytri for Hermitian matrix

');

pp_defc("potri",
       _decl => <<'EOF',
		extern int $TFD(c,z)potri_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if ($uplo())
			puplo = \'L\';

		$TFD(cpotri_,zpotri_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(info));
');

pp_defc("trtri",
       _decl => <<'EOF',
		extern int $TFD(c,z)trtri_(char *uplo, char *diag, integer *n, $GENERIC() *a, integer *
		lda, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int diag(); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
             char pdiag = \'N\';
		if ($uplo())
			puplo = \'L\';
		if ($diag())
			pdiag = \'U\';

		$TFD(ctrtri_, ztrtri_)(
		&puplo,
		&pdiag,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(info));
');

pp_defc("trti2",
       _decl => <<'EOF',
		extern int $TFD(c,z)trti2_(char *uplo, char *diag, integer *n, $GENERIC() *a, integer *
		lda, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int uplo(); int diag(); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
             char pdiag = \'N\';
		if ($uplo())
			puplo = \'L\';
		if ($diag())
			pdiag = \'U\';

		$TFD(ctrti2_, ztrti2_)(
		&puplo,
		&pdiag,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(info));
');

pp_defc("getrs",
       _decl => <<'EOF',
		extern int $TFD(c,z)getrs_(char *trans, integer *n, integer *nrhs,
		$GENERIC() *a, integer *lda, integer *ipiv, $GENERIC() *b, integer *
		ldb, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int trans(); [io,phys]B(2,n,m); int [phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char transp = \'N\';
		if($trans() == 1)
			transp = \'T\';
		else if($trans() == 2)
			transp = \'C\';

		$TFD(cgetrs_,zgetrs_)(
		&transp,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(info));
',
	Doc=>'

=for ref

Complex version of getrs

    Arguments   
    =========   
	trans:   = 0:  No transpose;
            	 = 1:  Transpose; 
            	 = 2:  Conjugate transpose;

');

pp_defc("sytrs",
       _decl => <<'EOF',
		extern int $TFD(c,z)sytrs_(char *uplo, integer *n, integer *nrhs,
		$GENERIC() *a, integer *lda, integer *ipiv, $GENERIC() *b, integer *
		ldb, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo();[io,phys]B(2,n,m); int [phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if($uplo())
			puplo = \'L\';

		$TFD(csytrs_,zsytrs_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(info));
');


pp_defc("hetrs",
       _decl => <<'EOF',
		extern int $TFD(c,z)hetrs_(char *uplo, integer *n, integer *nrhs,
		$GENERIC() *a, integer *lda, integer *ipiv, $GENERIC() *b, integer *
		ldb, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo();[io,phys]B(2,n,m); int [phys]ipiv(n); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if($uplo())
			puplo = \'L\';

		$TFD(chetrs_,zhetrs_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(info));
',
Doc => '

=for ref

Complex version of sytrs for Hermitian matrix

');

pp_defc("potrs",
       _decl => <<'EOF',
		extern int $TFD(c,z)potrs_(char *uplo, integer *n, integer *nrhs,
		$GENERIC() *a, integer *lda, $GENERIC() *b, integer *ldb, integer *
		info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo(); [io,phys]B(2,n,m); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		if($uplo())
			puplo = \'L\';

		$TFD(cpotrs_,zpotrs_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(info));
',

Doc=>'

=for ref

Complex version of potrs for Hermitian positive definite matrix

');

pp_defc("trtrs",
       _decl => <<'EOF',
		extern int $TFD(c,z)trtrs_(char *uplo, char *trans, char *diag, 
		integer *n, integer *nrhs,
		$GENERIC() *a, integer *lda, $GENERIC() *b, integer *
		ldb, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo(); int trans(); int diag();[io,phys]B(2,n,m); int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
             char ptrans = \'N\';
             char pdiag = \'N\';
		if($uplo())
			puplo = \'L\';
		if($trans() == 1)
			ptrans = \'T\';
		else if($trans() == 2)
			ptrans = \'C\';
		if($diag())
			pdiag = \'U\';

		$TFD(ctrtrs_,ztrtrs_)(
		&puplo,
		&ptrans,
		&pdiag,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(info));
', 
	Doc=>'

=for ref

Complex version of trtrs

    Arguments   
    =========   
	trans:   = 0:  No transpose;
            	 = 1:  Transpose; 
            	 = 2:  Conjugate transpose;

');


pp_defc("latrs",
       _decl => <<'EOF',
		extern int $TFD(c,z)latrs_(char *uplo, char *trans, char *diag, char *
		normin, integer *n, $GENERIC() *a, integer *lda, $GENERIC() *x, 
		$GENERIC() *scale, $GENERIC() *cnorm, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo(); int trans(); int diag(); int normin();[io,phys]x(2,n); [o,phys]scale();[io,phys]cnorm(n);int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
             char ptrans = \'N\';
             char pdiag = \'N\';
             char pnormin = \'N\';

		if($uplo())
			puplo = \'L\';
		if($trans())
			ptrans = \'T\';
		else if($trans() == 2)
			ptrans = \'C\';
		if($diag())
			pdiag = \'U\';
		if($normin())
			pnormin = \'Y\';

		$TFD(clatrs_,zlatrs_)(
		&puplo,
		&ptrans,
		&pdiag,
		&pnormin,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(x),
		$P(scale),
		$P(cnorm),
		$P(info));
',
	Doc=>'

=for ref

Complex version of latrs

    Arguments   
    =========   
	trans:   = 0:  No transpose;
            	 = 1:  Transpose; 
            	 = 2:  Conjugate transpose;

');



pp_defc("gecon",
       _decl => <<'EOF',
		extern int $TFD(c,z)gecon_(char *norm, integer *n, $GENERIC() *a, integer *
		lda, $GENERIC() *anorm, $GENERIC() *rcond, $GENERIC() *work, $GENERIC() *
		rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int norm(); [phys]anorm(); [o,phys]rcond();int [o,phys]info()',
	Code => generate_code '
             char pnorm = \'I\';
		$GENERIC() *work = ($GENERIC() *) malloc(($PRIV(__n_size) * 4) *  sizeof($GENERIC()));
		$GENERIC() *rwork = ($GENERIC() *) malloc(($PRIV(__n_size) * 2)*  sizeof(integer));

		if($norm())
			pnorm = \'O\';

		$TFD(cgecon_,zgecon_)(
		&pnorm,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(anorm),
		$P(rcond),
		work,
		rwork,
		$P(info));
		free (work);
		free(rwork);

');

pp_defc("sycon",
       _decl => <<'EOF',
		extern int $TFD(c,z)sycon_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, $GENERIC() *anorm, $GENERIC() *rcond, $GENERIC() *
		work, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo(); int ipiv(n); [phys]anorm(); [o,phys]rcond();int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';

		$GENERIC() *work = ($GENERIC() *) malloc(($PRIV(__n_size) * 4) *  sizeof($GENERIC()));
		if($uplo())
			puplo = \'L\';

		$TFD(csycon_,zsycon_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(anorm),
		$P(rcond),
		work,
		$P(info));
		free (work);

');

pp_defc("hecon",
       _decl => <<'EOF',
		extern int $TFD(c,z)hecon_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, integer *ipiv, $GENERIC() *anorm, $GENERIC() *rcond, $GENERIC() *
		work, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo(); int ipiv(n); [phys]anorm(); [o,phys]rcond();int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';

		$GENERIC() *work = ($GENERIC() *) malloc(($PRIV(__n_size) * 4) *  sizeof($GENERIC()));

		if($uplo())
			puplo = \'L\';

		$TFD(checon_,zhecon_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ipiv),
		$P(anorm),
		$P(rcond),
		work,
		$P(info));
		free (work);

',
Doc => '

=for ref

Complex version of sycon for Hermitian matrix

');

pp_defc("pocon",
       _decl => <<'EOF',
		extern int $TFD(c,z)pocon_(char *uplo, integer *n, $GENERIC() *a, integer *
		lda, $GENERIC() *anorm, $GENERIC() *rcond, $GENERIC() *work, $GENERIC() *
		rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int uplo(); [phys]anorm(); [o,phys]rcond();int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
		$GENERIC() *work = ($GENERIC() *) malloc(($PRIV(__n_size) * 4) *  sizeof($GENERIC()));
		$GENERIC() *rwork = ($GENERIC() *) malloc($PRIV(__n_size) *  sizeof(integer));

		if($uplo())
			puplo = \'L\';

		$TFD(cpocon_, zpocon_)(
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(anorm),
		$P(rcond),
		work,
		rwork,
		$P(info));
		free (work);
		free(rwork);

',
Doc => '

=for ref

Complex version of pocon for Hermitian positive definite matrix

');

pp_defc("trcon",
       _decl => <<'EOF',
		extern int $TFD(c,z)trcon_(char *norm, char *uplo, char *diag,integer *n, $GENERIC() *a, integer *
		lda, $GENERIC() *rcond, $GENERIC() *work, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,n); int norm();int uplo();int diag(); [o,phys]rcond();int [o,phys]info()',
	Code => generate_code '
             char puplo = \'U\';
             char pdiag = \'N\';
             char pnorm = \'I\';
		$GENERIC() *work = ($GENERIC() *) malloc(($PRIV(__n_size) * 4) *  sizeof($GENERIC()));
		$GENERIC() *rwork = ($GENERIC() *) malloc($PRIV(__n_size) *  sizeof(integer));

		if($uplo())
			puplo = \'L\';
		if($diag())
			pdiag = \'U\';
		if($norm())
			pnorm = \'O\';

		$TFD(ctrcon_,ztrcon_)(
		&pnorm,
		&puplo,
		&pdiag,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(rcond),
		work,
		rwork,
		$P(info));
		free (work);
		free(rwork);

');

pp_defc("geqp3",
       _decl => <<'EOF',
		extern int $TFD(c,z)geqp3_(integer *m, integer *n, $GENERIC() *a, integer *
		lda, integer *jpvt, $GENERIC() *tau, $GENERIC() *work, integer *lwork,
		$GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); int [io,phys]jpvt(n); [o,phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2], *rwork;
		rwork = ($GENERIC() *) malloc ($PRIV(__n_size) * 2  * sizeof($GENERIC()));

		$TFD(cgeqp3_,zgeqp3_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(jpvt),
		$P(tau),
		&tmp_work[0],
		&lwork,
		rwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
				$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
			$TFD(cgeqp3_,zgeqp3_)(
			&(integer){$PRIV(__m_size)},
			&(integer){$PRIV(__n_size)},
			$P(A),
			&(integer){$PRIV(__m_size)},
			$P(jpvt),
			$P(tau),
			work,
			&lwork,
			rwork,
			$P(info));
			free(work);
		}
		free(rwork);
'
);


pp_defc("geqrf",
       _decl => <<'EOF',
		extern int $TFD(c,z)geqrf_(integer *m, integer *n, $GENERIC() *a, integer *
		lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork,
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(cgeqrf_,zgeqrf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cgeqrf_,zgeqrf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

pp_defc("ungqr",
       _decl => <<'EOF',
		extern int $TFD(c,z)ungqr_(integer *m, integer *n, integer *k, $GENERIC() *
		a, integer *lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork, 
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		$TFD(cungqr_, zungqr_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cungqr_,zungqr_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of orgqr

');


pp_defc("unmqr",
       _decl => <<'EOF',
		extern int $TFD(c,z)unmqr_(char *side, char *trans, integer *m, integer *n, 
		integer *k, $GENERIC() *a, integer *lda, $GENERIC() *tau, $GENERIC() *
		c__, integer *ldc, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,p,k); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info()',
	Code => generate_code '
		char ptrans = \'N\', pside = \'L\';
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		if($trans())
			ptrans = \'C\';
		if($side())
			pside = \'R\';

		$TFD(cunmqr_,zunmqr_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__p_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cunmqr_,zunmqr_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__p_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of ormqr. Here trans = 1 means conjugate transpose.

');

pp_defc("gelqf",
       _decl => <<'EOF',
		extern int $TFD(c,z)gelqf_(integer *m, integer *n, $GENERIC() *a, integer *
		lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(cgelqf_,zgelqf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cgelqf_,zgelqf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

pp_defc("unglq",
       _decl => <<'EOF',
		extern int $TFD(c,z)unglq_(integer *m, integer *n, integer *k, $GENERIC() *
		a, integer *lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork, 
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		$TFD(cunglq_,zunglq_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cunglq_,zunglq_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of orglq

');

pp_defc("unmlq",
       _decl => <<'EOF',
		extern int $TFD(c,z)unmlq_(char *side, char *trans, integer *m, integer *n, 
		integer *k, $GENERIC() *a, integer *lda, $GENERIC() *tau, $GENERIC() *
		c__, integer *ldc, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,k,p); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info()',
	Code => generate_code '
		char ptrans = \'N\', pside = \'L\';
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		if($trans())
			ptrans = \'C\';
		if($side())
			pside = \'R\';

		$TFD(cunmlq_,zunmlq_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__k_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cunmlq_,zunmlq_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__k_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of ormlq. Here trans = 1 means conjugate transpose.

');


pp_defc("geqlf",
       _decl => <<'EOF',
		extern int $TFD(c,z)geqlf_(integer *m, integer *n, $GENERIC() *a, integer *
		lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(cgeqlf_,zgeqlf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cgeqlf_,zgeqlf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

pp_defc("ungql",
       _decl => <<'EOF',
		extern int $TFD(c,z)ungql_(integer *m, integer *n, integer *k, $GENERIC() *
		a, integer *lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork, 
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(cungql_,zungql_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cungql_,zungql_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of orgql.

');

pp_defc("unmql",
       _decl => <<'EOF',
		extern int $TFD(c,z)unmql_(char *side, char *trans, integer *m, integer *n, 
		integer *k, $GENERIC() *a, integer *lda, $GENERIC() *tau, $GENERIC() *
		c__, integer *ldc, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,p,k); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info()',
	Code => generate_code '
		char ptrans = \'N\', pside = \'L\';
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		if($trans())
			ptrans = \'C\';
		if($side())
			pside = \'R\';

		$TFD(cunmql_,zunmql_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__p_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cunmql_,zunmql_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__p_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of ormql. Here trans = 1 means conjugate transpose.

');

pp_defc("gerqf",
       _decl => <<'EOF',
		extern int $TFD(c,z)gerqf_(integer *m, integer *n, $GENERIC() *a, integer *
		lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		$TFD(cgerqf_,zgerqf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cgerqf_,zgerqf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

pp_defc("ungrq",
       _decl => <<'EOF',
		extern int $TFD(c,z)ungrq_(integer *m, integer *n, integer *k, $GENERIC() *
		a, integer *lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork, 
		integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(cungrq_,zungrq_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cungrq_,zungrq_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of orgrq.

');

pp_defc("unmrq",
       _decl => <<'EOF',
		extern int $TFD(c,z)unmrq_(char *side, char *trans, integer *m, integer *n, 
		integer *k, $GENERIC() *a, integer *lda, $GENERIC() *tau, $GENERIC() *
		c__, integer *ldc, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,k,p); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info()',
	Code => generate_code '
		char ptrans = \'N\', pside = \'L\';
		integer lwork = -1;
		$GENERIC() tmp_work[2];
		if($trans())
			ptrans = \'C\';
		if($side())
			pside = \'R\';

		$TFD(cunmrq_,zunmrq_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__k_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cunmrq_,zunmrq_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		$P(A),
		&(integer){$PRIV(__k_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of ormrq. Here trans = 1 means conjugate transpose.

');

pp_defc("tzrzf",
       _decl => <<'EOF',
		extern int $TFD(c,z)tzrzf_(integer *m, integer *n, $GENERIC() *a, integer *
		lda, $GENERIC() *tau, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(ctzrzf_,ztzrzf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
			$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(ctzrzf_,ztzrzf_)(
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

pp_defc("unmrz",
       _decl => <<'EOF',
		extern int $TFD(c,z)unmrz_(char *side, char *trans, integer *m, integer *n, 
		integer *k, integer *l, $GENERIC() *a, integer *lda, $GENERIC() *tau, $GENERIC() *
		c__, integer *ldc, $GENERIC() *work, integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,k,p); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info()',
	Code => generate_code '
		char ptrans = \'N\', pside = \'L\';
		integer lwork = -1;
		integer kk =  $SIZE(p) - $SIZE(k);
		$GENERIC() tmp_work[2];
		if($trans())
			ptrans = \'C\';
		if($side())
			pside = \'R\';

		$TFD(cunmrz_,zunmrz_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		&kk,
		$P(A),
		&(integer){$PRIV(__k_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(cunmrz_,zunmrz_)(
		&pside,
		&ptrans,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__k_size)},
		&kk,
		$P(A),
		&(integer){$PRIV(__k_size)},
		$P(tau),
		$P(C),
		&(integer){$PRIV(__m_size)},
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
	Doc=>'

=for ref

Complex version of ormrz. Here trans = 1 means conjugate transpose.

');


pp_defc("gehrd",
       _decl => <<'EOF',
		extern int $TFD(c,z)gehrd_(integer *n, integer *ilo, integer *ihi, 
		$GENERIC() *a, integer *lda, $GENERIC() *tau, $GENERIC() *work, 
		integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int [phys]ilo();int [phys]ihi();[o,phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(cgehrd_,zgehrd_)(
		&(integer){$PRIV(__n_size)},
		$P(ilo),
		$P(ihi),
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(cgehrd_,zgehrd_)(
		&(integer){$PRIV(__n_size)},
		$P(ilo),
		$P(ihi),
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

pp_defc("unghr",
       _decl => <<'EOF',
		extern int $TFD(c,z)unghr_(integer *n, integer *ilo, integer *ihi, 
		$GENERIC() *a, integer *lda, $GENERIC() *tau, $GENERIC() *work, 
		integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int [phys]ilo();int [phys]ihi();[phys]tau(2,k); int [o,phys]info()',
	Code => generate_code '
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		$TFD(cunghr_,zunghr_)(
		&(integer){$PRIV(__n_size)},
		$P(ilo),
		$P(ihi),
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(tau),
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2*lwork *  sizeof($GENERIC()));
		$TFD(cunghr_,zunghr_)(
		&(integer){$PRIV(__n_size)},
		$P(ilo),
		$P(ihi),
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(tau),
		work,
		&lwork,
		$P(info));
		free(work);
		}

',
Doc=>'

=for ref

Complex version of orghr

');


pp_defc("hseqr",
       _decl => <<'EOF',
		extern int $TFD(c,z)hseqr_(char *job, char *compz, integer *n, integer *ilo,
	 	integer *ihi, $GENERIC() *h__, integer *ldh, $GENERIC() *w, 
		$GENERIC() *z__, integer *ldz, $GENERIC() *work, 
		integer *lwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]H(2,n,n); int job();int compz();int [phys]ilo();int [phys]ihi();[o,phys]w(2,n); [o,phys]Z(2,m,m); int [o,phys]info()',
	Code => generate_code '
		char pcompz;
		char pjob = \'E\';
		integer lwork = -1;
		$GENERIC() tmp_work[2];

		if($job())
			pjob = \'S\';

		switch ($compz())
		{
			case 1: pcompz = \'I\';
				break;
			case 2: pcompz = \'V\';
				break;
			default: pcompz = \'N\';
		}

		$TFD(chseqr_,zhseqr_)(
		&pjob,
		&pcompz,
		&(integer){$PRIV(__n_size)},
		$P(ilo),
		$P(ihi),
		$P(H),
		&(integer){$PRIV(__n_size)},
		$P(w),
		$P(Z),
		&(integer){$PRIV(__m_size)},
		&tmp_work[0],
		&lwork,
		$P(info));

		lwork = (integer )tmp_work[0];
		{
		$GENERIC() *work = ($GENERIC() *)malloc(2 * lwork *  sizeof($GENERIC()));
		$TFD(chseqr_,zhseqr_)(
		&pjob,
		&pcompz,
		&(integer){$PRIV(__n_size)},
		$P(ilo),
		$P(ihi),
		$P(H),
		&(integer){$PRIV(__n_size)},
		$P(w),
		$P(Z),
		&(integer){$PRIV(__m_size)},
		work,
		&lwork,
		$P(info));
		free(work);
		}

');

pp_defc("trevc",
       _decl => <<'EOF',
		extern int $TFD(c,z)trevc_(char *side, char *howmny, logical *select, 
		integer *n, $GENERIC() *t, integer *ldt, $GENERIC() *vl, integer *
		ldvl, $GENERIC() *vr, integer *ldvr, integer *mm, integer *m, 
		$GENERIC() *work, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]T(2,n,n); int side();int howmny();int [phys]select(q);[io,phys]VL(2,m,r); [io,phys]VR(2,p,s);int [o,phys]m(); int [o,phys]info()',
	Code => generate_code '
		char pside,phowmny;
		integer mm = 0;
		$GENERIC() *work = ($GENERIC() *) malloc(5 * $SIZE(n) *sizeof($GENERIC()));

		switch ($howmny())
		{
			case 1: phowmny = \'B\';
				break;
			case 2: phowmny = \'S\';
				break;
			default: phowmny = \'A\';
		}

		switch ($side())
		{
			case 1: pside = \'R\';
				mm = $SIZE(s);
				break;
			case 2: pside = \'L\';
				mm = $SIZE(r);
				break;
			default:pside = \'B\';
				mm = $SIZE(s);
		}

		$TFD(ctrevc_,ztrevc_)(
		&pside,
		&phowmny,
		$P(select),
		&(integer){$PRIV(__n_size)},
		$P(T),
		&(integer){$PRIV(__n_size)},
		$P(VL),
		&(integer){$PRIV(__m_size)},
		$P(VR),
		&(integer){$PRIV(__p_size)},
		&mm,
		$P(m), 
		&work[$SIZE(n)],
		work,
		$P(info));
		free(work);

');

pp_defc("tgevc",
       _decl => <<'EOF',
		extern int $TFD(c,z)tgevc_(char *side, char *howmny, logical *select, 
		integer *n, $GENERIC() *a, integer *lda, $GENERIC() *b, integer *ldb,
		$GENERIC() *vl, integer *ldvl, $GENERIC() *vr, integer *ldvr, 
		integer *mm, integer *m, $GENERIC() *work, $GENERIC() *rwork, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int side();int howmny(); [io,phys]B(2,n,n);int [phys]select(q);[io,phys]VL(2,m,r); [io,phys]VR(2,p,s);int [o,phys]m(); int [o,phys]info()',
	Code => generate_code '
		char pside,phowmny;
		integer mm = 0;
		$GENERIC() *work = ($GENERIC() *) malloc(6 * $SIZE(n) *sizeof($GENERIC()));

		switch ($howmny())
		{
			case 1: phowmny = \'B\';
				break;
			case 2: phowmny = \'S\';
				break;
			default: phowmny = \'A\';
		}

		switch ($side())
		{
			case 1: pside = \'R\';
				mm = $SIZE(s);
				break;
			case 2: pside = \'L\';
				mm = $SIZE(r);
				break;
			default:pside = \'B\';
				mm = $SIZE(s);
		}

		$TFD(ctgevc_,ztgevc_)(
		&pside,
		&phowmny,
		$P(select),
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(B),
		&(integer){$PRIV(__n_size)},
		$P(VL),
		&(integer){$PRIV(__m_size)},
		$P(VR),
		&(integer){$PRIV(__p_size)},
		&mm,
		$P(m), 
		&work[2*$SIZE(n)],
		work,
		$P(info));
		free(work);

');


pp_defc("gebal",
       _decl => <<'EOF',
		extern int $TFD(c,z)gebal_(char *job, integer *n, $GENERIC() *a, integer *
		lda, integer *ilo, integer *ihi, $GENERIC() *scale, integer *info);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,n,n); int job(); int [o,phys]ilo();int [o,phys]ihi();[o,phys]scale(n); int [o,phys]info()',
	Code => generate_code '
		char pjob;
	        switch ($job())
		{
			case 1:   pjob = \'P\';
				  break;
			case 2:   pjob = \'S\';
				  break;
			case 3:   pjob = \'B\';
				  break;
			default:  pjob = \'N\';
		}
		$TFD(cgebal_,zgebal_)(
		&pjob,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		$P(ilo),
		$P(ihi),
		$P(scale),
		$P(info));
');


#################################################################################
pp_defc("lange",
       _decl => <<'EOF',
		extern $GENERIC() $TFD(c,z)lange_(char *norm, integer *m, integer *n, $GENERIC() *a, integer
		*lda, $GENERIC() *work);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,m); int norm(); [o]b()',
	Code =>  '
             char pnorm;
		$GENERIC() *work;
		switch ($norm())
		{
			case 1: pnorm = \'O\';
				break;
			case 2: pnorm = \'I\';
				work = ($GENERIC() *)malloc($PRIV(__n_size) *  sizeof($GENERIC()));
				break;
			case 3: pnorm = \'F\';
				break;
			default: pnorm = \'M\';
		}

		$b() = $TFD(clange_,zlange_)(
		&pnorm,
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		work);
		if ($norm() == 2)
			free (work);

');


pp_defc("lansy",
       _decl => <<'EOF',
		extern $GENERIC() $TFD(c,z)lansy_(char *norm, char *uplo, integer *n, $GENERIC() *a, integer 
		*lda, $GENERIC() *work);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2, n,n); int uplo(); int norm(); [o]b()',
	Code =>  '

             char pnorm, puplo = \'U\';
		$GENERIC() *work;
		switch ($norm())
		{
			case 1: pnorm = \'O\';
				work = ($GENERIC() *)malloc($PRIV(__n_size) *  sizeof($GENERIC()));
				break;
			case 2: pnorm = \'I\';
				work = ($GENERIC() *)malloc($PRIV(__n_size) *  sizeof($GENERIC()));
				break;
			case 3: pnorm = \'F\';
				break;
			default: pnorm = \'M\';
		}
		if($uplo())
			puplo = \'L\';

		$b() = $TFD(clansy_,zlansy_)(
		&pnorm,
		&puplo,
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		work);
		if ($norm() == 2 || $norm() == 1)
			free (work);

');

pp_defc("lantr",
       _decl => <<'EOF',
		extern $GENERIC() $TFD(c,z)lantr_(char *norm, char *uplo, char *diag, integer *m, integer *n, $GENERIC() *a, integer 
		*lda, $GENERIC() *work);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,m,n);int uplo();int norm();int diag();[o]b()',
	Code =>  '
             char pnorm, puplo = \'U\';
             char pdiag = \'N\';
		$GENERIC() *work;
		switch ($norm())
		{
			case 1: pnorm = \'O\';
				break;
			case 2: pnorm = \'I\';
				work = ($GENERIC() *)malloc($PRIV(__m_size) *  sizeof($GENERIC()));
				break;
			case 3: pnorm = \'F\';
				break;
			default: pnorm = \'M\';
		}
		if($uplo())
			puplo = \'L\';
		if($diag())
			pdiag = \'U\';

		$b() = $TFD(clantr_,zlantr_)(
		&pnorm,
		&puplo,
		&pdiag,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		work);
		if ($norm() == 2)
			free (work);

');

################################################################################
#
#		BLAS ROUTINES
#
################################################################################

pp_defc("gemm",
       _decl => <<'EOF',
			extern int $TFD(c,z)gemm_(char *transa, char *transb, integer *m, integer *
			n, integer *k, $GENERIC() *alpha, $GENERIC() *a, integer *lda,
			$GENERIC() *b, integer *ldb, $GENERIC() *beta, $GENERIC() *c__,
			integer *ldc);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,m,n); int transa(); int transb(); [phys]B(2,p,q);[phys]alpha(2); [phys]beta(2); [io,phys]C(2,r,s)',
	Code => '
		char ptransa = \'N\';
		char ptransb = \'N\';
		integer kk = $transa() ? $SIZE(m) : $SIZE(n);

		if ($transa() == 1)
			ptransa = \'T\';
		else if ($transa() == 2)
			ptransa = \'C\';
		if ($transb())
			ptransb = \'T\';
		else if ($transb() == 2)
			ptransb = \'C\';

		$TFD(cgemm_,zgemm_)(
		&ptransa,
		&ptransb,
		&(integer){$PRIV(__r_size)},
		&(integer){$PRIV(__s_size)},
		&kk,
		$P(alpha),
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(beta),
		$P(C),
		&(integer){$PRIV(__r_size)});
',
	Doc=>'

=for ref

Complex version of gemm. 

    Arguments   
    =========   
	transa:  = 0:  No transpose;
            	 = 1:  Transpose; 
            	 = 2:  Conjugate transpose;

	transb:  = 0:  No transpose;
            	 = 1:  Transpose; 
            	 = 2:  Conjugate transpose;

');

if ($config{CBLAS}){
pp_def("rmcgemm",
       HandleBad => 0,
	Pars => '[phys]A(2,m,n); int transa(); int transb(); [phys]B(2,p,q);[phys]alpha(2); [phys]beta(2); [io,phys]C(2,r,s)',
	Code => '
		int ptransa, ptransb;
			extern void $TFD(cblas_cgemm,cblas_zgemm)(const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
				const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
				const int K, const void *alpha, const void *A,
				const int lda, const void *B, const int ldb,
				const void *beta, void *C, const int ldc);
		integer kk = $transa() ? $SIZE(n) : $SIZE(m);

		switch($transa()){
			case 1:	ptransa = CblasTrans;
				break;
			case 2:	ptransa = CblasConjTrans;
				break;
			default:ptransa = CblasNoTrans;
		}
		switch($transb()){
			case 1:	ptransb = CblasTrans;
				break;
			case 2:	ptransb = CblasConjTrans;
				break;
			default:ptransb = CblasNoTrans;
		}

		$TFD(cblas_cgemm,cblas_zgemm)(
		CblasRowMajor,
		ptransa,
		ptransb,
		$PRIV(__s_size),
		$PRIV(__r_size),
		kk,
		$P(alpha),
		$P(A),
		$PRIV(__m_size),
		$P(B),
		$PRIV(__p_size),
		$P(beta),
		$P(C),
		$PRIV(__r_size));
',
Doc=>'

=for ref

Complex version of rmgemm. 

    Arguments   
    =========   
	transa:  = 0:  No transpose;
            	 = 1:  Transpose; 
            	 = 2:  Conjugate transpose;

	transb:  = 0:  No transpose;
            	 = 1:  Transpose; 
            	 = 2:  Conjugate transpose;

');
}

pp_defc("mmult",
       _decl => <<'EOF',
		extern int $TFD(c,z)gemm_(char *transa, char *transb, integer *m, integer *
		n, integer *k, $GENERIC() *alpha, $GENERIC() *a, integer *lda,
		$GENERIC() *b, integer *ldb, $GENERIC() *beta, $GENERIC() *c__,
		integer *ldc);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,m,n); [phys]B(2,p,m); [o,phys]C(2,p,n)',
	Code =>  '
		char ptrans = \'N\';
			$GENERIC() alpha[2] = {1,0};
			$GENERIC() beta[2] = {0,0};

		$TFD(cgemm_,zgemm_)(
		&ptrans,
		&ptrans,
		&(integer){$PRIV(__p_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		&alpha[0],
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		&beta[0],
		$P(C),
		&(integer){$PRIV(__p_size)});
');
if ($config{STRASSEN}){
pp_defc("smmult",
       _decl => <<'EOF',
		extern int $TFD(c,z)gemmb_(char *transa, char *transb, integer *m, integer *
		n, integer *k, $GENERIC() *alpha, $GENERIC() *a, integer *lda,
		$GENERIC() *b, integer *ldb, $GENERIC() *beta, $GENERIC() *c__,
		integer *ldc);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,m,n); [phys]B(2,p,m); [o,phys]C(2,p,n)',
	Code =>  '
		char ptrans = \'N\';
		$GENERIC() alpha[2] = {1,0};
		$GENERIC() beta[2] = {0,0};
		$TFD(cgemmb_,zgemmb_)(
		&ptrans,
		&ptrans,
		&(integer){$PRIV(__p_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		&alpha[0],
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		&beta[0],
		$P(C),
		&(integer){$PRIV(__p_size)});
');
}

pp_defc("crossprod",
       _decl => <<'EOF',
		extern int $TFD(c,z)gemm_(char *transa, char *transb, integer *m, integer *
		n, integer *k, $GENERIC() *alpha, $GENERIC() *a, integer *lda,
		$GENERIC() *b, integer *ldb, $GENERIC() *beta, $GENERIC() *c__,
		integer *ldc);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,n,m); [phys]B(2,p,m); [o,phys]C(2,p,n)',
	Code =>  '
		char btrans = \'N\';
		char atrans = \'C\';
		$GENERIC() alpha[2] = {1,0};
		$GENERIC() beta[2] = {0,0};
		$TFD(cgemm_,zgemm_)(
		&btrans,
		&atrans,
		&(integer){$PRIV(__p_size)},
		&(integer){$PRIV(__n_size)},
		&(integer){$PRIV(__m_size)},
		&alpha[0],
		$P(B),
		&(integer){$PRIV(__p_size)},
		$P(A),
		&(integer){$PRIV(__n_size)},
		&beta[0],
		$P(C),
		&(integer){$PRIV(__p_size)});
');

pp_defc("syrk",
       _decl => <<'EOF',
			extern int $TFD(c,z)syrk_(char *uplo, char *trans, integer *n, integer *k,
			$GENERIC() *alpha, $GENERIC() *a, integer *lda, $GENERIC() *beta,
			$GENERIC() *c__, integer *ldc);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,m,n); int uplo(); int trans(); [phys]alpha(2); [phys]beta(2); [io,phys]C(2,p,p)',
	RedoDimsCode => '$SIZE(p) = $trans() ? $SIZE(n) : $SIZE(m);',
	Code =>  '

		char puplo = \'U\';
		char ptrans = \'N\';
		integer kk = $trans() ? $SIZE(m) : $SIZE(n);

		if ($uplo())
			puplo = \'L\';

		if ($trans())
			ptrans = \'T\';


		$TFD(csyrk_,zsyrk_)(
		&puplo,
		&ptrans,
		&(integer){$PRIV(__p_size)},
		&kk,
		$P(alpha),
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(beta),
		$P(C),
		&(integer){$PRIV(__p_size)});
');

if ($config{CBLAS}){
pp_def("rmcsyrk",
       HandleBad => 0,
	Pars => '[phys]A(2,m,n); int uplo(); int trans(); [phys]alpha(2); [phys]beta(2); [io,phys]C(2,p,p)',
	Code =>  '
		int puplo = CblasUpper;
		int ptrans;
			extern void cblas_csyrk(const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
		                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
		                 const void *alpha, const void *A, const int lda,
		                 const void *beta, void *C, const int ldc);
		integer kk = $trans() ? $SIZE(n) : $SIZE(m);

		if ($uplo())
			puplo = CblasLower;

		switch($trans()){
			case 1:	ptrans = CblasTrans;
				break;
			case 2:	ptrans = CblasConjTrans;
				break;
			default:ptrans = CblasNoTrans;
		}


		$TFD(cblas_csyrk,cblas_zsyrk)(
		CblasRowMajor,
		puplo,
		ptrans,
		$PRIV(__p_size),
		kk,
		$P(alpha),
		$P(A),
		$PRIV(__m_size),
		$P(beta),
		$P(C),
		$PRIV(__p_size));
',
Doc=>'

=for ref

Complex version of rmsyrk

');
}
pp_defc("dot",
       _decl => <<'EOF',
			extern $GENERIC() $TFD(c,z)dotu_($GENERIC() *ret, integer *n, $GENERIC() *dx, integer *incx, $GENERIC() *dy,
			integer *incy);
EOF
       HandleBad => 0,
	Pars => '[phys]a(2,n);int [phys]inca();[phys]b(2,n);int [phys]incb();[o,phys]c(2)',
	Code =>  '
		integer n = (integer ) $PRIV(__n_size)/$inca();
		$TFD(cdotu_,zdotu_)(
		$P(c),
		&n,
		$P(a),
		$P(inca),
		$P(b),
		$P(incb));
');

pp_defc("dotc",
       _decl => <<'EOF',
			extern $GENERIC() $TFD(c,z)dotc_($GENERIC() *ret, integer *n, $GENERIC() *dx, integer *incx, $GENERIC() *dy,
			integer *incy);
EOF
       HandleBad => 0,
	Pars => '[phys]a(2,n);int [phys]inca();[phys]b(2,n);int [phys]incb();[o,phys]c(2)',
	Code =>  '
		integer n = (integer ) $PRIV(__n_size)/$inca();
		$TFD(cdotc_,zdotc_)(
		$P(c),
		&n,
		$P(a),
		$P(inca),
		$P(b),
		$P(incb));
',
Doc=>'

=for ref

Forms the dot product of two vectors, conjugating the first   
vector.

');

pp_defc("axpy",
       _decl => <<'EOF',
		extern int $TFD(c,z)axpy_(integer *n, $GENERIC() *da, $GENERIC() *dx,
		integer *incx, $GENERIC() *dy, integer *incy);
EOF
       HandleBad => 0,
	Pars => '[phys]a(2,n);int [phys]inca();[phys] alpha(2);[io,phys]b(2,n);int [phys]incb()',
	Code =>  '
		integer n = (integer ) $PRIV(__n_size)/$inca();
		$TFD(caxpy_,zaxpy_)(
		&n,
		$P(alpha),
		$P(a),
		$P(inca),
		$P(b),
		$P(incb));
');

pp_defc("nrm2",
       _decl => <<'EOF',
			extern $GENERIC() $TFD(sc,dz)nrm2_(integer *n, $GENERIC() *dx,
			integer *incx);
EOF
       HandleBad => 0,
	Pars => '[phys]a(2,n);int [phys]inca();[o,phys]b()',
	Code =>  '
		integer n = (integer ) $PRIV(__n_size)/$inca();
		$b() = $TFD(sc,dz)nrm2_(
		&n,
		$P(a),
		$P(inca));
');

pp_defc("asum",
       _decl => <<'EOF',
		extern $GENERIC() $TFD(sc,dz)asum_(integer *n, $GENERIC() *dx,
		integer *incx);
EOF
       HandleBad => 0,
	Pars => '[phys]a(2,n);int [phys]inca();[o,phys]b()',
	Code =>  '
		integer n = (integer ) $PRIV(__n_size)/$inca();
		$b() = $TFD(sc,dz)asum_(
		&n,
		$P(a),
		$P(inca));
');

pp_defc("scal",
	_decl => <<'EOF',
		extern int $TFD(c,z)scal_(integer *n, $GENERIC() *sa,
		$GENERIC() *dx, integer *incx);
EOF
        HandleBad => 0,
	Pars => '[io,phys]a(2,n);int [phys]inca();[phys]scale(2)',
	Code =>  '
		integer n = (integer ) $PRIV(__n_size)/$inca();
		$TFD(cscal_,zscal_)(
		&n,
		$P(scale),
		$P(a),
		$P(inca));
');

pp_def("sscal",
        HandleBad => 0,
	Pars => '[io,phys]a(2,n);int [phys]inca();[phys]scale()',
	GenericTypes => [F],
	Code =>  '
		extern int csscal_(integer *n, $GENERIC() *sa,
		$GENERIC() *dx, integer *incx);
		integer n = (integer ) $PRIV(__n_size)/$inca();
		csscal_( &n, $P(scale), $P(a), $P(inca));
',
Doc=>'

=for ref

Scales a complex vector by a real constant.

');


pp_defc("rotg",
       _decl => <<'EOF',
		extern int $TFD(c,z)rotg_($GENERIC() *dx,
		$GENERIC() *dy, $GENERIC() *c, $GENERIC() *s);
EOF
       HandleBad => 0,
	Pars => '[io,phys]a(2);[phys]b(2);[o,phys]c(); [o,phys]s(2)',
	Code =>  '
		$TFD(crotg_,zrotg_)(
		$P(a),
		$P(b),
		$P(c),
		$P(s)		
		);
');

################################################################################
#
#		LAPACK AUXILIARY ROUTINES
#
################################################################################
pp_defc("lacpy",
       _decl => <<'EOF',
		extern int $TFD(c,z)lacpy_(char *uplo, integer *m, integer *n, $GENERIC() *
		a, integer *lda, $GENERIC() *b, integer *ldb);
EOF
       HandleBad => 0,
	Pars => '[phys]A(2,m,n); int uplo(); [o,phys]B(2,p,n)',
	Code => '
		char puplo;
		switch ($uplo())
		{
			case 0: puplo = \'U\';
				break;
			case 1: puplo = \'L\';
				break;
			default: puplo = \'A\';
		}

		$TFD(clacpy_,zlacpy_)(
		&puplo,
		&(integer){$PRIV(__m_size)},
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(B),
		&(integer){$PRIV(__p_size)});
');

pp_defc("laswp",
       _decl => <<'EOF',
		extern int $TFD(c,z)laswp_(integer *n, $GENERIC() *a, integer *lda, integer 
		*k1, integer *k2, integer *ipiv, integer *incx);
EOF
       HandleBad => 0,
	Pars => '[io,phys]A(2,m,n); int [phys]k1(); int [phys]k2(); int [phys]ipiv(p);int [phys]inc()',
	Code => '
		$TFD(claswp_,zlaswp_)(
		&(integer){$PRIV(__n_size)},
		$P(A),
		&(integer){$PRIV(__m_size)},
		$P(k1),
		$P(k2),
		$P(ipiv),
		$P(inc));
');

################################################################################
#
#		OTHER AUXILIARY ROUTINES
#
################################################################################
pp_def(
	'ctricpy',
	Pars => 'A(c=2,m,n);int uplo();[o] C(c=2,m,n)',
	Code => '
		PDL_Long i, j, k;
		
		if ($uplo())
		{
			for (i = 0; i < $SIZE(n);i++)
			{
				k = min(i,($SIZE(m)-1));
				for (j = 0; j <= k; j++)
				{
	               			$C(c=>0,m=>j,n=>i) = $A(c=>0,m=>j,n=>i);
					$C(c=>1,m=>j,n=>i) = $A(c=>1,m=>j,n=>i);
				}
			}
		}
		else
		{
			for (i = 0; i < $SIZE(n);i++)
			{
				for (j = i; j < $SIZE(m); j++)
				{
	               			$C(c=>0,m=>j,n=>i) = $A(c=>0,m=>j,n=>i);
					$C(c=>1,m=>j,n=>i) = $A(c=>1,m=>j,n=>i);
				
				}
				if (i >= $SIZE(m))
					break;
			}
		}
		

	',
	Doc => <<EOT

=for ref

Copy triangular part to another matrix. If uplo == 0 copy upper triangular part.

=cut

EOT

);

pp_bless('PDL');
pp_def(
	'cmstack',
	DefaultFlow => 1,
	Reversible => 1,
	Pars => 'x(c,n,m);y(c,n,p);[o]out(c,n,q);',
	RedoDimsCode => '$SIZE(q) = $PDL(x)->dims[2] + $PDL(y)->dims[2];',
	Code => '
	  register PDL_Long i,j;
	  loop(m)%{
		  loop(n)%{
			  loop(c)%{
				$out(c=>c,n=>n,q=>m) = $x(c=>c,n=>n,m=>m);
			%}
		  %}
	  %}
	  j=0;
	  for (i = $SIZE(m); i < $SIZE(q) ;i++,j++)
	  {
		  loop(n)%{
			loop(c)%{
				$out(c=>c,n=>n,q=>i) = $y(c=>c,n=>n,p=>j);
			%}
		  %}
	  }	
	',

       BackCode => '
	  register PDL_Long i,j;
	  loop(m)%{
		  loop(n)%{
			loop(c)%{
				$x(c=>c,n=>n,m=>m) = $out(c=>c,n=>n,q=>m);
			%}
		  %}
	  %}
	  j=0;
	  for (i = $SIZE(m); i < $SIZE(q) ;i++,j++)
	  {
		  loop(n)%{
			loop(c)%{
				$y(c=>c,n=>n,p=>j) = $out(c=>c,n=>n,q=>i);
			%}
		  %}
	  }
       ',
	Doc => <<EOT

=for ref

Combine two 3D piddles into a single piddle.
This routine does backward and forward dataflow automatically.

=cut
EOT

);

pp_addhdr('
void cftrace(int n, void *a1, void *a2)
{
  float *mat = a1, *res = a2;
  int i;
  res[0] = mat[0];
  res[1] = mat[1];
  for (i = 1; i < n; i++)
  {
   	res[0] += mat[(i*(n+1))*2];
   	res[1] += mat[(i*(n+1))*2+1];
  }
}
void cdtrace(int n, void *a1, void *a2)
{
  double *mat = a1, *res = a2;
  int i;
  res[0] = mat[0];
  res[1] = mat[1];
  for (i = 1; i < n; i++)
  {
   	res[0] += mat[(i*(n+1))*2];
   	res[1] += mat[(i*(n+1))*2+1];
  }
}
');

pp_defc('charpol',
	_decl => <<'EOF',
	extern int $TFD(c,z)gemm_(char *transa, char *transb, integer *m, integer *
	n, integer *k, $GENERIC() *alpha, $GENERIC() *a, integer *lda,
	$GENERIC() *b, integer *ldb, $GENERIC() *beta, $GENERIC() *c__,
	integer *ldc);
EOF
	RedoDimsCode => '$SIZE(p) = $PDL(A)->dims[1] + 1;',
	Pars => '[phys]A(c=2,n,n);[phys,o]Y(c=2,n,n);[phys,o]out(c=2,p);',
	Code => '
	int i,j,k;
	$GENERIC() *p, tr[2], b[2];
	//$GENERIC() *tmp;	
	char ptrans = \'N\';	
	$GENERIC() alpha[2] = {1,0};
	$GENERIC() beta[2] = {0,0};
	p = ($GENERIC() * ) malloc (2* $SIZE(n) * $SIZE(n) * sizeof($GENERIC()));
	loop(n0)%{
		loop(n1)%{
			$Y(c=>0,n0=>n0,n1=>n1) = (n0 == n1) ?  ($GENERIC()) 1.0 : ($GENERIC()) 0.0;
			$Y(c=>1,n0=>n0,n1=>n1) = ($GENERIC()) 0.0;
		%}	
	%}
	$out(c=>0,p=>0) = 1;
	$out(c=>1,p=>0) = 0;

	i = 0;
	for (;;)
	{
		i++;
		$TFD(cgemm_,zgemm_)(&ptrans,&ptrans,&(integer){$PRIV(__n_size)},&(integer){$PRIV(__n_size)},
			&(integer){$PRIV(__n_size)},&alpha[0],$P(Y),&(integer){$PRIV(__n_size)}, $P(A), &(integer){$PRIV(__n_size)},
			&beta[0], p, &(integer){$PRIV(__n_size)});
		
		if (i == $SIZE(n)) break;

		// if (k+1) & 1 without the copy below => return diagonal matrix
		// with determinant (on my 5-year-old-pentium (windows)) !!!???
		// tmp = $P(Y);
		// $P(Y) = p;
		// p = tmp;
		
		
		
		memmove($P(Y), p, 2* $SIZE(n) * $SIZE(n) * sizeof($GENERIC()));
		
//		loop(n1)
//		%{
//			loop(n0)
//			%{
//				$Y(c=>0,n0=>n0,n1=>n1) = p[((n1*$SIZE(n))+n0)*2];
//				$Y(c=>1,n0=>n0,n1=>n1) = p[((n1*$SIZE(n))+n0)*2+1];
//			%}	
//		%}
	
		$TFD(cftrace,cdtrace)($SIZE(n), $P(Y), &tr[0]);
		
		b[0] = $out(c=>0,p=>i) = - tr[0] / i;
		b[1] = $out(c=>1,p=>i) = - tr[1] / i;
		for (j = 0; j < $SIZE(n); j++)
		{
			$Y(c=>0,n0=>j,n1=>j) +=  b[0];
			$Y(c=>1,n0=>j,n1=>j) +=  b[1];
		}

	}

	k = $SIZE(n);
	$TFD(cftrace,cdtrace)(k, p, &tr[0]);	
	$out(c=>0,p=>k) = - tr[0] / k;
	$out(c=>1,p=>k) = - tr[1] / k;
	if ((k+1) & 1)
	{
		loop(n0)
		%{
			loop(n1)
			%{
				$Y(c=>0,n0=>n0,n1=>n1) = -$Y(c=>0,n0=>n0,n1=>n1);
				$Y(c=>1,n0=>n0,n1=>n1) = -$Y(c=>1,n0=>n0,n1=>n1);
			%}	
		%}
	}
	free(p);
	'
);


pp_addpm({At=>'Bot'},<<'EOD');

=head1 AUTHOR

Copyright (C) Grgory Vanuxem 2005-2018.

This library is free software; you can redistribute it and/or modify
it under the terms of the Perl Artistic License as in the file Artistic_2
in this distribution.

=cut

EOD

pp_done();  # you will need this to finish pp processing

