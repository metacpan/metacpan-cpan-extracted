=pod

=encoding utf-8

=head1 Name

Zero::Emulator - Assemble and emulate a program written in the L<Zero|https://github.com/philiprbrenan/zero> assembler programming language.

=for html
<p><a href="https://github.com/philiprbrenan/zero"><img src="https://github.com/philiprbrenan/zero/workflows/Test/badge.svg"></a>

=head1 Synopsis

Say "hello world":

  Start 1;

  Out "hello World";

  my $e = Execute;

  is_deeply $e->out, ["hello World"];

=head1 Description



Version 20230514.


The following sections describe the methods in each functional area of this
module.  For an alphabetic listing of all methods by name see L<Index|/Index>.



=head1 Instruction Set

The instruction set used by the Zero assembler programming language.

=head2 Add($target, $s1, $s2)

Add the source locations together and store the result in the target area.

     Parameter  Description
  1  $target    Target address
  2  $s1        Source one
  3  $s2        Source two

B<Example:>


  if (1)                                                                          
   {Start 1;
  
    my $a = Add 3, 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out  $a;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [5];
   }
  

=head2 Array($name)

Create a new memory area and write its number into the address named by the target operand.

     Parameter  Description
  1  $name      Name of allocation

B<Example:>


  if (1)                                                                             
   {Start 1;
  
    my $a = Array "aaa";  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Mov [$a, 0, "aaa"], 1;
      Mov [$a, 1, "aaa"], 22;
      Mov [$a, 2, "aaa"], 333;
  
    my $n = ArraySize $a, "aaa";
  
    Out "Array size:"; Out $n;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    ArrayDump $a, "AAAA";
  
    ForArray
     {my ($i, $e, $check, $next, $end) = @_;
      Out $i; Out $e;
     }  $a, "aaa";
  
    Nop;
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->memory, {1=>[1, 22, 333]};
  
  
    is_deeply $e->out, [ "Array size:", 3,  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    "AAAA", "bless([1, 22, 333], \"aaa\")",
  
    "Stack trace",
    "    1     8 arrayDump",
  
    0,   1,
    1,  22,
    2, 333];
   }
  

=head2 ArrayCountLess()

Count the number of elements in the array specified by the first source operand that are less than the element supplied by the second source operand and place the result in the target location.


B<Example:>


  if (1)                                                                            
   {Start 1;
    my $a = Array "aaa";
    Mov [$a, 0, "aaa"], 10;
    Mov [$a, 1, "aaa"], 20;
    Mov [$a, 2, "aaa"], 30;
  
    Out ArrayIndex $a, 30;
    Out ArrayIndex $a, 20;
    Out ArrayIndex $a, 10;
    Out ArrayIndex $a, 15;
  
  
    Out ArrayCountLess $a, 35;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayCountLess $a, 25;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayCountLess $a, 15;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayCountLess $a,  5;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayCountGreater $a, 35;
    Out ArrayCountGreater $a, 25;
    Out ArrayCountGreater $a, 15;
    Out ArrayCountGreater $a,  5;
  
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [3,2,1,0,  3,2,1,0,  0,1,2,3];
   }
  

=head2 ArrayCountGreater()

Count the number of elements in the array specified by the first source operand that are greater than the element supplied by the second source operand and place the result in the target location.


B<Example:>


  if (1)                                                                            
   {Start 1;
    my $a = Array "aaa";
    Mov [$a, 0, "aaa"], 10;
    Mov [$a, 1, "aaa"], 20;
    Mov [$a, 2, "aaa"], 30;
  
    Out ArrayIndex $a, 30;
    Out ArrayIndex $a, 20;
    Out ArrayIndex $a, 10;
    Out ArrayIndex $a, 15;
  
    Out ArrayCountLess $a, 35;
    Out ArrayCountLess $a, 25;
    Out ArrayCountLess $a, 15;
    Out ArrayCountLess $a,  5;
  
  
    Out ArrayCountGreater $a, 35;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayCountGreater $a, 25;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayCountGreater $a, 15;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayCountGreater $a,  5;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [3,2,1,0,  3,2,1,0,  0,1,2,3];
   }
  

=head2 ArrayDump($target, $title)

Dump an array.

     Parameter  Description
  1  $target    Array to dump
  2  $title     Title of dump

B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Array "aaa";
      Mov [$a, 0, "aaa"], 1;
      Mov [$a, 1, "aaa"], 22;
      Mov [$a, 2, "aaa"], 333;
  
    ArrayDump $a, "AAAA";  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out, [
    "AAAA",
    "bless([1, 22, 333], \"aaa\")",
    "Stack trace",
    "    1     5 arrayDump"];
   }
  

=head2 ArrayIndex()

Find the 1 based index of the second source operand in the array referenced by the first source operand if it is present in the array else 0 into the target location.  The business of returning -1 would have led to the confusion of "try catch" and we certainly do not want that.


B<Example:>


  if (1)                                                                            
   {Start 1;
    my $a = Array "aaa";
    Mov [$a, 0, "aaa"], 10;
    Mov [$a, 1, "aaa"], 20;
    Mov [$a, 2, "aaa"], 30;
  
  
    Out ArrayIndex $a, 30;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayIndex $a, 20;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayIndex $a, 10;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayIndex $a, 15;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out ArrayCountLess $a, 35;
    Out ArrayCountLess $a, 25;
    Out ArrayCountLess $a, 15;
    Out ArrayCountLess $a,  5;
  
    Out ArrayCountGreater $a, 35;
    Out ArrayCountGreater $a, 25;
    Out ArrayCountGreater $a, 15;
    Out ArrayCountGreater $a,  5;
  
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [3,2,1,0,  3,2,1,0,  0,1,2,3];
   }
  

=head2 ArraySize($area, $name)

The current size of an array.

     Parameter  Description
  1  $area      Location of area
  2  $name      Name of area

B<Example:>


  if (1)                                                                             
   {Start 1;
    my $a = Array "aaa";
      Mov [$a, 0, "aaa"], 1;
      Mov [$a, 1, "aaa"], 22;
      Mov [$a, 2, "aaa"], 333;
  
  
    my $n = ArraySize $a, "aaa";  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out "Array size:"; Out $n;
    ArrayDump $a, "AAAA";
  
    ForArray
     {my ($i, $e, $check, $next, $end) = @_;
      Out $i; Out $e;
     }  $a, "aaa";
  
    Nop;
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->memory, {1=>[1, 22, 333]};
  
    is_deeply $e->out, [ "Array size:", 3,
  
    "AAAA", "bless([1, 22, 333], \"aaa\")",
  
    "Stack trace",
    "    1     8 arrayDump",
  
    0,   1,
    1,  22,
    2, 333];
   }
  

=head2 Assert(%options)

Assert regardless.

     Parameter  Description
  1  %options   Options

B<Example:>


  if (1)                                                                          
   {Start 1;
  
    Assert;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out, ["Assert failed", "    1     1 assert"];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

   }
  

=head2 AssertEq($a, $b, %options)

Assert two memory locations are equal.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options

B<Example:>


  if (1)                                                                          
   {Start 1;
    Mov 0, 1;
  
    AssertEq \0, 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Assert 1 == 2 failed", "    1     2 assertEq"];
   }
  

=head2 AssertFalse($a, %options)

Assert false.

     Parameter  Description
  1  $a         Source operand
  2  %options

B<Example:>


  if (1)                                                                          
   {Start 1;
    AssertTrue  1;
  
    AssertFalse 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1, trace=>1);
    is_deeply $e->out, [
    "   1     0     1    assertTrue                      ",
  
    "AssertFalse 1 failed",  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    "    1     2 assertFalse",
    "   2     1     1   assertFalse                      "];
  
   }
  

=head2 AssertGe($a, $b, %options)

Assert are greater than or equal.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options

B<Example:>


  if (1)                                                                          
   {Start 1;
    Mov 0, 1;
  
    AssertGe \0, 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Assert 1 >= 2 failed", "    1     2 assertGe"];
   }
  

=head2 AssertGt($a, $b, %options)

Assert two memory locations are greater than.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options

B<Example:>


  if (1)                                                                          
   {Start 1;
    Mov 0, 1;
  
    AssertGt \0, 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Assert 1 >  2 failed", "    1     2 assertGt"];
   }
  

=head2 AssertLe($a, $b, %options)

Assert two memory locations are less than or equal.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options

B<Example:>


  if (1)                                                                          
   {Start 1;
    Mov 0, 1;
  
    AssertLe \0, 0;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Assert 1 <= 0 failed", "    1     2 assertLe"];
   }
  

=head2 AssertLt($a, $b, %options)

Assert two memory locations are less than.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options

B<Example:>


  if (1)                                                                          
   {Start 1;
    Mov 0, 1;
  
    AssertLt \0, 0;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Assert 1 <  0 failed", "    1     2 assertLt"];
   }
  

=head2 AssertNe($a, $b, %options)

Assert two memory locations are not equal.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options

B<Example:>


  if (1)                                                                          
   {Start 1;
    Mov 0, 1;
  
    AssertNe \0, 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Assert 1 != 1 failed", "    1     2 assertNe"];
   }
  

=head2 AssertTrue($a, %options)

Assert true.

     Parameter  Description
  1  $a         Source operand
  2  %options

B<Example:>


  if (1)                                                                          
   {Start 1;
    AssertFalse 0;
  
    AssertTrue  0;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1, trace=>1);
    is_deeply $e->out, [
    "   1     0     1   assertFalse                      ",
  
    "AssertTrue 0 failed",  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    "    1     2 assertTrue",
    "   2     1     1    assertTrue                      "];
   }
  

=head2 Bad($bad)

A bad ending.

     Parameter  Description
  1  $bad       What to do on a bad ending

B<Example:>


  if (1)                                                                            
   {Start 1;
    Block
     {my ($start, $good, $bad, $end) = @_;
      Out 1;
      Jmp $good;
     }
    Good
     {Out 2;
     },
  
    Bad  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {Out 3;
     };
    Out 4;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [1,2,4];
   }
  

=head2 Block($block, %options)

Block of code that can either be restarted or come to a good or a bad ending.

     Parameter  Description
  1  $block     Block
  2  %options   Options

B<Example:>


  if (1)                                                                            
   {Start 1;
  
    Block  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {my ($start, $good, $bad, $end) = @_;
      Out 1;
      Jmp $good;
     }
    Good
     {Out 2;
     },
    Bad
     {Out 3;
     };
    Out 4;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [1,2,4];
   }
  
  if (1)                                                                          
   {Start 1;
  
    Block  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {my ($start, $good, $bad, $end) = @_;
      Out 1;
      Jmp $bad;
     }
    Good
     {Out 2;
     },
    Bad
     {Out 3;
     };
    Out 4;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [1,3,4];
   }
  

=head2 Call($p)

Call the subroutine at the target address.

     Parameter  Description
  1  $p         Procedure description

B<Example:>


  if (1)                                                                           
   {Start 1;
    my $w = Procedure 'write', sub
     {Out 'aaa';
      Return;
     };
  
    Call $w;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["aaa"];
   }
  
  if (1)                                                                          
   {Start 1;
    my $w = Procedure 'write', sub
     {my $a = ParamsGet 0;
      Out $a;
      Return;
     };
    ParamsPut 0, 'bbb';
  
    Call $w;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["bbb"];
   }
  
  if (1)                                                                            
   {Start 1;
    my $w = Procedure 'write', sub
     {ReturnPut 0, "ccc";
      Return;
     };
  
    Call $w;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    ReturnGet \0, 0;
    Out \0;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["ccc"];
   }
  
  if (1)                                                                            
   {Start 1;
    my $a = Array "aaa";
    Dump "dddd";
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [
    "dddd",
    "-2=bless([], \"return\")",
    "-1=bless([], \"params\")",
    "0=bless([1], \"stackArea\")",
    "1=bless([], \"aaa\")",
    "Stack trace",
    "    1     2 dump"];
   }
  
  if (1)                                                                              
   {Start 1;
    my $a = Array "aaa";
    my $i = Mov 1;
    my $v = Mov 11;
    ParamsPut 0, $a;
    ParamsPut 1, $i;
    ParamsPut 2, $v;
    my $set = Procedure 'set', sub
     {my $a = ParamsGet 0;
      my $i = ParamsGet 1;
      my $v = ParamsGet 2;
      Mov [$a, \$i, 'aaa'], $v;
      Return;
     };
  
    Call $set;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $V = Mov [$a, \$i, 'aaa'];
    AssertEq $v, $V;
    Out [$a, \$i, 'aaa'];
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [11];
   }
  
  if (1)                                                                            
   {Start 1;
    my $set = Procedure 'set', sub
     {my $a = ParamsGet 0;
      Out $a;
     };
  
    ParamsPut 0, 1;  Call $set;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    ParamsPut 0, 2;  Call $set;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    ParamsPut 0, 3;  Call $set;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [1..3];
   }
  

=head2 Clear($target)

Clear the first bytes of an area.  The area is specified by the first element of the address, the number of locations to clear is specified by the second element of the target address.

     Parameter  Description
  1  $target    Target address

B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Array "aaa";
  
    Clear [$a, 10, 'aaa'];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->memory->{1}, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
  

=head2 Confess()

Confess with a stack trace showing the location bioth in the emulated code and in the code that produced the emulated code.


B<Example:>


  if (1)                                                                          
   {Start 1;
    my $c = Procedure 'confess', sub
  
     {Confess;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     };
    Call $c;
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out, ["Confess at:", "    2     3 confess", "    1     6 call"];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

   }
  

=head2 Dec($target)

Decrement the target.

     Parameter  Description
  1  $target    Target address

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Mov 3;
  
    Dec $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out $a;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2];
   }
  

=head2 Dump($title)

Dump all the arrays currently in memory.

     Parameter  Description
  1  $title     Title

B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Array "node";
    Out $a;
    Mov [$a, 1, 'node'], 1;
    Mov [$a, 2, 'node'], 2;
    Mov 1, [$a, \1, 'node'];
  
    Dump "dddd";  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Free $a, "node";
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out, [
    1,
  
    "dddd",
    "-2=bless([], \"return\")",
    "-1=bless([], \"params\")",
    "0=bless([1, 1], \"stackArea\")",
    "1=bless([undef, 1, 2], \"node\")",
  
    "Stack trace",
    "    1     6 dump"];
   }
  

=head2 Else($e)

Else block.

     Parameter  Description
  1  $e         Else block subroutine

B<Example:>


  if (1)                                                                            
   {Start 1;
    Trace 1;
    IfEq 1, 2,
    Then
     {Mov 1, 1;
      Mov 2, 1;
     },
  
    Else  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {Mov 3, 3;
      Mov 4, 4;
     };
    IfEq 2, 2,
    Then
     {Mov 1, 1;
      Mov 2, 1;
     },
  
    Else  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {Mov 3, 3;
      Mov 4, 4;
     };
    my $e = Execute(suppressOutput=>1);
    is_deeply scalar($e->out->@*), 14;
   }
  

=head2 Execute(%options)

Execute the current assembly.

     Parameter  Description
  1  %options   Options

B<Example:>


  if (1)                                                                            
   {Start 1;
    Out "hello World";
  
    my $e = Execute(suppressOutput=>1);  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    is_deeply $e->out, ["hello World"];
   }
  

=head2 For($block, $range, %options)

For loop 0..range-1 or in reverse.

     Parameter  Description
  1  $block     Block
  2  $range     Limit
  3  %options   Options

B<Example:>


  if (1)                                                                           
   {my $N = 5;
    Start 1;
  
    For  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {Tally 1;
      my $a = Mov 1;
      Tally 2;
      Inc $a;
      Tally 0;
     } $N;
    my $e = Execute;
  
    is_deeply $e->tallyCount, 2 * $N;
    is_deeply $e->tallyCounts, { 1 => {mov => $N}, 2 => {inc => $N}};
   }
  

=head2 ForArray($block, $area, $name, %options)

For loop to process each element of the named area.

     Parameter  Description
  1  $block     Block of code
  2  $area      Area
  3  $name      Area name
  4  %options   Options

B<Example:>


  if (1)                                                                             
   {Start 1;
    my $a = Array "aaa";
      Mov [$a, 0, "aaa"], 1;
      Mov [$a, 1, "aaa"], 22;
      Mov [$a, 2, "aaa"], 333;
  
    my $n = ArraySize $a, "aaa";
    Out "Array size:"; Out $n;
    ArrayDump $a, "AAAA";
  
  
    ForArray  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {my ($i, $e, $check, $next, $end) = @_;
      Out $i; Out $e;
     }  $a, "aaa";
  
    Nop;
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->memory, {1=>[1, 22, 333]};
  
    is_deeply $e->out, [ "Array size:", 3,
  
    "AAAA", "bless([1, 22, 333], \"aaa\")",
  
    "Stack trace",
    "    1     8 arrayDump",
  
    0,   1,
    1,  22,
    2, 333];
   }
  

=head2 Free($target, $source)

Free the memory area named by the target operand after confirming that it has the name specified on the source operand.

     Parameter  Description
  1  $target    Target area yielding the id of the area to be freed
  2  $source    Source area yielding the name of the area to be freed

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Array "node";
  
    Free $a, "aaa";  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out, [
    "Wrong name: aaa for array with name: node",
    "    1     2 free",
  ];
   }
  
  if (1)                                                                           
   {Start 1;
    my $a = Array "node";
    Out $a;
    Mov [$a, 1, 'node'], 1;
    Mov [$a, 2, 'node'], 2;
    Mov 1, [$a, \1, 'node'];
    Dump "dddd";
  
    Free $a, "node";  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out, [
    1,
  
    "dddd",
    "-2=bless([], \"return\")",
    "-1=bless([], \"params\")",
    "0=bless([1, 1], \"stackArea\")",
    "1=bless([undef, 1, 2], \"node\")",
  
    "Stack trace",
    "    1     6 dump"];
   }
  

=head2 Good($good)

A good ending.

     Parameter  Description
  1  $good      What to do on a good ending

B<Example:>


  if (1)                                                                            
   {Start 1;
    Block
     {my ($start, $good, $bad, $end) = @_;
      Out 1;
      Jmp $good;
     }
  
    Good  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {Out 2;
     },
    Bad
     {Out 3;
     };
    Out 4;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [1,2,4];
   }
  

=head2 IfEq($a, $b, %options)

Execute then or else clause depending on whether two memory locations are equal.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options   Then block

B<Example:>


  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
  
    IfEq $a, $a, Then {Out "Eq"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfNe $a, $a, Then {Out "Ne"};
    IfLe $a, $a, Then {Out "Le"};
    IfLt $a, $a, Then {Out "Lt"};
    IfGe $a, $a, Then {Out "Ge"};
    IfGt $a, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Eq", "Le", "Ge"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
  
    IfEq $a, $b, Then {Out "Eq"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfNe $a, $b, Then {Out "Ne"};
    IfLe $a, $b, Then {Out "Le"};
    IfLt $a, $b, Then {Out "Lt"};
    IfGe $a, $b, Then {Out "Ge"};
    IfGt $a, $b, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Le", "Lt"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
  
    IfEq $b, $a, Then {Out "Eq"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfNe $b, $a, Then {Out "Ne"};
    IfLe $b, $a, Then {Out "Le"};
    IfLt $b, $a, Then {Out "Lt"};
    IfGe $b, $a, Then {Out "Ge"};
    IfGt $b, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Ge", "Gt"];
   }
  

=head2 IfFalse($a, %options)

Execute then clause if the specified memory address is zero thus representing false.

     Parameter  Description
  1  $a         Memory address
  2  %options   Then block

B<Example:>


  if (1)                                                                            
   {Start 1;
  
    IfFalse 1,  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Then
     {Out 1
     },
    Else
     {Out 0
     };
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [0];
   }
  

=head2 IfGe($a, $b, %options)

Execute then or else clause depending on whether two memory locations are greater than or equal.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options   Then block

B<Example:>


  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $a, Then {Out "Eq"};
    IfNe $a, $a, Then {Out "Ne"};
    IfLe $a, $a, Then {Out "Le"};
    IfLt $a, $a, Then {Out "Lt"};
  
    IfGe $a, $a, Then {Out "Ge"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfGt $a, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Eq", "Le", "Ge"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $b, Then {Out "Eq"};
    IfNe $a, $b, Then {Out "Ne"};
    IfLe $a, $b, Then {Out "Le"};
    IfLt $a, $b, Then {Out "Lt"};
  
    IfGe $a, $b, Then {Out "Ge"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfGt $a, $b, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Le", "Lt"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $b, $a, Then {Out "Eq"};
    IfNe $b, $a, Then {Out "Ne"};
    IfLe $b, $a, Then {Out "Le"};
    IfLt $b, $a, Then {Out "Lt"};
  
    IfGe $b, $a, Then {Out "Ge"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfGt $b, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Ge", "Gt"];
   }
  

=head2 IfGt($a, $b, %options)

Execute then or else clause depending on whether two memory locations are greater than.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options   Then block

B<Example:>


  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $a, Then {Out "Eq"};
    IfNe $a, $a, Then {Out "Ne"};
    IfLe $a, $a, Then {Out "Le"};
    IfLt $a, $a, Then {Out "Lt"};
    IfGe $a, $a, Then {Out "Ge"};
  
    IfGt $a, $a, Then {Out "Gt"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Eq", "Le", "Ge"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $b, Then {Out "Eq"};
    IfNe $a, $b, Then {Out "Ne"};
    IfLe $a, $b, Then {Out "Le"};
    IfLt $a, $b, Then {Out "Lt"};
    IfGe $a, $b, Then {Out "Ge"};
  
    IfGt $a, $b, Then {Out "Gt"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Le", "Lt"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $b, $a, Then {Out "Eq"};
    IfNe $b, $a, Then {Out "Ne"};
    IfLe $b, $a, Then {Out "Le"};
    IfLt $b, $a, Then {Out "Lt"};
    IfGe $b, $a, Then {Out "Ge"};
  
    IfGt $b, $a, Then {Out "Gt"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Ge", "Gt"];
   }
  

=head2 IfNe($a, $b, %options)

Execute then or else clause depending on whether two memory locations are not equal.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options   Then block

B<Example:>


  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $a, Then {Out "Eq"};
  
    IfNe $a, $a, Then {Out "Ne"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfLe $a, $a, Then {Out "Le"};
    IfLt $a, $a, Then {Out "Lt"};
    IfGe $a, $a, Then {Out "Ge"};
    IfGt $a, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Eq", "Le", "Ge"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $b, Then {Out "Eq"};
  
    IfNe $a, $b, Then {Out "Ne"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfLe $a, $b, Then {Out "Le"};
    IfLt $a, $b, Then {Out "Lt"};
    IfGe $a, $b, Then {Out "Ge"};
    IfGt $a, $b, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Le", "Lt"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $b, $a, Then {Out "Eq"};
  
    IfNe $b, $a, Then {Out "Ne"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfLe $b, $a, Then {Out "Le"};
    IfLt $b, $a, Then {Out "Lt"};
    IfGe $b, $a, Then {Out "Ge"};
    IfGt $b, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Ge", "Gt"];
   }
  

=head2 IfLe($a, $b, %options)

Execute then or else clause depending on whether two memory locations are less than or equal.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options   Then block

B<Example:>


  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $a, Then {Out "Eq"};
    IfNe $a, $a, Then {Out "Ne"};
  
    IfLe $a, $a, Then {Out "Le"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfLt $a, $a, Then {Out "Lt"};
    IfGe $a, $a, Then {Out "Ge"};
    IfGt $a, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Eq", "Le", "Ge"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $b, Then {Out "Eq"};
    IfNe $a, $b, Then {Out "Ne"};
  
    IfLe $a, $b, Then {Out "Le"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfLt $a, $b, Then {Out "Lt"};
    IfGe $a, $b, Then {Out "Ge"};
    IfGt $a, $b, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Le", "Lt"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $b, $a, Then {Out "Eq"};
    IfNe $b, $a, Then {Out "Ne"};
  
    IfLe $b, $a, Then {Out "Le"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfLt $b, $a, Then {Out "Lt"};
    IfGe $b, $a, Then {Out "Ge"};
    IfGt $b, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Ge", "Gt"];
   }
  

=head2 IfLt($a, $b, %options)

Execute then or else clause depending on whether two memory locations are less than.

     Parameter  Description
  1  $a         First memory address
  2  $b         Second memory address
  3  %options   Then block

B<Example:>


  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $a, Then {Out "Eq"};
    IfNe $a, $a, Then {Out "Ne"};
    IfLe $a, $a, Then {Out "Le"};
  
    IfLt $a, $a, Then {Out "Lt"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfGe $a, $a, Then {Out "Ge"};
    IfGt $a, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Eq", "Le", "Ge"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $a, $b, Then {Out "Eq"};
    IfNe $a, $b, Then {Out "Ne"};
    IfLe $a, $b, Then {Out "Le"};
  
    IfLt $a, $b, Then {Out "Lt"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfGe $a, $b, Then {Out "Ge"};
    IfGt $a, $b, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Le", "Lt"];
   }
  
  if (1)                                                                                   
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    IfEq $b, $a, Then {Out "Eq"};
    IfNe $b, $a, Then {Out "Ne"};
    IfLe $b, $a, Then {Out "Le"};
  
    IfLt $b, $a, Then {Out "Lt"};  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfGe $b, $a, Then {Out "Ge"};
    IfGt $b, $a, Then {Out "Gt"};
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["Ne", "Ge", "Gt"];
   }
  

=head2 IfTrue($a, %options)

Execute then clause if the specified memory address is not zero thus representing true.

     Parameter  Description
  1  $a         Memory address
  2  %options   Then block

B<Example:>


  if (1)                                                                          
   {Start 1;
  
    IfTrue 1,  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Then
     {Out 1
     },
    Else
     {Out 0
     };
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [1];
   }
  

=head2 Inc($target)

Increment the target.

     Parameter  Description
  1  $target    Target address

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Mov 3;
  
    Inc $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out $a;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [4];
   }
  

=head2 Jeq($target, $source, $source2)

Jump to a target label if the first source field is equal to the second source field.

     Parameter  Description
  1  $target    Target label
  2  $source    Source to test
  3  $source2

B<Example:>


  if (1)                                                                                 
   {Start 1;
    my $a = Array "aaa";
    my $b = Array "bbb";
    Mov [$a, 0, 'aaa'], $b;
    Mov [$b, 0, 'bbb'], 99;
  
    For
     {my ($i, $check, $next, $end) = @_;
      my $c = Mov [$a, \0, 'aaa'];
      my $d = Mov [$c, \0, 'bbb'];
  
      Jeq $next, $d, $d;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Jne $next, $d, $d;
      Jle $next, $d, $d;
      Jlt $next, $d, $d;
      Jge $next, $d, $d;
      Jgt $next, $d, $d;
     } 3;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->analyzeExecutionResults(doubleWrite=>3), "#       24 instructions executed";
    is_deeply $e->memory, { 1=>  bless([2], "aaa"), 2=>  bless([99], "bbb") };
   }
  

=head2 JFalse($target, $source)

Jump to a target label if the first source field is equal to zero.

     Parameter  Description
  1  $target    Target label
  2  $source    Source to test

B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Mov 1;
    Block
     {my ($start, $good, $bad, $end) = @_;
      JTrue $end, $a;
      Out 1;
     };
    Block
     {my ($start, $good, $bad, $end) = @_;
  
      JFalse $end, $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Out 2;
     };
    Mov $a, 0;
    Block
     {my ($start, $good, $bad, $end) = @_;
      JTrue $end, $a;
      Out 3;
     };
    Block
     {my ($start, $good, $bad, $end) = @_;
  
      JFalse $end, $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Out 4;
     };
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2, 3];
   }
  

=head2 Jge($target, $source, $source2)

Jump to a target label if the first source field is greater than or equal to the second source field.

     Parameter  Description
  1  $target    Target label
  2  $source    Source to test
  3  $source2

B<Example:>


  if (1)                                                                                 
   {Start 1;
    my $a = Array "aaa";
    my $b = Array "bbb";
    Mov [$a, 0, 'aaa'], $b;
    Mov [$b, 0, 'bbb'], 99;
  
    For
     {my ($i, $check, $next, $end) = @_;
      my $c = Mov [$a, \0, 'aaa'];
      my $d = Mov [$c, \0, 'bbb'];
      Jeq $next, $d, $d;
      Jne $next, $d, $d;
      Jle $next, $d, $d;
      Jlt $next, $d, $d;
  
      Jge $next, $d, $d;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Jgt $next, $d, $d;
     } 3;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->analyzeExecutionResults(doubleWrite=>3), "#       24 instructions executed";
    is_deeply $e->memory, { 1=>  bless([2], "aaa"), 2=>  bless([99], "bbb") };
   }
  

=head2 Jgt($target, $source, $source2)

Jump to a target label if the first source field is greater than the second source field.

     Parameter  Description
  1  $target    Target label
  2  $source    Source to test
  3  $source2

B<Example:>


  if (1)                                                                                 
   {Start 1;
    my $a = Array "aaa";
    my $b = Array "bbb";
    Mov [$a, 0, 'aaa'], $b;
    Mov [$b, 0, 'bbb'], 99;
  
    For
     {my ($i, $check, $next, $end) = @_;
      my $c = Mov [$a, \0, 'aaa'];
      my $d = Mov [$c, \0, 'bbb'];
      Jeq $next, $d, $d;
      Jne $next, $d, $d;
      Jle $next, $d, $d;
      Jlt $next, $d, $d;
      Jge $next, $d, $d;
  
      Jgt $next, $d, $d;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     } 3;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->analyzeExecutionResults(doubleWrite=>3), "#       24 instructions executed";
    is_deeply $e->memory, { 1=>  bless([2], "aaa"), 2=>  bless([99], "bbb") };
   }
  

=head2 Jle($target, $source, $source2)

Jump to a target label if the first source field is less than or equal to the second source field.

     Parameter  Description
  1  $target    Target label
  2  $source    Source to test
  3  $source2

B<Example:>


  if (1)                                                                                 
   {Start 1;
    my $a = Array "aaa";
    my $b = Array "bbb";
    Mov [$a, 0, 'aaa'], $b;
    Mov [$b, 0, 'bbb'], 99;
  
    For
     {my ($i, $check, $next, $end) = @_;
      my $c = Mov [$a, \0, 'aaa'];
      my $d = Mov [$c, \0, 'bbb'];
      Jeq $next, $d, $d;
      Jne $next, $d, $d;
  
      Jle $next, $d, $d;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Jlt $next, $d, $d;
      Jge $next, $d, $d;
      Jgt $next, $d, $d;
     } 3;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->analyzeExecutionResults(doubleWrite=>3), "#       24 instructions executed";
    is_deeply $e->memory, { 1=>  bless([2], "aaa"), 2=>  bless([99], "bbb") };
   }
  

=head2 Jlt($target, $source, $source2)

Jump to a target label if the first source field is less than the second source field.

     Parameter  Description
  1  $target    Target label
  2  $source    Source to test
  3  $source2

B<Example:>


  if (1)                                                                                 
   {Start 1;
    my $a = Array "aaa";
    my $b = Array "bbb";
    Mov [$a, 0, 'aaa'], $b;
    Mov [$b, 0, 'bbb'], 99;
  
    For
     {my ($i, $check, $next, $end) = @_;
      my $c = Mov [$a, \0, 'aaa'];
      my $d = Mov [$c, \0, 'bbb'];
      Jeq $next, $d, $d;
      Jne $next, $d, $d;
      Jle $next, $d, $d;
  
      Jlt $next, $d, $d;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Jge $next, $d, $d;
      Jgt $next, $d, $d;
     } 3;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->analyzeExecutionResults(doubleWrite=>3), "#       24 instructions executed";
    is_deeply $e->memory, { 1=>  bless([2], "aaa"), 2=>  bless([99], "bbb") };
   }
  

=head2 Jmp($target)

Jump to a label.

     Parameter  Description
  1  $target    Target address

B<Example:>


  if (1)                                                                          
   {Start 1;
  
    Jmp (my $a = label);  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Out  1;
  
      Jmp (my $b = label);  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    setLabel($a);
      Out  2;
    setLabel($b);
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2];
   }
  

=head2 Jne($target, $source, $source2)

Jump to a target label if the first source field is not equal to the second source field.

     Parameter  Description
  1  $target    Target label
  2  $source    Source to test
  3  $source2

B<Example:>


  if (1)                                                                                 
   {Start 1;
    my $a = Array "aaa";
    my $b = Array "bbb";
    Mov [$a, 0, 'aaa'], $b;
    Mov [$b, 0, 'bbb'], 99;
  
    For
     {my ($i, $check, $next, $end) = @_;
      my $c = Mov [$a, \0, 'aaa'];
      my $d = Mov [$c, \0, 'bbb'];
      Jeq $next, $d, $d;
  
      Jne $next, $d, $d;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Jle $next, $d, $d;
      Jlt $next, $d, $d;
      Jge $next, $d, $d;
      Jgt $next, $d, $d;
     } 3;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->analyzeExecutionResults(doubleWrite=>3), "#       24 instructions executed";
    is_deeply $e->memory, { 1=>  bless([2], "aaa"), 2=>  bless([99], "bbb") };
   }
  

=head2 JTrue($target, $source)

Jump to a target label if the first source field is not equal to zero.

     Parameter  Description
  1  $target    Target label
  2  $source    Source to test

B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Mov 1;
    Block
     {my ($start, $good, $bad, $end) = @_;
  
      JTrue $end, $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Out 1;
     };
    Block
     {my ($start, $good, $bad, $end) = @_;
      JFalse $end, $a;
      Out 2;
     };
    Mov $a, 0;
    Block
     {my ($start, $good, $bad, $end) = @_;
  
      JTrue $end, $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Out 3;
     };
    Block
     {my ($start, $good, $bad, $end) = @_;
      JFalse $end, $a;
      Out 4;
     };
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2, 3];
   }
  

=head2 LoadAddress()

Load the address component of an address.


B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Array "array";
    my $b = Mov 2;
    my $c = Mov 5;
  
    my $d = LoadAddress $c;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $f = LoadArea    [$a, \0, 'array'];
  
    Out $d;
    Out $f;
  
    Mov [$a, \$b, 'array'], 22;
    Mov [$a, \$c, 'array'], 33;
    Mov [$f, \$d, 'array'], 44;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out,    [2,1];
    is_deeply $e->memory, {1=>[undef, undef, 44, undef, undef, 33]};
   }
  

=head2 LoadArea()

Load the area component of an address.


B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Array "array";
    my $b = Mov 2;
    my $c = Mov 5;
    my $d = LoadAddress $c;
  
    my $f = LoadArea    [$a, \0, 'array'];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out $d;
    Out $f;
  
    Mov [$a, \$b, 'array'], 22;
    Mov [$a, \$c, 'array'], 33;
    Mov [$f, \$d, 'array'], 44;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out,    [2,1];
    is_deeply $e->memory, {1=>[undef, undef, 44, undef, undef, 33]};
   }
  

=head2 Mov()

Copy a constant or memory address to the target address.


B<Example:>


  if (1)                                                                          
   {Start 1;
  
    my $a = Mov 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out $a;
  
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2];
   }
  
   {Start 1;                                                                      
  
  if (1)                                                                          
   {Start 1;
    my $a = Array "aaa";
  
    Mov     [$a,  1, "aaa"],  11;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Mov  1, [$a, \1, "aaa"];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out \1;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [11];
   }
  
  if (1)                                                                           
   {Start 1;
    my $a = Array "alloc";
  
    my $b = Mov 99;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    my $c = Mov $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Mov [$a, 0, 'alloc'], $b;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Mov [$c, 1, 'alloc'], 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    ok Execute(memory=>  { 1=>  bless([99, 2], "alloc") });
   }
  
  if (1)                                                                            
   {Start 1;
    my $a = Array "aaa";
    Dump "dddd";
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [
    "dddd",
    "-2=bless([], \"return\")",
    "-1=bless([], \"params\")",
    "0=bless([1], \"stackArea\")",
    "1=bless([], \"aaa\")",
    "Stack trace",
    "    1     2 dump"];
   }
  
  if (1)                                                                              
   {Start 1;
    my $a = Array "aaa";
  
    my $i = Mov 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    my $v = Mov 11;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    ParamsPut 0, $a;
    ParamsPut 1, $i;
    ParamsPut 2, $v;
    my $set = Procedure 'set', sub
     {my $a = ParamsGet 0;
      my $i = ParamsGet 1;
      my $v = ParamsGet 2;
  
      Mov [$a, \$i, 'aaa'], $v;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Return;
     };
    Call $set;
  
    my $V = Mov [$a, \$i, 'aaa'];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    AssertEq $v, $V;
    Out [$a, \$i, 'aaa'];
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [11];
   }
  
  if (1)                                                                            
   {Start 1;
    my $set = Procedure 'set', sub
     {my $a = ParamsGet 0;
      Out $a;
     };
    ParamsPut 0, 1;  Call $set;
    ParamsPut 0, 2;  Call $set;
    ParamsPut 0, 3;  Call $set;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [1..3];
   }
  
  if (1)                                                                                 
   {Start 1;
    my $a = Array "aaa";
    my $b = Array "bbb";
  
    Mov [$a, 0, 'aaa'], $b;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Mov [$b, 0, 'bbb'], 99;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    For
     {my ($i, $check, $next, $end) = @_;
  
      my $c = Mov [$a, \0, 'aaa'];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
      my $d = Mov [$c, \0, 'bbb'];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Jeq $next, $d, $d;
      Jne $next, $d, $d;
      Jle $next, $d, $d;
      Jlt $next, $d, $d;
      Jge $next, $d, $d;
      Jgt $next, $d, $d;
     } 3;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->analyzeExecutionResults(doubleWrite=>3), "#       24 instructions executed";
    is_deeply $e->memory, { 1=>  bless([2], "aaa"), 2=>  bless([99], "bbb") };
   }
  
  if (1)                                                                           
   {Start 1;
    my $a = Array 'aaa';
  
    my $b = Mov 2;                                                                # Location to move to in a  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    For
     {my ($i, $check, $next, $end) = @_;
  
      Mov [$a, \$b, 'aaa'], 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Jeq $next, [$a, \$b, 'aaa'], 1;
     } 3;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->analyzeExecutionResults(doubleWrite=>3), "#       19 instructions executed";
    is_deeply $e->memory, {1=>  bless([undef, undef, 1], "aaa")};
   }
  
  if (1)                                                                           
   {Start 1;
    my $a = Array "aaa";
  
      Mov [$a, 0, "aaa"], 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
      Mov [$a, 1, "aaa"], 22;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
      Mov [$a, 2, "aaa"], 333;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    ArrayDump $a, "AAAA";
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->out, [
    "AAAA",
    "bless([1, 22, 333], \"aaa\")",
    "Stack trace",
    "    1     5 arrayDump"];
   }
  

=head2 MoveLong($target, $source, $source2)

Copy the number of elements specified by the second source operand from the location specified by the first source operand to the target operand.

     Parameter  Description
  1  $target    Target of move
  2  $source    Source of move
  3  $source2   Length of move

B<Example:>


  if (1)                                                                          
   {my $N = 10;
    Start 1;
    my $a = Array "aaa";
    my $b = Array "bbb";
    For
     {my ($i, $Check, $Next, $End) = @_;
      Mov [$a, \$i, "aaa"], $i;
      my $j = Add $i, 100;
      Mov [$b, \$i, "bbb"], $j;
     } $N;
  
  
    MoveLong [$b, \2, 'bbb'], [$a, \4, 'aaa'], 3;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->memory, {
    1 => bless([0 .. 9], "aaa"),
    2 => bless([100, 101, 4, 5, 6, 105 .. 109], "bbb")};
   }
  

=head2 Not()

Move and not.


B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Mov 3;
  
    my $b = Not $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    my $c = Not $b;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out $a;
    Out $b;
    Out $c;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [3, "", 1];
   }
  

=head2 Nop()

Do nothing (but do it well!).


B<Example:>


  if (1)                                                                          
   {Start 1;
  
    Nop;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    ok Execute(out=>[]);
   }
  
  if (1)                                                                             
   {Start 1;
    my $a = Array "aaa";
      Mov [$a, 0, "aaa"], 1;
      Mov [$a, 1, "aaa"], 22;
      Mov [$a, 2, "aaa"], 333;
  
    my $n = ArraySize $a, "aaa";
    Out "Array size:"; Out $n;
    ArrayDump $a, "AAAA";
  
    ForArray
     {my ($i, $e, $check, $next, $end) = @_;
      Out $i; Out $e;
     }  $a, "aaa";
  
  
    Nop;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->memory, {1=>[1, 22, 333]};
  
    is_deeply $e->out, [ "Array size:", 3,
  
    "AAAA", "bless([1, 22, 333], \"aaa\")",
  
    "Stack trace",
    "    1     8 arrayDump",
  
    0,   1,
    1,  22,
    2, 333];
   }
  

=head2 Out($source)

Write memory location contents to out.

     Parameter  Description
  1  $source    Either a scalar constant or memory address to output

B<Example:>


  if (1)                                                                            
   {Start 1;
  
    Out "hello World";  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["hello World"];
   }
  

=head2 ParamsGet()

Get a word from the parameters in the previous frame and store it in the current frame.


B<Example:>


  if (1)                                                                              
   {Start 1;
    my $a = Array "aaa";
    my $i = Mov 1;
    my $v = Mov 11;
    ParamsPut 0, $a;
    ParamsPut 1, $i;
    ParamsPut 2, $v;
    my $set = Procedure 'set', sub
  
     {my $a = ParamsGet 0;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
      my $i = ParamsGet 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
      my $v = ParamsGet 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Mov [$a, \$i, 'aaa'], $v;
      Return;
     };
    Call $set;
    my $V = Mov [$a, \$i, 'aaa'];
    AssertEq $v, $V;
    Out [$a, \$i, 'aaa'];
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [11];
   }
  

=head2 ParamsPut($target, $source)

Put a word into the parameters list to make it visible in a called procedure.

     Parameter  Description
  1  $target    Parameter number
  2  $source    Address to fetch parameter from

B<Example:>


  if (1)                                                                              
   {Start 1;
    my $a = Array "aaa";
    my $i = Mov 1;
    my $v = Mov 11;
  
    ParamsPut 0, $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    ParamsPut 1, $i;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    ParamsPut 2, $v;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $set = Procedure 'set', sub
     {my $a = ParamsGet 0;
      my $i = ParamsGet 1;
      my $v = ParamsGet 2;
      Mov [$a, \$i, 'aaa'], $v;
      Return;
     };
    Call $set;
    my $V = Mov [$a, \$i, 'aaa'];
    AssertEq $v, $V;
    Out [$a, \$i, 'aaa'];
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [11];
   }
  

=head2 Pop(if (@_ == 0))

Pop the memory area specified by the source operand into the memory address specified by the target operand.

     Parameter     Description
  1  if (@_ == 0)  Pop current stack frame into a local variable

B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Array "aaa";
    Push $a, 1;
    Push $a, 2;
  
    my $c = Pop $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    my $d = Pop $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Out $c;
    Out $d;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out,    [2, 1];
    is_deeply $e->memory, { 1=>  []};
   }
  

=head2 Procedure($name, $source)

Define a procedure.

     Parameter  Description
  1  $name      Name of procedure
  2  $source    Source code as a subroutine# $assembly->instruction(action=>"procedure"

B<Example:>


  if (1)                                                                          
   {Start 1;
  
    my $add = Procedure 'add2', sub  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {my $a = ParamsGet 0;
      my $b = Add $a, 2;
      ReturnPut 0, $b;
      Return;
     };
    ParamsPut 0, 2;
    Call $add;
    my $c = ReturnGet 0;
    Out $c;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [4];
   }
  
  if (1)                                                                          
   {Start 1;
    for my $i(1..10)
     {Out $i;
     };
    IfTrue 0,
    Then
     {Out 99;
     };
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [1..10];
   }
  

=head2 Push()

Push the value in the current stack frame specified by the source operand onto the memory area identified by the target operand.


B<Example:>


  if (1)                                                                           
   {Start 1;
    my $a = Array "aaa";
  
    Push $a, 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    Push $a, 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    my $c = Pop $a;
    my $d = Pop $a;
  
    Out $c;
    Out $d;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out,    [2, 1];
    is_deeply $e->memory, { 1=>  []};
   }
  

=head2 Resize($target, $source)

Resize the target area to the source size.

     Parameter  Description
  1  $target    Target address
  2  $source    Source address

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Array 'aaa';
    Mov [$a, 0, 'aaa'], 1;
    Mov [$a, 1, 'aaa'], 2;
    Mov [$a, 2, 'aaa'], 3;
  
    Resize $a, 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->memory, {1=>  [1, 2]};
   }
  

=head2 Return()

Return from a procedure via the call stack.


B<Example:>


  if (1)                                                                           
   {Start 1;
    my $w = Procedure 'write', sub
     {Out 'aaa';
  
      Return;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     };
    Call $w;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["aaa"];
   }
  

=head2 ReturnGet(if (@_ == 1))

Get a word from the return area and save it.

     Parameter     Description
  1  if (@_ == 1)  Create a variable

B<Example:>


  if (1)                                                                            
   {Start 1;
    my $w = Procedure 'write', sub
     {ReturnPut 0, "ccc";
      Return;
     };
    Call $w;
  
    ReturnGet \0, 0;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out \0;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["ccc"];
   }
  

=head2 ReturnPut($target, $source)

Put a word into the return area.

     Parameter  Description
  1  $target    Offset in return area to write to
  2  $source    Memory address whose contents are to be placed in the return area

B<Example:>


  if (1)                                                                            
   {Start 1;
    my $w = Procedure 'write', sub
  
     {ReturnPut 0, "ccc";  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Return;
     };
    Call $w;
    ReturnGet \0, 0;
    Out \0;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["ccc"];
   }
  

=head2 ShiftDown(if (@_ == 1))

Shift an element down one in an area.

     Parameter     Description
  1  if (@_ == 1)  Create a variable

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Array "array";
    Mov [$a, 0, 'array'], 0;
    Mov [$a, 1, 'array'], 99;
    Mov [$a, 2, 'array'], 2;
  
  
    my $b = ShiftDown [$a, \1, 'array'];  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out $b;
  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->memory, {1=>[0, 2]};
    is_deeply $e->out,    [99];
   }
  

=head2 ShiftLeft(my ($target, $source)

Shift left within an element.

     Parameter    Description
  1  my ($target  Target to shift
  2  $source      Amount to shift

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Mov 1;
  
    ShiftLeft $a, $a;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out $a;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2];
   }
  

=head2 ShiftRight(my ($target, $source)

Shift right with an element.

     Parameter    Description
  1  my ($target  Target to shift
  2  $source      Amount to shift

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Mov 4;
  
    ShiftRight $a, 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out $a;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2];
   }
  

=head2 ShiftUp($target, $source)

Shift an element up one in an area.

     Parameter  Description
  1  $target    Target to shift
  2  $source    Amount to shift

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Array "array";
  
    Mov [$a, 0, 'array'], 0;
    Mov [$a, 1, 'array'], 1;
    Mov [$a, 2, 'array'], 2;
  
    ShiftUp [$a, 1, 'array'], 99;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

  
    my $e = Execute(suppressOutput=>1);
  
    is_deeply $e->memory, {1=>[0, 99, 1, 2]};
   }
  

=head2 Start($version)

Start the current assembly using the specified version of the Zero language.  At  the moment only version 1 works.

     Parameter  Description
  1  $version   Version desired - at the moment only 1

B<Example:>


  if (1)                                                                            
  
   {Start 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out "hello World";
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, ["hello World"];
   }
  

=head2 Subtract($target, $s1, $s2)

Subtract the second source operand value from the first source operand value and store the result in the target area.

     Parameter  Description
  1  $target    Target address
  2  $s1        Source one
  3  $s2        Source two

B<Example:>


  if (1)                                                                          
   {Start 1;
  
    my $a = Subtract 4, 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Out $a;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2];
   }
  

=head2 Tally($source)

Counts instructions when enabled.

     Parameter  Description
  1  $source    Tally instructions when true

B<Example:>


  if (1)                                                                           
   {my $N = 5;
    Start 1;
    For
  
     {Tally 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      my $a = Mov 1;
  
      Tally 2;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

      Inc $a;
  
      Tally 0;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     } $N;
    my $e = Execute;
  
    is_deeply $e->tallyCount, 2 * $N;
    is_deeply $e->tallyCounts, { 1 => {mov => $N}, 2 => {inc => $N}};
   }
  

=head2 Then($t)

Then block.

     Parameter  Description
  1  $t         Then block subroutine

B<Example:>


  if (1)                                                                            
   {Start 1;
    Trace 1;
    IfEq 1, 2,
  
    Then  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {Mov 1, 1;
      Mov 2, 1;
     },
    Else
     {Mov 3, 3;
      Mov 4, 4;
     };
    IfEq 2, 2,
  
    Then  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

     {Mov 1, 1;
      Mov 2, 1;
     },
    Else
     {Mov 3, 3;
      Mov 4, 4;
     };
    my $e = Execute(suppressOutput=>1);
    is_deeply scalar($e->out->@*), 14;
   }
  

=head2 Trace($source)

Start or stop tracing.  Tracing prints each instruction executed and its effect on memeory.

     Parameter  Description
  1  $source    Trace setting

B<Example:>


  if (1)                                                                            
   {Start 1;
  
    Trace 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    IfEq 1, 2,
    Then
     {Mov 1, 1;
      Mov 2, 1;
     },
    Else
     {Mov 3, 3;
      Mov 4, 4;
     };
    IfEq 2, 2,
    Then
     {Mov 1, 1;
      Mov 2, 1;
     },
    Else
     {Mov 3, 3;
      Mov 4, 4;
     };
    my $e = Execute(suppressOutput=>1);
    is_deeply scalar($e->out->@*), 14;
   }
  

=head2 TracePoints($source)

Enable or disable trace points.  If trace points are enabled a stack trace is printed for each instructyion executed showing the call stack at the time the instruction was generated as well as the current stack frames.

     Parameter  Description
  1  $source    Trace points if true

B<Example:>


  if (1)                                                                          
   {my $N = 5;
    Start 1;
  
    TracePoints 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    For
     {my $a = Mov 1;
      Inc $a;
     } $N;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [
  
    "TracePoints: 1",  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    "Trace",
    "    1     6 tracePoint",
    "Trace",
    "    1     6 tracePoint",
    "Trace",
    "    1     6 tracePoint",
    "Trace",
    "    1     6 tracePoint",
    "Trace",
    "    1     6 tracePoint"];
   }
  

=head2 Var($value)

Create a variable initialized to the specified value.

     Parameter  Description
  1  $value     Value

B<Example:>


  if (1)                                                                          
   {Start 1;
  
    my $a = Var 1;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    AssertEq $a, 1;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [];
   }
  

=head2 Watch($target)

Watches for changes to the specified memory location.

     Parameter  Description
  1  $target    Memory address to watch

B<Example:>


  if (1)                                                                          
   {Start 1;
    my $a = Mov 1;
    my $b = Mov 2;
    my $c = Mov 3;
  
    Watch $b;  # ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²

    Mov $a, 4;
    Mov $b, 5;
    Mov $c, 6;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [
    "Change at watched area: 0 (stackArea), address: 1",
    "    1     6 mov",
    "Current value: 2",
    "New     value: 5",
    "-2=bless([], \"return\")",
    "-1=bless([], \"params\")",
    "0=bless([4, 2, 3], \"stackArea\")"];
   }
  


=head1 Private Methods

=head2 Assert1($op, $a)

Assert operation.

     Parameter  Description
  1  $op        Operation
  2  $a         Source operand

=head2 Assert2($op, $a, $b)

Assert operation.

     Parameter  Description
  1  $op        Operation
  2  $a         First memory address
  3  $b         Second memory address

=head2 Ifx($cmp, $a, $b, %options)

Execute then or else clause depending on whether two memory locations are equal.

     Parameter  Description
  1  $cmp       Comparison
  2  $a         First memory address
  3  $b         Second memory address
  4  %options   Then block

=head2 Label($source)

Create a label.

     Parameter  Description
  1  $source    Name of label

B<Example:>


  if (1)                                                                           
   {Start 1;
    Mov 0, 1;
    Jlt ((my $a = label), \0, 2);
      Out  1;
      Jmp (my $b = label);
    setLabel($a);
      Out  2;
    setLabel($b);
  
    Jgt ((my $c = label), \0, 3);
      Out  1;
      Jmp (my $d = label);
    setLabel($c);
      Out  2;
    setLabel($d);
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [2,1];
   }
  
  if (1)                                                                          
   {Start 1;
    Mov 0, 0;
    my $a = setLabel;
      Out \0;
      Inc \0;
    Jlt $a, \0, 10;
    my $e = Execute(suppressOutput=>1);
    is_deeply $e->out, [0..9];
   }
  

=head2 TracePoint(%options)

Trace point - a point in the code where the flow of execution might change.

     Parameter  Description
  1  %options   Parameters


=head1 Index


1 L<Add|/Add> - Add the source locations together and store the result in the target area.

2 L<Array|/Array> - Create a new memory area and write its number into the address named by the target operand.

3 L<ArrayCountGreater|/ArrayCountGreater> - Count the number of elements in the array specified by the first source operand that are greater than the element supplied by the second source operand and place the result in the target location.

4 L<ArrayCountLess|/ArrayCountLess> - Count the number of elements in the array specified by the first source operand that are less than the element supplied by the second source operand and place the result in the target location.

5 L<ArrayDump|/ArrayDump> - Dump an array.

6 L<ArrayIndex|/ArrayIndex> - Find the 1 based index of the second source operand in the array referenced by the first source operand if it is present in the array else 0 into the target location.

7 L<ArraySize|/ArraySize> - The current size of an array.

8 L<Assert|/Assert> - Assert regardless.

9 L<Assert1|/Assert1> - Assert operation.

10 L<Assert2|/Assert2> - Assert operation.

11 L<AssertEq|/AssertEq> - Assert two memory locations are equal.

12 L<AssertFalse|/AssertFalse> - Assert false.

13 L<AssertGe|/AssertGe> - Assert are greater than or equal.

14 L<AssertGt|/AssertGt> - Assert two memory locations are greater than.

15 L<AssertLe|/AssertLe> - Assert two memory locations are less than or equal.

16 L<AssertLt|/AssertLt> - Assert two memory locations are less than.

17 L<AssertNe|/AssertNe> - Assert two memory locations are not equal.

18 L<AssertTrue|/AssertTrue> - Assert true.

19 L<Bad|/Bad> - A bad ending.

20 L<Block|/Block> - Block of code that can either be restarted or come to a good or a bad ending.

21 L<Call|/Call> - Call the subroutine at the target address.

22 L<Clear|/Clear> - Clear the first bytes of an area.

23 L<Confess|/Confess> - Confess with a stack trace showing the location bioth in the emulated code and in the code that produced the emulated code.

24 L<Dec|/Dec> - Decrement the target.

25 L<Dump|/Dump> - Dump all the arrays currently in memory.

26 L<Else|/Else> - Else block.

27 L<Execute|/Execute> - Execute the current assembly.

28 L<For|/For> - For loop 0.

29 L<ForArray|/ForArray> - For loop to process each element of the named area.

30 L<Free|/Free> - Free the memory area named by the target operand after confirming that it has the name specified on the source operand.

31 L<Good|/Good> - A good ending.

32 L<IfEq|/IfEq> - Execute then or else clause depending on whether two memory locations are equal.

33 L<IfFalse|/IfFalse> - Execute then clause if the specified memory address is zero thus representing false.

34 L<IfGe|/IfGe> - Execute then or else clause depending on whether two memory locations are greater than or equal.

35 L<IfGt|/IfGt> - Execute then or else clause depending on whether two memory locations are greater than.

36 L<IfLe|/IfLe> - Execute then or else clause depending on whether two memory locations are less than or equal.

37 L<IfLt|/IfLt> - Execute then or else clause depending on whether two memory locations are less than.

38 L<IfNe|/IfNe> - Execute then or else clause depending on whether two memory locations are not equal.

39 L<IfTrue|/IfTrue> - Execute then clause if the specified memory address is not zero thus representing true.

40 L<Ifx|/Ifx> - Execute then or else clause depending on whether two memory locations are equal.

41 L<Inc|/Inc> - Increment the target.

42 L<Jeq|/Jeq> - Jump to a target label if the first source field is equal to the second source field.

43 L<JFalse|/JFalse> - Jump to a target label if the first source field is equal to zero.

44 L<Jge|/Jge> - Jump to a target label if the first source field is greater than or equal to the second source field.

45 L<Jgt|/Jgt> - Jump to a target label if the first source field is greater than the second source field.

46 L<Jle|/Jle> - Jump to a target label if the first source field is less than or equal to the second source field.

47 L<Jlt|/Jlt> - Jump to a target label if the first source field is less than the second source field.

48 L<Jmp|/Jmp> - Jump to a label.

49 L<Jne|/Jne> - Jump to a target label if the first source field is not equal to the second source field.

50 L<JTrue|/JTrue> - Jump to a target label if the first source field is not equal to zero.

51 L<Label|/Label> - Create a label.

52 L<LoadAddress|/LoadAddress> - Load the address component of an address.

53 L<LoadArea|/LoadArea> - Load the area component of an address.

54 L<Mov|/Mov> - Copy a constant or memory address to the target address.

55 L<MoveLong|/MoveLong> - Copy the number of elements specified by the second source operand from the location specified by the first source operand to the target operand.

56 L<Nop|/Nop> - Do nothing (but do it well!).

57 L<Not|/Not> - Move and not.

58 L<Out|/Out> - Write memory location contents to out.

59 L<ParamsGet|/ParamsGet> - Get a word from the parameters in the previous frame and store it in the current frame.

60 L<ParamsPut|/ParamsPut> - Put a word into the parameters list to make it visible in a called procedure.

61 L<Pop|/Pop> - Pop the memory area specified by the source operand into the memory address specified by the target operand.

62 L<Procedure|/Procedure> - Define a procedure.

63 L<Push|/Push> - Push the value in the current stack frame specified by the source operand onto the memory area identified by the target operand.

64 L<Resize|/Resize> - Resize the target area to the source size.

65 L<Return|/Return> - Return from a procedure via the call stack.

66 L<ReturnGet|/ReturnGet> - Get a word from the return area and save it.

67 L<ReturnPut|/ReturnPut> - Put a word into the return area.

68 L<ShiftDown|/ShiftDown> - Shift an element down one in an area.

69 L<ShiftLeft|/ShiftLeft> - Shift left within an element.

70 L<ShiftRight|/ShiftRight> - Shift right with an element.

71 L<ShiftUp|/ShiftUp> - Shift an element up one in an area.

72 L<Start|/Start> - Start the current assembly using the specified version of the Zero language.

73 L<Subtract|/Subtract> - Subtract the second source operand value from the first source operand value and store the result in the target area.

74 L<Tally|/Tally> - Counts instructions when enabled.

75 L<Then|/Then> - Then block.

76 L<Trace|/Trace> - Start or stop tracing.

77 L<TracePoint|/TracePoint> - Trace point - a point in the code where the flow of execution might change.

78 L<TracePoints|/TracePoints> - Enable or disable trace points.

79 L<Var|/Var> - Create a variable initialized to the specified value.

80 L<Watch|/Watch> - Watches for changes to the specified memory location.

=head1 Installation

This module is written in 100% Pure Perl and, thus, it is easy to read,
comprehend, use, modify and install via B<cpan>:

  sudo cpan install Zero::Emulator

=head1 Author

L<philiprbrenan@gmail.com|mailto:philiprbrenan@gmail.com>

L<http://www.appaapps.com|http://www.appaapps.com>

=head1 Copyright

Copyright (c) 2016-2023 Philip R Brenan.

This module is free software. It may be used, redistributed and/or modified
under the same terms as Perl itself.

=cut
