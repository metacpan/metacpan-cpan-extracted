=pod

=head1 Overview

=head2 Before 0.3.0

The following are planned as part of the 0.3.0 release.

=over

=item Script incremental builds (done)

=item Script attribute reporting (done)

=item Documentation rewrite (done)

=item Goal scheduling (done)

=item Attribute average values (done)

=item Node filtering for average values (done)

=item Attribute support modulus operator (done)

=item Script attribute grid for averages (done)

=item Per-activity goals (done)

=item Script incremental build supports configuration overwrite (done)

=item Goals support attribute weighting (done)

=item Automatic attributes per node (maybe)

=back

=head1 Features

=head2 Goals

Scheduling goals are available starting with 0.2.4.  Only attribute-based, average value goals seeking is planned at this time.

Per-activity goals are experimental starting with 0.2.7.  Commandline support and attribute weighting is available with 0.2.8.

=head2 Attributes

Attribute recomputation is supported starting with 0.2.2, primarily for merged annotation support.

Attribute average values are available for goals starting with 0.2.5, which also cleaned up behavioral questions about initial average values, and averages during time overlaps.  See L<Schedule::Activity/Consistency>.

Attribute reporting supports many different output formats starting in 0.2.7.

JSON output from the script is being considered, and would include JSON renderings of the attribute outputs.

Attributes that are internal and automatic per node are being considered.  These attributes would always be of the form C<ACT:node name>, with a configurable prefix.  Such attributes would permit node filtering based on the previous appearance of nodes, without needing to create a separate named attribute.  Coupled with the modulus operator, a node could be activated "every N appearances", for example.

=head2 Node filtering

Average value filtering is available starting with 0.2.5.  Floating-point modulus is available starting with 0.2.6.

=head2 Annotations

Annotation filtering.  Some annotations may occur before an action but not when after certain other actions.  Annotations should support node filtering for this situation.  No timeline has been established.

Annotations may also benefit from a schedule-wide closeness configuration, but no timeline has been established.

=head2 Scheduling

Incremental scheduling is available in the module and from the commandline starting with 0.2.1.  Attribute recomputation is supported for materialized annotations starting with 0.2.2.  Ideally a finalized savefile could also store materialized annotations, but no timeline has been established.

Weighting for the C<next> array is being considered.

=head2 Tension configuration

Tension should also be configurable in the outer scheduling step.  This would permit incrementally relaxing the scheduler in case of retries.  No timeline has been established.

=head2 Tutorial

A basic tutorial and sample configuration is provided starting with 0.2.0.  It may be extended, but there is no timeline.

=head2 Action limits

The case C<limit=1> is not the primary/initial use case of this scheduler, but some events will likely never be repeated.  This can already be achieved by setting the attribute to zero initially, incrementing as appropriate, and then filtering.  Because there's a difference between limit-per-activity and limit-per-schedule, it's not clear that a special mechanism will be created.

=head2 Slack/buffer defaults

As an improvement, support passing slack/buffer ratios during configuration building.  Eventually it will be helpful to pass slack/buffer defaults as part of schedule building:  Having a value used during schedule building would permit relaxation during retries, and could be reported with the result.  This requires changing assumptions in the validators.

=head2 Pre-scheduling safety

No known issues at this time.

=head2 Markdown

Basic Markdown support is likely to change in non-backwards-compatible ways.  A written proposal might be posted to ensure support for the common use cases that would aide with faster definitions and imports.

=head2 Sample text to speech tool

An HTML+Javascript solution utilizing Web text to speech already exists to handle reminders for schedules of the form C<hh:mm:ss message # comment> and could be provided in C<samples/>.

=head2 Additional samples

First, something like a music playlist is similar to the base case here.  This is a "large number of random choices" but "each is very fixed in time length".  There are multiple potential actions to be randomized.  Music has attributes (mood).  Scheduling can be arranged in chunks (activities), so there are natural groupings for an arrangement.  Scheduling requires Action limits, above, so currently this is slightly difficult and/or requires a helper import mechanism to build the schedules.  Moreover, the slack/buffer mechanisms operate 'backwards', in the sense that music+pause periods are fixed and may be impossible to schedule within a fixed/given window of time (hence the common patterns of advertisements between songs and fade-in/out techniques).  It's not clear that an arithmetic equivalent of fading will ever be supported in this library.  Nevertheless, a "playlist import" type mechanism to build the configurations would be helpful.

Second, something like holiday activities.  This is a "small number of choices" but "each is very fluid in length" and has C<limit=1>.  An import tool for this type of request should be rather easy, but Action limits are a prerequisite.

Third, scheduling of paired events is not straightforward.  An example would be match-off lineups of N teams (eg fantasy leagues).  That is less a concern of temporal scheduling and more about uniformity in the lineup.  This is possible by running two simultaneous builders on the same configuration, with very fixed times, but may result in self-alignment of activities.  It's not clear that this type of scheduling will ever be supported in this library.

Fourth, this may be useful as a test generation tool.  The C<prove> command already supports shuffling, but for load and performance testing it's often useful to rerun test workloads and workflows in seemingly random order.  This mimics traffic patterns more accurately since similar requests can appear frequently.  Nothing in the existing code mandates the unit of time as "seconds", and message objects can be used to represent sequential tests, or a queue potentially offloaded to a number of parallel workers.

=head1 Functional improvements

=head2 Annotation validation

Annotations need better pre-scheduling validation and better separation from the main scheduling code.  Currently unclear of the best place to provide those helpers, as well as annotation-group-merging functions and the associated configurations.

=head2 Slackless/Bufferless configurations

Goals can never be met if slack/buffers are zero and the activity time requested doesn't exactly match action choices.  This should likely fail with an error similar to the convenience functions mentioned above.

=head2 Backtracking behavior

The current mechanism is primarily for safety.  Better backtracking support should be possible.

=head2 Performance

Both processing time and memory have been secondary considerations in initial versions.  Some optimizations are possible, particularly with rolling averages and the main scheduling algorithm.

=cut
