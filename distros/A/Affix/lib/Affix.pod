=pod

=encoding utf-8

=head1 NAME

Affix - A Foreign Function Interface eXtension

=head1 SYNOPSIS

    use v5.40;
    use Affix qw[:all];

    # Load a Library
    # Affix finds the system math library automatically
    my $libm = libm();

    # Bind Functions
    # double pow(double x, double y);
    affix $libm, 'pow', [Double, Double] => Double;

    # Call from Perl
    warn pow(2.0, 10.0); # 1024

    # Wrap an exported function in a code reference
    my $bar = wrap( 'libfoo', 'bar', [Str, Float] => Double );

    # Call from Perl
    print $bar->( 'Baz', 3.14 );

    # Bind an exported value to a Perl value
    pin( my $ver, 'libfoo', 'VERSION', Int );

    # Read the value
    say $ver;

    # Write to it too
    $ver = 9;

    # Complex Types (Structs)
    # typedef struct { int x, y; int w, h; } Rect;
    typedef Rect => Struct [
        x => Int, y => Int,
        w => Int, h => Int
    ];

    # void draw_rect(Rect r);
    affix $lib, 'draw_rect', [ Rect() ] => Void;

    # Pass a simple HashRef - Affix marshals it automatically
    draw_rect( { x => 10, y => 10, w => 100, h => 50 } );

    # High performance memory
    # For hot loops, allocate once and reuse
    my $rect_ptr = calloc(1, Rect());

    # Create views into the memory for fast updates
    my $ptr_x = cast( $rect_ptr, Pointer[Int] );

    while ($running) {
        # Pointer arithmetic and dereferencing
        my $next_int = ptr_add($ptr_x, 4);
        $$next_int = 99;

        draw_rect($rect_ptr);  # Pass the pointer
    }

=head1 DESCRIPTION

B<Affix> is a modern Foreign Function Interface (FFI) that allows Perl to call functions exported by dynamic libraries
(DLLs, .so files, dylibs) developed in C, C++, Rust, Zig, Fortran, Assembly, and others without writing XS code.

It is built on top of B<infix>, a lightweight C-based JIT engine designed specifically for zero-overhead calls. Affix
handles the complex ABI details of passing Structs, Arrays, and Callbacks by value or reference, on Windows, macOS,
Linux, and BSD, on both x64 and AArch64.

=head1 EXPORTS

No functions are exported by default. You may import them individually or using tags.

    use Affix qw[:all];     # Everything
    use Affix qw[:types];   # Int, Float, Struct, Pointer, Enum...
    use Affix qw[:memory];  # malloc, free, cast, dump, ptr_add...
    use Affix qw[:lib];     # load_library, find_symbol, get_last_error_message...
    use Affix qw[:pin];     # pin, unpin

=head1 THE BASICS

Affix's API is designed to be expressive. Let's start at the beginning with the eponymous C<affix( ... )> function.

=head2 C<affix( ... )>

Attaches a given symbol to a named perl sub in the current namespace.

    affix libm, 'pow', [Double, Double] => Double;
    warn pow( 3, 5 );

    affix libc, 'puts', [String], Int;
    puts( 'Hello' );

    # Rename a function during import
    affix './mylib.dll', ['output', 'write'], [String], Int;
    write( 'Hello' );

    # Use current process symbols (e.g. standard C library)
    affix undef, [ 'rint', 'round' ], [Double], Double;
    warn round(3.14);

Parameters:

=over

=item C<$lib> - required

A library handle returned by L</load_library( $path )>, a file path string, or C<undef> (to pull functions from the
main executable).

=item C<$symbol_name> - required

Name of the symbol to wrap.

If you pass a string, Affix will try to load the symbol with that exact name.

If you pass an array reference (e.g., C<['real_name', 'alias']>), Affix will look up C<real_name> in the library but
install the subroutine as C<alias> in your Perl package.

=item C<$parameters> - required

An array reference of argument types. See L</TYPES> for the full list (primitives, Struct, Pointer, etc.).

If you pass an empty array C<[]>, Affix assumes the function takes no arguments.

=item C<$return> - required

A single return type for the function. Use C<Void> if the function returns nothing.

=back

On success, C<affix( ... )> installs the subroutine and returns the generated code reference.

=head2 C<wrap( ... )>

Creates a wrapper around a given symbol but returns it as an anonymous CodeRef.

    my $pow = wrap libm, 'pow', [Double, Double] => Double;
    warn $pow->(5, 10); # 5**10

Arguments are nearly identical to L</affix( ... )>. C<wrap( ... )> allows you to use FFI functions without polluting
your namespace which means you cannot rename the function with an alias.

=begin :experimental

=head2 C<direct_affix( ... )>

Same as C<affix>, but uses the 'direct marshalling' backend. This generates a specialized JIT trampoline that accesses
Perl SVs directly, avoiding intermediate argument processing. This is experimental but significantly faster for
primitives.

=head2 C<direct_wrap( ... )>

Same as C<wrap>, but uses the "Direct Marshalling" backend.

=end :experimental

=head2 C<pin( ... )>

    my $errno;
    pin $errno, libc, 'errno', Int;
    print $errno;
    $errno = 0;

Variables exported by a library - also referred to as "global" or "extern" variables - can be accessed using C<pin( ...
)>. The above example code applies magic to C<$errno> that binds it to the integer variable named "errno" as exported
by the C runtime. Reading the scalar reads the memory; writing to it writes to the memory.

Parameters:

=over

=item C<$var> - required

The scalar that will be bound to the exported variable.

=item C<$lib> - required

The library handle or path.

=item C<$symbol_name> - required

Name of the exported variable.

=item C<$type> - required

Indicate to Affix what type of data the variable contains.

=back

This is might be broken on BSDs. I don't run BSD to figure out if it's impossible but patches are welcome.

=head2 C<unpin( ... )>

    unpin $errno;

Removes the magic applied by C<pin( ... )> to a variable. The variable retains its last value but is no longer linked
to C memory.

=head2 C<typedef( ... )>

    typedef MyType => Struct[ name => String, age => Int ];

    # Use it
    affix $lib, 'func', [ MyType() ] => Void;

Registers a named type alias in the Affix system. This is required for:

=over 4

=item 1.

B<Recursive Types>: A struct that contains a pointer to itself.

=item 2.

B<Reusability>: Defining a complex signature once and using it in multiple functions.

=item 3.

B<Smart Enums>: Generating Perl constants in your package.

=back

=head1 LIBRARY FUNCTIONS

Locating libraries on different platforms can be tricky. These utilities help you load and manage dynamic libraries.

They are exported by default but may be imported specifically with the C<:lib> tag.

=head2 C<load_library( $path )>

    my $lib = load_library('user32.dll');

Locates and loads a dynamic library, returning an opaque handle (C<Affix::Lib>).

If you pass a name without an extension (e.g., 'm'), Affix will apply platform-specific prefixes and suffixes (e.g.,
'libm.so', 'libm.dylib', 'm.dll') and search standard system paths.

=head2 C<locate_lib( $name, [$version] )>

    my $path = locate_lib('ssl', '1.1');

Searches system paths (LD_LIBRARY_PATH, PATH, DYLD_LIBRARY_PATH, etc.) and returns the full absolute path to the
library file, without loading it.

=head2 C<find_symbol( $lib, $name )>

Returns the raw memory address (as a pointer/integer) of a symbol within a loaded library.

=head2 C<get_last_error_message( )>

Returns a human-readable string describing the most recent error that occurred during library loading or symbol lookup.

=head2 C<libc()> / C<libm()>

Convenience functions that return handles to the standard C library and Math library, respectively.

=head1 MEMORY FUNCTIONS

Affix uses a concept I decided to call B<pins> to manage C pointers safely. A pin is a magical scalar reference that
holds a raw memory address.

Memory functions are exported via the C<:memory> or C<:all> tags.

=head2 C<malloc( ... )>

    my $ptr = malloc( $size );

Allocates C<$size> bytes of uninitialized storage.

Returns a managed pin. When this variable goes out of scope in Perl, the memory is automatically freed.

=head2 C<calloc( ... )>

    my $ptr = calloc( $num, $size_or_type );

Allocates memory for an array of C<$num> objects and initializes them to zero. You may pass a type object (like C<Int>)
as the second argument, and Affix will calculate the size for you. Returns a managed pin.

=head2 C<realloc( ... )>

    $ptr = realloc( $ptr, $new_size );

Reallocates the given area of memory. Returns the new pointer (which may be different from the original). The original
pointer object is updated to point to the new address.

=head2 C<free( ... )>

    free( $ptr );

Manually deallocates the space pointed to by C<$ptr>.

B<Note:> This only works on managed pins created by Affix. Attempting to free a pointer returned by a C library (which
probably uses the system allocator) will throw an exception to prevent heap corruption. To free C memory, you should
bind the library's C<free> function.

=head2 C<cast( ... )>

    my $int_ptr = cast( $void_ptr, Pointer[Int] );

Reinterprets a pointer.

=over

=item *

B<To value:> If casting to a value type (C<Int>, C<String>, etc.), it immediately reads the memory and returns a Perl
scalar value.

=item *

B<To reference:> If casting to a Pointer or other aggregate type, it returns a new pin that aliases the same memory.
You can dereference this pin (C<$$pin>) to read or write to the memory using the new type definition.

=back

=head2 C<own( ... )>

    own( $ptr, $bool );

Changes the ownership status of a pin.

=over

=item *

C<own($p, 1)>: Perl takes ownership. The memory will be freed when C<$p> goes out of scope.

=item *

C<own($p, 0)>: Perl relinquishes ownership. The memory will B<not> be freed by Perl. Use this when passing a buffer to
a C function that takes ownership of it.

=back

=head2 C<address( $ptr )>

Returns the numerical virtual memory address of a pointer as a C<UInt64> (probably).

=head2 Pointer Utilities

=over

=item C<ptr_add( $ptr, $offset_bytes )>

Returns a new unmanaged pin pointing C<$offset_bytes> from the original. If the original pin is an Array type (e.g.,
C<[10:int]>), the new pin decays to a Pointer type (e.g., C<*int>).

=item C<ptr_diff( $ptr1, $ptr2 )>

Returns the difference in bytes between two pointers (C<$ptr1 - $ptr2>).

=item C<is_null( $ptr )>

Returns true if the pointer is NULL (0x0).

=item C<strdup( $string )>

Allocates managed C memory and copies the Perl string into it (including the null terminator). Returns a
C<Pointer[Char]> pin.

=item C<strnlen( $ptr, $maxlen )>

Calculates the length of a C string pointed to by C<$ptr>, checking at most C<$maxlen> bytes.

=back

=head2 Raw Memory Ops

Standard C memory operations are available for high-performance manipulation of Pins.

=over

=item C<memchr( $ptr, $ch, $count )>

=item C<memcmp( $lhs, $rhs, $count )>

=item C<memset( $dest, $ch, $count )>

=item C<memcpy( $dest, $src, $count )>

=item C<memmove( $dest, $src, $count )>

=back

=head2 C<dump( $ptr, $length )>

Dumps C<$length> bytes of raw data from a given point in memory to STDOUT in a hex editor style. Useful for debugging
layout issues.

=head1 INTROSPECTION

=head2 C<sizeof( ... )>

    my $size = sizeof( Int );
    my $size_rect = sizeof( Struct[ x => Int, y => Int ] );

Returns the size, in bytes, of the Type passed to it.

=head2 C<offsetof( ... )>

    my $struct = Struct[ name => String, age => Int ];
    my $offset = offsetof( $struct, 'age' );

Returns the byte offset of a field within a structure, accounting for platform alignment and padding.

=head2 C<alignof( ... )>

Returns the alignment requirement (in bytes) of a type.

=head2 C<types()>

Returns a list of all named types currently registered in the Affix system.

=head1 TYPES

Affix uses type helpers to define signatures. These are exported via the C<:types> tag.

    # Example Signature
    [ Int, String ] => Void

=head2 Primitive Types

Primitives map to native C types.

    Type        Description
    ----------------------------------------------------------------------------
    Void        Return type only
    Bool        Mapped to Perl true/false
    Char        signed char (8-bit usually)
    UChar       unsigned char
    SChar       Explicitly signed char
    Short       signed short
    UShort      unsigned short
    Int         signed int (platform native, usually 32-bit)
    UInt        unsigned int
    Long        signed long (32-bit on Win64, 64-bit on Linux64)
    ULong       unsigned long
    LongLong    signed long long (guaranteed 64-bit)
    ULongLong   unsigned long long
    Float       32-bit float
    Double      64-bit float
    LongDouble  Platform specific (80-bit or 128-bit)
    Size_t      size_t
    SSize_t     ssize_t

=head3 Explicit Width Types

For precise control, use these types which are guaranteed to have specific bit widths across all platforms:

    Int8, UInt8
    Int16, UInt16
    Int32, UInt32
    Int64, UInt64
    Int128, UInt128 (Passed as Decimal Strings)

=head2 Pointers

Pointers are the glue of C. Affix provides distinct ways to handle them based on intent.

=head3 Basic Pointers (C<Pointer[Type]>)

When a function expects C<int*> or C<double*>, pass a B<reference to a scalar>.

    # C: void split_float(double val, int* whole, double* frac);
    affix $lib, 'split_float', [ Double, Pointer[Int], Pointer[Double] ] => Void;

    my ($whole, $frac);
    split_float( 3.14, \$whole, \$frac );

    say "Whole: $whole, Frac: $frac"; # Whole: 3, Frac: 0.14

Affix automatically:

=over 4

=item 1. Allocates temporary memory.

=item 2. Copies the Perl value into it (if defined).

=item 3. Passes the pointer to C.

=item 4. Copies the result back into your Perl scalar after the call.

=back

=head3 Strings (C<String> vs C<Pointer[Char]>)

=over 4

=item * B<C<String>>: Use this for C<const char*> (input strings). Affix copies the Perl string to a temporary C buffer.

=item * B<C<Pointer[Char]>>: Use this for mutable strings C<char*>. You must ensure the scalar passed has enough pre-allocated capacity (e.g. using C<"\0" x 1024>).

=back

=head3 Void Pointers (C<Pointer[Void]>)

Used for opaque handles or generic data.

=over 4

=item * Pass C<undef> to send C<NULL>.

=item * Pass a reference C<\$scalar> to send the address of that scalar.

=item * Pass a B<Pin> (from C<malloc> or C<cast>) to pass that memory address directly.

=back

=head3 Pins (Managed Pointers)

For manual memory management, use C<malloc>, C<calloc>, or C<cast>. These return B<Pins>. A Pin is a reference to a
scalar holding the memory address, blessed with magic.

    my $ptr = malloc(1024);   # Allocate 1024 bytes
    my $view = cast($ptr, Int); # Treat it as an integer

    $$view = 123;             # Write 123 to the memory
    free($ptr);               # Free it manually (optional, GC handles it otherwise)

=over

=item C<String>

Alias for C<const char*>. Affix automatically handles UTF-8 encoding (Perl to C) and decoding (C to Perl).

=item C<WString>

Alias for C<const wchar_t*>. Affix handles the complexity of UTF-16 (Windows) vs UTF-32 (Linux/macOS) and Surrogate
Pairs automatically.

=item C<SV>

The raw Perl Interpreter Object (C<SV*>). Use this if you are writing a function that manipulates Perl internals
directly.

=back

=head2 Aggregates

=head3 Structs

Structs are the bread and butter of C APIs. In Affix, they map to B<Perl Hash References>.

    # C: typedef struct { int x; int y; } Point;
    #    void draw_line(Point a, Point b);

    # 1. Define the type (recommended for reuse)
    typedef Point => Struct [
        x => Int,
        y => Int
    ];

    # 2. Bind the function
    affix $lib, 'draw_line', [ Point, Point ] => Void;

    # 3. Call with HashRefs
    draw_line( { x => 0, y => 0 }, { x => 100, y => 100 } );

B<Nested Structs:> Affix handles deep structures automatically.

    typedef Rect => Struct [
        top_left     => Point,
        bottom_right => Point,
        color        => Int
    ];

    draw_rect({
        top_left     => { x => 10, y => 10 },
        bottom_right => { x => 50, y => 50 },
        color        => 0xFF0000
    });

=head3 Unions

Unions allow storing different data types in the same memory location. In Affix, pass a Hash Reference with B<exactly
one key> corresponding to the field you want to set.

    # C: union Event { int key_code; float pressure; };
    typedef Event => Union [
        key_code => Int,
        pressure => Float
    ];

    # Pass an integer
    handle_event( { key_code => 27 } );

    # Pass a float
    handle_event( { pressure => 0.5 } );

=over

=item C<Packed [ $align, $aggregate ]>

Defines a struct with specific byte alignment (e.g. C<#pragma pack(1)>).

    Packed [ 1,
        Struct[
            name => Pointer[Char],
            # ...etc.
        ]
    ];

=back

=head2 Working with Arrays

Fixed-size C arrays are mapped to Perl Array References.

    # C: void process_matrix(int matrix[9]);
    affix $lib, 'process_matrix', [ Array[Int, 9] ] => Void;

    # Pass a reference to a Perl array
    process_matrix( [1..9] );

For character arrays (C<char[N]>), you can pass a standard Perl string. Affix will copy the bytes and ensure it is
null-terminated if space permits, or truncated if it does not.

    # C: void set_name(char name[32]);
    affix $lib, 'set_name', [ Array[Char, 32] ] => Void;

    set_name("Affix");

=head2 SIMD Vectors

Vectors (e.g. C<__m128> on x86, C<float32x4_t> on ARM) are first-class types in Affix. You can interact with them in
two ways:

=over

=item 1.

B<Array References>: Simplest to read and write

=item 2.

B<Packed Strings>: Highest performance (avoids marshalling overhead)

=back

    # C: typedef float v4f __attribute__((vector_size(16)));
    #    v4f add_vecs(v4f a, v4f b);
    affix $lib, 'add_vecs', [ Vector[4, Float], Vector[4, Float] ] => Vector[4, Float];

    # Option 1: Array References (Convenient)
    my $res = add_vecs( [1, 2, 3, 4], [10, 20, 30, 40] );
    # $res is [11.0, 22.0, 33.0, 44.0]

    # Option 2: Packed Strings (Fast)
    # Useful for tight loops, graphics, or physics math
    my $packed_a = pack('f4', 1.0, 2.0, 3.0, 4.0);
    my $packed_b = pack('f4', 10.0, 20.0, 30.0, 40.0);

    # Pass binary strings directly
    my $res_ref = add_vecs( $packed_a, $packed_b );

=head2 Enumerations

    typedef Status => Enum [
        [ OK => 0 ],
        'ERROR',                    # Auto-increments to 1
        [ FLAG_A => 1 << 0 ],       # Bit shifting
        [ FLAG_B => '1 << 1' ],     # String expression
        [ FLAG_C => 'FLAG_B << 1' ] # References previous keys
    ];

Defines a C enum backed by an integer.

=over

=item *

B<Constants>: C<typedef> installs constants (like C<OK>) into your package.

=item *

B<Dualvars:> Values returned from C are dual-typed. C<OK> behaves as the integer C<0> in numeric operations, but prints
as the string C<"OK">.

=item *

B<Calculated Values:> You can use string expressions to define values. These are evaluated at definition time and can
refer to previously defined constants within the same Enum.

    typedef Permissions => Enum [
        [ READ    => 4 ],
        [ WRITE   => 2 ],
        [ EXEC    => 1 ],
        [ R_W     => 'READ | WRITE' ],          # 6
        [ ALL     => 'READ | WRITE | EXEC' ]    # 7
    ];

=back

=head2 Callbacks

You can pass Perl subroutines to C functions that expect function pointers.

    # C: void set_handler( void (*callback)(int status, const char* msg) );

    affix $lib, 'set_handler',
        [ Callback[ [Int, String] => Void ] ] => Void;

    set_handler(sub ($status, $msg) {
        say "Received status $status: $msg";
    });

B<Note:> The callback is valid only as long as the C function holds onto it. If the C library stores the function
pointer globally, ensure your Perl code keeps the reference alive if necessary (though Affix handles the trampoline
lifecycle automatically for the duration of the call).

=head1 UTILITIES

=head2 C<get_system_error()>

Returns the C<errno> (Linux/Unix) or C<GetLastError> (Windows) from the most recent FFI call. This must be called
immediately after the function invokes to ensure accuracy.

=head2 C<sv_dump( $sv )>

Dumps the internal structure of a Perl scalar to STDERR. Useful for debugging Perl internals.

=head1 COMPILER WRAPPER

Affix includes a lightweight, cross-platform C compiler wrapper C<Affix::Compiler>. This is useful for compiling small
C stubs or "glue" code at runtime to bridge complex macros or inline functions that cannot be bound directly.

    use Affix;
    my $compiler = Affix::Compiler->new(
        name   => 'my_wrapper',
        source => [ 'wrapper.c' ]
    );
    $compiler->compile();
    my $lib_path = $compiler->link;
    affix $lib_path, 'some_function', [], Void;

Supported languages include C and C++. Other languages will be supported in the future provided the underlying
toolchain is installed on the system.

=head1 EXAMPLES

=head2 High Performance Batching

    # Allocate one C struct and reuse it to avoid GC overhead
    my $rect = calloc(1, 'SDL_Rect');
    my $x_ptr = cast(address($rect) + 0, 'Pointer[int]');

    while ($running) {
        # Update C memory directly
        $$x_ptr++;
        # Pass the pointer to C
        SDL_RenderFillRect($renderer, $rect);
    }

=head2 Vectors and 128bit Math

    use Affix;

    # 128-bit Integers (Passed as Strings)
    # __int128_t add128(__int128_t a, __int128_t b);
    my $add = Affix::affix('libtest', 'add128', '(sint128, sint128) -> sint128');

    # Pass strings, receive string
    my $result = $add->("100000000000000000000", "5");
    print $result; # "100000000000000000005"


    # SIMD Vectors (Passed as Packed Data)
    # m128 add_vecs(m128 a, m128 b); # Adds 4 floats
    my $vec_add = Affix::affix('libtest', 'add_vecs', '(v[4:float], v[4:float]) -> v[4:float]');

    # Pack arguments (4 floats)
    my $v1 = pack('f4', 1.0, 2.0, 3.0, 4.0);
    my $v2 = pack('f4', 5.0, 5.0, 5.0, 5.0);

    # Pass binary strings directly (Fast Path)
    my $res_ref = $vec_add->($v1, $v2);

    # Result comes back as Array Ref by default from pull_vector
    use Data::Dumper;
    print Dumper($res_ref); # [6.0, 7.0, 8.0, 9.0]

=head1 SEE ALSO

L<FFI::Platypus>, L<C::DynaLib>, L<XS::TCC>

All the heavy lifting is done by B<infix> (L<https://github.com/sanko/infix>).

=head1 AUTHOR

Sanko Robinson E<lt>sanko@cpan.orgE<gt>

=head1 COPYRIGHT

Copyright (C) 2023-2025 by Sanko Robinson.

This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=cut
