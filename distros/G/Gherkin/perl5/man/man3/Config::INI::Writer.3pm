.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Config::INI::Writer 3pm"
.TH Config::INI::Writer 3pm "2014-11-16" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::INI::Writer \- a subclassable .ini\-file emitter
.SH "VERSION"
.IX Header "VERSION"
version 0.025
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
If <$hash> contains:
.PP
.Vb 11
\&  {
\&    \*(Aq_\*(Aq  => { admin => \*(Aqrjbs\*(Aq },
\&    rjbs => {
\&      awesome => \*(Aqyes\*(Aq,
\&      height  => q{5\*(Aq 10"},
\&    },
\&    mj   => {
\&      awesome => \*(Aqtotally\*(Aq,
\&      height  => \*(Aq23"\*(Aq,
\&    },
\&  }
.Ve
.PP
Then when your program contains:
.PP
.Vb 1
\&  Config::INI::Writer\->write_file($hash, \*(Aqfamily.ini\*(Aq);
.Ve
.PP
\&\fIfamily.ini\fR will contains:
.PP
.Vb 1
\&  admin = rjbs
\&
\&  [rjbs]
\&  awesome = yes
\&  height = 5\*(Aq 10"
\&
\&  [mj]
\&  awesome = totally
\&  height = 23"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Config::INI::Writer is \fIyet another\fR config module implementing \fIyet another\fR
slightly different take on the undeniably easy to read \*(L".ini\*(R" file
format.  Its default behavior is quite similar to that of
Config::Tiny, on which it is based.
.PP
The chief difference is that Config::INI::Writer is designed to be subclassed
to allow for side-effects and self-reconfiguration to occur during the course
of reading its input.
.SH "METHODS FOR WRITING CONFIG"
.IX Header "METHODS FOR WRITING CONFIG"
There are three writer methods, \f(CW\*(C`write_string\*(C'\fR, \f(CW\*(C`write_file\*(C'\fR, and
\&\f(CW\*(C`write_handle\*(C'\fR.  The first two are implemented in terms of the third.  It
iterates over a collection of data, emitting lines to the filehandle as it
goes.  The lines are generated by events produced by iterating over the data.
Those events are detailed below in the \*(L"\s-1METHODS FOR SUBCLASSING\*(R"\s0 section.
.PP
The given data should be a hashref of hashrefs:
.PP
.Vb 4
\&  {
\&    section_name_1 => { prop1 => \*(Aqvalue1\*(Aq, prop2 => \*(Aqvalue2\*(Aq },
\&    section_name_2 => ...
\&  }
.Ve
.PP
\&...or an arrayref of section name and arrayref pairs:
.PP
.Vb 4
\&  [
\&    section_name_1 => [ prop1 => \*(Aqvalue1\*(Aq, prop2 => \*(Aqvalue2\*(Aq ],
\&    section_name_2 => ...
\&  ]
.Ve
.PP
\&...or a combination of those:
.PP
.Vb 5
\&  [
\&    section_name_1 => { prop1 => \*(Aqvalue1\*(Aq, prop2 => \*(Aqvalue2\*(Aq },
\&    section_name_2 => [ prop3 => \*(Aqvalue3\*(Aq, prop4 => \*(Aqvalue4\*(Aq ],
\&    section_name_3 => ...
\&  ]
.Ve
.PP
All the reader methods throw an exception when they encounter an error.
.SS "write_file"
.IX Subsection "write_file"
.Vb 1
\&  Config::INI::Writer\->write_file($input, $filename);
.Ve
.PP
This method writes out the configuration represented by \f(CW$data\fR to the file
named by \f(CW$filename\fR.  If a file by that name exists, it is overwritten.
.PP
This method will either succeed or raise an exception.  (Its return value is
not defined.)
.SS "write_string"
.IX Subsection "write_string"
.Vb 1
\&  my $string = Config::INI::Writer\->write_string($input);
.Ve
.PP
This method returns a string containing the \s-1INI\s0 content describing the given
data.
.SS "write_handle"
.IX Subsection "write_handle"
.Vb 1
\&  Config::INI::Writer\->write_handle($input, $handle);
.Ve
.PP
This method writes the data in \f(CW$data\fR to the IO::Handle\-like object in
\&\f(CW$handle\fR.  This method should either succeed or throw an exception.
.SH "METHODS FOR SUBCLASSING"
.IX Header "METHODS FOR SUBCLASSING"
These are the methods you need to understand and possibly change when
subclassing Config::INI::Reader to handle a different format of input.
.SS "preprocess_input"
.IX Subsection "preprocess_input"
.Vb 1
\&  my $processed_input = $writer\->preprocess_input($input_data);
.Ve
.PP
This method is called to ensure that the data given to the \f(CW\*(C`write_*\*(C'\fR methods
are in a canonical form for processing and emitting.  The default
implementation converts hashrefs to arrayrefs and, if the input is a hashref,
moves the \*(L"starting_section\*(R" to the beginning of the produced arrayref.
.PP
In other words, given:
.PP
.Vb 5
\&  {
\&    section_1 => { a => 1, b => 2 },
\&    section_2 => { c => 3, c => 4 },
\&    _         => { d => 5, e => 6 },
\&  }
.Ve
.PP
This method will return:
.PP
.Vb 5
\&  [
\&    _         => [ d => 5, e => 6 ],
\&    section_2 => [ c => 3, c => 4 ],
\&    section_1 => [ a => 1, b => 2 ],
\&  ]
.Ve
.PP
The only guaranteed ordering when hashes are provided as input is that the
starting section will appear first.
.SS "validate_section_name"
.IX Subsection "validate_section_name"
.Vb 2
\&  Carp::croak "section name contains illegal character"
\&    if not $writer\->is_valid_section_name($name);
.Ve
.SS "is_valid_property_name"
.IX Subsection "is_valid_property_name"
.Vb 2
\&  Carp::croak "property name contains illegal character"
\&    if not $writer\->is_valid_property_name($name);
.Ve
.SS "is_valid_value"
.IX Subsection "is_valid_value"
.Vb 2
\&  Carp::croak "value contains illegal character"
\&    if not $writer\->is_valid_value($name);
.Ve
.SS "validate_input"
.IX Subsection "validate_input"
.Vb 1
\&  $writer\->validate_input($input);
.Ve
.PP
This method is called on the input data once they've been preprocessed by
\&\f(CW"preprocess_input"\fR.
.PP
It ensures that the processed input is structurally sound before beginning to
output it.  For example, it ensures that no property is ever assigned more than
once in a given section.
.PP
This method either raises an exception or it doesn't.
.SS "change_section"
.IX Subsection "change_section"
.Vb 1
\&  $writer\->change_section($section_name);
.Ve
.PP
This method is called each time a new section is going to be written out.  If
the same section appears twice in a row in the input, this method will still be
called between instances of that section.
.PP
In other words, given this input:
.PP
.Vb 4
\&  [
\&    section_1 => [ a => 1 ],
\&    section_1 => [ b => 2 ],
\&  ]
.Ve
.PP
\&\f(CW\*(C`change_section\*(C'\fR will be called twice: once before the first \f(CW\*(C`section_1\*(C'\fR and
once before the second \f(CW\*(C`section_1\*(C'\fR.
.SS "current_section"
.IX Subsection "current_section"
.Vb 1
\&  $writer\->current_section
.Ve
.PP
This method returns the section currently being written out.
.SS "finish_section"
.IX Subsection "finish_section"
.Vb 1
\&  $writer\->finish_section
.Ve
.PP
This method is called after all of the current section's properties have been
written.
.SS "done_sections"
.IX Subsection "done_sections"
.Vb 1
\&  my @names = $writer\->done_sections;
.Ve
.PP
This method returns a list of all sections that have been written out and
finished.  The fact that a section name is returned by \f(CW\*(C`done_sections\*(C'\fR does
not mean that there will be no more data for that section, but that at least
one entire set of data has been written out for it.
.SS "stringify_section"
.IX Subsection "stringify_section"
.Vb 1
\&  my $string = $writer\->stringify_section($props);
.Ve
.PP
This method returns a string assigning all the properties set in the given
data.  This still will include the section header, if needed.  (The only case
in which it is not needed is when the \f(CW"explicit_starting_header"\fR method
returns false, no other sections have been done, and the section about to be
stringified is the \f(CW"starting_section"\fR.
.PP
This method is implemented in terms of \f(CW"stringify_section_header"\fR and
\&\f(CW"stringify_section_data"\fR.
.SS "stringify_section_data"
.IX Subsection "stringify_section_data"
.Vb 1
\&  my $string = $writer\->stringify_section_data($props)
.Ve
.PP
This method returns a string containing a series of lines, each containing a
value assignment for the given properties.
.SS "stringify_value_assignment"
.IX Subsection "stringify_value_assignment"
.Vb 1
\&  my $string = $writer\->stringify_value_assignment($name => $value);
.Ve
.PP
This method returns a string that assigns a value to a named property.  If the
value is undefined, an empty string is returned.
.SS "stringify_value"
.IX Subsection "stringify_value"
.Vb 1
\&  my $string = $writer\->stringify_value($value);
.Ve
.PP
This method returns the string that will represent the given value in a
property assignment.
.SS "stringify_section_header"
.IX Subsection "stringify_section_header"
.Vb 1
\&  my $string = $writer\->stringify_section_header($section_name);
.Ve
.PP
This method returns the string (a line) that represents the given section name.
Basically, this returns:
.PP
.Vb 1
\&  [section_name]
.Ve
.SS "starting_section"
.IX Subsection "starting_section"
This method returns the name of the starting section.  If this section appears
first (as it will, when given a hashref as input) and if
\&\f(CW"explicit_starting_header"\fR returns false, its section header can be
omitted.
.SS "explicit_starting_header"
.IX Subsection "explicit_starting_header"
If this method returns true (which it does \fInot\fR, by default), then the
section header for the starting section will be emitted, even if it appears
first.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $reader = Config::INI::Writer\->new;
.Ve
.PP
This method returns a new writer.  This generally does not need to be called by
anything but the various \f(CW\*(C`write_*\*(C'\fR methods, which create a writer object only
ephemerally.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2007 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
