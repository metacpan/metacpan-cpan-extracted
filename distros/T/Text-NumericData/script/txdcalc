#!/usr/bin/env perl

use Text::NumericData::App::txdcalc;

my $app = Text::NumericData::App::txdcalc->new();
exit $app->run();

__END__

=head1 NAME

txdcalc - text data calculations


=head1 SYNOPSIS

	pipe | txdcalc <options> [--] <formula;formula;formula...> [files] | pipe

=head1 DESCRIPTION


It takes STDIN as primary data source and the files as secondary sources. Operation is line-wise in and out. So, this program is just a filter for data in ASCII files with quite some freedom in manipulating the data.
About formula syntax:
It is Perl, mostly. The variables (elements of corresponding rows) are denoted [n,m] in general. n is the file number (0 is the data from STDIN) and m the column (starting at 1). Short form [m] means implicitly n=0. Also there are $x or x for [0,1],  $y or y for [0,2] and $z for [0,3].

Additionally there are two arrays: A0, A1, A2, ... and C0, C1, C2, ... in the formula or references $A and $C in the plain Perl code. Both arrays are usable as you like (global scope) with the difference that @C gets initialized via the const parameter. Apart from the special syntax added here you can just use Perl to build advanced expressions, so that

	[3] = [1,2] != 0 ? [2]/[1,2] : 0

catches the division by zero. You can switch to plain Perl syntax, too (see --plainperl).

To discard a data line, place a "return 1" (or some other true --- not 0 or undefined --- value):

	return 1 if [3] != 85000;

will only include data lines with the third column being equal to 85000.


=head1 PARAMETERS

These are the general rules for specifying parameters to this program:

	txdcalc -s -xyz -s=value --long --long=value [--] [files/stuff]

You mention the parameters/switches you want to change in any order or even multiple times (they are processed in the oder given, later operations overriding/extending earlier settings.
An only mentioned short/long name (no "=value") means setting to 1, which is true in the logical sense. Also, prepending + instead of the usual - negates this, setting the value to 0 (false).
Specifying "-s" and "--long" is the same as "-s=1" and "--long=1", while "+s" and "++long" is the sames as "-s=0" and "--long=0".

There are also different operators than just "=" available, notably ".=", "+=", "-=", "*=" and "/=" for concatenation / appending array/hash elements and scalar arithmetic operations on the value. Arrays are appended to via "array.=element", hash elements are set via "hash.=name=value". You can also set more array/hash elements by specifying a separator after the long parameter line like this for comma separation:
	--array/,/=1,2,3  --hash/,/=name=val,name2=val2


The available parameters are these, default values (in Perl-compatible syntax) at the time of generating this document following the long/short names:

=over 2

=item B<aftercode>, B<A> (scalar)

	''

FullFun: Some code that gets eval()ed after the input file is through (only useful together with justcalc and ignored otherwise)

=item B<beforecode>, B<B> (scalar)

	''

FullFun: Some code that gets eval()ed before input processing (yes, first B, then A, because B[efore] A[fter];-)

=item B<black> (scalar)

	0

ignore whitespace at beginning and end of line (disables strict mode) (from Text::NumericData)

=item B<bycol>, B<c> (scalar)

	1

correlate data via this column in STDIN data(1..#columns)

=item B<byrow>, B<r> (scalar)

	0

correlate data sets simply by row number (0 / 1)

=item B<comchar> (scalar)

	undef

comment character (if not set, deduce from data or use #) (from Text::NumericData)

=item B<comregex> (scalar)

	'[#%]*[^\\S\\015\\012]*'

regex for matching comments (from Text::NumericData)

=item B<config>, B<I> (array)

	[]

Which configfile(s) to use (overriding automatic search in likely paths);
special: just -I or --config causes printing a current config file to STDOUT

=item B<const>, B<n> (scalar)

	undef

specify a constant array (separated by spaces)

=item B<debug>, B<d> (scalar)

	0

give some info that may help debugging

=item B<empty> (scalar)

	0

treat empty lines as empty data sets, preserving them in output (from Text::NumericData)

=item B<filehead>, B<F> (scalar)

	0

use header from file (use number starting at 1 for a file in provided list) - overriden by manual header

=item B<fill> (scalar)

	undef

fill value for undefined data (from Text::NumericData)

=item B<formula>, B<m> (scalar)

	undef

specify formula here or as first command line parameter

=item B<fromcol>, B<l> (scalar)

	0

specify diferent columns (commalist) for correlation for each input file

=item B<headcode>, B<C> (scalar)

	''

FullFun: Some code that gets eval()ed with possibility to parse/modify every head line (variable $line; line number is $num).

=item B<header>, B<H> (scalar)

	undef

use this header instead (\n becomes an appropriate line end, end of string by itself) - this one overrides the others

=item B<help>, B<h> (scalar)

	0

show the help message; 1: normal help, >1: more help; "par": help for paramter "par" only


Additional fun with negative values, optionally followed by comma-separated list of parameter names:
-1: list par names, -2: list one line per name, -3: -2 without builtins, -10: dump values (Perl style), -11: dump values (lines), -100: print POD.

=item B<interpolate> (scalar)

	'linear'

use interpolation inter-/extrapolation for correlation of data sets (choose linear or spline, or 0 for switching it off) (from Text::NumericData::File)

=item B<justcalc>, B<j> (scalar)

	0

just print values of the A array after calculation and not the resulting data (for simply doing some calculation like summing, averaging...)

=item B<lin> (scalar)

	0

shortcut for enforcing linear interpolation

=item B<lineend> (scalar)

	undef

line ending to use: (DOS, MAC, UNIX or be explicit if you can, taken from data if undefined, finally resorting to UNIX) (from Text::NumericData)

=item B<numformat>, B<N> (array)

	[]

printf formats to use (if there is no "%" present at all, one will be prepended) (from Text::NumericData)

=item B<numregex> (scalar)

	'[\\+\\-]?\\d*\\.?\\d*[eE]?\\+?\\-?\\d*'

regex for matching numbers (from Text::NumericData)

=item B<outsep> (scalar)

	undef

use this separator for output (leave undefined to use input separator, fallback to TAB) (from Text::NumericData)

=item B<plainperl> (scalar)

	0

Use plain Perl syntax for formula for full force without confusing the intermediate parser.

=item B<quote> (scalar)

	undef

quote titles (from Text::NumericData)

=item B<quotechar> (scalar)

	undef

quote character to use (derived from input or ") (from Text::NumericData)

=item B<separator> (scalar)

	undef

use this separator for input (otherwise deduce from data; TAB is another way to say "tabulator", fallback is	) (from Text::NumericData)

=item B<spline> (scalar)

	0

shortcut for enforcing spline interpolation (overrules --line)

=item B<stdhead>, B<s> (scalar)

	1

use header from STDIN (overridden by other options)

=item B<strict>, B<S> (scalar)

	0

strictly split data lines at configured separator (otherwise more fuzzy logic is involved) (from Text::NumericData)

=item B<text>, B<T> (scalar)

	1

allow text as data (not first column) (from Text::NumericData)

=item B<version> (scalar)

	0

print out the program version

=back

=head1 AUTHOR

Thomas Orgis <thomas@orgis.org>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2005-2016 Thomas Orgis, Free Software licensed under the same terms as Perl 5.10

=cut
