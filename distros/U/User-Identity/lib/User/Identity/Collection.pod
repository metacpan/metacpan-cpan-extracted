=encoding utf8

=head1 NAME

User::Identity::Collection - base class for collecting roles of a user

=head1 INHERITANCE

 User::Identity::Collection
   is a User::Identity::Item

 User::Identity::Collection is extended by
   User::Identity::Collection::Emails
   User::Identity::Collection::Locations
   User::Identity::Collection::Systems
   User::Identity::Collection::Users

=head1 SYNOPSIS

  use User::Identity;
  use User::Identity::Collection;
  my $me    = User::Identity->new(...);
  my $set   = User::Identity::Collection::Emails->new(...);
  $me->addCollection($set);

  # Simpler
  use User::Identity;
  my $me    = User::Identity->new(...);
  my $set   = $me->addCollection(type => 'email', ...)
  my $set   = $me->addCollection('email', ...)

  my @roles = $me->collection('email');  # list of collected items

  my $coll  = $me->collection('email');  # a User::Identity::Collection
  my @roles = $coll->roles;
  my @roles = @$coll;                    # same, by overloading

  my $role  = $me->collection('email')->find($coderef);
  my $role  = $me->collection('location')->find('work');
  my $role  = $me->find(location => 'work');

=head1 DESCRIPTION

The C<User::Identity::Collection> object maintains a set user related
objects.  It helps selecting these objects, which is partially common to
all collections (for instance, each object has a name so you can search
on names), and sometimes specific to the extension of this collection.

Currently imlemented extensions are

=over 4

=item * I<people> is a L<collection of users|User::Identity::Collection::Users>

=item * I<whereabouts> are L<locations|User::Identity::Collection::Locations>

=item * a I<mailinglist> is a

L<collection of email addresses|User::Identity::Collection::Emails>

=item * a I<network> contains

L<groups of systems|User::Identity::Collection::Systems>

=back

Extends L<"DESCRIPTION" in User::Identity::Item|User::Identity::Item/"DESCRIPTION">.

=head1 OVERLOADED

=over 4

=item overload: B<""> stringification

Returns the name of the collection and a sorted list of defined items.

» example: 

  print "$collection\n";  #   location: home, work

=item overload: B<@{}> array dereference

When the reference to a collection object is used as array-reference, it
will be shown as list of roles.

» example: 

  my $locations = $ui->collection('location');
  foreach my $loc (@$location) ...
  print $location->[0];

=back

=head1 METHODS

Extends L<"METHODS" in User::Identity::Item|User::Identity::Item/"METHODS">.

=head2 Constructors

Extends L<"Constructors" in User::Identity::Item|User::Identity::Item/"Constructors">.

=over 4

=item $class-E<gt>B<new>( [$name], %options )

Z<>

 -Option     --Defined in          --Default
  description  User::Identity::Item  undef
  item_type                          <required>
  name         User::Identity::Item  <required>
  parent       User::Identity::Item  undef
  roles                              undef

=over 2

=item description => STRING

=item item_type => CLASS

The CLASS which is used to store the information for each of the maintained
objects within this collection.

=item name => STRING

=item parent => OBJECT

=item roles => $role|\@roles

Immediately add some C<@roles> to this collection.  In case of an ARRAY,
each element is passed separately to L<addRole()|User::Identity::Collection/"Maintaining roles">. So, you may end-up
with an ARRAY of ARRAYS each grouping a set of options to create a role.

=back

=back

=head2 Attributes

Extends L<"Attributes" in User::Identity::Item|User::Identity::Item/"Attributes">.

=over 4

=item $obj-E<gt>B<description>()

Inherited, see L<User::Identity::Item/"Attributes">

=item $obj-E<gt>B<itemType>()

Returns the type of the items collected.

=item $obj-E<gt>B<name>( [$newname] )

Inherited, see L<User::Identity::Item/"Attributes">

=item $obj-E<gt>B<roles>()

Returns all defined roles within this collection.  Be warned: the rules
are returned in random (hash) order.

=back

=head2 Collections

Extends L<"Collections" in User::Identity::Item|User::Identity::Item/"Collections">.

=over 4

=item $obj-E<gt>B<add>($collection, $role)

Inherited, see L<User::Identity::Item/"Collections">

=item $obj-E<gt>B<addCollection>( $object | <[$type], %options> )

Inherited, see L<User::Identity::Item/"Collections">

=item $obj-E<gt>B<collection>($name)

Inherited, see L<User::Identity::Item/"Collections">

=item $obj-E<gt>B<parent>( [$parent] )

Inherited, see L<User::Identity::Item/"Collections">

=item $obj-E<gt>B<removeCollection>($object|$name)

Inherited, see L<User::Identity::Item/"Collections">

=item $any-E<gt>B<type>()

Inherited, see L<User::Identity::Item/"Collections">

=item $obj-E<gt>B<user>()

Inherited, see L<User::Identity::Item/"Collections">

=back

=head2 Maintaining roles

=over 4

=item $obj-E<gt>B<addRole>($role|([$name], %options))

Adds a new role to this collection.  C<$role> is an object of the right type
(depends on the extension of this module which type that is) or a list
of C<%options> which are used to create such role.  The options can also be
passed as reference to an ARRAY.  The added role is returned.

» example: 

  my $uicl = User::Identity::Collection::Locations->new;

  my $uil  = User::Identity::Location->new(home => ...);
  $uicl->addRole($uil);
  $uicl->addRole(  home => address => 'street 32' );
  $uicl->addRole( [home => address => 'street 32'] );

Easier

  $ui      = User::Identity;
  $ui->add(location => 'home', address => 'street 32' );
  $ui->add(location => [ 'home', address => 'street 32' ] );

=item $obj-E<gt>B<removeRole>($role|$name)

The deleted role is returned (if it existed).

=item $obj-E<gt>B<renameRole>( <$role|$oldname>, $newname )

Give the role a different name, and move it in the collection.

=item $obj-E<gt>B<sorted>()

Returns the roles sorted by name, alphabetically and case-sensitive.

=back

=head2 Searching

Extends L<"Searching" in User::Identity::Item|User::Identity::Item/"Searching">.

=over 4

=item $obj-E<gt>B<find>($name|CODE|undef)

Find the object with the specified C<$name> in this collection.  With C<undef>,
a randomly selected role is returned.

When a code reference is specified, all collected roles are scanned one
after the other (in unknown order).  For each role,

  CODE->($object, $collection)

is called.  When the C<CODE> returns C<true>, the role is selected.  In list context,
all selected roles are returned.  In scalar context, the first match is
returned and the scan is aborted immediately.
Improves base, see L<User::Identity::Item/"Searching">

» example: 

  my $emails = $ui->collection('emails');
  $emails->find('work');

  sub find_work($$) {
     my ($mail, $emails) = @_;
     $mail->location->name eq 'work';
  }
  my @at_work = $emails->find(\&find_work);
  my @at_work = $ui->find(location => \&find_work);
  my $any     = $ui->find(location => undef );

=back

=head1 DIAGNOSTICS

=over 4

=item Error: cannot create a $type to add this to my collection.

Some options are specified to create a C<$type> object, which is native to
this collection.  However, for some reason this failed.
Cast by C<addRole()>

=item Error: cannot load collection module for $type ($class): $@

Either the specified C<$type> does not exist, or that module named C<$class> returns
compilation errors.  If the type as specified in the warning is not
the name of a package, you specified a nickname which was not defined.
Maybe you forgot the 'require' the package which defines the nickname.
Cast by C<addCollection()>

=item Error: cannot rename $from into $to: already exists.

Cast by C<renameRole()>

=item Error: cannot rename $from into $to: doesn't exist.

Cast by C<renameRole()>

=item Error: nvalid collection $name.

The collection with C<$name> does not exist and can not be created.
Cast by C<add()>

=item Error: this $object is not a collection.

Cast by C<addCollection()>

=item Error: wrong type of role for $collection: requires a $expect but got a $type.

Each C<$collection> groups sets of roles of one specific type (C<$expect>).  You
cannot add objects of a different C<$type>.
Cast by C<addRole()>

=back

=head1 SEE ALSO

This module is part of User-Identity version 4.00,
built on December 12, 2025. Website: F<http://perl.overmeer.net/CPAN/>

=head1 LICENSE

For contributors see file ChangeLog.

This software is copyright (c) 2003-2025 by Mark Overmeer.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

