=head1 NAME

Catalyst::Manual::Tutorial::03_MoreCatalystBasics - Catalyst Tutorial - Chapter 3: More Catalyst Application Development Basics


=head1 OVERVIEW

This is B<Chapter 3 of 10> for the Catalyst tutorial.

L<Tutorial Overview|Catalyst::Manual::Tutorial>

=over 4

=item 1

L<Introduction|Catalyst::Manual::Tutorial::01_Intro>

=item 2

L<Catalyst Basics|Catalyst::Manual::Tutorial::02_CatalystBasics>

=item 3

B<03_More Catalyst Basics>

=item 4

L<Basic CRUD|Catalyst::Manual::Tutorial::04_BasicCRUD>

=item 5

L<Authentication|Catalyst::Manual::Tutorial::05_Authentication>

=item 6

L<Authorization|Catalyst::Manual::Tutorial::06_Authorization>

=item 7

L<Debugging|Catalyst::Manual::Tutorial::07_Debugging>

=item 8

L<Testing|Catalyst::Manual::Tutorial::08_Testing>

=item 9

L<Advanced CRUD|Catalyst::Manual::Tutorial::09_AdvancedCRUD>

=item 10

L<Appendices|Catalyst::Manual::Tutorial::10_Appendices>

=back


=head1 DESCRIPTION

This chapter of the tutorial builds on the work done in Chapter 2 to
explore some features that are more typical of "real world" web
applications. From this chapter of the tutorial onward, we will be
building a simple book database application.  Although the application
will be too limited to be of use to anyone, it should provide a basic
environment where we can explore a variety of features used in virtually
all web applications.

Source code for the tutorial in included in the F</home/catalyst/Final>
directory of the Tutorial Virtual machine (one subdirectory per
chapter).  There are also instructions for downloading the code in
L<Catalyst::Manual::Tutorial::01_Intro>.

Please take a look at
L<Catalyst::Manual::Tutorial::01_Intro/STARTING WITH THE TUTORIAL VIRTUAL MACHINE>
before doing the rest of this tutorial.  Although the tutorial should
work correctly under most any recent version of Perl running on any
operating system, the tutorial has been written using the virtual
machine that is available for download.  The entire tutorial has been
tested to be sure it runs correctly in this environment, so it is
the most trouble-free way to get started with Catalyst.


=head1 CREATE A NEW APPLICATION

The remainder of the tutorial will build an application called C<MyApp>.
First use the Catalyst C<catalyst.pl> script to initialize the framework
for the C<MyApp> application (make sure you aren't still inside the
directory of the C<Hello> application from the previous chapter of the
tutorial or in a directory that already has a "MyApp" subdirectory):

    $ catalyst.pl MyApp
    created "MyApp"
    created "MyApp/script"
    created "MyApp/lib"
    created "MyApp/root"
    ...
    created "MyApp/script/myapp_create.pl"
    Change to application directory and Run "perl Makefile.PL" to make sure your install is complete

And change the "MyApp" directory the helper created:

    $ cd MyApp

This creates a similar skeletal structure to what we saw in Chapter 2 of
the tutorial, except with C<MyApp> and C<myapp> substituted for C<Hello>
and C<hello>.  (As noted in Chapter 2, omit the ".pl" from the command
if you are using Strawberry Perl.)


=head1 EDIT THE LIST OF CATALYST PLUGINS

One of the greatest benefits of Catalyst is that it has such a large
library of base classes and plugins available that you can use to easily
add functionality to your application. Plugins are used to seamlessly
integrate existing Perl modules into the overall Catalyst framework. In
general, they do this by adding additional methods to the C<context>
object (generally written as C<$c>) that Catalyst passes to every
component throughout the framework.

Take a look at the file C<lib/MyApp.pm> that the helper created above.
By default, Catalyst enables three plugins/flags:

=over 4

=item *

C<-Debug> Flag

Enables the Catalyst debug output you saw when we started the
C<script/myapp_server.pl> development server earlier.  You can remove
this item when you place your application into production.

To be technically correct, it turns out that C<-Debug> is not a plugin,
but a I<flag>.  Although most of the items specified on the C<use
Catalyst> line of your application class will be plugins, Catalyst
supports a limited number of flag options (of these, C<-Debug> is the
most common).  See the documentation for
L<https://metacpan.org/module/Catalyst|Catalyst.pm> to get details on
other flags (currently C<-Engine>, C<-Home>, C<-Log>, and C<-Stats>).

If you prefer, there are several other ways to enable debug output:

=over 4

=item *

the C<$c-E<gt>debug> method on the C<$c> Catalyst context object

=item *

the C<-d> option on the C<script/myapp_server.pl> script

=item *

the C<CATALYST_DEBUG=1> environment variable (or C<CATALYST_DEBUG=0>
to temporarily disable debug output)

=back

B<TIP>: Depending on your needs, it can be helpful to permanently remove
C<-Debug> from C<lib/MyApp.pm> and then use the C<-d> option to
C<script/myapp_server.pl> to re-enable it when needed.  We will not be
using that approach in the tutorial, but feel free to make use of it in
your own projects.

=item *

L<Catalyst::Plugin::ConfigLoader>

C<ConfigLoader> provides an automatic way to load configurable
parameters for your application from a central
L<Config::General> file (versus having the values
hard-coded inside your Perl modules).  Config::General uses syntax very
similar to Apache configuration files.  We will see how to use this
feature of Catalyst during the authentication and authorization sections
(L<Chapter 5|Catalyst::Manual::Tutorial::05_Authentication> and
L<Chapter 6|Catalyst::Manual::Tutorial::06_Authorization>).

B<IMPORTANT NOTE:> If you are using a version of
L<Catalyst::Devel> prior to version 1.06, be aware that
Catalyst changed the default format from YAML to the more
straightforward C<Config::General> style.  This tutorial uses the newer
C<myapp.conf> file for C<Config::General>. However, Catalyst supports
both formats and will automatically use either C<myapp.conf> or
C<myapp.yml> (or any other format supported by
L<Catalyst::Plugin::ConfigLoader> and
L<Config::Any>).  If you are using a version of
Catalyst::Devel prior to 1.06, you can convert to the newer format by
simply creating the C<myapp.conf> file manually and deleting
C<myapp.yml>.  The default contents of the C<myapp.conf> you create
should only consist of one line:

    name MyApp

B<TIP>: This script can be useful for converting between configuration
formats:

    perl -Ilib -e 'use MyApp; use Config::General;
        Config::General->new->save_file("myapp.conf", MyApp->config);'

=item *

L<Catalyst::Plugin::Static::Simple>

C<Static::Simple> provides an easy way to serve static content, such as
images and CSS files, from the development server.

=back

For our application, we want to add one new plugin to the mix.  To do
this, edit C<lib/MyApp.pm> (this file is generally referred to as your
I<application class>) and delete the lines with:

    use Catalyst qw/
        -Debug
        ConfigLoader
        Static::Simple
    /;

Then replace it with:

    # Load plugins
    use Catalyst qw/
        -Debug
        ConfigLoader
        Static::Simple
    
        StackTrace
    /;

B<Note:> Recent versions of C<Catalyst::Devel> have used a variety of
techniques to load these plugins/flags.  For example, you might see the
following:

    __PACKAGE__->setup(qw/-Debug ConfigLoader Static::Simple/);

Don't let these variations confuse you -- they all accomplish the same
result.

This tells Catalyst to start using one additional plugin,
L<Catalyst::Plugin::StackTrace>, to add a stack trace near the top of
the standard Catalyst "debug screen" (the screen Catalyst sends to your
browser when an error occurs). Be aware that
L<StackTrace|Catalyst::Plugin::StackTrace> output appears in your
browser, not in the console window from which you're running your
application, which is where logging output usually goes.

Make sure when adding new plugins you also include them as a new
dependency within the Makefile.PL file. For example, after adding the
StackTrace plugin the Makefile.PL should include the following line:

    requires 'Catalyst::Plugin::StackTrace';


B<Notes:>

=over 4

=item *

C<__PACKAGE__> is just a shorthand way of referencing the name of the
package where it is used.  Therefore, in C<MyApp.pm>, C<__PACKAGE__> is
equivalent to C<MyApp>.

=item *

You will want to disable L<StackTrace|Catalyst::Plugin::StackTrace>
before you put your application into production, but it can be helpful
during development.

=item *

When specifying plugins, you can omit C<Catalyst::Plugin::> from the
name.  Additionally, you can spread the plugin names across multiple
lines as shown here or place them all on one line.

=item *

If you want to see what the StackTrace error screen looks like, edit
C<lib/MyApp/Controller/Root.pm> and put a C<die "Oops";> command in the
C<sub index :Path :Args(0)> method.  Then start the development server
and open C<http://localhost:3000/> in your browser.  You should get a
screen that starts with "Caught exception in
MyApp::Controller::Root->index" with sections showing a stacktrace,
information about the Request and Response objects, the stash (something
we will learn about soon), and the applications configuration.
B<Just don't forget to remove the die before you continue the tutorial!>
:-)

=back


=head1 CREATE A CATALYST CONTROLLER

As discussed earlier, controllers are where you write methods that
interact with user input.  Typically, controller methods respond to
C<GET> and C<POST> requests from the user's web browser.

Use the Catalyst C<create> script to add a controller for book-related
actions:

    $ script/myapp_create.pl controller Books
     exists "/home/catalyst/MyApp/script/../lib/MyApp/Controller"
     exists "/home/catalyst/MyApp/script/../t"
    created "/home/catalyst/MyApp/script/../lib/MyApp/Controller/Books.pm"
    created "/home/catalyst/MyApp/script/../t/controller_Books.t"

Then edit C<lib/MyApp/Controller/Books.pm> (as discussed in
L<Chapter 2|Catalyst::Manual::Tutorial::02_CatalystBasics> of
the Tutorial, Catalyst has a separate directory under C<lib/MyApp> for
each of the three parts of MVC: C<Model>, C<View> and C<Controller>)
and add the following method to the controller:

    =head2 list
    
    Fetch all book objects and pass to books/list.tt2 in stash to be displayed
    
    =cut
    
    sub list :Local {
        # Retrieve the usual Perl OO '$self' for this object. $c is the Catalyst
        # 'Context' that's used to 'glue together' the various components
        # that make up the application
        my ($self, $c) = @_;
    
        # Retrieve all of the book records as book model objects and store in the
        # stash where they can be accessed by the TT template
        # $c->stash(books => [$c->model('DB::Book')->all]);
        # But, for now, use this code until we create the model later
        $c->stash(books => '');
    
        # Set the TT template to use.  You will almost always want to do this
        # in your action methods (action methods respond to user input in
        # your controllers).
        $c->stash(template => 'books/list.tt2');
    }

B<TIP>: See L<Appendix 1|Catalyst::Manual::Tutorial::10_Appendices> for
tips on removing the leading spaces when cutting and pasting example
code from POD-based documents.

Programmers experienced with object-oriented Perl should recognize
C<$self> as a reference to the object where this method was called.  On
the other hand, C<$c> will be new to many Perl programmers who have not
used Catalyst before.  This is the "Catalyst Context object", and it is
automatically passed as the second argument to all Catalyst action
methods.  It is used to pass information between components and provide
access to Catalyst and plugin functionality.

Catalyst Controller actions are regular Perl methods, but they make use
of attributes (the "C<:Local>" next to the "C<sub list>" in the code
above) to provide additional information to the Catalyst dispatcher
logic (note that there can be an optional space between the colon and
the attribute name; you will see attributes written both ways).  Most
Catalyst Controllers use one of five action types:

=over 4

=item *

B<:Private> -- Use C<:Private> for methods that you want to make into an
action, but you do not want Catalyst to directly expose the method to
your users.  Catalyst will not map C<:Private> methods to a URI.  Use
them for various sorts of "special" methods (the C<begin>, C<auto>, etc.
discussed below) or for methods you want to be able to C<forward> or
C<detach> to.  (If the method is a "plain old method" that you
don't want to be an action at all, then just define the method without
any attribute -- you can call it in your code, but the Catalyst
dispatcher will ignore it.  You will also have to manually include
C<$c> if you want access to the context object in the method vs. having
Catalyst automatically include C<$c> in the argument list for you
if it's a full-fledged action.)

There are five types of "special" built-in C<:Private> actions:
C<begin>, C<end>, C<default>, C<index>, and C<auto>.

=over 4

=item *

With C<begin>, C<end>, C<default>, C<index> private actions, only the
most specific action of each type will be called.  For example, if you
define a C<begin> action in your controller it will I<override> a
C<begin> action in your application/root controller -- I<only> the
action in your controller will be called.

=item *

Unlike the other actions where only a single method is called for each
request, I<every> auto action along the chain of namespaces will be
called.  Each C<auto> action will be called I<from the application/root
controller down through the most specific class>.

=back

=item *

B<:Path> -- C<:Path> actions let you map a method to an explicit URI
path.  For example, "C<:Path('list')>" in
C<lib/MyApp/Controller/Books.pm> would match on the URL
C<http://localhost:3000/books/list>, but "C<:Path('/list')>" would match
on C<http://localhost:3000/list> (because of the leading slash).  You
can use C<:Args()> to specify how many arguments an action should
accept.  See L<Catalyst::Manual::Intro/Action-types> for more
information and examples.

=item *

B<:Local> -- C<:Local> is merely a shorthand for
"C<:Path('_name_of_method_')>".  For example, these are equivalent:
"C<sub create_book :Local {...}>" and
"C<sub create_book :Path('create_book') {...}>".

=item *

B<:Global> -- C<:Global> is merely a shorthand for
"C<:Path('/_name_of_method_')>".  For example, these are equivalent:
"C<sub create_book :Global {...}>" and "C<sub create_book
:Path('/create_book') {...}>".

=item *

B<:Chained> -- Newer Catalyst applications tend to use the Chained
dispatch form of action types because of its power and flexibility.  It
allows a series of controller methods to be automatically dispatched
when servicing a single user request.  See
L<Catalyst::Manual::Tutorial::04_BasicCRUD> and
L<Catalyst::DispatchType::Chained> for more information on chained
actions.

=back

You should refer to L<Catalyst::Manual::Intro/Action-types> for
additional information and for coverage of some lesser-used action types
not discussed here (C<Regex> and C<LocalRegex>).


=head1 CATALYST VIEWS

As mentioned in L<Chapter 2|Catalyst::Manual::Tutorial::02_CatalystBasics>
of the tutorial, views are where you render output, typically for
display in the user's web browser (but can generate other types of
output such as PDF or JSON).  The code in C<lib/MyApp/View> selects the
I<type> of view to use, with the actual rendering template found in the
C<root> directory.  As with virtually every aspect of Catalyst, options
abound when it comes to the specific view technology you adopt inside
your application. However, most Catalyst applications use the Template
Toolkit, known as TT (for more information on TT, see
L<http://www.template-toolkit.org>). Other somewhat popular view
technologies include Mason (L<http://www.masonhq.com> and
L<http://www.masonbook.com>) and L<HTML::Template>
(L<http://html-template.sourceforge.net>).


=head2 Create a Catalyst View

When using TT for the Catalyst view, the main helper script is
L<Catalyst::Helper::View::TT>.  You may also come across references to
L<Catalyst::Helper::View::TTSite>, but its use is now deprecated.

For our book application, enter the following command to enable the
C<TT> style of view rendering:

    $ script/myapp_create.pl view HTML TT
     exists "/home/catalyst/MyApp/script/../lib/MyApp/View"
     exists "/home/catalyst/MyApp/script/../t"
     created "/home/catalyst/MyApp/script/../lib/MyApp/View/HTML.pm"
     created "/home/catalyst/MyApp/script/../t/view_HTML.t"

This creates a view called C<HTML> (the first argument) in a file called
C<HTML.pm> that uses L<Catalyst::View::TT> (the second argument) as the
"rendering engine".

It is now up to you to decide how you want to structure your view
layout.  For the tutorial, we will start with a very simple TT template
to initially demonstrate the concepts, but quickly migrate to a more
typical "wrapper page" type of configuration (where the "wrapper"
controls the overall "look and feel" of your site from a single file or
set of files).

Edit C<lib/MyApp/View/HTML.pm> and you should see something similar to
the following:

    __PACKAGE__->config(
        TEMPLATE_EXTENSION => '.tt',
        render_die => 1,
    );

And update it to match:

    __PACKAGE__->config(
        # Change default TT extension
        TEMPLATE_EXTENSION => '.tt2',
        render_die => 1,
    );

This changes the default extension for Template Toolkit from '.tt' to
'.tt2'.

You can also configure components in your application class. For
example, Edit C<lib/MyApp.pm> and you should see the default
configuration above the call to C<_PACKAGE__-E<gt>setup> (your defaults
could be different depending on the version of Catalyst you are using):

    __PACKAGE__->config(
        name => 'MyApp',
        # Disable deprecated behavior needed by old applications
        disable_component_resolution_regex_fallback => 1,
    );


Change this to match the following (insert a new
C<__PACKAGE__-E<gt>config> below the existing statement):

    __PACKAGE__->config(
        name => 'MyApp',
        # Disable deprecated behavior needed by old applications
        disable_component_resolution_regex_fallback => 1,
    );
    __PACKAGE__->config(
        # Configure the view
        'View::HTML' => {
            #Set the location for TT files
            INCLUDE_PATH => [
                __PACKAGE__->path_to( 'root', 'src' ),
            ],
        },
    );

This changes the base directory for your template files from C<root> to
C<root/src>.

Please stick with the settings above for the duration of the tutorial,
but feel free to use whatever options you desire in your applications
(as with most things in Perl, there's more than one way to do it...).

B<Note:> We will use C<root/src> as the base directory for our template
files, with a full naming convention of
C<root/src/_controller_name_/_action_name_.tt2>.  Another popular option
is to use C<root/> as the base (with a full filename pattern of
C<root/_controller_name_/_action_name_.tt2>).


=head2 Create a TT Template Page

First create a directory for book-related TT templates:

    $ mkdir -p root/src/books

Then create C<root/src/books/list.tt2> in your editor and enter:

    [% # This is a TT comment. -%]
    
    [%- # Provide a title -%]
    [% META title = 'Book List' -%]
    
    [% # Note That the '-' at the beginning or end of TT code  -%]
    [% # "chomps" the whitespace/newline at that end of the    -%]
    [% # output (use View Source in browser to see the effect) -%]
    
    [% # Some basic HTML with a loop to display books -%]
    <table>
    <tr><th>Title</th><th>Rating</th><th>Author(s)</th></tr>
    [% # Display each book in a table row %]
    [% FOREACH book IN books -%]
      <tr>
        <td>[% book.title %]</td>
        <td>[% book.rating %]</td>
        <td></td>
      </tr>
    [% END -%]
    </table>

As indicated by the inline comments above, the C<META title> line uses
TT's META feature to provide a title to the "wrapper" that we will
create later (and essentially does nothing at the moment). Meanwhile,
the C<FOREACH> loop iterates through each C<book> model object and
prints the C<title> and C<rating> fields.

The C<[%> and C<%]> tags are used to delimit Template Toolkit code.  TT
supports a wide variety of directives for "calling" other files,
looping, conditional logic, etc.  In general, TT simplifies the usual
range of Perl operators down to the single dot (".") operator.  This
applies to operations as diverse as method calls, hash lookups, and list
index values (see L<Template::Manual::Variables> for details and
examples).  In addition to the usual L<Template::Toolkit> module Pod
documentation, you can access the TT manual at
L<https://metacpan.org/module/Template::Manual>.

B<TIP:> While you can build all sorts of complex logic into your TT
templates, you should in general keep the "code" part of your templates
as simple as possible.  If you need more complex logic, create helper
methods in your model that abstract out a set of code into a single call
from your TT template.  (Note that the same is true of your controller
logic as well -- complex sections of code in your controllers should
often be pulled out and placed into your model objects.)  In
L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD> of the tutorial we
will explore some extremely helpful and powerful features of
L<DBIx::Class> that allow you to pull code out of your views and
controllers and place it where it rightfully belongs in a model class.


=head2 Test Run The Application

To test your work so far, first start the development server:

    $ script/myapp_server.pl -r

Then point your browser to L<http://localhost:3000> and you should still
get the Catalyst welcome page.  Next, change the URL in your browser to
L<http://localhost:3000/books/list>.  If you have everything working so
far, you should see a web page that displays nothing other than our
column headers for "Title", "Rating", and "Author(s)" -- we will not see
any books until we get the database and model working below.

If you run into problems getting your application to run correctly, it
might be helpful to refer to some of the debugging techniques covered in
the L<Debugging|Catalyst::Manual::Tutorial::07_Debugging> chapter of the
tutorial.


=head1 CREATE A SQLITE DATABASE

In this step, we make a text file with the required SQL commands to
create a database table and load some sample data.  We will use SQLite
(L<http://www.sqlite.org>), a popular database that is lightweight and
easy to use. Be sure to get at least version 3. Open C<myapp01.sql> in
your editor and enter:

    --
    -- Create a very simple database to hold book and author information
    --
    PRAGMA foreign_keys = ON;
    CREATE TABLE book (
            id          INTEGER PRIMARY KEY,
            title       TEXT ,
            rating      INTEGER
    );
    -- 'book_author' is a many-to-many join table between books & authors
    CREATE TABLE book_author (
            book_id     INTEGER REFERENCES book(id) ON DELETE CASCADE ON UPDATE CASCADE,
            author_id   INTEGER REFERENCES author(id) ON DELETE CASCADE ON UPDATE CASCADE,
            PRIMARY KEY (book_id, author_id)
    );
    CREATE TABLE author (
            id          INTEGER PRIMARY KEY,
            first_name  TEXT,
            last_name   TEXT
    );
    ---
    --- Load some sample data
    ---
    INSERT INTO book VALUES (1, 'CCSP SNRS Exam Certification Guide', 5);
    INSERT INTO book VALUES (2, 'TCP/IP Illustrated, Volume 1', 5);
    INSERT INTO book VALUES (3, 'Internetworking with TCP/IP Vol.1', 4);
    INSERT INTO book VALUES (4, 'Perl Cookbook', 5);
    INSERT INTO book VALUES (5, 'Designing with Web Standards', 5);
    INSERT INTO author VALUES (1, 'Greg', 'Bastien');
    INSERT INTO author VALUES (2, 'Sara', 'Nasseh');
    INSERT INTO author VALUES (3, 'Christian', 'Degu');
    INSERT INTO author VALUES (4, 'Richard', 'Stevens');
    INSERT INTO author VALUES (5, 'Douglas', 'Comer');
    INSERT INTO author VALUES (6, 'Tom', 'Christiansen');
    INSERT INTO author VALUES (7, 'Nathan', 'Torkington');
    INSERT INTO author VALUES (8, 'Jeffrey', 'Zeldman');
    INSERT INTO book_author VALUES (1, 1);
    INSERT INTO book_author VALUES (1, 2);
    INSERT INTO book_author VALUES (1, 3);
    INSERT INTO book_author VALUES (2, 4);
    INSERT INTO book_author VALUES (3, 5);
    INSERT INTO book_author VALUES (4, 6);
    INSERT INTO book_author VALUES (4, 7);
    INSERT INTO book_author VALUES (5, 8);

Then use the following command to build a C<myapp.db> SQLite database:

    $ sqlite3 myapp.db < myapp01.sql

If you need to create the database more than once, you probably want to
issue the C<rm myapp.db> command to delete the database before you use
the C<sqlite3 myapp.db E<lt> myapp01.sql> command.

Once the C<myapp.db> database file has been created and initialized, you
can use the SQLite command line environment to do a quick dump of the
database contents:

    $ sqlite3 myapp.db
    SQLite version 3.7.3
    Enter ".help" for instructions
    Enter SQL statements terminated with a ";"
    sqlite> select * from book;
    1|CCSP SNRS Exam Certification Guide|5
    2|TCP/IP Illustrated, Volume 1|5
    3|Internetworking with TCP/IP Vol.1|4
    4|Perl Cookbook|5
    5|Designing with Web Standards|5
    sqlite> .q
    $

Or:

    $ sqlite3 myapp.db "select * from book"
    1|CCSP SNRS Exam Certification Guide|5
    2|TCP/IP Illustrated, Volume 1|5
    3|Internetworking with TCP/IP Vol.1|4
    4|Perl Cookbook|5
    5|Designing with Web Standards|5

As with most other SQL tools, if you are using the full "interactive"
environment you need to terminate your SQL commands with a ";" (it's not
required if you do a single SQL statement on the command line).  Use
".q" to exit from SQLite from the SQLite interactive mode and return to
your OS command prompt.

Please note that here we have chosen to use 'singular' table names. This
is because the default inflection code for older versions of
L<DBIx::Class::Schema::Loader> does NOT handle plurals. There has been
much philosophical discussion on whether table names should be plural or
singular.  There is no one correct answer, as long as one makes a choice
and remains consistent with it. If you prefer plural table names (e.g.
you think that they are easier to read) then see the documentation in
L<DBIx::Class::Schema::Loader::Base/naming> (version 0.05 or greater).

For using other databases, such as PostgreSQL or MySQL, see
L<Appendix 2|Catalyst::Manual::Tutorial::10_Appendices>.


=head1 DATABASE ACCESS WITH DBIx::Class

Catalyst can be used with virtually any form of datastore available via
Perl.  For example, L<Catalyst::Model::DBI> can be used to access
databases through the traditional Perl L<DBI> interface or you can use a
model to access files of any type on the filesystem.  However, most
Catalyst applications use some form of object-relational mapping (ORM)
technology to create objects associated with tables in a relational
database, and Matt Trout's L<DBIx::Class> (abbreviated as "DBIC") is the
usual choice (this tutorial will use L<DBIx::Class>).

Although DBIx::Class has included support for a C<create=dynamic> mode
to automatically read the database structure every time the application
starts, its use is no longer recommended.  While it can make for
"flashy" demos, the use of the C<create=static> mode we use below can be
implemented just as quickly and provides many advantages (such as the
ability to add your own methods to the overall DBIC framework, a
technique that we see in
L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD>).


=head2 Create Static DBIx::Class Schema Files

B<Note:> If you are not following along in the Tutorial Virtual Machine,
please be sure that you have version 1.27 or higher of DBD::SQLite and
version 0.39 or higher of Catalyst::Model::DBIC::Schema.  (The Tutorial
VM already has versions that are known to work.)  You can get your
currently installed version numbers with the following commands.

    $ perl -MCatalyst::Model::DBIC::Schema\ 999
    $ perl -MDBD::SQLite\ 999

Before you continue, make sure your C<myapp.db> database file is in the
application's topmost directory. Now use the model helper with the
C<create=static> option to read the database with
L<DBIx::Class::Schema::Loader> and
automatically build the required files for us:

    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \
        create=static dbi:SQLite:myapp.db \
        on_connect_do="PRAGMA foreign_keys = ON"
     exists "/home/catalyst/MyApp/script/../lib/MyApp/Model"
     exists "/home/catalyst/MyApp/script/../t"
    Dumping manual schema for MyApp::Schema to directory /home/catalyst/MyApp/script/../lib ...
    Schema dump completed.
    created "/home/catalyst/MyApp/script/../lib/MyApp/Model/DB.pm"
    created "/home/catalyst/MyApp/script/../t/model_DB.t"

Please note the '\' above.  Depending on your environment, you might be
able to cut and paste the text as shown or need to remove the '\'
character to that the command is all on a single line.

The C<script/myapp_create.pl> command breaks down like this:

=over 4

=item *

C<DB> is the name of the model class to be created by the helper in
the C<lib/MyApp/Model> directory.

=item *

C<DBIC::Schema> is the type of the model to create.  This equates to
L<Catalyst::Model::DBIC::Schema>, the standard way to use a DBIC-based
model inside of Catalyst.

=item *

C<MyApp::Schema> is the name of the DBIC schema file written to
C<lib/MyApp/Schema.pm>.

=item *

C<create=static> causes L<DBIx::Class::Schema::Loader> to load the
schema as it runs and then write that information out into
C<lib/MyApp/Schema.pm> and files under the C<lib/MyApp/Schema>
directory.

=item *

C<dbi:SQLite:myapp.db> is the standard DBI connect string for use with
SQLite.

=item *

And finally, the C<on_connect_do> string requests that
L<DBIx::Class::Schema::Loader> create
foreign key relationships for us (this is not needed for databases such
as PostgreSQL and MySQL, but is required for SQLite). If you take a look
at C<lib/MyApp/Model/DB.pm>, you will see that the SQLite pragma is
propagated to the Model, so that SQLite's recent (and optional) foreign
key enforcement is enabled at the start of every database connection.

=back


If you look in the C<lib/MyApp/Schema.pm> file, you will find that it
only contains a call to the C<load_namespaces> method.  You will also
find that C<lib/MyApp> contains a C<Schema> subdirectory, which then has
a subdirectory called "Result".  This "Result" subdirectory then has
files named according to each of the tables in our simple database
(C<Author.pm>, C<BookAuthor.pm>, and C<Book.pm>).  These three files are
called "Result Classes" (or
"L<ResultSource Classes|DBIx::Class::ResultSource>") in DBIx::Class
nomenclature. Although the Result Class files are named after tables in
our database, the classes correspond to the I<row-level data> that is
returned by DBIC (more on this later, especially in
L<Catalyst::Manual::Tutorial::04_BasicCRUD/EXPLORING THE POWER OF DBIC>).

The idea with the Result Source files created under
C<lib/MyApp/Schema/Result> by the C<create=static> option is to only
edit the files below the C<# DO NOT MODIFY THIS OR ANYTHING ABOVE!>
warning. If you place all of your changes below that point in the file,
you can regenerate the automatically created information at the top of
each file should your database structure get updated.

Also note the "flow" of the model information across the various files
and directories.  Catalyst will initially load the model from
C<lib/MyApp/Model/DB.pm>.  This file contains a reference to
C<lib/MyApp/Schema.pm>, so that file is loaded next.  Finally, the call
to C<load_namespaces> in C<Schema.pm> will load each of the "Result
Class" files from the C<lib/MyApp/Schema/Result> subdirectory.  The
final outcome is that Catalyst will dynamically create three
table-specific Catalyst models every time the application starts (you
can see these three model files listed in the debug output generated
when you launch the application).

Additionally, the C<lib/MyApp/Schema.pm> model can easily be loaded
outside of Catalyst, for example, in command-line utilities and/or cron
jobs. C<lib/MyApp/Model/DB.pm> provides a very thin "bridge" between
Catalyst and this external database model.  Once you see how we can
add some powerful features to our DBIC model in
L<Chapter 4|Catalyst::Manual::Tutorial::04_BasicCRUD>, the elegance
of this approach will start to become more obvious.

B<NOTE:> Older versions of
L<Catalyst::Model::DBIC::Schema> use the
deprecated DBIx::Class C<load_classes> technique instead of the newer
C<load_namespaces>.  For new applications, please try to use
C<load_namespaces> since it more easily supports a very useful DBIC
technique called "ResultSet Classes."  If you need to convert an
existing application from "load_classes" to "load_namespaces," you can
use this process to automate the migration, but first make sure you have
version C<0.39> of L<Catalyst::Model::DBIC::Schema> and
L<DBIx::Class::Schema::Loader> version C<0.05000> or later.

    $ # Re-run the helper to upgrade for you
    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema \
        create=static naming=current use_namespaces=1 \
        dbi:SQLite:myapp.db \
        on_connect_do="PRAGMA foreign_keys = ON"


=head1 ENABLE THE MODEL IN THE CONTROLLER

Open C<lib/MyApp/Controller/Books.pm> and un-comment the model code we
left disabled earlier so that your version matches the following
(un-comment the line containing C<[$c-E<gt>model('DB::Book')-E<gt>all]>
and delete the next 2 lines):

    =head2 list
    
    Fetch all book objects and pass to books/list.tt2 in stash to be displayed
    
    =cut
    
    sub list :Local {
        # Retrieve the usual Perl OO '$self' for this object. $c is the Catalyst
        # 'Context' that's used to 'glue together' the various components
        # that make up the application
        my ($self, $c) = @_;
    
        # Retrieve all of the book records as book model objects and store
        # in the stash where they can be accessed by the TT template
        $c->stash(books => [$c->model('DB::Book')->all]);
    
        # Set the TT template to use.  You will almost always want to do this
        # in your action methods (action methods respond to user input in
        # your controllers).
        $c->stash(template => 'books/list.tt2');
    }

B<TIP>: You may see the C<$c-E<gt>model('DB::Book')> un-commented above
written as C<$c-E<gt>model('DB')-E<gt>resultset('Book')>.  The two are
equivalent.  Either way, C<$c-E<gt>model> returns a
L<DBIx::Class::ResultSet> which handles queries
against the database and iterating over the set of results that is
returned.

We are using the C<-E<gt>all> to fetch all of the books.  DBIC supports
a wide variety of more advanced operations to easily do things like
filtering and sorting the results.  For example, the following could be
used to sort the results by descending title:

    $c->model('DB::Book')->search({}, {order_by => 'title DESC'});

Some other examples are provided in
L<DBIx::Class::Manual::Cookbook/Complex WHERE clauses>, with additional
information found at L<DBIx::Class::ResultSet/search>,
L<DBIx::Class::Manual::FAQ/Searching>, L<DBIx::Class::Manual::Intro> and
L<Catalyst::Model::DBIC::Schema>.


=head2 Test Run The Application

First, let's enable an environment variable that causes L<DBIx::Class>
to dump the SQL statements used to access the database.  This is a
helpful trick when you are trying to debug your database-oriented code.
Press C<Ctrl-C> to break out of the development server and enter:

    $ export DBIC_TRACE=1
    $ script/myapp_server.pl -r

This assumes you are using bash as your shell -- adjust accordingly if
you are using a different shell (for example, under tcsh, use
C<setenv DBIC_TRACE 1>).

B<NOTE:> You can also set this in your code using
C<$class-E<gt>storage-E<gt>debug(1);>.  See
L<DBIx::Class::Manual::Troubleshooting> for details (including options
to log to a file instead of displaying to the Catalyst development
server log).

Then launch the Catalyst development server.  The log output should
display something like:

    $ script/myapp_server.pl -r
    [debug] Debug messages enabled
    [debug] Statistics enabled
    [debug] Loaded plugins:
    .----------------------------------------------------------------------------.
    | Catalyst::Plugin::ConfigLoader  0.30                                       |
    | Catalyst::Plugin::StackTrace  0.11                                         |
    '----------------------------------------------------------------------------'
    
    [debug] Loaded dispatcher "Catalyst::Dispatcher"
    [debug] Loaded engine "Catalyst::Engine"
    [debug] Found home "/home/catalyst/MyApp"
    [debug] Loaded Config "/home/catalyst/MyApp/myapp.conf"
    [debug] Loaded components:
    .-----------------------------------------------------------------+----------.
    | Class                                                           | Type     |
    +-----------------------------------------------------------------+----------+
    | MyApp::Controller::Books                                        | instance |
    | MyApp::Controller::Root                                         | instance |
    | MyApp::Model::DB                                                | instance |
    | MyApp::Model::DB::Author                                        | class    |
    | MyApp::Model::DB::Book                                          | class    |
    | MyApp::Model::DB::BookAuthor                                    | class    |
    | MyApp::View::HTML                                               | instance |
    '-----------------------------------------------------------------+----------'
    
    [debug] Loaded Private actions:
    .----------------------+--------------------------------------+--------------.
    | Private              | Class                                | Method       |
    +----------------------+--------------------------------------+--------------+
    | /default             | MyApp::Controller::Root              | default      |
    | /end                 | MyApp::Controller::Root              | end          |
    | /index               | MyApp::Controller::Root              | index        |
    | /books/index         | MyApp::Controller::Books             | index        |
    | /books/list          | MyApp::Controller::Books             | list         |
    '----------------------+--------------------------------------+--------------'
    
    [debug] Loaded Path actions:
    .-------------------------------------+--------------------------------------.
    | Path                                | Private                              |
    +-------------------------------------+--------------------------------------+
    | /                                   | /default                             |
    | /                                   | /index                               |
    | /books                              | /books/index                         |
    | /books/list                         | /books/list                          |
    '-------------------------------------+--------------------------------------'
    
    [info] MyApp powered by Catalyst 5.80020
    HTTP::Server::PSGI: Accepting connections at http://0:3000

B<NOTE:> Be sure you run the C<script/myapp_server.pl> command from the
'base' directory of your application, not inside the C<script> directory
itself or it will not be able to locate the C<myapp.db> database file.
You can use a fully qualified or a relative path to locate the database
file, but we did not specify that when we ran the model helper earlier.

Some things you should note in the output above:

=over 4

=item *

L<Catalyst::Model::DBIC::Schema> dynamically created three model
classes, one to represent each of the three tables in our database
(C<MyApp::Model::DB::Author>, C<MyApp::Model::DB::BookAuthor>, and
C<MyApp::Model::DB::Book>).

=item *

The "list" action in our Books controller showed up with a path of
C</books/list>.

=back

Point your browser to L<http://localhost:3000> and you should still get
the Catalyst welcome page.

Next, to view the book list, change the URL in your browser to
L<http://localhost:3000/books/list>. You should get a list of the five
books loaded by the C<myapp01.sql> script above without any formatting.
The rating for each book should appear on each row, but the "Author(s)"
column will still be blank (we will fill that in later).

Also notice in the output of the C<script/myapp_server.pl> that
L<DBIx::Class> used the following SQL to retrieve the data:

    SELECT me.id, me.title, me.rating FROM book me

because we enabled DBIC_TRACE.

You now have the beginnings of a simple but workable web application.
Continue on to future sections and we will develop the application more
fully.


=head1 CREATE A WRAPPER FOR THE VIEW

When using TT, you can (and should) create a wrapper that will literally
wrap content around each of your templates.  This is certainly useful as
you have one main source for changing things that will appear across
your entire site/application instead of having to edit many individual
files.


=head2 Configure HTML.pm For The Wrapper

In order to create a wrapper, you must first edit your TT view and tell
it where to find your wrapper file.

Edit your TT view in C<lib/MyApp/View/HTML.pm> and change it to match
the following:

    __PACKAGE__->config(
        # Change default TT extension
        TEMPLATE_EXTENSION => '.tt2',
        # Set the location for TT files
        INCLUDE_PATH => [
                MyApp->path_to( 'root', 'src' ),
            ],
        # Set to 1 for detailed timer stats in your HTML as comments
        TIMER              => 0,
        # This is your wrapper template located in the 'root/src'
        WRAPPER => 'wrapper.tt2',
    );


=head2 Create the Wrapper Template File and Stylesheet

Next you need to set up your wrapper template.  Basically, you'll want
to take the overall layout of your site and put it into this file.  For
the tutorial, open C<root/src/wrapper.tt2> and input the following:

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" [%#
        %]"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <title>[% template.title or "My Catalyst App!" %]</title>
    <link rel="stylesheet" href="[% c.uri_for('/static/css/main.css') %]" />
    </head>
    
    <body>
    <div id="outer">
    <div id="header">
        [%# Your logo could go here -%]
        <img src="[% c.uri_for('/static/images/btn_88x31_powered.png') %]" />
        [%# Insert the page title -%]
        <h1>[% template.title or site.title %]</h1>
    </div>
    
    <div id="bodyblock">
    <div id="menu">
        Navigation:
        <ul>
            <li><a href="[% c.uri_for('/books/list') %]">Home</a></li>
            <li><a href="[% c.uri_for('/')
                %]" title="Catalyst Welcome Page">Welcome</a></li>
        </ul>
    </div><!-- end menu -->
    
    <div id="content">
        [%# Status and error messages %]
        <span class="message">[% status_msg %]</span>
        <span class="error">[% error_msg %]</span>
        [%# This is where TT will stick all of your template's contents. -%]
        [% content %]
    </div><!-- end content -->
    </div><!-- end bodyblock -->
    
    <div id="footer">Copyright (c) your name goes here</div>
    </div><!-- end outer -->
    
    </body>
    </html>

Notice the status and error message sections in the code above:

    <span class="status">[% status_msg %]</span>
    <span class="error">[% error_msg %]</span>

If we set either message in the Catalyst stash (e.g.,
C<$c-E<gt>stash-E<gt>{status_msg} = 'Request was successful!'>) it will
be displayed whenever any view used by that request is rendered.  The
C<message> and C<error> CSS styles can be customized to suit your needs
in the C<root/static/css/main.css> file we create below.

B<Notes:>

=over 4

=item *

The Catalyst stash only lasts for a single HTTP request.  If you need to
retain information across requests you can use
L<Catalyst::Plugin::Session> (we will use Catalyst sessions in the
Authentication chapter of the tutorial).

=item *

Although it is beyond the scope of this tutorial, you may wish to use a
JavaScript or AJAX tool such as jQuery (L<http://www.jquery.com>) or
Dojo (L<http://www.dojotoolkit.org>).

=back


=head3 Create A Basic Stylesheet

First create a central location for stylesheets under the static
directory:

    $ mkdir root/static/css

Then open the file C<root/static/css/main.css> (the file referenced in
the stylesheet href link of our wrapper above) and add the following
content:

    #header {
        text-align: center;
    }
    #header h1 {
        margin: 0;
    }
    #header img {
        float: right;
    }
    #footer {
        text-align: center;
        font-style: italic;
        padding-top: 20px;
    }
    #menu {
        font-weight: bold;
        background-color: #ddd;
    }
    #menu ul {
        list-style: none;
        float: left;
        margin: 0;
        padding: 0 0 50% 5px;
        font-weight: normal;
        background-color: #ddd;
        width: 100px;
    }
    #content {
        margin-left: 120px;
    }
    .message {
        color: #390;
    }
    .error {
        color: #f00;
    }

You may wish to check out a "CSS Framework" like Emastic
(L<http://code.google.com/p/emastic/>) as a way to quickly provide lots
of high-quality CSS functionality.


=head2 Test Run The Application

Hit "Reload" in your web browser and you should now see a formatted
version of our basic book list. (Again, the development server should
have automatically restarted when you made changes to
C<lib/MyApp/View/HTML.pm>. If you are not using the "-r" option, you
will need to hit C<Ctrl-C> and manually restart it. Also note that the
development server does I<NOT> need to restart for changes to the TT and
static files we created and edited in the C<root> directory -- those
updates are handled on a per-request basis.)

Although our wrapper and stylesheet are obviously very simple, you
should see how it allows us to control the overall look of an entire
website from two central files. To add new pages to the site, just
provide a template that fills in the C<content> section of our wrapper
template -- the wrapper will provide the overall feel of the page.


=head2 Updating the Generated DBIx::Class Result Class Files

If you take a look at the Schema files automatically generated by
L<DBIx::Class::Schema::Loader>, you will see that it has already defined
C<has_many> and C<belongs_to> relationships on each side of our foreign
keys. For example, take a look at C<lib/MyApp/Schema/Result/Book.pm> and
notice the following code:

    =head1 RELATIONS
    
    =head2 book_authors
    
    Type: has_many
    
    Related object: L<MyApp::Schema::Result::BookAuthor>
    
    =cut
    
    __PACKAGE__->has_many(
      "book_authors",
      "MyApp::Schema::Result::BookAuthor",
      { "foreign.book_id" => "self.id" },
      { cascade_copy => 0, cascade_delete => 0 },
    );

Each C<Book> "has_many" C<book_authors>, where C<BookAuthor> is the
many-to-many table that allows each Book to have multiple Authors, and
each Author to have multiple books.  The arguments to C<has_many> are:

=over 4

=item *

C<book_authors> - The name for this relationship.  DBIC will create an
accessor on the C<Books> DBIC Row object with this name.

=item *

C<MyApp::Schema::Result::BookAuthor> - The name of the DBIC model class
referenced by this C<has_many> relationship.

=item *

C<foreign.book_id> - C<book_id> is the name of the foreign key column in
the I<foreign> table that points back to this table.

=item *

C<self.id> - C<id> is the name of the column in I<this> table that is
referenced by the foreign key.

=back

See L<DBIx::Class::Relationship/has_many> for additional information.
Note that you might see a "hand coded" version of the C<has_many>
relationship above expressed as:

    __PACKAGE__->has_many(
      "book_authors",
      "MyApp::Schema::Result::BookAuthor",
      "book_id",
    );

Where the third argument is simply the name of the column in the foreign
table.  However, the hashref syntax used by
L<DBIx::Class::Schema::Loader> is more flexible (for example, it can
handle "multi-column foreign keys").

B<Note:> If you are using older versions of SQLite and related DBIC
tools, you will need to manually define your C<has_many> and
C<belongs_to> relationships. We recommend upgrading to the versions
specified above. :-)

Have a look at C<lib/MyApp/Schema/Result/BookAuthor.pm> and notice that
there is a C<belongs_to> relationship defined that acts as the "mirror
image" to the C<has_many> relationship we just looked at above:

    =head1 RELATIONS
    
    =head2 book
    
    Type: belongs_to
    
    Related object: L<MyApp::Schema::Result::Book>
    
    =cut
    
    __PACKAGE__->belongs_to(
      "book",
      "MyApp::Schema::Result::Book",
      { id => "book_id" },
      { join_type => "LEFT", on_delete => "CASCADE", on_update => "CASCADE" },
    );

The arguments are similar, but see
L<DBIx::Class::Relationship/belongs_to> for the details.

Although recent versions of SQLite and L<DBIx::Class::Schema::Loader>
automatically handle the C<has_many> and C<belongs_to> relationships,
C<many_to_many> relationship bridges (not technically a relationship)
currently need to be manually inserted.  To add a C<many_to_many>
relationship bridge, first edit C<lib/MyApp/Schema/Result/Book.pm> and
add the following text below the C<# You can replace this text...>
comment:

    # many_to_many():
    #   args:
    #     1) Name of relationship bridge, DBIC will create accessor with this name
    #     2) Name of has_many() relationship this many_to_many() is shortcut for
    #     3) Name of belongs_to() relationship in model class of has_many() above
    #   You must already have the has_many() defined to use a many_to_many().
    __PACKAGE__->many_to_many(authors => 'book_authors', 'author');

B<Note:> Be careful to put this code I<above> the C<1;> at the end of
the file.  As with any Perl package, we need to end the last line with a
statement that evaluates to C<true>.  This is customarily done with
C<1;> on a line by itself.

The C<many_to_many> relationship bridge is optional, but it makes it
easier to map a book to its collection of authors.  Without it, we would
have to "walk" through the C<book_author> table as in
C<$book-E<gt>book_author-E<gt>first-E<gt>author-E<gt>last_name> (we will
see examples on how to use DBIx::Class objects in your code soon, but
note that because C<$book-E<gt>book_author> can return multiple authors,
we have to use C<first> to display a single author).  C<many_to_many>
allows us to use the shorter
C<$book-E<gt>author-E<gt>first-E<gt>last_name>. Note that you cannot
define a C<many_to_many> relationship bridge without also having the
C<has_many> relationship in place.

Then edit C<lib/MyApp/Schema/Result/Author.pm> and add the reverse
C<many_to_many> relationship bridge for C<Author> as follows (again, be
careful to put in above the C<1;> but below the C<# DO NOT MODIFY THIS
OR ANYTHING ABOVE!> comment):

    # many_to_many():
    #   args:
    #     1) Name of relationship bridge, DBIC will create accessor with this name
    #     2) Name of has_many() relationship this many_to_many() is shortcut for
    #     3) Name of belongs_to() relationship in model class of has_many() above
    #   You must already have the has_many() defined to use a many_to_many().
    __PACKAGE__->many_to_many(books => 'book_authors', 'book');


=head2 Run The Application

Run the Catalyst development server script with the C<DBIC_TRACE> option
(it might still be enabled from earlier in the tutorial, but here is an
alternate way to specify the trace option just in case):

    $ DBIC_TRACE=1 script/myapp_server.pl -r

Make sure that the application loads correctly and that you see the
three dynamically created model classes (one for each of the Result
Classes we created).

Then hit the URL L<http://localhost:3000/books/list> with your browser
and be sure that the book list still displays correctly.

B<Note:> You will not see the authors yet because the view isn't taking
advantage of these relationships. Read on to the next section where we
update the template to do that.


=head1 UPDATING THE VIEW

Let's add a new column to our book list page that takes advantage of the
relationship information we manually added to our schema files in the
previous section.  Edit C<root/src/books/list.tt2> and replace the
"empty" table cell "<td></td>" with the following:

    ...
    <td>
      [% # NOTE: See Chapter 4 for a better way to do this!                      -%]
      [% # First initialize a TT variable to hold a list.  Then use a TT FOREACH -%]
      [% # loop in 'side effect notation' to load just the last names of the     -%]
      [% # authors into the list. Note that the 'push' TT vmethod doesn't return -%]
      [% # a value, so nothing will be printed here.  But, if you have something -%]
      [% # in TT that does return a value and you don't want it printed, you     -%]
      [% # 1) assign it to a bogus value, or                                     -%]
      [% # 2) use the CALL keyword to call it and discard the return value.      -%]
      [% tt_authors = [ ];
         tt_authors.push(author.last_name) FOREACH author = book.authors %]
      [% # Now use a TT 'virtual method' to display the author count in parens   -%]
      [% # Note the use of the TT filter "| html" to escape dangerous characters -%]
      ([% tt_authors.size | html %])
      [% # Use another TT vmethod to join & print the names & comma separators   -%]
      [% tt_authors.join(', ') | html %]
    </td>
    ...

B<IMPORTANT NOTE:> Again, you should keep as much "logic code" as
possible out of your views.  This kind of logic belongs in your model
(the same goes for controllers -- keep them as "thin" as possible and
push all of the "complicated code" out to your model objects).  Avoid
code like you see in the previous example -- we are only using it here
to show some extra features in TT until we get to the more advanced
model features we will see in Chapter 4 (see
L<Catalyst::Manual::Tutorial::04_BasicCRUD/EXPLORING THE POWER OF DBIC>).

Then hit "Reload" in your browser (note that you don't need to reload
the development server or use the C<-r> option when updating TT
templates) and you should now see the number of authors each book has
along with a comma-separated list of the authors' last names.  (If you
didn't leave the development server running from the previous step, you
will obviously need to start it before you can refresh your browser
window.)

If you are still running the development server with C<DBIC_TRACE>
enabled, you should also now see five more C<SELECT> statements in the
debug output (one for each book as the authors are being retrieved by
DBIx::Class):

    SELECT me.id, me.title, me.rating FROM book me:
    SELECT author.id, author.first_name, author.last_name FROM book_author me  
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '1'
    SELECT author.id, author.first_name, author.last_name FROM book_author me  
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '2'
    SELECT author.id, author.first_name, author.last_name FROM book_author me  
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '3'
    SELECT author.id, author.first_name, author.last_name FROM book_author me  
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '4'
    SELECT author.id, author.first_name, author.last_name FROM book_author me  
    JOIN author author ON author.id = me.author_id WHERE ( me.book_id = ? ): '5'

Also note in C<root/src/books/list.tt2> that we are using "| html", a
type of TT filter, to escape characters such as E<lt> and E<gt> to &lt;
and &gt; and avoid various types of dangerous hacks against your
application.  In a real application, you would probably want to put "|
html" at the end of every field where a user has control over the
information that can appear in that field (and can therefore inject
markup or code if you don't "neutralize" those fields).  In addition to
"| html", Template Toolkit has a variety of other useful filters that
can be found in the documentation for L<Template::Filters>.  (While we
are on the topic of security and escaping of dangerous values, one of
the advantages of using tools like DBIC for database access or
L<HTML::FormFu> for form management [see
L<Chapter 9|Catalyst::Manual::Tutorial::09_AdvancedCRUD::09_FormFu>]
is that they automatically handle most escaping for you and therefore
dramatically increase the security of your app.)


=head1 RUNNING THE APPLICATION FROM THE COMMAND LINE

In some situations, it can be useful to run your application and display
a page without using a browser.  Catalyst lets you do this using the
C<script/myapp_test.pl> script.  Just supply the URL you wish to
display and it will run that request through the normal controller
dispatch logic and use the appropriate view to render the output
(obviously, complex pages may dump a lot of text to your terminal
window).  For example, if C<Ctrl+C> out of the development server
and then type:

    $ script/myapp_test.pl "/books/list"

You should get the same text as if you visited
L<http://localhost:3000/books/list> with the normal development server
and asked your browser to view the page source.  You can even pipe this
HTML text output to a text-based browser using a command like:

    $ script/myapp_test.pl "/books/list" | lynx -stdin

And you should see a fully rendered text-based view of your page.  (If
you are following along in Debian 6, type
C<sudo aptitude -y install lynx> to install lynx.)  If you do start
lynx, you can use the "Q" key to quit.


=head1 OPTIONAL INFORMATION

B<NOTE: The rest of this chapter of the tutorial is optional.  You can
skip to Chapter 4, L<Basic CRUD|Catalyst::Manual::Tutorial::04_BasicCRUD>,
if you wish.>


=head2 Using 'RenderView' for the Default View

Once your controller logic has processed the request from a user, it
forwards processing to your view in order to generate the appropriate
response output.  Catalyst uses
L<Catalyst::Action::RenderView> by default
to automatically perform this operation.  If you look in
C<lib/MyApp/Controller/Root.pm>, you should see the empty definition for
the C<sub end> method:

    sub end : ActionClass('RenderView') {}

The following bullet points provide a quick overview of the
C<RenderView> process:

=over 4

=item *

C<Root.pm> is designed to hold application-wide logic.

=item *

At the end of a given user request, Catalyst will call the most specific
C<end> method that's appropriate.  For example, if the controller for a
request has an C<end> method defined, it will be called.  However, if
the controller does not define a controller-specific C<end> method, the
"global" C<end> method in C<Root.pm> will be called.

=item *

Because the definition includes an C<ActionClass> attribute, the
L<Catalyst::Action::RenderView> logic will be executed B<after> any code
inside the definition of C<sub end> is run.  See
L<Catalyst::Manual::Actions> for more information on C<ActionClass>.

=item *

Because C<sub end> is empty, this effectively just runs the default
logic in C<RenderView>.  However, you can easily extend the
C<RenderView> logic by adding your own code inside the empty method body
(C<{}>) created by the Catalyst Helpers when we first ran the
C<catalyst.pl> to initialize our application.  See
L<Catalyst::Action::RenderView> for more
detailed information on how to extend C<RenderView> in C<sub end>.

=back


=head2 RenderView's "dump_info" Feature

One of the nice features of C<RenderView> is that it automatically
allows you to add C<dump_info=1> to the end of any URL for your
application and it will force the display of the "exception dump" screen
to the client browser.  You can try this out by pointing your browser to
this URL:

    http://localhost:3000/books/list?dump_info=1

You should get a page with the following message at the top:

    Caught exception in MyApp::Controller::Root->end "Forced debug - 
    Scrubbed output at /usr/share/perl5/Catalyst/Action/RenderView.pm line 46."

Along with a summary of your application's state at the end of the
processing for that request.  The "Stash" section should show a
summarized version of the DBIC book model objects.  If desired, you can
adjust the summarization logic (called "scrubbing" logic) -- see
L<Catalyst::Action::RenderView> for
details.

Note that you shouldn't need to worry about "normal clients" using this
technique to "reverse engineer" your application -- C<RenderView> only
supports the C<dump_info=1> feature when your application is running in
C<-Debug> mode (something you won't do once you have your application
deployed in production).


=head2 Using The Default Template Name

By default, C<Catalyst::View::TT> will look for a template that uses the
same name as your controller action, allowing you to save the step of
manually specifying the template name in each action.  For example, this
would allow us to remove the
C<$c-E<gt>stash-E<gt>{template} = 'books/list.tt2';>
line of our C<list> action in the Books controller.
Open C<lib/MyApp/Controller/Books.pm> in your editor and comment out
this line to match the following (only the
C<$c-E<gt>stash-E<gt>{template}> line has changed):

    =head2 list
    
    Fetch all book objects and pass to books/list.tt2 in stash to be displayed
    
    =cut
    
    sub list :Local {
        # Retrieve the usual Perl OO '$self' for this object. $c is the Catalyst
        # 'Context' that's used to 'glue together' the various components
        # that make up the application
        my ($self, $c) = @_;
    
        # Retrieve all of the book records as book model objects and store in the
        # stash where they can be accessed by the TT template
        $c->stash(books => [$c->model('DB::Book')->all]);
    
        # Set the TT template to use.  You will almost always want to do this
        # in your action methods (actions methods respond to user input in
        # your controllers).
        #$c->stash(template => 'books/list.tt2');
    }


You should now be able to access the L<http://localhost:3000/books/list>
URL as before.

B<NOTE:> If you use the default template technique, you
will B<not> be able to use either the C<$c-E<gt>forward> or the
C<$c-E<gt>detach> mechanisms (these are discussed in Chapter 2 and
Chapter 9 of the Tutorial).

B<IMPORTANT:> Make sure that you do B<not> skip the following section
before continuing to the next chapter 4 Basic CRUD.


=head2 Return To A Manually Specified Template

In order to be able to use C<$c-E<gt>forward> and C<$c-E<gt>detach>
later in the tutorial, you should remove the comment from the statement
in C<sub list> in C<lib/MyApp/Controller/Books.pm>:

    $c->stash(template => 'books/list.tt2');

Then delete the C<TEMPLATE_EXTENSION> line in C<lib/MyApp/View/HTML.pm>.

Check the L<http://localhost:3000/books/list> URL in your browser.  It
should look the same manner as with earlier sections.


You can jump to the next chapter of the tutorial here:
L<Basic CRUD|Catalyst::Manual::Tutorial::04_BasicCRUD>


=head1 AUTHOR

Kennedy Clark, C<hkclark@gmail.com>

Feel free to contact the author for any errors or suggestions, but the
best way to report issues is via the CPAN RT Bug system at
L<https://rt.cpan.org/Public/Dist/Display.html?Name=Catalyst-Manual>.

Copyright 2006-2011, Kennedy Clark, under the
Creative Commons Attribution Share-Alike License Version 3.0
(L<http://creativecommons.org/licenses/by-sa/3.0/us/>).
